KitManager default currentKitNamed: 'Compiler' !

KitManager default currentKit ensureLoaded: #('Core') !

Object subclassNamed: #BytecodeSpec
	instVarNames: 'number name type numberOfBytes argumentSpec decompileString'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object variableSubclassNamed: #CodeContext
	instVarNames: 'frame stackOffset pcOffset method methodContext contextId'
	classInstVarNames: 'bytecodeBlocks'
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object variableSubclassNamed: #CodeSimulator
	instVarNames: 'currentContext frames stopFrame stopMethod'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #CommandHandler
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Error subclassNamed: #CompileError
	instVarNames: 'startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Warning subclassNamed: #CompileWarning
	instVarNames: 'startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #DecompileStream
	instVarNames: 'byteStream compiledCode'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #Decompiler
	instVarNames: 'literals targetClass offsetStream decompiledCodeStream formattedBytecodeStream byteStream resultStream numberOfArguments numberOfTemporaries numberOfCopiedVariables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

CommandHandler subclassNamed: #DevelopmentCommandHandler
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #FileinReader
	instVarNames: 'stream readingString quoting chunkStream readingComment starting precedingEmptyChunk'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

FileinReader subclassNamed: #ClassFileinReader
	instVarNames: 'targetClass organization'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #IndirectVariableList
	instVarNames: 'variables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #LexicalAnalyzer
	instVarNames: 'stream next next2 parseTree position startSourceOffset endSourceOffset tokens'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

LexicalAnalyzer subclassNamed: #JSONLexicalAnalyzer
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #ParseTreeNode
	instVarNames: 'startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #BinaryHeaderNode
	instVarNames: 'selector argument'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #BinaryMessageNode
	instVarNames: 'receiver selector argument'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #BlockNode
	instVarNames: 'arguments statements scope hasReturn parent'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #BlockParameterListNode
	instVarNames: 'variables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #CascadeNode
	instVarNames: 'receiver messages'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #GlobalVariableAssignmentNode
	instVarNames: 'variable value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #GlobalVariableReferenceNode
	instVarNames: 'variable'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #InstanceVariableAssignmentNode
	instVarNames: 'variable value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #InstanceVariableReferenceNode
	instVarNames: 'variable'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #KeywordHeaderNode
	instVarNames: 'selector arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #KeywordMessageNode
	instVarNames: 'receiver selector arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #LocalVariableAssignmentNode
	instVarNames: 'variable value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #LocalVariableReferenceNode
	instVarNames: 'variable scopeNumber'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #MethodNode
	instVarNames: 'header body pragmas scope'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #NamespaceVariableAssignmentNode
	instVarNames: 'variable value nameComponents'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #NamespaceVariableReferenceNode
	instVarNames: 'nameComponents'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #ParenthesisNode
	instVarNames: 'expression'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #ParseTreeVisitor
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeVisitor subclassNamed: #CodeGenerator
	instVarNames: 'literals bytecodeStream targetClass globalDictionaries selector hasReturned pragmas nodeStack isInlinedBlock nestedVariablesRead nestedVariablesWritten methodLocalVariableAnalysis returnLevel outerMethod sourceOffsets'
	classInstVarNames: 'bytecodesByIndex bytecodesByName'
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeVisitor subclassNamed: #MethodLocalVariableAnalysisVisitor
	instVarNames: 'rootNode scopeStack scopes'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #Parser
	instVarNames: 'currentRule'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Parser subclassNamed: #JSONParser
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #ParserRule
	instVarNames: 'parser parentRule tokenStream result produceBlock errorString'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #OneOfParserRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #OneOrMoreParserRule
	instVarNames: 'nodes passed'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #OptionalParserRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #ParseMethodRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #PragmaNode
	instVarNames: 'selector arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #ReturnNode
	instVarNames: 'value returnLevel'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #RootRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #Scope
	instVarNames: 'variables scopeNumber parentScope childScopes'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #ScopeAnalysisResult
	instVarNames: 'node temporaryVariables copiedVariables indirectVariables hasReturn parent children arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #SequenceNode
	instVarNames: 'sequence'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #SequenceParserRule
	instVarNames: 'allPassed sequence rulesRun'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

LexicalAnalyzer subclassNamed: #SmalltalkLexicalAnalyzer
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Parser subclassNamed: #SmalltalkParser
	instVarNames: 'scopeStack scopes targetClass globalDictionaries tokensToExpect currentMethodName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #StatementListNode
	instVarNames: 'variables statements'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #TempVarListNode
	instVarNames: 'variables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Parser subclassNamed: #TestParser
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #Token
	instVarNames: 'value startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #ArrayLiteralToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #AssignToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #BarToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #BinaryToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #BlockArgumentToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #ByteArrayLiteralToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #CharacterToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #CloseBraceToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #CloseParenthesisToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #CloseSquareBracketToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #ColonToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #CommaToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #CompoundWordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #ErrorToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #FloatToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #IntegerToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #KeywordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #LeftAngleToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #OpenBraceToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #OpenParenthesisToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #OpenSquareBracketToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #PeriodToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #ReturnToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #RightAngleToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #SemicolonToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #SpecialWordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #StringToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #SymbolToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #TokenNode
	instVarNames: 'token'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #TokenRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #UnaryHeaderNode
	instVarNames: 'selector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #UnaryMessageNode
	instVarNames: 'receiver selector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParseTreeNode subclassNamed: #ValueNode
	instVarNames: 'value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ValueNode subclassNamed: #LiteralNode
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

LiteralNode subclassNamed: #BlockLiteralNode
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ValueNode subclassNamed: #ObjectNode
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ValueNode subclassNamed: #SpecialNode
	instVarNames: 'special'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Object subclassNamed: #Variable
	instVarNames: 'variableName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Variable subclassNamed: #GlobalVariable
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Variable subclassNamed: #InstanceVariable
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Variable subclassNamed: #LocalVariable
	instVarNames: 'scope scopeNumber indirect isArgument'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Variable subclassNamed: #NamespaceVariable
	instVarNames: 'namespaceComponents'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

LocalVariable subclassNamed: #SelfVariable
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

Token subclassNamed: #WordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

ParserRule subclassNamed: #ZeroOrMoreParserRule
	instVarNames: 'nodes passed'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler' !

! BytecodeSpec methodsFor: 'accessing' !
argumentSpec

	^argumentSpec! !

! BytecodeSpec methodsFor: 'accessing' !
argumentSpec: anObject

	argumentSpec := anObject! !

! BytecodeSpec methodsFor: 'accessing' !
decompileString

	^decompileString! !

! BytecodeSpec methodsFor: 'accessing' !
decompileString: anObject

	decompileString := anObject! !

! BytecodeSpec methodsFor: 'accessing' !
name

	^name! !

! BytecodeSpec methodsFor: 'accessing' !
name: anObject

	name := anObject! !

! BytecodeSpec methodsFor: 'accessing' !
number

	^number! !

! BytecodeSpec methodsFor: 'accessing' !
number: anObject

	number := anObject! !

! BytecodeSpec methodsFor: 'accessing' !
numberOfBytes

	^numberOfBytes! !

! BytecodeSpec methodsFor: 'accessing' !
numberOfBytes: anObject

	numberOfBytes := anObject! !

! BytecodeSpec methodsFor: 'accessing' !
type

	^type! !

! BytecodeSpec methodsFor: 'accessing' !
type: anObject

	type := anObject! !

! BytecodeSpec methodsFor: 'printing' !
printOn: aStream

	aStream nextPutAll: self decompileString! !

! CodeContext methodsFor: 'accessing' !
allLocalNames

	| localNames |

	localNames := OrderedCollection new.
	self method localVariableNames do: [:each |
		each isArray
			ifTrue: [localNames addAll: each]
			ifFalse: [localNames add: each]].
	^localNames! !

! CodeContext methodsFor: 'accessing' !
basicLocalAt: aNumber

	frame isNil ifTrue: [^nil].
	^frame basicAt: (frame stackOffset + aNumber + 1)! !

! CodeContext methodsFor: 'accessing' !
basicLocalAt: aNumber put: anObject

	frame isNil ifTrue: [^nil].
	frame basicAt: (frame stackOffset + aNumber + 1) put: anObject ! !

! CodeContext methodsFor: 'accessing' !
contextId

	^contextId! !

! CodeContext methodsFor: 'accessing' !
contextId: anObject

	contextId := anObject! !

! CodeContext methodsFor: 'accessing' !
frame

	^frame! !

! CodeContext methodsFor: 'accessing' !
frame: aCodeContext

	frame := aCodeContext! !

! CodeContext methodsFor: 'accessing' !
getSelf

	self method isCompiledBlock ifTrue: [
		^self rootSelfFor: self method outerMethod].
	^self receiver! !

! CodeContext methodsFor: 'accessing' !
localAt: aNumber

	| localNumber |

	frame isNil ifTrue: [^nil].

	localNumber := 1.
	self method localVariableNames keysAndValuesDo: [:key :value |
		value isArray
			ifTrue: [
				(aNumber between: localNumber and: localNumber + value size - 1)
					ifTrue: [
						^(self basicLocalAt: key) at: aNumber - localNumber + 1].
				localNumber := localNumber + value size]
			ifFalse: [
				localNumber = aNumber ifTrue: [^self basicLocalAt: key].
				localNumber := localNumber + 1]
		].
	^nil ! !

! CodeContext methodsFor: 'accessing' !
method
	^method! !

! CodeContext methodsFor: 'accessing' !
method: aCompiledMethod

	method := aCompiledMethod! !

! CodeContext methodsFor: 'accessing' !
methodClass

	^self rootMethod mclass! !

! CodeContext methodsFor: 'accessing' !
methodContext

	^methodContext! !

! CodeContext methodsFor: 'accessing' !
methodContext: aCodeContext

	methodContext := aCodeContext! !

! CodeContext methodsFor: 'accessing' !
pcOffset
	^pcOffset! !

! CodeContext methodsFor: 'accessing' !
pcOffset: aNumber

	pcOffset := aNumber! !

! CodeContext methodsFor: 'accessing' !
receiver

	^self basicLocalAt: 0! !

! CodeContext methodsFor: 'accessing' !
rootContext

	| frame method |

	frame := self.
	method := self rootMethod.
	[frame method == method] whileFalse: [
		frame := frame frame.
		frame isNil ifTrue: [^nil].
		].


	^frame! !

! CodeContext methodsFor: 'accessing' !
rootMethod

	^self method rootMethod! !

! CodeContext methodsFor: 'accessing' !
rootMethodClass

	^self rootMethod mclass! !

! CodeContext methodsFor: 'accessing' !
rootSelfFor: aCompiledMethod

	| frame |

	frame := self.
	[frame method == aCompiledMethod] whileFalse: [
		frame := frame frame.
		frame isNil ifTrue: [^nil].
		].


	^frame getSelf! !

! CodeContext methodsFor: 'accessing' !
sender
	^frame! !

! CodeContext methodsFor: 'accessing' !
stackAt: aNumber

	^self basicAt: aNumber! !

! CodeContext methodsFor: 'accessing' !
stackNames

	| stackNames |

	stackNames := OrderedCollection new.
	1 to: self stackOffset do: [:each |
		stackNames add: each printString].

	^stackNames! !

! CodeContext methodsFor: 'accessing' !
stackOffset
	^stackOffset! !

! CodeContext methodsFor: 'accessing' !
stackOffset: aNumber

	stackOffset := aNumber! !

! CodeContext methodsFor: 'dumping' !
allFrames

	| context frames |

	context := self.
	frames := OrderedCollection new.

	[context notNil] whileTrue: [
		context method isNil ifFalse: [
			frames add: context].
		context := context sender].

	^frames! !

! CodeContext methodsFor: 'dumping' !
walkback
	| context stream |

	context := self.
	stream := WriteStream on: (String new: 1000).

	[context notNil] whileTrue: [
		context method isNil ifFalse: [
			stream
				nextPutAll: context method mclass printString.
			(context method isBlock) ifFalse: [
				stream
					nextPutAll: ' >> ';
					nextPutAll: context method selector].
			stream cr].
		context := context sender].
	^stream contents! !

! CodeContext methodsFor: 'initializing' !
initialize

	stackOffset := 0.
	pcOffset := 0.! !

! CodeContext methodsFor: 'printing' !
printOn: aStream

	self receiver class ~= self method mclass ifTrue: [
		aStream nextPut: $(;
			print: self receiver class;
			nextPut: $);
			space].

	aStream print: self method! !

! CodeContext methodsFor: 'simulating' !
doBytecode: aNumber

	^(self class bytecodeBlocks at: aNumber + 1) value: self! !

! CodeContext methodsFor: 'simulating' !
dropCascadeReceiver

	| object |

	object := self pop.
	self pop.
	self push: object! !

! CodeContext methodsFor: 'simulating' !
dup

	| object |
	object := self pop.
	self push: object; push: object
! !

! CodeContext methodsFor: 'simulating' !
findCompiledMethod: selector startingAt: aBehavior

	| behavior |

	behavior := aBehavior.
	[behavior methodDictionary includesKey: selector] whileFalse: [
		behavior := behavior superclass.
		behavior isNil ifTrue: [^nil]].

	^behavior methodDictionary at: selector

! !

! CodeContext methodsFor: 'simulating' !
grow

	| newInstance |
	newInstance := self class new: (self basicSize + 6).
	self shallowCopyTo: newInstance.
	self become: newInstance! !

! CodeContext methodsFor: 'simulating' !
jump: anInteger

	pcOffset := pcOffset + anInteger! !

! CodeContext methodsFor: 'simulating' !
jumpIfFalse: anInteger

	self pop == true ifFalse: [pcOffset := pcOffset + anInteger]! !

! CodeContext methodsFor: 'simulating' !
jumpIfTrue: anInteger

	self pop == true ifTrue: [pcOffset := pcOffset + anInteger]! !

! CodeContext methodsFor: 'simulating' !
nextBytecode

	^method bytecodes at: (pcOffset := pcOffset + 1)! !

! CodeContext methodsFor: 'simulating' !
nextFourBytecodes

	^(((self nextBytecode * 256) + self nextBytecode) * 256 + self nextBytecode) * 256 + self nextBytecode ! !

! CodeContext methodsFor: 'simulating' !
nextFourSignedBytes

	| byte |
	byte := self nextFourBytecodes.
	^byte >= 2147483648
		ifTrue: [byte - 4294967296]
		ifFalse: [byte] ! !

! CodeContext methodsFor: 'simulating' !
nextSignedByte

	| byte |
	byte := self nextBytecode.
	^byte >= 128
		ifTrue: [byte - 256]
		ifFalse: [byte]! !

! CodeContext methodsFor: 'simulating' !
nextTwoBytecodes

	^(self nextBytecode * 256) + self nextBytecode! !

! CodeContext methodsFor: 'simulating' !
nextTwoSignedBytes

	| byte |
	byte := self nextTwoBytecodes.
	^byte >= 32768
		ifTrue: [byte - 65536]
		ifFalse: [byte]! !

! CodeContext methodsFor: 'simulating' !
peek

	^self basicAt: stackOffset! !

! CodeContext methodsFor: 'simulating' !
peek: aNumber

	^self basicAt: stackOffset - aNumber! !

! CodeContext methodsFor: 'simulating' !
peekBytecode

	^method bytecodes at: pcOffset + 1! !

! CodeContext methodsFor: 'simulating' !
pop

	| result |
	result := self basicAt: stackOffset.
	stackOffset := stackOffset - 1.
	^result! !

! CodeContext methodsFor: 'simulating' !
push: anObject

	stackOffset := stackOffset + 1.
	stackOffset > self basicSize ifTrue: [self grow].
	self basicAt: stackOffset put: anObject! !

! CodeContext methodsFor: 'simulating' !
pushCopyingBlock: aNumber copiedVariables: numberOfCopiedVariables

	| copiedVariables compiledBlock |

	compiledBlock := method basicAt: aNumber + 1.

	copiedVariables := Array new: numberOfCopiedVariables.
	numberOfCopiedVariables to: 1 by: -1 do: [:index |
		copiedVariables at: index put: self pop].

	self push: (BlockClosure new
		method: compiledBlock;
		copiedValues: copiedVariables;
		yourself)
! !

! CodeContext methodsFor: 'simulating' !
pushFullBlock: aNumber copiedVariables: numberOfCopiedVariables

	| copiedVariables compiledBlock |

	compiledBlock := method basicAt: aNumber + 1.

	copiedVariables := Array new: numberOfCopiedVariables.
	numberOfCopiedVariables to: 1 by: -1 do: [:index |
		copiedVariables at: index put: self pop].

	self push: (BlockClosure new
		method: compiledBlock;
		copiedValues: copiedVariables;
		methodContext: (self methodContext ifNil: [self contextId]);
		yourself)
! !

! CodeContext methodsFor: 'simulating' !
pushGlobal: aNumber

	self push: (self method basicAt: aNumber + 1) value! !

! CodeContext methodsFor: 'simulating' !
pushInstVar: aNumber

	self push: (self receiver instVarAt: aNumber + 1)! !

! CodeContext methodsFor: 'simulating' !
pushLiteral: aNumber

	self push: (self method basicAt: aNumber + 1)! !

! CodeContext methodsFor: 'simulating' !
pushLocal: aNumber

	self push: (self basicLocalAt: aNumber + 1)! !

! CodeContext methodsFor: 'simulating' !
pushLocal: aNumber indirect: varNumber

	| localObject instSize |
	localObject := self basicLocalAt: aNumber + 1.
	instSize := localObject class instSize.
	self push: (varNumber <= instSize
		ifTrue: [localObject instVarAt: varNumber + 1]
		ifFalse: [localObject basicAt: varNumber + 1 - instSize]) ! !

! CodeContext methodsFor: 'simulating' !
pushSelf

	self push: self receiver! !

! CodeContext methodsFor: 'simulating' !
pushSelfInstVar: aNumber

	self push: (self receiver instVarAt: aNumber + 1) ! !

! CodeContext methodsFor: 'simulating' !
restart

	stackOffset := 0.
	pcOffset := 0! !

! CodeContext methodsFor: 'simulating' !
storeGlobal: aNumber

	(self method basicAt: aNumber + 1) value: self pop! !

! CodeContext methodsFor: 'simulating' !
storeInstVar: aNumber

	self receiver instVarAt: aNumber + 1 put: self peek! !

! CodeContext methodsFor: 'simulating' !
storeLocal: aNumber

	self basicLocalAt: aNumber + 1 put: self peek! !

! CodeContext methodsFor: 'simulating' !
storeLocal: aNumber indirect: varNumber

	| localObject instSize |
	localObject := self basicLocalAt: aNumber + 1.
	instSize := localObject class instSize.
	varNumber <= instSize
		ifTrue: [localObject instVarAt: varNumber + 1 put: self peek]
		ifFalse: [localObject basicAt: varNumber + 1 - instSize put: self peek] ! !

! CodeContext methodsFor: 'simulating' !
storeNewArray: size local: localNumber

	self basicLocalAt: localNumber + 1 put: (Array new: size)
! !

! CodeContext methodsFor: 'simulating' !
storeSelfInstVar: aNumber

	self receiver instVarAt: aNumber + 1 put: self peek ! !

! CodeContext methodsFor: 'testing' !
isBlockContext

	^(method isMemberOf: CompiledMethod) not! !

! CodeContext class methodsFor: 'bytecodes' !
bytecodeBlockAt: bytecodeNumber

	^bytecodeBlocks at: bytecodeNumber + 1

! !

! CodeContext class methodsFor: 'bytecodes' !
bytecodeBlockAt: bytecodeNumber put: aBlock

	bytecodeBlocks at: bytecodeNumber + 1 put: aBlock

! !

! CodeContext class methodsFor: 'bytecodes' !
bytecodeBlocks

	bytecodeBlocks isNil ifTrue: [self setupBytecodeBlocks].
	^bytecodeBlocks! !

! CodeContext class methodsFor: 'bytecodes' !
callReturnBytecodes

	self
		bytecodeBlockAt: 16rC0 put: [:simulator | simulator call: 0 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 1"
		bytecodeBlockAt: 16rC1 put: [:simulator | simulator call: 1 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 2"
		bytecodeBlockAt: 16rC2 put: [:simulator | simulator call: 2 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 3"
		bytecodeBlockAt: 16rC3 put: [:simulator | simulator call: 3 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 4"
		bytecodeBlockAt: 16rC4 put: [:simulator | simulator call: 4 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 5"
		bytecodeBlockAt: 16rC5 put: [:simulator | simulator call: 5 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 6"
		bytecodeBlockAt: 16rC6 put: [:simulator | simulator call: 6 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 7"
		bytecodeBlockAt: 16rC7 put: [:simulator | simulator call: 7 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 8"
		bytecodeBlockAt: 16rC8 put: [:simulator | simulator call: 8 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 9"
		bytecodeBlockAt: 16rC9 put: [:simulator | simulator call: 9 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 10"
		bytecodeBlockAt: 16rCA put: [:simulator | simulator call: 10 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 11"
		bytecodeBlockAt: 16rCB put: [:simulator | simulator call: 11 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 12"
		bytecodeBlockAt: 16rCC put: [:simulator | simulator call: 12 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 13"
		bytecodeBlockAt: 16rCD put: [:simulator | simulator call: 13 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 14"
		bytecodeBlockAt: 16rCE put: [:simulator | simulator call: 14 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 15"
		bytecodeBlockAt: 16rCF put: [:simulator | simulator call: 15 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 16"

		bytecodeBlockAt: 16rD0 put: [:simulator | simulator superCall: 0 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 1"
		bytecodeBlockAt: 16rD1 put: [:simulator | simulator superCall: 1 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 2"
		bytecodeBlockAt: 16rD2 put: [:simulator | simulator superCall: 2 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 3"
		bytecodeBlockAt: 16rD3 put: [:simulator | simulator superCall: 3 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 4"
		bytecodeBlockAt: 16rD4 put: [:simulator | simulator superCall: 4 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 5"
		bytecodeBlockAt: 16rD5 put: [:simulator | simulator superCall: 5 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 6"

		bytecodeBlockAt: 16rD6 put: [:simulator | simulator callWellKnown: simulator currentContext nextBytecode; yourself]; 		"Call well known"
		bytecodeBlockAt: 16rD7 put: [:simulator | simulator call: simulator currentContext nextBytecode arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal"
		bytecodeBlockAt: 16rD8 put: [:simulator | simulator call: simulator currentContext nextTwoBytecodes arguments literals: simulator currentContext nextTwoBytecodes; yourself]; 		"Call literal extended"
		bytecodeBlockAt: 16rD9 put: [:simulator | simulator superCall: simulator currentContext nextBytecode arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal"
		bytecodeBlockAt: 16rDA put: [:simulator | simulator superCall: simulator currentContext nextTwoBytecodes arguments literals: simulator currentContext nextTwoBytecodes; yourself]; 		"Super call literal extended"
		bytecodeBlockAt: 16rDB put: [:simulator | simulator callPrimitive: simulator currentContext nextBytecode arguments: simulator currentContext nextBytecode; yourself]; 		"Call primitive"

		bytecodeBlockAt: 16rDC put: [:simulator | simulator return; yourself]; 		"Return"
		bytecodeBlockAt: 16rDD put: [:simulator | simulator blockReturn; yourself]; 		"Block Return"
		bytecodeBlockAt: 16rDE put: [:simulator | simulator nonLocalReturn; yourself]; 		"Non Local Return"
		bytecodeBlockAt: 16rDF put: [:simulator | simulator primitiveReturn; yourself]; 		"Primitive Return"
		yourself

! !

! CodeContext class methodsFor: 'bytecodes' !
clearBytecodeBlocks

	bytecodeBlocks := nil! !

! CodeContext class methodsFor: 'bytecodes' !
jumpBytecodes

	self
		bytecodeBlockAt: 16rB0 put: [:simulator | simulator currentContext jump: simulator currentContext nextSignedByte; yourself]; 		"Jump"
		bytecodeBlockAt: 16rB1 put: [:simulator | simulator currentContext jump: simulator currentContext nextTwoSignedBytes; yourself]; 		"Jump Extended"
		bytecodeBlockAt: 16rB2 put: [:simulator | simulator currentContext jumpIfTrue: simulator currentContext nextSignedByte; yourself]; 		"Jump If True"
		bytecodeBlockAt: 16rB3 put: [:simulator | simulator currentContext jumpIfTrue: simulator currentContext nextTwoSignedBytes; yourself]; 		"Jump If True Extended"
		bytecodeBlockAt: 16rB4 put: [:simulator | simulator currentContext jumpIfFalse: simulator currentContext nextSignedByte; yourself]; 		"Jump If False"
		bytecodeBlockAt: 16rB5 put: [:simulator | simulator currentContext jumpIfFalse: simulator currentContext nextTwoSignedBytes; yourself]; 		"Jump If False Extended"
		yourself

! !

! CodeContext class methodsFor: 'bytecodes' !
pushGlobalBytecodes

	self
		bytecodeBlockAt: 16r40 put: [:simulator | simulator currentContext pushGlobal: 0; yourself]; 		"Push Global 0"
		bytecodeBlockAt: 16r41 put: [:simulator | simulator currentContext pushGlobal: 1; yourself]; 		"Push Global 1"
		bytecodeBlockAt: 16r42 put: [:simulator | simulator currentContext pushGlobal: 2; yourself]; 		"Push Global 2"
		bytecodeBlockAt: 16r43 put: [:simulator | simulator currentContext pushGlobal: 3; yourself]; 		"Push Global 3"
		bytecodeBlockAt: 16r44 put: [:simulator | simulator currentContext pushGlobal: 4; yourself]; 		"Push Global 4"
		bytecodeBlockAt: 16r45 put: [:simulator | simulator currentContext pushGlobal: 5; yourself]; 		"Push Global 5"
		bytecodeBlockAt: 16r46 put: [:simulator | simulator currentContext pushGlobal: 6; yourself]; 		"Push Global 6"
		bytecodeBlockAt: 16r47 put: [:simulator | simulator currentContext pushGlobal: 7; yourself]; 		"Push Global 7"
		bytecodeBlockAt: 16r48 put: [:simulator | simulator currentContext pushGlobal: 8; yourself]; 		"Push Global 8"
		bytecodeBlockAt: 16r49 put: [:simulator | simulator currentContext pushGlobal: 9; yourself]; 		"Push Global 9"
		bytecodeBlockAt: 16r4A put: [:simulator | simulator currentContext pushGlobal: 10; yourself]; 		"Push Global 10"
		bytecodeBlockAt: 16r4B put: [:simulator | simulator currentContext pushGlobal: 11; yourself]; 		"Push Global 11"
		bytecodeBlockAt: 16r4C put: [:simulator | simulator currentContext pushGlobal: 12; yourself]; 		"Push Global 12"
		bytecodeBlockAt: 16r4D put: [:simulator | simulator currentContext pushGlobal: 13; yourself]; 		"Push Global 13"
		bytecodeBlockAt: 16r4E put: [:simulator | simulator currentContext pushGlobal: 14; yourself]; 		"Push Global 14"
		bytecodeBlockAt: 16r4F put: [:simulator | simulator currentContext pushGlobal: 15; yourself]; 		"Push Global 15"
		bytecodeBlockAt: 16r9A put: [:simulator | simulator currentContext pushGlobal: simulator currentContext nextBytecode; yourself]; 		"Push Global"
		bytecodeBlockAt: 16r9B put: [:simulator | simulator currentContext pushGlobal: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Global Extended"
		yourself

 ! !

! CodeContext class methodsFor: 'bytecodes' !
pushInstVarBytecodes

	self
		bytecodeBlockAt: 16r00 put: [:simulator | simulator currentContext pushInstVar: 0; yourself]; 		"Push Inst Var 0"
		bytecodeBlockAt: 16r01 put: [:simulator | simulator currentContext pushInstVar: 1; yourself]; 		"Push Inst Var 1"
		bytecodeBlockAt: 16r02 put: [:simulator | simulator currentContext pushInstVar: 2; yourself]; 		"Push Inst Var 2"
		bytecodeBlockAt: 16r03 put: [:simulator | simulator currentContext pushInstVar: 3; yourself]; 		"Push Inst Var 3"
		bytecodeBlockAt: 16r04 put: [:simulator | simulator currentContext pushInstVar: 4; yourself]; 		"Push Inst Var 4"
		bytecodeBlockAt: 16r05 put: [:simulator | simulator currentContext pushInstVar: 5; yourself]; 		"Push Inst Var 5"
		bytecodeBlockAt: 16r06 put: [:simulator | simulator currentContext pushInstVar: 6; yourself]; 		"Push Inst Var 6"
		bytecodeBlockAt: 16r07 put: [:simulator | simulator currentContext pushInstVar: 7; yourself]; 		"Push Inst Var 7"
		bytecodeBlockAt: 16r08 put: [:simulator | simulator currentContext pushInstVar: 8; yourself]; 		"Push Inst Var 8"
		bytecodeBlockAt: 16r09 put: [:simulator | simulator currentContext pushInstVar: 9; yourself]; 		"Push Inst Var 9"
		bytecodeBlockAt: 16r0A put: [:simulator | simulator currentContext pushInstVar: 10; yourself]; 		"Push Inst Var 10"
		bytecodeBlockAt: 16r0B put: [:simulator | simulator currentContext pushInstVar: 11; yourself]; 		"Push Inst Var 11"
		bytecodeBlockAt: 16r0C put: [:simulator | simulator currentContext pushInstVar: 12; yourself]; 		"Push Inst Var 12"
		bytecodeBlockAt: 16r0D put: [:simulator | simulator currentContext pushInstVar: 13; yourself]; 		"Push Inst Var 13"
		bytecodeBlockAt: 16r0E put: [:simulator | simulator currentContext pushInstVar: 14; yourself]; 		"Push Inst Var 14"
		bytecodeBlockAt: 16r0F put: [:simulator | simulator currentContext pushInstVar: 15; yourself]; 		"Push Inst Var 15"
		bytecodeBlockAt: 16r94 put: [:simulator | simulator currentContext pushInstVar: simulator currentContext nextBytecode; yourself]; 		"Push Inst Var"
		bytecodeBlockAt: 16r95 put: [:simulator | simulator currentContext pushInstVar: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Inst Var Extended"
		bytecodeBlockAt: 16rB7 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Push Self Inst Var"
		bytecodeBlockAt: 16rB8 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Local Indirect Extended"
		yourself

 ! !

! CodeContext class methodsFor: 'bytecodes' !
pushIntegerBytecodes

	self
		bytecodeBlockAt: 16r60 put: [:simulator | simulator currentContext push: 1; yourself]; 		"Push 1"
		bytecodeBlockAt: 16r61 put: [:simulator | simulator currentContext push: 2; yourself]; 		"Push 2"
		bytecodeBlockAt: 16r62 put: [:simulator | simulator currentContext push: 3; yourself]; 		"Push 3"
		bytecodeBlockAt: 16r63 put: [:simulator | simulator currentContext push: 4; yourself]; 		"Push 4"
		bytecodeBlockAt: 16r64 put: [:simulator | simulator currentContext push: 5; yourself]; 		"Push 5"
		bytecodeBlockAt: 16r65 put: [:simulator | simulator currentContext push: 6; yourself]; 		"Push 6"
		bytecodeBlockAt: 16r66 put: [:simulator | simulator currentContext push: 7; yourself]; 		"Push 7"
		bytecodeBlockAt: 16r67 put: [:simulator | simulator currentContext push: 8; yourself]; 		"Push 8"
		bytecodeBlockAt: 16r68 put: [:simulator | simulator currentContext push: 9; yourself]; 		"Push 9"
		bytecodeBlockAt: 16r69 put: [:simulator | simulator currentContext push: 10; yourself]; 		"Push 10"
		bytecodeBlockAt: 16r6A put: [:simulator | simulator currentContext push: 11; yourself]; 		"Push 11"
		bytecodeBlockAt: 16r6B put: [:simulator | simulator currentContext push: 12; yourself]; 		"Push 12"
		bytecodeBlockAt: 16r6C put: [:simulator | simulator currentContext push: 13; yourself]; 		"Push 13"
		bytecodeBlockAt: 16r6D put: [:simulator | simulator currentContext push: 14; yourself]; 		"Push 14"
		bytecodeBlockAt: 16r6E put: [:simulator | simulator currentContext push: 15; yourself]; 		"Push 15"
		bytecodeBlockAt: 16r6F put: [:simulator | simulator currentContext push: 16; yourself]; 		"Push 16"
		bytecodeBlockAt: 16r70 put: [:simulator | simulator currentContext push: 0; yourself]; 		"Push 0"
		bytecodeBlockAt: 16r71 put: [:simulator | simulator currentContext push: -1; yourself]; 		"Push -1"
		bytecodeBlockAt: 16r72 put: [:simulator | simulator currentContext push: -2; yourself]; 		"Push -2"
		bytecodeBlockAt: 16r73 put: [:simulator | simulator currentContext push: -3; yourself]; 		"Push -3"
		bytecodeBlockAt: 16r74 put: [:simulator | simulator currentContext push: -4; yourself]; 		"Push -4"
		bytecodeBlockAt: 16r75 put: [:simulator | simulator currentContext push: -5; yourself]; 		"Push -5"
		bytecodeBlockAt: 16r76 put: [:simulator | simulator currentContext push: -6; yourself]; 		"Push -6"
		bytecodeBlockAt: 16r77 put: [:simulator | simulator currentContext push: -7; yourself]; 		"Push -7"
		bytecodeBlockAt: 16r78 put: [:simulator | simulator currentContext push: -8; yourself]; 		"Push -8"
		bytecodeBlockAt: 16r79 put: [:simulator | simulator currentContext push: -9; yourself]; 		"Push -9"
		bytecodeBlockAt: 16r7A put: [:simulator | simulator currentContext push: -10; yourself]; 		"Push -10"
		bytecodeBlockAt: 16r7B put: [:simulator | simulator currentContext push: -11; yourself]; 		"Push -11"
		bytecodeBlockAt: 16r7C put: [:simulator | simulator currentContext push: -12; yourself]; 		"Push -12"
		bytecodeBlockAt: 16r7D put: [:simulator | simulator currentContext push: -13; yourself]; 		"Push -13"
		bytecodeBlockAt: 16r7E put: [:simulator | simulator currentContext push: -14; yourself]; 		"Push -14"
		bytecodeBlockAt: 16r7F put: [:simulator | simulator currentContext push: -15; yourself]; 		"Push -15"

		bytecodeBlockAt: 16r9E put: [:simulator | simulator currentContext push: simulator currentContext nextSignedByte; yourself]; 			"Push Integer"
		bytecodeBlockAt: 16r9F put: [:simulator | simulator currentContext push: simulator currentContext nextTwoSignedBytes; yourself]; 		"Push Two Byte Integer"
		bytecodeBlockAt: 16rA0 put: [:simulator | simulator currentContext push: simulator currentContext nextFourSignedBytes; yourself]; 	"Push Four Byte Integer"
		yourself

 ! !

! CodeContext class methodsFor: 'bytecodes' !
pushLiteralBytecodes

	self
		bytecodeBlockAt: 16r80 put: [:simulator | simulator currentContext pushLiteral: 0; yourself]; 		"Push Literal 0"
		bytecodeBlockAt: 16r81 put: [:simulator | simulator currentContext pushLiteral: 1; yourself]; 		"Push Literal 1"
		bytecodeBlockAt: 16r82 put: [:simulator | simulator currentContext pushLiteral: 2; yourself]; 		"Push Literal 2"
		bytecodeBlockAt: 16r83 put: [:simulator | simulator currentContext pushLiteral: 3; yourself]; 		"Push Literal 3"
		bytecodeBlockAt: 16r84 put: [:simulator | simulator currentContext pushLiteral: 4; yourself]; 		"Push Literal 4"
		bytecodeBlockAt: 16r85 put: [:simulator | simulator currentContext pushLiteral: 5; yourself]; 		"Push Literal 5"
		bytecodeBlockAt: 16r86 put: [:simulator | simulator currentContext pushLiteral: 6; yourself]; 		"Push Literal 6"
		bytecodeBlockAt: 16r87 put: [:simulator | simulator currentContext pushLiteral: 7; yourself]; 		"Push Literal 7"
		bytecodeBlockAt: 16r88 put: [:simulator | simulator currentContext pushLiteral: 8; yourself]; 		"Push Literal 8"
		bytecodeBlockAt: 16r89 put: [:simulator | simulator currentContext pushLiteral: 9; yourself]; 		"Push Literal 9"
		bytecodeBlockAt: 16r8A put: [:simulator | simulator currentContext pushLiteral: 10; yourself]; 		"Push Literal 10"
		bytecodeBlockAt: 16r8B put: [:simulator | simulator currentContext pushLiteral: 11; yourself]; 		"Push Literal 11"
		bytecodeBlockAt: 16r8C put: [:simulator | simulator currentContext pushLiteral: 12; yourself]; 		"Push Literal 12"
		bytecodeBlockAt: 16r8D put: [:simulator | simulator currentContext pushLiteral: 13; yourself]; 		"Push Literal 13"
		bytecodeBlockAt: 16r8E put: [:simulator | simulator currentContext pushLiteral: 14; yourself]; 		"Push Literal 14"
		bytecodeBlockAt: 16r8F put: [:simulator | simulator currentContext pushLiteral: 15; yourself]; 		"Push Literal 15"
		bytecodeBlockAt: 16r9C put: [:simulator | simulator currentContext pushLiteral: simulator currentContext nextBytecode; yourself]; 		"Push Literal"
		bytecodeBlockAt: 16r9D put: [:simulator | simulator currentContext pushLiteral: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Literal Extended"
		yourself

! !

! CodeContext class methodsFor: 'bytecodes' !
pushLocalBytecodes

	self
		bytecodeBlockAt: 16r20 put: [:simulator | simulator currentContext pushLocal: 0; yourself]; 		"Push Local 1"
		bytecodeBlockAt: 16r21 put: [:simulator | simulator currentContext pushLocal: 1; yourself]; 		"Push Local 2"
		bytecodeBlockAt: 16r22 put: [:simulator | simulator currentContext pushLocal: 2; yourself]; 		"Push Local 3"
		bytecodeBlockAt: 16r23 put: [:simulator | simulator currentContext pushLocal: 3; yourself]; 		"Push Local 4"
		bytecodeBlockAt: 16r24 put: [:simulator | simulator currentContext pushLocal: 4; yourself]; 		"Push Local 5"
		bytecodeBlockAt: 16r25 put: [:simulator | simulator currentContext pushLocal: 5; yourself]; 		"Push Local 6"
		bytecodeBlockAt: 16r26 put: [:simulator | simulator currentContext pushLocal: 6; yourself]; 		"Push Local 7"
		bytecodeBlockAt: 16r27 put: [:simulator | simulator currentContext pushLocal: 7; yourself]; 		"Push Local 8"
		bytecodeBlockAt: 16r28 put: [:simulator | simulator currentContext pushLocal: 8; yourself]; 		"Push Local 9"
		bytecodeBlockAt: 16r29 put: [:simulator | simulator currentContext pushLocal: 9; yourself]; 		"Push Local 10"
		bytecodeBlockAt: 16r2A put: [:simulator | simulator currentContext pushLocal: 10; yourself]; 		"Push Local 11"
		bytecodeBlockAt: 16r2B put: [:simulator | simulator currentContext pushLocal: 11; yourself]; 		"Push Local 12"
		bytecodeBlockAt: 16r2C put: [:simulator | simulator currentContext pushLocal: 12; yourself]; 		"Push Local 13"
		bytecodeBlockAt: 16r2D put: [:simulator | simulator currentContext pushLocal: 13; yourself]; 		"Push Local 14"
		bytecodeBlockAt: 16r2E put: [:simulator | simulator currentContext pushLocal: 14; yourself]; 		"Push Local 15"
		bytecodeBlockAt: 16r2F put: [:simulator | simulator currentContext pushLocal: 15; yourself]; 		"Push Local 16"
		bytecodeBlockAt: 16r96 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextBytecode; yourself]; 		"Push Local"
		bytecodeBlockAt: 16r97 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Local Extended"

		bytecodeBlockAt: 16r98 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Push Local Indirect"
		bytecodeBlockAt: 16r99 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Local Indirect Extended"

		yourself

 ! !

! CodeContext class methodsFor: 'bytecodes' !
setupBytecodeBlocks

	bytecodeBlocks := Array new: 256 withAll: [:simulator | self error: 'Unknown bytecode'].
	self
		pushInstVarBytecodes;
		storeInstVarBytecodes;
		pushLocalBytecodes;
		storeLocalBytecodes;
		pushGlobalBytecodes;
		storeGlobalBytecodes;
		pushIntegerBytecodes;
		pushLiteralBytecodes;
		callReturnBytecodes;
		jumpBytecodes;
		setupMiscBytecodes

! !

! CodeContext class methodsFor: 'bytecodes' !
setupMiscBytecodes

	self
		bytecodeBlockAt: 16r90 put: [:simulator | simulator currentContext push: true; yourself]; 		"Push true"
		bytecodeBlockAt: 16r91 put: [:simulator | simulator currentContext push: false; yourself]; 		"Push false"
		bytecodeBlockAt: 16r92 put: [:simulator | simulator currentContext push: nil; yourself]; 		"Push nil"
		bytecodeBlockAt: 16r93 put: [:simulator | simulator currentContext pushSelf; yourself]; 		"Push self"
		bytecodeBlockAt: 16rAC put: [:simulator | simulator currentContext pop; yourself]; 		"Pop"
		bytecodeBlockAt: 16rAD put: [:simulator | simulator currentContext dup; yourself]; 		"Dup"
		bytecodeBlockAt: 16rAE put: [:simulator | simulator currentContext dropCascadeReceiver; yourself]; 		"Drop Cascade Receiver"

		bytecodeBlockAt: 16rA1 put: [:simulator | simulator currentContext pushCopyingBlock: simulator currentContext nextBytecode copiedVariables: simulator currentContext nextBytecode; yourself]; 		"Push Copying Block"
		bytecodeBlockAt: 16rA2 put: [:simulator | simulator currentContext pushFullBlock: simulator currentContext nextBytecode copiedVariables: simulator currentContext nextBytecode; yourself]; 		"Push Full Block"
		bytecodeBlockAt: 16rAB put: [:simulator | simulator currentContext storeNewArray: simulator currentContext nextBytecode local: simulator currentContext nextBytecode; yourself]; 		"Store New Array"

		yourself

! !

! CodeContext class methodsFor: 'bytecodes' !
storeGlobalBytecodes

	self
		bytecodeBlockAt: 16r50 put: [:simulator | simulator currentContext storeGlobal: 0; yourself]; 		"store Global 0"
		bytecodeBlockAt: 16r51 put: [:simulator | simulator currentContext storeGlobal: 1; yourself]; 		"store Global 1"
		bytecodeBlockAt: 16r52 put: [:simulator | simulator currentContext storeGlobal: 2; yourself]; 		"store Global 2"
		bytecodeBlockAt: 16r53 put: [:simulator | simulator currentContext storeGlobal: 3; yourself]; 		"store Global 3"
		bytecodeBlockAt: 16r54 put: [:simulator | simulator currentContext storeGlobal: 4; yourself]; 		"store Global 4"
		bytecodeBlockAt: 16r55 put: [:simulator | simulator currentContext storeGlobal: 5; yourself]; 		"store Global 5"
		bytecodeBlockAt: 16r56 put: [:simulator | simulator currentContext storeGlobal: 6; yourself]; 		"store Global 6"
		bytecodeBlockAt: 16r57 put: [:simulator | simulator currentContext storeGlobal: 7; yourself]; 		"store Global 7"
		bytecodeBlockAt: 16r58 put: [:simulator | simulator currentContext storeGlobal: 8; yourself]; 		"store Global 8"
		bytecodeBlockAt: 16r59 put: [:simulator | simulator currentContext storeGlobal: 9; yourself]; 		"store Global 9"
		bytecodeBlockAt: 16r5A put: [:simulator | simulator currentContext storeGlobal: 10; yourself]; 		"store Global 10"
		bytecodeBlockAt: 16r5B put: [:simulator | simulator currentContext storeGlobal: 11; yourself]; 		"store Global 11"
		bytecodeBlockAt: 16r5C put: [:simulator | simulator currentContext storeGlobal: 12; yourself]; 		"store Global 12"
		bytecodeBlockAt: 16r5D put: [:simulator | simulator currentContext storeGlobal: 13; yourself]; 		"store Global 13"
		bytecodeBlockAt: 16r5E put: [:simulator | simulator currentContext storeGlobal: 14; yourself]; 		"store Global 14"
		bytecodeBlockAt: 16r5F put: [:simulator | simulator currentContext storeGlobal: 15; yourself]; 		"store Global 15"
		bytecodeBlockAt: 16rA9 put: [:simulator | simulator currentContext storeGlobal: simulator current nextBytecode; yourself]; 		"store Global"
		bytecodeBlockAt: 16rAA put: [:simulator | simulator currentContext storeGlobal: simulator current nextTwoBytecodes; yourself]; 		"store Global Extended"
		yourself

! !

! CodeContext class methodsFor: 'bytecodes' !
storeInstVarBytecodes

	self
		bytecodeBlockAt: 16r10 put: [:simulator | simulator currentContext storeInstVar: 0; yourself]; 		"Store Inst Var 0"
		bytecodeBlockAt: 16r11 put: [:simulator | simulator currentContext storeInstVar: 1; yourself]; 		"Store Inst Var 1"
		bytecodeBlockAt: 16r12 put: [:simulator | simulator currentContext storeInstVar: 2; yourself]; 		"Store Inst Var 2"
		bytecodeBlockAt: 16r13 put: [:simulator | simulator currentContext storeInstVar: 3; yourself]; 		"Store Inst Var 3"
		bytecodeBlockAt: 16r14 put: [:simulator | simulator currentContext storeInstVar: 4; yourself]; 		"Store Inst Var 4"
		bytecodeBlockAt: 16r15 put: [:simulator | simulator currentContext storeInstVar: 5; yourself]; 		"Store Inst Var 5"
		bytecodeBlockAt: 16r16 put: [:simulator | simulator currentContext storeInstVar: 6; yourself]; 		"Store Inst Var 6"
		bytecodeBlockAt: 16r17 put: [:simulator | simulator currentContext storeInstVar: 7; yourself]; 		"Store Inst Var 7"
		bytecodeBlockAt: 16r18 put: [:simulator | simulator currentContext storeInstVar: 8; yourself]; 		"Store Inst Var 8"
		bytecodeBlockAt: 16r19 put: [:simulator | simulator currentContext storeInstVar: 9; yourself]; 		"Store Inst Var 9"
		bytecodeBlockAt: 16r1A put: [:simulator | simulator currentContext storeInstVar: 10; yourself]; 		"Store Inst Var 10"
		bytecodeBlockAt: 16r1B put: [:simulator | simulator currentContext storeInstVar: 11; yourself]; 		"Store Inst Var 11"
		bytecodeBlockAt: 16r1C put: [:simulator | simulator currentContext storeInstVar: 12; yourself]; 		"Store Inst Var 12"
		bytecodeBlockAt: 16r1D put: [:simulator | simulator currentContext storeInstVar: 13; yourself]; 		"Store Inst Var 13"
		bytecodeBlockAt: 16r1E put: [:simulator | simulator currentContext storeInstVar: 14; yourself]; 		"Store Inst Var 14"
		bytecodeBlockAt: 16r1F put: [:simulator | simulator currentContext storeInstVar: 15; yourself]; 		"Store Inst Var 15"
		bytecodeBlockAt: 16rA3 put: [:simulator | simulator currentContext storeInstVar: simulator currentContext nextBytecode; yourself]; 		"Store Inst Var"
		bytecodeBlockAt: 16rA4 put: [:simulator | simulator currentContext storeInstVar: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Inst Var Extended"
		bytecodeBlockAt: 16rB9 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Store Local Indirect"
		bytecodeBlockAt: 16rBA put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Local Indirect Extended"
		yourself

 ! !

! CodeContext class methodsFor: 'bytecodes' !
storeLocalBytecodes

	self
		bytecodeBlockAt: 16r30 put: [:simulator | simulator currentContext storeLocal: 0; yourself]; 		"Store Local 0"
		bytecodeBlockAt: 16r31 put: [:simulator | simulator currentContext storeLocal: 1; yourself]; 		"Store Local 1"
		bytecodeBlockAt: 16r32 put: [:simulator | simulator currentContext storeLocal: 2; yourself]; 		"Store Local 2"
		bytecodeBlockAt: 16r33 put: [:simulator | simulator currentContext storeLocal: 3; yourself]; 		"Store Local 3"
		bytecodeBlockAt: 16r34 put: [:simulator | simulator currentContext storeLocal: 4; yourself]; 		"Store Local 4"
		bytecodeBlockAt: 16r35 put: [:simulator | simulator currentContext storeLocal: 5; yourself]; 		"Store Local 5"
		bytecodeBlockAt: 16r36 put: [:simulator | simulator currentContext storeLocal: 6; yourself]; 		"Store Local 6"
		bytecodeBlockAt: 16r37 put: [:simulator | simulator currentContext storeLocal: 7; yourself]; 		"Store Local 7"
		bytecodeBlockAt: 16r38 put: [:simulator | simulator currentContext storeLocal: 8; yourself]; 		"Store Local 8"
		bytecodeBlockAt: 16r39 put: [:simulator | simulator currentContext storeLocal: 9; yourself]; 		"Store Local 9"
		bytecodeBlockAt: 16r3A put: [:simulator | simulator currentContext storeLocal: 10; yourself]; 		"Store Local 10"
		bytecodeBlockAt: 16r3B put: [:simulator | simulator currentContext storeLocal: 11; yourself]; 		"Store Local 11"
		bytecodeBlockAt: 16r3C put: [:simulator | simulator currentContext storeLocal: 12; yourself]; 		"Store Local 12"
		bytecodeBlockAt: 16r3D put: [:simulator | simulator currentContext storeLocal: 13; yourself]; 		"Store Local 13"
		bytecodeBlockAt: 16r3E put: [:simulator | simulator currentContext storeLocal: 14; yourself]; 		"Store Local 14"
		bytecodeBlockAt: 16r3F put: [:simulator | simulator currentContext storeLocal: 15; yourself]; 		"Store Local 15"
		bytecodeBlockAt: 16rA5 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextBytecode; yourself]; 		"Store Local"
		bytecodeBlockAt: 16rA6 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Local Extended"


		bytecodeBlockAt: 16rA7 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Store Local Indirect"
		bytecodeBlockAt: 16rA8 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Local Indirect Extended"
		yourself

! !

! CodeContext class methodsFor: 'instance creation' !
new

	^super new initialize
! !

! CodeSimulator methodsFor: 'accessing' !
currentContext

	^currentContext! !

! CodeSimulator methodsFor: 'accessing' !
currentContext: aCodeContext

	currentContext := aCodeContext! !

! CodeSimulator methodsFor: 'accessing' !
frames

	^frames! !

! CodeSimulator methodsFor: 'accessing' !
frames: aCollection

	frames := aCollection.
	self currentContext: aCollection first
! !

! CodeSimulator methodsFor: 'accessing' !
stopFrame

	^stopFrame! !

! CodeSimulator methodsFor: 'accessing' !
stopFrame: aCodeContext

	stopFrame := aCodeContext
! !

! CodeSimulator methodsFor: 'accessing' !
stopMethod

	^stopMethod! !

! CodeSimulator methodsFor: 'accessing' !
stopMethod: aCompiledMethod

	stopMethod := aCompiledMethod
! !

! CodeSimulator methodsFor: 'simulating' !
blockReturn

	| returnValue |

	returnValue := currentContext pop.
	frames removeFirst.
	currentContext := frames first.
	currentContext push: returnValue
! !

! CodeSimulator methodsFor: 'simulating' !
buildFrameFor: aCompiledMethod

	self frames addFirst: (currentContext := CodeContext new
		method: aCompiledMethod;
		frame: currentContext;
		contextId: currentContext contextId - self class headerSize;
		yourself).
! !

! CodeSimulator methodsFor: 'simulating' !
call: literalNumber arguments: aNumber

	| selector compiledMethod receiver args |

	args := Array new: aNumber.

	selector := self currentContext method basicAt: literalNumber + 1.
	compiledMethod := self currentContext findCompiledMethod: selector startingAt: (self currentContext peek: aNumber) class.
	compiledMethod isNil ifTrue: [^self error: 'Message not understood'].

	compiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].
	compiledMethod numberOfTemporaries timesRepeat: [currentContext pop].

	aNumber to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.

	self invoke: compiledMethod on: receiver selector: selector arguments: args
! !

! CodeSimulator methodsFor: 'simulating' !
callSelector: aSymbol arguments: aNumber

	| selector compiledMethod receiver args |

	args := Array new: aNumber.

	compiledMethod := self currentContext findCompiledMethod: aSymbol startingAt: (self currentContext peek: aNumber) class.

	compiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].
	compiledMethod numberOfTemporaries timesRepeat: [currentContext pop].

	aNumber to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.

	self invoke: compiledMethod on: receiver selector: aSymbol arguments: args
! !

! CodeSimulator methodsFor: 'simulating' !
callWellKnown: aNumber

	| receiver selector args |

	selector := CodeGenerator specialSelectors at: aNumber + 1.

	args := Array new: selector numArgs.

	args size to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.
	(selector = #perform:withArguments:) ifTrue: [
		currentContext push: receiver.
		(args at: 2) do: [:each | currentContext push: each].
		self callSelector: args first arguments: args first numArgs.
		^self].

	currentContext push: (receiver perform: selector withArguments: args)
	
	
! !

! CodeSimulator methodsFor: 'simulating' !
getMethodStartFrame

	| currentMethod |

	currentMethod := self currentContext rootMethod.

	self frames reverseDo: [:context |
		(context isBlockContext not and: [context method = currentMethod]) ifTrue: [
			^context]].

	^nil


! !

! CodeSimulator methodsFor: 'simulating' !
into

	| bytecode |
	self stopFrame: nil; stopMethod: nil.

	bytecode := currentContext nextBytecode.
	self runBytecode: bytecode.
	self runToImportantBytecode! !

! CodeSimulator methodsFor: 'simulating' !
invoke: aCompiledMethod on: receiver selector: aSymbol arguments: anArray

	(aCompiledMethod selector = #halt) ifTrue: [
		currentContext push: receiver.
		^self].

	aCompiledMethod isPrimitive ifTrue: [
		(aCompiledMethod mclass = BlockClosure and: [#(value value: value:value: value:withArguments:) includes: aCompiledMethod selector]) ifTrue: [
			^self invokeBlock: receiver method: aCompiledMethod arguments: anArray].
		^self currentContext push: (receiver perform: aSymbol withArguments: anArray)].

	aCompiledMethod isNil ifTrue: [^receiver doesNotUnderstand: aSymbol ].
	self buildFrameFor: aCompiledMethod! !

! CodeSimulator methodsFor: 'simulating' !
invokeBlock: aBlockClosure method: aCompiledMethod arguments: anArray

	| previousStackOffset |

	"Simulate a call into the value... method"
	self frames addFirst: (currentContext := CodeContext new
		method: aCompiledMethod ;
		frame: currentContext;
		pcOffset: 3;
		contextId: currentContext contextId - self class headerSize;
		yourself).


	currentContext push: 0.

	previousStackOffset := currentContext stackOffset.

	currentContext push: aBlockClosure.

	anArray do: [:each | currentContext push: each].
	aBlockClosure copiedValues notNil ifTrue: [
		aBlockClosure copiedValues do: [:each | currentContext push: each]].

	aCompiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].

	currentContext stackOffset: previousStackOffset.

	self frames addFirst: (currentContext := CodeContext new
		method: aBlockClosure method;
		frame: currentContext;
		methodContext: aBlockClosure methodContext;
		contextId: currentContext contextId - self class headerSize;
		yourself).

	

 ! !

! CodeSimulator methodsFor: 'simulating' !
isImportantBytecode: aBytecode

	^#(call super callWellKnown return blockReturn nonLocalReturn primitive storeInstVar storeLocal storeGlobal storeLocalIndirect)
		includes: (CodeGenerator bytecodesByIndex at: aBytecode + 1) type! !

! CodeSimulator methodsFor: 'simulating' !
isReturnBytecode: aBytecode

	^#(return nonLocalReturn)
		includes: (CodeGenerator bytecodesByIndex at: aBytecode + 1) type! !

! CodeSimulator methodsFor: 'simulating' !
nonLocalReturn

	| returnValue stop |

	returnValue := currentContext pop.
	stop := false.

	frames detect: [:each | each contextId == currentContext methodContext] ifNone: [^self error: 'This block has already returned'].

	[frames notEmpty and: [frames first contextId ~~ currentContext methodContext]] whileTrue: [
		frames first method == self stopMethod ifTrue: [stop := true].
		frames removeFirst].

	currentContext := frames first.
	stop ifTrue: [
		self
			stopMethod: nil;
			stopFrame: nil].

	currentContext push: returnValue.
	self return
! !

! CodeSimulator methodsFor: 'simulating' !
over

	| bytecode |
	self stopFrame: self currentContext; stopMethod: nil.
	(self isImportantBytecode: currentContext peekBytecode)
		ifTrue: [
			(self isReturnBytecode: currentContext peekBytecode)
				ifTrue: [self runBytecode: currentContext peekBytecode]
				ifFalse: [self runBytecodes]].
	self runToImportantBytecode! !

! CodeSimulator methodsFor: 'simulating' !
primitiveReturn

	| topOfStack result |

	topOfStack := currentContext pop.
	result := currentContext pop.

	result = 0
		ifTrue: [currentContext push: topOfStack. self return]
		ifFalse: [currentContext push: result]
! !

! CodeSimulator methodsFor: 'simulating' !
reinvokeMethod

	| startFrame receiver |

	startFrame := self getMethodStartFrame.
	receiver := startFrame receiver.

	self currentContext: startFrame.
	self returnToCurrentFrame.
	self currentContext method: (self currentContext method mclass compiledMethodAt: self currentContext method selector).
	self restart

! !

! CodeSimulator methodsFor: 'simulating' !
restart

	self currentContext restart

! !

! CodeSimulator methodsFor: 'simulating' !
return

	| returnValue |

	returnValue := currentContext pop.
	frames removeFirst.
	currentContext := frames first.
	currentContext push: returnValue
! !

! CodeSimulator methodsFor: 'simulating' !
returnToCurrentFrame

	[frames first == self currentContext] whileFalse: [
		frames removeFirst].
! !

! CodeSimulator methodsFor: 'simulating' !
returnToFrame: aFrame

	[frames first == aFrame] whileFalse: [
		frames removeFirst].

	self currentContext: aFrame
! !

! CodeSimulator methodsFor: 'simulating' !
runBytecode: bytecode

	(CodeContext bytecodeBlockAt: bytecode) value: self
! !

! CodeSimulator methodsFor: 'simulating' !
runBytecodes

	[
	self runBytecode: currentContext nextBytecode.
	self shouldContinueRunning] whileTrue: []

! !

! CodeSimulator methodsFor: 'simulating' !
runToContext: aCodeContext

	self stopContext: aCodeContext; stopMethod: nil.
	self runBytecodes

! !

! CodeSimulator methodsFor: 'simulating' !
runToImportantBytecode

	| bytecode |
	[bytecode := currentContext peekBytecode.
	self isImportantBytecode: bytecode] whileFalse: [
		currentContext nextBytecode.
		self runBytecode: bytecode]! !

! CodeSimulator methodsFor: 'simulating' !
shouldContinueRunning

	(self stopFrame isNil & self stopMethod isNil) ifTrue: [^false].
	(self stopFrame notNil and: [self currentContext == self stopFrame]) ifTrue: [^false].
	(self stopMethod notNil and: [self currentContext method rootMethod == self stopMethod]) ifTrue: [^false].
	^true


! !

! CodeSimulator methodsFor: 'simulating' !
stepBytecode

	| bytecode |
	self stopFrame: nil; stopMethod: nil.

	bytecode := currentContext nextBytecode.
	self runBytecode: bytecode! !

! CodeSimulator methodsFor: 'simulating' !
superCall: literalNumber arguments: aNumber

	| selector compiledMethod  receiver args startingClass |

	args := Array new: aNumber.

	selector := self currentContext method basicAt: literalNumber + 1.
	compiledMethod := self currentContext findCompiledMethod: selector startingAt: (self currentContext peek: 0) superclass.

	compiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].
	compiledMethod numberOfTemporaries timesRepeat: [currentContext pop].

	startingClass := currentContext pop.

	aNumber to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.

	self invoke: compiledMethod on: receiver selector: selector arguments: args
! !

! CodeSimulator methodsFor: 'simulating' !
through

	| bytecode |
	self stopFrame: nil; stopMethod: self currentContext method rootMethod.

	(self isImportantBytecode: currentContext peekBytecode)
		ifTrue: [
			(self isReturnBytecode: currentContext peekBytecode)
				ifTrue: [self runBytecode: currentContext peekBytecode]
				ifFalse: [self runBytecodes]].
	self runToImportantBytecode! !

! CodeSimulator class methodsFor: 'accessing' !
headerSize

	^40! !

! CommandHandler methodsFor: 'processing' !
processMessage: aMessage onWebSocket: aWebSocket

	| commandStream command |

	commandStream := (aMessage isString ifTrue: [aMessage] ifFalse: [aMessage message]) readStream.
	command := commandStream upTo: Character space.

	command = 'printit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult printString.
		^true].
	command = 'storeit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult storeString.
		^true].
	command = 'doit' ifTrue: [
		SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '"Done"'.
		^true].
	command = 'filein' ifTrue: [
		commandStream upToEnd readStream fileIn.
		aWebSocket send: '"Done"'.
		^true].
	command = 'showstring' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult.
		^true].
	command = 'close' ifTrue: [
		aWebSocket close.
		^false].
	command = 'shutdown' ifTrue: [
		BeagleSystem shutdown.
		^false].
	command = 'renderit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '~', evaluateResult.
		^true].
	command = 'keydown' ifTrue: [
		aWebSocket send: 'Key: ', commandStream upToEnd.
		^true].
	command = 'mouseMove' ifTrue: [
		aWebSocket send: 'MouseMove: ', commandStream upToEnd.
		^true].
	command = 'mouseDown' ifTrue: [
		aWebSocket send: 'MouseDown: ', commandStream upToEnd.
		^true].
	command = 'mouseUp' ifTrue: [
		aWebSocket send: 'MouseUp: ', commandStream upToEnd.
		^true].
	command = 'wheel' ifTrue: [
		aWebSocket send: 'Wheel: ', commandStream upToEnd.
		^true].
	command = 'evaluateJSON' ifTrue: [
		JSONParser evaluateJsonString: commandStream upToEnd.
		^true].
! !

! CompileError methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset ifNil: [-1]! !

! CompileError methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject! !

! CompileError methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset! !

! CompileError methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject! !

! CompileWarning methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset! !

! CompileWarning methodsFor: 'accessing' !
endSourceOffset: aNumber

	endSourceOffset := aNumber! !

! CompileWarning methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset! !

! CompileWarning methodsFor: 'accessing' !
startSourceOffset: aNumber

	startSourceOffset := aNumber! !

! DecompileStream methodsFor: 'accessing' !
byteStream

	^byteStream! !

! DecompileStream methodsFor: 'accessing' !
byteStream: aStream

	byteStream := aStream! !

! DecompileStream methodsFor: 'accessing' !
compiledCode

	^compiledCode! !

! DecompileStream methodsFor: 'accessing' !
compiledCode: aStream

	compiledCode := aStream! !

! DecompileStream methodsFor: 'reading' !
atEnd

	^byteStream atEnd! !

! DecompileStream methodsFor: 'reading' !
next

	| bytecode position bytecodeSpec additionalBytes |

	self atEnd ifTrue: [^nil].

	position := byteStream position.
	bytecode := byteStream next.
	bytecodeSpec := (CodeGenerator bytecodesByIndex at: bytecode + 1).
	additionalBytes := byteStream nextAvailable: bytecodeSpec numberOfBytes - 1.

	^Array with: position with: bytecode with: bytecodeSpec with: additionalBytes! !

! DecompileStream class methodsFor: 'instance creation' !
on: aCompiledCode

	^self new
		compiledCode: aCompiledCode;
		byteStream: aCompiledCode bytecodes readStream;
		yourself! !

! Decompiler methodsFor: 'accessing' !
finishLine

	| string |
	string := (WriteStream on: String new)
				nextPutAll: offsetStream contents;
				nextPutAll: ':   ';
				nextPutAll: formattedBytecodeStream contents;
				nextPutAll: (String new: (25 - formattedBytecodeStream contents size) // 4
							withAll: Character tab);
				nextPutAll: decompiledCodeStream contents;
				contents.

	self resetLineStreams.

	resultStream nextPutAll: string; cr! !

! Decompiler methodsFor: 'accessing' !
finishLineNoBytes

	| string |
	string := (WriteStream on: String new)
				nextPutAll: offsetStream contents;
				nextPutAll: ':   ';
				nextPutAll: decompiledCodeStream contents;
				contents.

	self resetLineStreams.

	resultStream nextPutAll: string; cr! !

! Decompiler methodsFor: 'accessing' !
literals

	^literals! !

! Decompiler methodsFor: 'accessing' !
literals: anObject

	literals := anObject! !

! Decompiler methodsFor: 'accessing' !
numberOfArguments

	^numberOfArguments! !

! Decompiler methodsFor: 'accessing' !
numberOfArguments: anObject

	numberOfArguments := anObject! !

! Decompiler methodsFor: 'accessing' !
numberOfCopiedVariables

	^numberOfCopiedVariables! !

! Decompiler methodsFor: 'accessing' !
numberOfCopiedVariables: anObject

	numberOfCopiedVariables := anObject! !

! Decompiler methodsFor: 'accessing' !
numberOfTemporaries

	^numberOfTemporaries! !

! Decompiler methodsFor: 'accessing' !
numberOfTemporaries: anObject

	numberOfTemporaries := anObject! !

! Decompiler methodsFor: 'accessing' !
resetLineStreams

	offsetStream := WriteStream on: String new.
	formattedBytecodeStream := WriteStream on: String new.
	decompiledCodeStream := WriteStream on: String new! !

! Decompiler methodsFor: 'accessing' !
result

	^resultStream contents! !

! Decompiler methodsFor: 'accessing' !
targetClass

	^targetClass! !

! Decompiler methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject! !

! Decompiler methodsFor: 'decompiling' !
decompile

	self writeHeader.
	[byteStream atEnd] whileFalse: 
			[self decompileNextBytecode.
				self finishLine].! !

! Decompiler methodsFor: 'decompiling' !
decompile: aByteArray

	byteStream := aByteArray readStream.
	self resetLineStreams.

	self decompile.
	^self result! !

! Decompiler methodsFor: 'decompiling' !
decompileNextBytecode

	| byte byteString stream |
	self writeOffset.
	byte := self writeNextBytecode.

	byteString := (CodeGenerator bytecodesByIndex at: byte + 1) decompileString.

	stream := byteString readStream.

	[stream atEnd] whileFalse: [
		| character |
		character := stream next.
		character = $%
			ifTrue: [self readEscapeSequenceFrom: stream]
			ifFalse: [decompiledCodeStream nextPut: character] ]! !

! Decompiler methodsFor: 'decompiling' !
decompileNoBytes

	self writeHeader.
	[byteStream atEnd] whileFalse: 
			[self decompileNextBytecode.
				self finishLineNoBytes].! !

! Decompiler methodsFor: 'decompiling' !
decompileNoBytes: aByteArray

	byteStream := aByteArray readStream.
	self resetLineStreams.

	self decompileNoBytes.
	^self result! !

! Decompiler methodsFor: 'decompiling' !
decompileSingleBytecode

	self decompileNextBytecode.
	self finishLine ! !

! Decompiler methodsFor: 'decompiling' !
decompileSingleBytecodeFrom: aByteArray startingAt: offset

	byteStream := aByteArray readStream.
	byteStream position: offset.
	self resetLineStreams.

	self decompileSingleBytecode.
	^self result ! !

! Decompiler methodsFor: 'decompiling' !
readEscapeSequenceFrom: aStream

	| number character |

	number := Integer readFrom: aStream.

	character := aStream next.
	character = $b ifTrue: [
		| integer |
		integer := 0.
		number = 0 ifTrue: [number := 1].
		number timesRepeat: [integer := integer * 256 + self writeNextBytecode].
		integer >= (2 raisedToInteger: ((number * 8) - 1)) ifTrue: [
			integer := integer - (2 raisedToInteger: (number * 8))].
		number := integer.
		character := aStream next].

	character = $u ifTrue: [
		| integer |
		integer := 0.
		number = 0 ifTrue: [number := 1].
		number timesRepeat: [integer := integer * 256 + self writeNextBytecode].
		number := integer.
		character := aStream next].

	character = $I ifTrue: [decompiledCodeStream nextPutAll: number printString].
	character = $i ifTrue: [decompiledCodeStream nextPutAll: (targetClass allInstVarNames at: number + 1)].
	character = $l ifTrue: [decompiledCodeStream nextPutAll: ' literal ', number printString, ' '; nextPutAll: (literals at: number + 1) printString].
	character = $g ifTrue: [
		| assoc |
		assoc := (literals at: number + 1).
		decompiledCodeStream nextPutAll: ' literal ', number printString, ' ', (assoc isNil ifTrue: ['<undeclared>'] ifFalse: [assoc key]) printString].
	character = $o ifTrue: [decompiledCodeStream nextPutAll: '16r', ((byteStream position + number) printStringRadix: 16)].
	character = $t ifTrue: [decompiledCodeStream nextPutAll: 't', number printString].
	character = $L ifTrue: [decompiledCodeStream nextPutAll: 't', (number // 65536) printString, '_', (number \\ 65536 // 256) printString, '_', (number \\ 256) printString].
	character = $w ifTrue: [decompiledCodeStream nextPutAll: number printString, ' #', (CodeGenerator specialSelectors at: number + 1)].! !

! Decompiler methodsFor: 'decompiling' !
writeHeader

	resultStream
		nextPutAll: 'Args: ';
		print: self numberOfArguments;
		nextPutAll: ' Temporaries: ';
		print: self numberOfTemporaries;
		nextPutAll: ' Copied: ';
		print: self numberOfCopiedVariables;
		cr! !

! Decompiler methodsFor: 'decompiling' !
writeNextBytecode

	| byte |

	byte := byteStream next.
	byte
		printOn: formattedBytecodeStream
		paddedWith: $0
		to: 2
		base: 16.
	formattedBytecodeStream space.
	^byte! !

! Decompiler methodsFor: 'decompiling' !
writeOffset

	byteStream position
		printOn: offsetStream
		paddedWith: Character space
		to: 3
		base: 16! !

! Decompiler methodsFor: 'initialize-release' !
initialize

	self resetLineStreams.
	resultStream := WriteStream on: (String new: 100).! !

! Decompiler class methodsFor: 'instance creation' !
new

	^super new initialize! !

! DevelopmentCommandHandler methodsFor: 'handling' !
processMessage: aMessage onWebSocket: aWebSocket

	| commandStream command |

	commandStream := (aMessage isString ifTrue: [aMessage] ifFalse: [aMessage message]) readStream.
	command := commandStream upTo: Character space.

	command = 'printit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult printString.
		^true].
	command = 'storeit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult storeString.
		^true].
	command = 'doit' ifTrue: [
		SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '"Done"'.
		^true].
	command = 'filein' ifTrue: [
		commandStream upToEnd readStream fileIn.
		aWebSocket send: '"Done"'.
		^true].
	command = 'showstring' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult asString.
		^true].
	command = 'close' ifTrue: [
		aWebSocket close.
		^false].
	command = 'shutdown' ifTrue: [
		BeagleSystem shutdown.
		^false].
	command = 'renderit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '~', evaluateResult.
		^true].
	command = 'keydown' ifTrue: [
		aWebSocket send: 'Key: ', commandStream upToEnd.
		^true].
	command = 'mouseMove' ifTrue: [
		aWebSocket send: 'MouseMove: ', commandStream upToEnd.
		^true].
	command = 'mouseDown' ifTrue: [
		aWebSocket send: 'MouseDown: ', commandStream upToEnd.
		^true].
	command = 'mouseUp' ifTrue: [
		aWebSocket send: 'MouseUp: ', commandStream upToEnd.
		^true].
	command = 'wheel' ifTrue: [
		aWebSocket send: 'Wheel: ', commandStream upToEnd.
		^true].
	command = 'evaluateJSON' ifTrue: [
		JSONParser evaluateJsonString: commandStream upToEnd.
		^true].! !

! FileinReader methodsFor: 'accessing' !
captureCharacter: aCharacter

	quoting ifTrue: [chunkStream nextPut: aCharacter. quoting := false. ^true].
	
	readingString ifTrue: [
		aCharacter = $'
			ifTrue: [
				(stream atEnd not and: [stream peek = $'])
					ifTrue: [chunkStream nextPut: $'; nextPut: $'. stream next. ^true].
				chunkStream nextPut: $'. readingString := false. ^true].
			chunkStream nextPut: aCharacter.
			^true].

	readingComment ifTrue: [
		aCharacter = $"
			ifTrue: [
				(stream atEnd not and: [stream peek = $"])
					ifTrue: [chunkStream nextPut: $"; nextPut: $". stream next. ^true].
				chunkStream nextPut: $". readingComment := false. ^true].
			chunkStream nextPut: aCharacter.
			^true].

	aCharacter = $' ifTrue: [
		chunkStream nextPut: $'.
		readingString := true.
		^true].

	aCharacter = $" ifTrue: [
		chunkStream nextPut: $".
		readingComment := true.
		^true].

	aCharacter = $$ ifTrue: [
		chunkStream nextPut: $$.
		quoting := true.
		^true].

	aCharacter = $! ifTrue: [
		(stream atEnd not and: [stream peek = $!])
			ifTrue: [chunkStream nextPut: $!; nextPut: $!. stream next. ^true].
		^false].

	chunkStream nextPut: aCharacter.
	^true! !

! FileinReader methodsFor: 'accessing' !
fileIn
	| result |
	
	[stream atEnd] whileFalse: [
		result := self fileInChunk].
	^result! !

! FileinReader methodsFor: 'accessing' !
fileInChunk

	| chunk result |

	chunk := self readChunk.
	chunk isEmpty ifTrue: [
		precedingEmptyChunk := true.
		^self].

	precedingEmptyChunk ifFalse: [
		^self runDoit: chunk].

	result := (self runDoit: chunk)
		fileInFrom: stream.

	precedingEmptyChunk := false.
	^result! !

! FileinReader methodsFor: 'accessing' !
readChunk

	| continue |

	chunkStream := WriteStream on: (String new: 10).
	readingString := false.
	readingComment := false.
	quoting := false.
	continue := true.

	[stream atEnd not and: [stream peek isSeparator]] whileTrue: [stream next].

	[stream atEnd or: [continue not]] whileFalse: [
		continue := self captureCharacter: stream next].

	^chunkStream contents! !

! FileinReader methodsFor: 'accessing' !
runDoit: aString

	| trimmedString |

	trimmedString := aString trimSeparators.
	trimmedString isEmpty ifTrue: [
		precedingEmptyChunk := true.
		^self].
	precedingEmptyChunk := false.
	^SmalltalkParser evaluate: trimmedString! !

! FileinReader methodsFor: 'accessing' !
stream

	^stream! !

! FileinReader methodsFor: 'accessing' !
stream: anObject

	stream := anObject.
	precedingEmptyChunk := false! !

! FileinReader class methodsFor: 'instance creation' !
fileIn: aStream

	^(self on: aStream) fileIn! !

! FileinReader class methodsFor: 'instance creation' !
on: aStream

	^self new
		stream: aStream;
		yourself! !

! ClassFileinReader methodsFor: 'accessing' !
fileInFrom: aStream

	| chunk method |

	stream := aStream.
	[chunk := self readChunk.
	chunk isEmpty] whileFalse: [

		method := SmalltalkParser
			generateForClass: targetClass
			globals: targetClass globalDictionaries
			methodString: chunk
			organization: self organization
			writeChangesInto: BeagleSystem changesFile.
		
		(method isKindOf: String) ifTrue: [
			^self error: method].

		targetClass methodDictionary at: method selector put: method.
		targetClass organizationAt: self organization add: method selector].

	^method! !

! ClassFileinReader methodsFor: 'accessing' !
fixLineEndConventionsIn: aString
	| inStream outStream lfReceived crReceived char cr lf |
	lfReceived := false.
	crReceived := false.
	inStream := aString readStream.
	cr := Character cr.
	lf := Character lf.
	
	outStream := WriteStream on: (String new: aString size).
	
	[inStream atEnd] whileFalse: [
		char := inStream next.
		char = cr
			ifTrue: [lfReceived ifTrue: [lfReceived := false. outStream nextPut: cr] ifFalse: [crReceived := true]]
			ifFalse: [char = lf
				ifTrue: [crReceived ifTrue: [crReceived := false. outStream nextPut: cr] ifFalse: [lfReceived := true]]
				ifFalse: [
					crReceived | lfReceived ifTrue: [outStream nextPut: cr].
					crReceived := false.
					lfReceived := false.
					outStream nextPut: char]]].

	^outStream contents! !

! ClassFileinReader methodsFor: 'accessing' !
organization

	^organization! !

! ClassFileinReader methodsFor: 'accessing' !
organization: anObject

	organization := anObject! !

! ClassFileinReader methodsFor: 'accessing' !
targetClass

	^targetClass! !

! ClassFileinReader methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject! !

! IndirectVariableList methodsFor: 'accessing' !
variables

	^variables! !

! IndirectVariableList methodsFor: 'accessing' !
variables: anObject

	variables := anObject! !

! IndirectVariableList methodsFor: 'initialize-release' !
initialize

	variables := OrderedCollection new! !

! IndirectVariableList methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' variables: '.
	self variables do: [:each | each printOn: aStream. aStream space]! !

! IndirectVariableList methodsFor: 'testing' !
isIndirectList

	^true! !

! IndirectVariableList methodsFor: 'testing' !
isIndirectVariableList

	^true! !

! IndirectVariableList methodsFor: 'testing' !
isReturnContext

	^false! !

! IndirectVariableList methodsFor: 'testing' !
isSelf

	^false! !

! IndirectVariableList class methodsFor: 'instance creation' !
new

	^super new initialize! !

! LexicalAnalyzer methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset! !

! LexicalAnalyzer methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject! !

! LexicalAnalyzer methodsFor: 'accessing' !
next2

	^next2! !

! LexicalAnalyzer methodsFor: 'accessing' !
next2: anObject

	next2 := anObject! !

! LexicalAnalyzer methodsFor: 'accessing' !
next: anObject

	next := anObject! !

! LexicalAnalyzer methodsFor: 'accessing' !
position

	^position! !

! LexicalAnalyzer methodsFor: 'accessing' !
position: anObject

	position := anObject! !

! LexicalAnalyzer methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset! !

! LexicalAnalyzer methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject! !

! LexicalAnalyzer methodsFor: 'accessing' !
stream

	^stream! !

! LexicalAnalyzer methodsFor: 'accessing' !
stream: anObject

	stream := anObject! !

! LexicalAnalyzer methodsFor: 'api' !
tokens

	| token |
	tokens := OrderedCollection new.
	self start.
	[(token := self nextToken) notNil] whileTrue: [tokens add: token].
	^tokens! !

! LexicalAnalyzer methodsFor: 'errors' !
reportError: aString start: start end: end

	^(CompileError new)
		message: aString;
		startSourceOffset: start;
		endSourceOffset: end;
		raiseSignal! !

! LexicalAnalyzer methodsFor: 'parsing' !
advance

	next := next2.
	stream atEnd
		ifTrue: [
			next = self finishedCharacter ifFalse: [
				position := position + 1].
			next2 := self finishedCharacter]
		ifFalse: [
			next2 := stream next.
			position := position + 1].! !

! LexicalAnalyzer methodsFor: 'parsing' !
captureOffsetsIn: parseBlock creating: createBlock

	startSourceOffset := self position.
	parseBlock value.
	endSourceOffset := self next = self finishedCharacter
				ifTrue: [self position]
				ifFalse: [self position - 1].
	^(createBlock value)
		startSourceOffset: startSourceOffset;
		endSourceOffset: endSourceOffset;
		yourself! !

! LexicalAnalyzer methodsFor: 'parsing' !
finishedCharacter

	^Character value: 0! !

! LexicalAnalyzer methodsFor: 'parsing' !
next

	^next! !

! LexicalAnalyzer methodsFor: 'parsing' !
nextCharacter

	stream atEnd ifTrue: [^self finishedCharacter].
	^stream next! !

! LexicalAnalyzer methodsFor: 'parsing' !
nextToken

	self subclassResponsibility! !

! LexicalAnalyzer methodsFor: 'parsing' !
skipComment

	! !

! LexicalAnalyzer methodsFor: 'parsing' !
skipSeparator

	self subclassResponsibility! !

! LexicalAnalyzer methodsFor: 'parsing' !
skipSeparators

	[self skipSeparator] whileTrue: []! !

! LexicalAnalyzer methodsFor: 'parsing' !
start
	position := stream position.
	next := self nextCharacter.
	next2 := self nextCharacter! !

! LexicalAnalyzer methodsFor: 'testing' !
isDigit: aCharacter radix: aNumber

	^aCharacter digitValue between: 0 and: aNumber! !

! LexicalAnalyzer class methodsFor: 'instance creation' !
on: aStream

	^self new
		stream: aStream;
		yourself! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
nextToken

	self skipSeparators.
	self next = self finishedCharacter ifTrue: [^nil].
	self next isAlphabetic ifTrue: [^self parseWord].
	(self next isDigit or: [self next = $- and: [self next2 isDigit]])
		ifTrue: [^self parseNumber].
	self next = $, ifTrue: [^self parseComma].
	self next = $: ifTrue: [^self parseColon].
	self next = $[ ifTrue: [^self parseOpenSquareBracket].
	self next = $] ifTrue: [^self parseCloseSquareBracket].
	self next = ${ ifTrue: [^self parseOpenBrace].
	self next = $} ifTrue: [^self parseCloseBrace].
	self next = $" ifTrue: [^self parseStringLiteral].
	self log: 'nextToken: ', self next printString, self next2 printString, ' position: ', stream position printString.
	^self reportError: 'Unknown token' start: self position end: self position! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseCloseBrace

	^self captureOffsetsIn: [self advance]
		creating: [CloseBraceToken new value: $}]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseCloseSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [CloseSquareBracketToken new value: $]]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseColon

	^self captureOffsetsIn: [self advance]
		creating: [ColonToken new value: $:]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseComma

	^self captureOffsetsIn: [self advance]
		creating: [CommaToken new value: $,]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseNumber

	| number |
	^self captureOffsetsIn: [number := self readNumber]
		creating: 
			[(number isInteger ifTrue: [IntegerToken new] ifFalse: [FloatToken new])
				value: number;
				yourself]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseOpenBrace

	^self captureOffsetsIn: [self advance]
		creating: [OpenBraceToken new value: ${]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseOpenSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [OpenSquareBracketToken new value: $[]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseStringLiteral

	| string |
	^self captureOffsetsIn: 
			[string := self readStringLiteral.
			string isNil
				ifTrue: 
					[self reportError: 'Missing end quote' start: self startSourceOffset end: self position]]
		creating: [StringToken new value: string]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseWord

	| word |
	^self captureOffsetsIn: [word := self readWord]
		creating: [self wordTokenFor: word]! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
readAlphaNumericWord

	| wordStream |
	wordStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^wordStream contents].
	self next isAlphaNumeric or: [self next = $_]]
			whileTrue: 
				[wordStream nextPut: self next.
				self advance].
	^wordStream contents! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
skipSeparator

	self next = self finishedCharacter ifTrue: [^false].
	self next isSeparator ifTrue: [self advance. ^true].
	^false! !

! JSONLexicalAnalyzer methodsFor: 'parsing' !
wordTokenFor: word

	word = 'null' ifTrue: [^SpecialWordToken new value: 'null'].
	word = 'true' ifTrue: [^SpecialWordToken new value: 'true'].
	word = 'false' ifTrue: [^SpecialWordToken new value: 'false'].
	^WordToken new value: word! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readDecimalPart: integerPart

	| value factor |
	factor := 0.1.
	value := integerPart asFloat.
	[self next isDigit] whileTrue: 
			[value := value positive
						ifTrue: [value + (self next digitValue * factor)]
						ifFalse: [value - (self next digitValue * factor)].
			factor := factor / 10.0.
			self advance].
	^value! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readExponent

	| value |
	value := 0.
	[self next isDigit] whileTrue: 
			[value := value * 10 + self next digitValue.
			self advance].
	^value! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readFloatStartingWith: aNumber

	| value |
	value := aNumber asFloat.
	(self next = $. and: [self next2 isDigit])
		ifTrue: 
			[self advance.
			value := self readDecimalPart: aNumber].
	self next asLowercase = $e ifFalse: [^value].
	self advance.
	^value asFloat * (10 ** self readExponent)! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readInteger

	| number sign |
	number := 0.
	sign := 1.
	self next = $-
		ifTrue: 
			[sign := -1.
			self advance].
	[self next isDigit] whileTrue: 
			[number := number * 10 + self next digitValue.
			self advance].
	^sign * number! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readNumber

	| number |
	number := self readInteger.
	self next = self finishedCharacter ifTrue: [^number].
	((self next = $. and: [self next2 isDigit]) or: [self next asLowercase = $e])
		ifTrue: [^self readFloatStartingWith: number].
	^number! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readStringLiteral

	| literalStream |
	self advance.
	literalStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^nil].
	self next = $"]
			whileFalse: 
				[self next = $\
					ifTrue: [self readStringQuotedCharacterInto: literalStream]
					ifFalse: [literalStream nextPut: self next].
				self advance].
	self advance.
	^literalStream contents! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readStringQuotedCharacterInto: aStream

	self advance.
	self next = $" ifTrue: [^aStream nextPut: $"].
	self next = $\ ifTrue: [^aStream nextPut: $\].
	self next = $/ ifTrue: [^aStream nextPut: $/].
	self next = $b ifTrue: [^aStream nextPut: Character backspace].
	self next = $f ifTrue: [^aStream nextPut: Character newPage].
	self next = $r ifTrue: [^aStream nextPut: Character cr].
	self next = $n ifTrue: [^aStream nextPut: Character lf].
	self next = $t ifTrue: [^aStream nextPut: Character tab].
	self error: 'Illegal quoted character'! !

! JSONLexicalAnalyzer methodsFor: 'reading' !
readWord

	| wordStream |
	wordStream := WriteStream on: (String new: 100).
	wordStream nextPutAll: self readAlphaNumericWord.
	^wordStream contents! !

! ParseTreeNode methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset! !

! ParseTreeNode methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject! !

! ParseTreeNode methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset! !

! ParseTreeNode methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject! !

! ParseTreeNode methodsFor: 'testing' !
isBinaryHeaderNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isBinaryMessageNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isBlockLiteralNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isBlockNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isBlockParameterListNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isCascadeNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isKeywordHeaderNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isKeywordMessageNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isLiteralNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isMethodNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isParenthesisNode

	^false! !

! ParseTreeNode methodsFor: 'testing' !
isSequence

	^false! !

! ParseTreeNode methodsFor: 'visiting' !
acceptVisitor: aVisitor! !

! ParseTreeNode class methodsFor: 'instance creation' !
on: anObject

	^self new
		value: anObject;
		yourself! !

! BinaryHeaderNode methodsFor: 'accessing' !
argument

	^argument! !

! BinaryHeaderNode methodsFor: 'accessing' !
argument: anObject

	argument := anObject! !

! BinaryHeaderNode methodsFor: 'accessing' !
selector

	^selector! !

! BinaryHeaderNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! BinaryHeaderNode methodsFor: 'testing' !
isBinaryHeaderNode

	^true! !

! BinaryHeaderNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBinaryHeader: self! !

! BinaryHeaderNode class methodsFor: 'instance creation' !
selector: selectorToken argument: argument

	^self new
		selector: selectorToken;
		argument: argument;
		yourself! !

! BinaryMessageNode methodsFor: 'accessing' !
argument

	^argument! !

! BinaryMessageNode methodsFor: 'accessing' !
argument: anObject

	argument := anObject! !

! BinaryMessageNode methodsFor: 'accessing' !
arguments

	^Array with: self argument! !

! BinaryMessageNode methodsFor: 'accessing' !
receiver

	^receiver! !

! BinaryMessageNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject! !

! BinaryMessageNode methodsFor: 'accessing' !
selector

	^selector! !

! BinaryMessageNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! BinaryMessageNode methodsFor: 'testing' !
isBinaryMessageNode

	^true! !

! BinaryMessageNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitMessageNodeStart: self.
	self receiver ifNotNil: [self receiver acceptVisitor: anObject].
	self argument acceptVisitor: anObject.
	anObject visitMessageNodeEnd: self! !

! BinaryMessageNode class methodsFor: 'instance creation' !
receiver: receiver selector: selector argument: argument

	^self new
		receiver: receiver;
		selector: selector;
		argument: argument;
		yourself! !

! BinaryMessageNode class methodsFor: 'instance creation' !
receiver: receiver selector: selector argument: argument startSourceOffset: sourceOffset endSourceOffset: endOffset

	^self new
		receiver: receiver;
		selector: selector;
		argument: argument;
		startSourceOffset: sourceOffset;
		endSourceOffset: endOffset;
		yourself! !

! BinaryMessageNode class methodsFor: 'instance creation' !
selector: selector argument: argument

	^self new
		selector: selector;
		argument: argument;
		yourself! !

! BlockNode methodsFor: 'accessing' !
addVariableAssignment: aVariable

	scope addVariable: aVariable.! !

! BlockNode methodsFor: 'accessing' !
addVariableReference: aVariable

	scope addVariable: aVariable! !

! BlockNode methodsFor: 'accessing' !
arguments

	^arguments! !

! BlockNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject! !

! BlockNode methodsFor: 'accessing' !
hasReturn

	^hasReturn! !

! BlockNode methodsFor: 'accessing' !
hasReturn: anObject

	hasReturn := anObject.
	self parent ifNotNil: [:aBlockNode | aBlockNode hasReturn: anObject]! !

! BlockNode methodsFor: 'accessing' !
parent

	^parent! !

! BlockNode methodsFor: 'accessing' !
parent: anObject

	parent := anObject! !

! BlockNode methodsFor: 'accessing' !
scope

	^scope! !

! BlockNode methodsFor: 'accessing' !
scope: anObject

	scope := anObject! !

! BlockNode methodsFor: 'accessing' !
statements

	^statements! !

! BlockNode methodsFor: 'accessing' !
statements: anObject

	statements := anObject! !

! BlockNode methodsFor: 'testing' !
isBlockNode

	^true! !

! BlockNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBlockNodeStart: self.
	self arguments ifNotNil: [self arguments acceptVisitor: anObject].
	self statements
		ifNil: [anObject visitEmptyStatements]
		ifNotNil: [self statements acceptVisitor: anObject].

	anObject visitBlockNode: self! !

! BlockParameterListNode methodsFor: 'accessing' !
variables

	^variables! !

! BlockParameterListNode methodsFor: 'accessing' !
variables: anObject

	variables := anObject! !

! BlockParameterListNode methodsFor: 'testing' !
isBlockParameterListNode

	^true! !

! BlockParameterListNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBlockParameterListNode: self! !

! CascadeNode methodsFor: 'accessing' !
messages

	^messages! !

! CascadeNode methodsFor: 'accessing' !
messages: anObject

	messages := anObject! !

! CascadeNode methodsFor: 'accessing' !
receiver

	^receiver! !

! CascadeNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject! !

! CascadeNode methodsFor: 'testing' !
isCascadeNode

	^true! !

! CascadeNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self receiver acceptVisitor: anObject.
	anObject visitCascadeStart: self.

	self messages
		do: [:eachMessage | eachMessage acceptVisitor: anObject]
		separatedBy: [anObject visitCascadeInterMessage: self].

	anObject visitCascadeEnd: self! !

! CascadeNode class methodsFor: 'instance creation' !
receiver: receiver messages: messages

	^self new
		receiver: receiver;
		messages: messages;
		yourself! !

! GlobalVariableAssignmentNode methodsFor: 'accessing' !
value

	^value! !

! GlobalVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! GlobalVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable! !

! GlobalVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! GlobalVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitGlobalVariableAssignmentNode: self.! !

! GlobalVariableAssignmentNode class methodsFor: 'instance creation' !
variable: variable value: value

	^self new
		variable: variable;
		value: value;
		yourself! !

! GlobalVariableReferenceNode methodsFor: 'accessing' !
variable

	^variable! !

! GlobalVariableReferenceNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! GlobalVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitGlobalVariableReferenceNode: self! !

! GlobalVariableReferenceNode class methodsFor: 'instance creation' !
variable: aToken

	^self new
		variable: aToken;
		yourself! !

! InstanceVariableAssignmentNode methodsFor: 'accessing' !
value

	^value! !

! InstanceVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! InstanceVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable! !

! InstanceVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! InstanceVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitInstanceVariableAssignmentNode: self! !

! InstanceVariableAssignmentNode class methodsFor: 'instance creation' !
variable: variable value: value

	^self new
		variable: variable;
		value: value;
		yourself! !

! InstanceVariableReferenceNode methodsFor: 'accessing' !
variable

	^variable! !

! InstanceVariableReferenceNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! InstanceVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitInstanceVariableReferenceNode: self! !

! InstanceVariableReferenceNode class methodsFor: 'instance creation' !
variable: aToken

	^self new
		variable: aToken;
		yourself! !

! KeywordHeaderNode methodsFor: 'accessing' !
arguments

	^arguments! !

! KeywordHeaderNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject! !

! KeywordHeaderNode methodsFor: 'accessing' !
selector

	^selector! !

! KeywordHeaderNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! KeywordHeaderNode methodsFor: 'testing' !
isKeywordHeaderNode

	^true! !

! KeywordHeaderNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitKeywordHeader: self! !

! KeywordHeaderNode class methodsFor: 'instance creation' !
selector: selector arguments: arguments

	^self new
		selector: selector;
		arguments: arguments;
		yourself! !

! KeywordMessageNode methodsFor: 'accessing' !
arguments

	^arguments! !

! KeywordMessageNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject! !

! KeywordMessageNode methodsFor: 'accessing' !
receiver

	^receiver! !

! KeywordMessageNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject! !

! KeywordMessageNode methodsFor: 'accessing' !
selector

	^selector! !

! KeywordMessageNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! KeywordMessageNode methodsFor: 'testing' !
isInlinedSelector: aSymbol

	(aSymbol = #ifTrue: and: [self arguments first isBlockLiteralNode])
		ifTrue: [^true].
		
	(aSymbol = #ifFalse: and: [self arguments first isBlockLiteralNode])
		ifTrue: [^true].
	
	(aSymbol = #ifTrue:ifFalse: and: [self arguments allSatisfy: [:eachNode | eachNode isBlockLiteralNode]])
		ifTrue: [^true].

	(aSymbol = #ifFalse:ifTrue: and: [self arguments allSatisfy: [:eachNode | eachNode isBlockLiteralNode]])
		ifTrue: [^true].

	(aSymbol = #whileTrue: and: [self receiver isBlockLiteralNode and: [self arguments first isBlockLiteralNode]])
		ifTrue: [^true].

	(aSymbol = #whileFalse: and: [self receiver isBlockLiteralNode and: [self arguments first isBlockLiteralNode]])
		ifTrue: [^true].

	^false! !

! KeywordMessageNode methodsFor: 'testing' !
isKeywordMessageNode

	^true! !

! KeywordMessageNode methodsFor: 'visiting' !
acceptVisitor: anObject

	(self isInlinedSelector: self selector) ifTrue: [
		^self visitInlinedObject: anObject].
	anObject visitMessageNodeStart: self.
	self receiver ifNotNil: [self receiver acceptVisitor: anObject].
	self arguments do: [:eachArgument | eachArgument acceptVisitor: anObject].
	anObject visitMessageNodeEnd: self! !

! KeywordMessageNode methodsFor: 'visiting' !
visitIfFalse: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfFalseBlock: self arguments first! !

! KeywordMessageNode methodsFor: 'visiting' !
visitIfFalseIfTrue: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfFalseBlock: self arguments first ifTrueBlock: self arguments last! !

! KeywordMessageNode methodsFor: 'visiting' !
visitIfTrue: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfTrueBlock: self arguments first! !

! KeywordMessageNode methodsFor: 'visiting' !
visitIfTrueIfFalse: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfTrueBlock: self arguments first ifFalseBlock: self arguments last! !

! KeywordMessageNode methodsFor: 'visiting' !
visitInlinedObject: anObject

	self selector = #ifTrue: ifTrue: [^self visitIfTrue: anObject].
	self selector = #ifFalse: ifTrue: [^self visitIfFalse: anObject].
	self selector = #ifTrue:ifFalse: ifTrue: [^self visitIfTrueIfFalse: anObject].
	self selector = #ifFalse:ifTrue: ifTrue: [^self visitIfFalseIfTrue: anObject].
	self selector = #whileTrue: ifTrue: [^self visitWhileTrue: anObject].
	self selector = #whileFalse: ifTrue: [^self visitWhileFalse: anObject].
	self error: 'Bad inlined selector ', self selector printString! !

! KeywordMessageNode methodsFor: 'visiting' !
visitWhileFalse: anObject

	anObject visitWhileFalseBlock: self receiver doBlock: self arguments first! !

! KeywordMessageNode methodsFor: 'visiting' !
visitWhileTrue: anObject

	anObject visitWhileTrueBlock: self receiver doBlock: self arguments first! !

! KeywordMessageNode class methodsFor: 'instance creation' !
receiver: receiver selector: selectorToken arguments: argumentsArray

	^self new
		receiver: receiver;
		selector: selectorToken;
		arguments: argumentsArray;
		yourself! !

! KeywordMessageNode class methodsFor: 'instance creation' !
selector: selectorToken arguments: argumentsArray

	^self new
		selector: selectorToken;
		arguments: argumentsArray;
		yourself! !

! LocalVariableAssignmentNode methodsFor: 'accessing' !
value

	^value! !

! LocalVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! LocalVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable! !

! LocalVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! LocalVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitLocalVariableAssignmentNode: self! !

! LocalVariableAssignmentNode class methodsFor: 'instance creation' !
variable: variable value: value

	^self new
		variable: variable;
		value: value;
		yourself! !

! LocalVariableReferenceNode methodsFor: 'accessing' !
scopeNumber

	^scopeNumber! !

! LocalVariableReferenceNode methodsFor: 'accessing' !
scopeNumber: anObject

	scopeNumber := anObject! !

! LocalVariableReferenceNode methodsFor: 'accessing' !
variable

	^variable! !

! LocalVariableReferenceNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! LocalVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitLocalVariableReferenceNode: self! !

! MethodNode methodsFor: 'accessing' !
body

	^body! !

! MethodNode methodsFor: 'accessing' !
body: anObject

	body := anObject! !

! MethodNode methodsFor: 'accessing' !
header

	^header! !

! MethodNode methodsFor: 'accessing' !
header: anObject

	header := anObject! !

! MethodNode methodsFor: 'accessing' !
pragmas

	^pragmas! !

! MethodNode methodsFor: 'accessing' !
pragmas: anObject

	pragmas := anObject! !

! MethodNode methodsFor: 'testing' !
isMethodNode

	^true! !

! MethodNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitMethodNodeStart: self.
	self header acceptVisitor: anObject.
	self pragmas do: [:pragma | pragma acceptVisitor: anObject].
	self body isNil
		ifTrue: [anObject visitEmptyMethodNode: self]
		ifFalse: [
			self body acceptVisitor: anObject.
			anObject visitMethodNode: self]! !

! MethodNode class methodsFor: 'instance creation' !
header: header body: body

	^self new
		header: header;
		body: body;
		yourself! !

! MethodNode class methodsFor: 'instance creation' !
header: header pragmas: pragmas body: body

	^self new
		header: header;
		pragmas: pragmas;
		body: body;
		yourself! !

! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
nameComponents

	^nameComponents! !

! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
nameComponents: anObject

	nameComponents := anObject! !

! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
value

	^value! !

! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable! !

! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject! !

! NamespaceVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self value acceptVisitor: anObject.
	anObject visitNamespaceVariableAssignmentNode: self! !

! NamespaceVariableAssignmentNode class methodsFor: 'instance creation' !
nameComponents: variableNames value: value

	^self new
		nameComponents: variableNames;
		value: value;
		yourself! !

! NamespaceVariableAssignmentNode class methodsFor: 'instance creation' !
variable: aVariable value: value

	^self new
		variable: aVariable;
		value: value;
		yourself! !

! NamespaceVariableReferenceNode methodsFor: 'accessing' !
nameComponents

	^nameComponents! !

! NamespaceVariableReferenceNode methodsFor: 'accessing' !
nameComponents: anObject

	nameComponents := anObject! !

! NamespaceVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitNamespaceVariableReferenceNode: self! !

! ParenthesisNode methodsFor: 'accessing' !
expression

	^expression! !

! ParenthesisNode methodsFor: 'accessing' !
expression: anObject

	expression := anObject! !

! ParenthesisNode methodsFor: 'testing' !
isParenthesisNode

	^true! !

! ParenthesisNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self expression acceptVisitor: anObject! !

! ParenthesisNode class methodsFor: 'instance creation' !
expression: aNode

	^self new
		expression: aNode;
		yourself! !

! ParseTreeVisitor methodsFor: 'initialize-release' !
initialize! !

! ParseTreeVisitor methodsFor: 'messages' !
visitIfFalseBlock: aBlockLiteralNode

	aBlockLiteralNode value acceptVisitor: self! !

! ParseTreeVisitor methodsFor: 'messages' !
visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode

	falseBlockLiteralNode value acceptVisitor: self.
	trueBlockLiteralNode value acceptVisitor: self.! !

! ParseTreeVisitor methodsFor: 'messages' !
visitIfTrueBlock: aBlockLiteralNode

	aBlockLiteralNode value acceptVisitor: self! !

! ParseTreeVisitor methodsFor: 'messages' !
visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode

	trueBlockLiteralNode value acceptVisitor: self.
	falseBlockLiteralNode value acceptVisitor: self.! !

! ParseTreeVisitor methodsFor: 'messages' !
visitWhileFalseBlock: conditionBlock doBlock: doBlock

	conditionBlock value acceptVisitor: self.
	doBlock value acceptVisitor: self.! !

! ParseTreeVisitor methodsFor: 'messages' !
visitWhileTrueBlock: conditionBlock doBlock: doBlock

	conditionBlock value acceptVisitor: self.
	doBlock value acceptVisitor: self! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visit: aNode

	^aNode acceptVisitor: self! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitArgument: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBinaryHeader: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockLiteralNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockNodeStart: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockParameterListNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitCascadeEnd: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitCascadeInterMessage: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitCascadeStart: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitEmptyMethodNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitEmptyStatements! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitGlobalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitGlobalVariableReferenceNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitInstanceVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitInstanceVariableReferenceNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitKeywordHeader: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitLiteralNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitLocalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitLocalVariableReferenceNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMessageNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMessageNodeEnd: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMessageNodeStart: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMethodNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMethodNodeStart: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitNamespaceVariableAssignmentNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitNamespaceVariableReferenceNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitPragma: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitReceiver: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitReturnNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitSpecialNode: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementList: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementListEnd! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementListEnd: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementListStart: aNode! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementSeparator! !

! ParseTreeVisitor methodsFor: 'visitor handling' !
visitUnaryHeader: aNode! !

! ParseTreeVisitor class methodsFor: 'instance creation' !
new

	^super new initialize! !

! CodeGenerator methodsFor: 'accessing' !
addBytecode: aByte

	^bytecodeStream nextPut: aByte! !

! CodeGenerator methodsFor: 'accessing' !
addGlobalDictionary: aDictionary

	globalDictionaries add: aDictionary! !

! CodeGenerator methodsFor: 'accessing' !
bytecodeFor: aSymbol

	^(self class bytecodesByName at: aSymbol) number! !

! CodeGenerator methodsFor: 'accessing' !
bytecodeStream

	^bytecodeStream! !

! CodeGenerator methodsFor: 'accessing' !
bytecodeStream: anObject

	bytecodeStream := anObject! !

! CodeGenerator methodsFor: 'accessing' !
bytecodes

	^bytecodeStream contents! !

! CodeGenerator methodsFor: 'accessing' !
globalDictionaries

	^globalDictionaries! !

! CodeGenerator methodsFor: 'accessing' !
globalDictionaries: anObject

	globalDictionaries := anObject! !

! CodeGenerator methodsFor: 'accessing' !
hasReturned

	^hasReturned! !

! CodeGenerator methodsFor: 'accessing' !
hasReturned: anObject

	hasReturned := anObject! !

! CodeGenerator methodsFor: 'accessing' !
isInlinedBlock

	^isInlinedBlock! !

! CodeGenerator methodsFor: 'accessing' !
isInlinedBlock: anObject

	isInlinedBlock := anObject! !

! CodeGenerator methodsFor: 'accessing' !
literals

	^literals! !

! CodeGenerator methodsFor: 'accessing' !
literals: anObject

	literals := anObject! !

! CodeGenerator methodsFor: 'accessing' !
method

	| method scope |

	scope := self methodLocalVariableAnalysis scopeFor: self methodLocalVariableAnalysis rootNode.

	method := (CompiledMethod new: self literals size)
		numberOfTemporaries: scope temporaryVariables size;
		numberOfArguments: scope arguments size;
		bytecodes: self bytecodes;
		mclass: self targetClass;
		selector: self selector;
		localVariableNames: scope localVariableNames asArray;
		sourceOffsets: self sourceOffsets;
		yourself.

	self writeLiteralsInto: method";
		writePICInto: method".
	
	^method! !

! CodeGenerator methodsFor: 'accessing' !
methodLocalVariableAnalysis

	^methodLocalVariableAnalysis! !

! CodeGenerator methodsFor: 'accessing' !
methodLocalVariableAnalysis: anObject

	methodLocalVariableAnalysis := anObject! !

! CodeGenerator methodsFor: 'accessing' !
nodeStack

	^nodeStack! !

! CodeGenerator methodsFor: 'accessing' !
nodeStack: anObject

	nodeStack := anObject! !

! CodeGenerator methodsFor: 'accessing' !
outerMethod

	^outerMethod! !

! CodeGenerator methodsFor: 'accessing' !
outerMethod: anObject

	outerMethod := anObject! !

! CodeGenerator methodsFor: 'accessing' !
popNode

	self nodeStack removeLast! !

! CodeGenerator methodsFor: 'accessing' !
pragmas

	^pragmas! !

! CodeGenerator methodsFor: 'accessing' !
pragmas: anObject

	pragmas := anObject! !

! CodeGenerator methodsFor: 'accessing' !
pushNode: aNode

	self nodeStack add: aNode! !

! CodeGenerator methodsFor: 'accessing' !
returnLevel

	^returnLevel! !

! CodeGenerator methodsFor: 'accessing' !
returnLevel: anObject

	returnLevel := anObject! !

! CodeGenerator methodsFor: 'accessing' !
selector

	^selector! !

! CodeGenerator methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! CodeGenerator methodsFor: 'accessing' !
sourceOffsets

	^sourceOffsets! !

! CodeGenerator methodsFor: 'accessing' !
sourceOffsets: anObject

	sourceOffsets := anObject! !

! CodeGenerator methodsFor: 'accessing' !
targetClass

	^targetClass! !

! CodeGenerator methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject! !

! CodeGenerator methodsFor: 'accessing' !
writeLiteralsInto: method

	self literals keysAndValuesDo: [:eachIndex :eachLiteral |
		method basicAt: eachIndex put: eachLiteral.
		eachLiteral isCompiledBlock ifTrue: [
			eachLiteral outerMethod: method].

		eachLiteral isBlockClosure
			ifTrue: [eachLiteral method outerMethod: method]]! !

! CodeGenerator methodsFor: 'accessing' !
writePICInto: method

	| picOffset |

	picOffset := 1.
	method polymorphicInlineCache: (Array new: self numberOfSends * 9).
	"self callOffsetsDo: [:offset |
			method polymorphicInlineCache
				at: picOffset put: offset;
				at: picOffset + 1 put: offset;
				at: picOffset + 2 put: nil;
				at: picOffset + 3 put: nil;
				at: picOffset + 4 put: nil;
				at: picOffset + 5 put: nil;
				at: picOffset + 6 put: nil;
				at: picOffset + 7 put: nil;
				at: picOffset + 8 put: nil.
			picOffset := picOffset + 9]"! !

! CodeGenerator methodsFor: 'blocks' !
createBlockFor: newCodeGenerator variablesToCopy: variablesToCopy

	| locals block scope |

	locals := (self methodLocalVariableAnalysis scopeFor: self nodeStack last) allLocals.
	variablesToCopy do: [:eachVariable |
		| index |
		index := locals indexOf: eachVariable.
		index = 0
			ifTrue: [
				eachVariable isSelf
					ifTrue: [self pushSelf]
					ifFalse: [self compileError: 'Compile error 1']]
			ifFalse: [self pushLocalVariableNumber: index]].

	scope := newCodeGenerator methodLocalVariableAnalysis scopeFor: newCodeGenerator nodeStack last.

	block := (CompiledBlock new: newCodeGenerator literals size)
				numberOfTemporaries: scope temporaryVariables size;
				numberOfArguments: scope arguments size;
				bytecodes: newCodeGenerator bytecodeStream contents;
				localVariableNames: scope localVariableNames asArray;
				mclass: self targetClass;
				sourceOffsets: (newCodeGenerator sourceOffsets asArray);
				yourself.

	newCodeGenerator
		writeLiteralsInto: block;
		writePICInto: block.

	^self addLiteral: block! !

! CodeGenerator methodsFor: 'blocks' !
pushCopyBlock: newCodeGenerator variablesToCopy: variablesToCopy

	| literalNumber |
	
	literalNumber := self createBlockFor: newCodeGenerator variablesToCopy: variablesToCopy.

	self
		addBytecode: self bytecodePushCopyingBlock;
		addBytecode: literalNumber - 1;
		addBytecode: variablesToCopy size! !

! CodeGenerator methodsFor: 'blocks' !
pushFullBlock: newCodeGenerator variablesToCopy: variablesToCopy

	| literalNumber |

	literalNumber := self createBlockFor: newCodeGenerator variablesToCopy: variablesToCopy.

	self
		addBytecode: self bytecodePushFullBlock;
		addBytecode: literalNumber - 1;
		addBytecode: variablesToCopy size! !

! CodeGenerator methodsFor: 'bytecodes' !
addDup
	^self addBytecode: self bytecodeDup! !

! CodeGenerator methodsFor: 'bytecodes' !
addPop
	^self addBytecode: self bytecodePop! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeBlockReturn

	^self bytecodeFor: #blockReturn! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallOneByte

	^self bytecodeFor: #callLiteral! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallOneByteSuper

	^self bytecodeFor: #callSuperLiteral! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallShort

	^self bytecodeFor: #callLiteral1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallShortSuper

	^self bytecodeFor: #superCallLiteral1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallSuperTwoBytes

	^self bytecodeFor: #superCallLiteralExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallTwoBytes

	^self bytecodeFor: #callLiteralExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallWellKnown

	^self bytecodeFor: #callWellKnown! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeDropCascadeReceiver

	^self bytecodeFor: #dropCascadeReceiver! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeDup

	^self bytecodeFor: #dup! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfFalseOneByte

	^self bytecodeFor: #jumpIfFalse! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfFalseTwoBytes

	^self bytecodeFor: #jumpIfFalseExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfTrueOneByte

	^self bytecodeFor: #jumpIfTrue! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfTrueTwoBytes

	^self bytecodeFor: #jumpIfTrueExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpOneByte

	^self bytecodeFor: #jump! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpTwoBytes

	^self bytecodeFor: #jumpExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeNonLocalReturn

	^self bytecodeFor: #nonLocalReturn! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePop

	^self bytecodeFor: #pop! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePrimitive

	^self bytecodeFor: #callPrimitive! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePrimitiveReturn

	^self bytecodeFor: #primitiveReturn! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushCopyingBlock

	^self bytecodeFor: #pushCopyingBlock! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushFalse

	^self bytecodeFor: #pushFalse! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushFourByteInteger

	^self bytecodeFor: #pushFourByteInteger! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushFullBlock

	^self bytecodeFor: #pushFullBlock! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushLocalIndirect

	^self bytecodeFor: #pushLocalIndirect! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushNil

	^self bytecodeFor: #pushNil! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteGlobal

	^self bytecodeFor: #pushGlobal! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteInstanceVariable

	^self bytecodeFor: #pushInstVar! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteInteger

	^self bytecodeFor: #pushOneByteInteger! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteLiteral

	^self bytecodeFor: #pushLiteral! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteLocalVariable

	^self bytecodeFor: #pushLocal! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSelf

	^self bytecodeFor: #pushSelf! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSelfInstvarIndirect

	^self bytecodeFor: #pushSelfInstvarIndirect! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushShortGlobal

	^self bytecodeFor: #pushGlobal1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushShortInstanceVariable

	^self bytecodeFor: #pushInstVar1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushShortLocalVariable

	^self bytecodeFor: #pushLocal1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSmallLiteral

	^self bytecodeFor: #pushLiteral1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSmallNegativeInteger

	^self bytecodeFor: #pushInteger0! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSmallPositiveInteger

	^self bytecodeFor: #pushInteger1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushThisContext

	^self bytecodeFor: #pushThisContext! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTrue

	^self bytecodeFor: #pushTrue! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteGlobal

	^self bytecodeFor: #pushGlobalExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteInstanceVariable

	^self bytecodeFor: #pushInstVarExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteInteger

	^self bytecodeFor: #pushTwoByteInteger! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteLiteral

	^self bytecodeFor: #pushLiteralExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeReturn

	^self bytecodeFor: #return! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreLocalIndirect

	^self bytecodeFor: #storeLocalIndirect! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreNewArray

	^self bytecodeFor: #storeNewArray! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreOneByteGlobal

	^self bytecodeFor: #storeGlobal! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreOneByteInstanceVariable

	^self bytecodeFor: #storeInstVar! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreOneByteLocalVariable

	^self bytecodeFor: #storeLocal! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreSelfInstvarIndirect

	^self bytecodeFor: #storeSelfInstVarIndirect! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreShortGlobalVariable

	^self bytecodeFor: #storeGlobal1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreShortInstanceVariable

	^self bytecodeFor: #storeInstVar1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreShortLocalVariable

	^self bytecodeFor: #storeLocal1! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreTwoByteGlobalVariable

	^self bytecodeFor: #storeGlobalExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreTwoByteInstanceVariable

	^self bytecodeFor: #storeInstVarExtended! !

! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreTwoByteLocalVariable

	^self bytecodeFor: #storeLocalExtended! !

! CodeGenerator methodsFor: 'calls' !
callLiteral: literalNumber args: anInteger

	| numberOfArguments |
	numberOfArguments := (literals at: literalNumber) numArgs.
	
	literalNumber <= 16 ifTrue: [^self callShortLiteral: literalNumber args: anInteger].
	literalNumber <= 256 ifTrue: [^self callOneByteLiteral: literalNumber args: anInteger].
	literalNumber <= 65536 ifTrue: [^self callTwoByteLiteral: literalNumber args: anInteger].
	
	self compileError: 'Too many literals'! !

! CodeGenerator methodsFor: 'calls' !
callOneByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallOneByte;
		addBytecode: literalNumber - 1;
		addBytecode: anInteger! !

! CodeGenerator methodsFor: 'calls' !
callShortLiteral: literalNumber args: anInteger

	self
		addBytecode: (self bytecodeCallShort + literalNumber - 1);
		addBytecode: anInteger! !

! CodeGenerator methodsFor: 'calls' !
callSpecialSelector: aSymbol
	| numberOfArguments |

	numberOfArguments := aSymbol numArgs.
	self
		addBytecode: (self bytecodeCallWellKnown);
		addBytecode: (self class specialSelectors indexOf: aSymbol) - 1! !

! CodeGenerator methodsFor: 'calls' !
callSuperLiteral: literalNumber args: anInteger

	literalNumber <= 6 ifTrue: [^self callSuperShortLiteral: literalNumber args: anInteger].
	literalNumber < 256 ifTrue: [^self callSuperOneByteLiteral: literalNumber args: anInteger].
	self callSuperTwoByteLiteral: literalNumber args: anInteger! !

! CodeGenerator methodsFor: 'calls' !
callSuperOneByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallOneByteSuper;
		addBytecode: literalNumber - 1;
		addBytecode: anInteger! !

! CodeGenerator methodsFor: 'calls' !
callSuperShortLiteral: literalNumber args: anInteger

	self addBytecode: (self bytecodeCallShortSuper + literalNumber - 1);
		addBytecode: anInteger! !

! CodeGenerator methodsFor: 'calls' !
callSuperTwoByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallSuperTwoBytes;
		addBytecode: literalNumber - 1 // 256;
		addBytecode: literalNumber - 1 \\ 256;
		addBytecode: anInteger! !

! CodeGenerator methodsFor: 'calls' !
callTwoByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallTwoBytes;
		addBytecode: literalNumber - 1 // 256;
		addBytecode: literalNumber - 1 \\ 256;
		addBytecode: anInteger! !

! CodeGenerator methodsFor: 'decompiling' !
callOffsetsDo: aBlock

	| decompileStream line matchNext offset|

	matchNext := false.

	decompileStream := self decompileNoBytes readStream.
	decompileStream upTo: Character cr.

	[decompileStream atEnd] whileFalse: [
		line := decompileStream upTo: Character cr.
		matchNext ifTrue: [
			offset := line trimSeparators readStream upTo: $:.
			aBlock value: (Integer readHexFrom: offset readStream).
			matchNext := false].
		((line indexOfSubCollection: 'Call' startingAt: 1) > 0) ifTrue: [matchNext := true].
		((line indexOfSubCollection: 'call' startingAt: 1) > 0) ifTrue: [matchNext := true]
		]! !

! CodeGenerator methodsFor: 'decompiling' !
decompile

	^Decompiler new
		literals: self literals;
		targetClass: self targetClass;
		decompile: self bytecodes! !

! CodeGenerator methodsFor: 'decompiling' !
decompileNoBytes

	^Decompiler new
		literals: self literals;
		targetClass: self targetClass;
		decompileNoBytes: self bytecodes! !

! CodeGenerator methodsFor: 'decompiling' !
numberOfSends

	| numberOfSends |
	numberOfSends := 0.
	self callOffsetsDo: [:offset |
		numberOfSends := numberOfSends + 1].

	^numberOfSends! !

! CodeGenerator methodsFor: 'errors' !
compileError: aString

	self halt
	"^(CompileError new)
		message: aString;
		startSourceOffset: start;
		endSourceOffset: end;
		raiseSignal"! !

! CodeGenerator methodsFor: 'errors' !
compileError: aString node: aParseNode

	^(CompileError new)
		message: aString;
		startSourceOffset: aParseNode startSourceOffset;
		endSourceOffset: aParseNode endSourceOffset;
		raiseSignal! !

! CodeGenerator methodsFor: 'errors' !
compileWarning: aString
	^self! !

! CodeGenerator methodsFor: 'errors' !
compileWarning: aString node: aParseNode

	^(CompileWarning new)
		message: aString;
		startSourceOffset: aParseNode startSourceOffset;
		endSourceOffset: aParseNode endSourceOffset;
		raiseSignal! !

! CodeGenerator methodsFor: 'initialize-release' !
initialize

	literals := OrderedCollection new.
	bytecodeStream := WriteStream on: (ByteArray new).
	hasReturned := false.
	self pragmas: OrderedCollection new.
	globalDictionaries := OrderedCollection new.
	nodeStack := OrderedCollection new.
	isInlinedBlock := false.
	nestedVariablesRead := Set new.
	nestedVariablesWritten := Set new.
	returnLevel := 0.
	sourceOffsets := OrderedCollection with: 0 with: 0 with: 0! !

! CodeGenerator methodsFor: 'literals' !
addLiteral: anObject

	| literalNumber |

	anObject isNil ifTrue: [self  halt. self compileError: 'Compile error 3'].
	(literalNumber := literals indexOf: anObject) = 0 ifTrue: [
		literals add: anObject.
		literalNumber := literals size].

	^literalNumber! !

! CodeGenerator methodsFor: 'literals' !
pushFourByteInteger: anInteger

	| twoByteInteger |

	anInteger positive ifTrue: [
		self
			addBytecode: self bytecodePushFourByteInteger;
			addBytecode: anInteger // 16777216;
			addBytecode: (anInteger bitAnd: 16rFF0000) // 65536;
			addBytecode: (anInteger bitAnd: 16rFF00) // 256;
			addBytecode: (anInteger bitAnd: 16rFF).
		^self].

	twoByteInteger := 4294967296 + anInteger.

	self
		addBytecode: self bytecodePushFourByteInteger;
		addBytecode: twoByteInteger // 16777216;
		addBytecode: (twoByteInteger bitAnd: 16rFF0000) // 65536;
		addBytecode: (twoByteInteger bitAnd: 16rFF00) // 256;
		addBytecode: (twoByteInteger bitAnd: 16rFF)! !

! CodeGenerator methodsFor: 'literals' !
pushInteger: integer

	(integer between: 1 and: 16) ifTrue: [^self pushSmallPositiveInteger: integer].
	(integer between: -15 and: 0) ifTrue: [^self pushSmallNegativeInteger: integer].
	(integer between: -128 and: 127) ifTrue: [^self pushOneByteInteger: integer].
	(integer between: -32768 and: 32767) ifTrue: [^self pushTwoByteInteger: integer].
	(integer between: -2147483648 and: 2147483647) ifTrue: [^self pushFourByteInteger: integer].
	self pushLiteral: integer! !

! CodeGenerator methodsFor: 'literals' !
pushLiteral: anObject

	| literalNumber |

	literalNumber := self addLiteral: anObject.

	literalNumber <= 16 ifTrue: [^self pushShortLiteral: literalNumber].
	literalNumber <= 256 ifTrue: [^self pushOneByteLiteral: literalNumber].
	self pushTwoByteLiteral: literalNumber! !

! CodeGenerator methodsFor: 'literals' !
pushOneByteInteger: anInteger

	anInteger positive ifTrue: [^
		self
			addBytecode: self bytecodePushOneByteInteger;
			addBytecode: anInteger].

	self
		addBytecode: self bytecodePushOneByteInteger;
		addBytecode: 256 + anInteger! !

! CodeGenerator methodsFor: 'literals' !
pushOneByteLiteral: literalNumber

	self
		addBytecode: self bytecodePushOneByteLiteral;
		addBytecode: literalNumber - 1! !

! CodeGenerator methodsFor: 'literals' !
pushShortLiteral: literalNumber

	self addBytecode: self bytecodePushSmallLiteral + (literalNumber - 1)! !

! CodeGenerator methodsFor: 'literals' !
pushSmallNegativeInteger: anInteger

	self addBytecode: self bytecodePushSmallNegativeInteger + anInteger negated! !

! CodeGenerator methodsFor: 'literals' !
pushSmallPositiveInteger: anInteger

	self addBytecode: self bytecodePushSmallPositiveInteger + (anInteger - 1)! !

! CodeGenerator methodsFor: 'literals' !
pushTwoByteInteger: anInteger

	| twoByteInteger |

	anInteger positive ifTrue: [
		self
			addBytecode: self bytecodePushTwoByteInteger;
			addBytecode: anInteger // 256;
			addBytecode: anInteger \\ 256.
		^self].

	twoByteInteger := 65536 + anInteger.

	self
		addBytecode: self bytecodePushTwoByteInteger;
		addBytecode: twoByteInteger // 256;
		addBytecode: twoByteInteger \\ 256.! !

! CodeGenerator methodsFor: 'literals' !
pushTwoByteLiteral: literalNumber

	self
		addBytecode: self bytecodePushTwoByteLiteral;
		addBytecode: literalNumber - 1 // 256;
		addBytecode: literalNumber - 1 \\ 256! !

! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: aBlockLiteralNode

	^self visitIfFalseBlock: aBlockLiteralNode useLongJumps: false! !

! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode

	^self visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: false! !

! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex hasFalseReturned jump1Offset jump2Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	"push receiver
	jump if false - jump1
	code for ifTrue
	jump - jump 2
	code for ifFalse"

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfTrueTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfTrueOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		falseBlockLiteralNode value acceptVisitor: self].

	hasFalseReturned := self hasReturned.
	self hasReturned: false.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: 0].

	jump2Offset := self bytecodes size.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self whileEmbeddedBlockDo: [
		trueBlockLiteralNode value acceptVisitor: self].

	"Fix the jump 2 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump2Offset.
			self bytecodeStream
				at: jump2Offset - 1 put: (forwardJump // 256);
				at: jump2Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump2Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at:  jump2Offset put: forwardJump].

	self hasReturned: (self hasReturned & hasFalseReturned)! !

! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: aBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jump1Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfTrueTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfTrueOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		aBlockLiteralNode value acceptVisitor: self].

	self
		addBytecode: self bytecodeJumpOneByte;
		addBytecode: 1.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfFalseBlock: aBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self addBytecode: self bytecodePushNil.

	self hasReturned: false. ! !

! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: aBlockLiteralNode

	^self visitIfTrueBlock: aBlockLiteralNode useLongJumps: false! !

! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode

	^self visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: false! !

! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex hasTrueReturned jump1Offset jump2Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfFalseTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfFalseOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		trueBlockLiteralNode value acceptVisitor: self].

	hasTrueReturned := self hasReturned.
	self hasReturned: false.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: 0].

	jump2Offset := self bytecodes size.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self whileEmbeddedBlockDo: [
		falseBlockLiteralNode value acceptVisitor: self].

	"Fix the jump 2 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump2Offset.
			self bytecodeStream
				at: jump2Offset - 1 put: (forwardJump // 256);
				at: jump2Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump2Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at:  jump2Offset put: forwardJump].

	self hasReturned: (self hasReturned & hasTrueReturned)! !

! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: aBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jump1Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfFalseTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfFalseOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		aBlockLiteralNode value acceptVisitor: self].

	self
		addBytecode: self bytecodeJumpOneByte;
		addBytecode: 1.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfTrueBlock: aBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self addBytecode: self bytecodePushNil.

	self hasReturned: false. ! !

! CodeGenerator methodsFor: 'messages' !
visitWhileFalseBlock: conditionBlock doBlock: doBlock

	self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: false! !

! CodeGenerator methodsFor: 'messages' !
visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jumpForwardOffset backwardJump forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	self whileEmbeddedBlockDo: [conditionBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfTrueTwoBytes;
				addBytecode: 0;
				addBytecode: 0.
			jumpForwardOffset := self bytecodes size]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfTrueOneByte;
				addBytecode: 0.
			jumpForwardOffset := self bytecodes size].

	self whileEmbeddedBlockDo: [doBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			backwardJump := 65536 - (self bytecodes size + 4 - startBytecodeIndex).
			
			self
				addPop;
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: backwardJump // 256;
				addBytecode: backwardJump \\ 256]
		ifFalse: [
			backwardJump := self bytecodes size + 3 - startBytecodeIndex.
			backwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			backwardJump := 256 - backwardJump.

			self
				addPop;
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: backwardJump].
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			self bytecodeStream
				at: jumpForwardOffset - 1 put: (forwardJump // 256);
				at: jumpForwardOffset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			self bytecodeStream
				at: jumpForwardOffset put: forwardJump].

	self pushSelf ! !

! CodeGenerator methodsFor: 'messages' !
visitWhileTrueBlock: conditionBlock doBlock: doBlock

	self visitWhileTrueBlock: conditionBlock doBlock: doBlock useLongJumps: false
! !

! CodeGenerator methodsFor: 'messages' !
visitWhileTrueBlock: conditionBlock doBlock: doBlock useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jumpForwardOffset backwardJump forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	self whileEmbeddedBlockDo: [conditionBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfFalseTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfFalseOneByte;
				addBytecode: 0].

	jumpForwardOffset := self bytecodes size.

	self whileEmbeddedBlockDo: [doBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			backwardJump := 65536 - (self bytecodes size + 4 - startBytecodeIndex).
			
			self
				addPop;
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: backwardJump // 256;
				addBytecode: backwardJump \\ 256]
		ifFalse: [
			backwardJump := self bytecodes size + 3 - startBytecodeIndex.
			backwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			backwardJump := 256 - backwardJump.

			self
				addPop;
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: backwardJump].
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			self bytecodeStream
				at: jumpForwardOffset - 1 put: (forwardJump // 256);
				at: jumpForwardOffset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			self bytecodeStream
				at: jumpForwardOffset put: forwardJump].

	self pushSelf ! !

! CodeGenerator methodsFor: 'messages' !
whileEmbeddedBlockDo: aBlock

	| oldEmbedded |
	oldEmbedded := self isInlinedBlock.
	self isInlinedBlock: true.
	"self log: 'Start embeddedBlock'."
	aBlock value.
	"self log: 'Finish embeddedBlock'."
	self isInlinedBlock: oldEmbedded! !

! CodeGenerator methodsFor: 'special words' !
pushCopiedSelf

	| selfVariable |
	selfVariable := self selfVariable.
	self pushLocalVariableReference: selfVariable! !

! CodeGenerator methodsFor: 'special words' !
pushFalse
	self addBytecode: self bytecodePushFalse! !

! CodeGenerator methodsFor: 'special words' !
pushNil
	self addBytecode: self bytecodePushNil! !

! CodeGenerator methodsFor: 'special words' !
pushReturn
	self addBytecode: self bytecodeReturn! !

! CodeGenerator methodsFor: 'special words' !
pushSelf
	self nodeStack last isBlockNode ifTrue: [^self pushCopiedSelf].
	self addBytecode: self bytecodePushSelf! !

! CodeGenerator methodsFor: 'special words' !
pushThisContext
	self addBytecode: self bytecodePushThisContext! !

! CodeGenerator methodsFor: 'special words' !
pushTrue
	self addBytecode: self bytecodePushTrue! !

! CodeGenerator methodsFor: 'special words' !
selfVariable

	| selfVariable |
	selfVariable := (self methodLocalVariableAnalysis scopeFor: nodeStack last)
				copiedVariables detect: [:eachVariable | eachVariable isSelf]
					ifNone: [self compileError: 'Compiler error'].
	^selfVariable! !

! CodeGenerator methodsFor: 'testing' !
globalAssociationFor: aVariable

	| currentDictionary result |

	currentDictionary := globalDictionaries detect: [:dictionary | dictionary notNil and: [dictionary includesKey: aVariable variableName]] ifNone: [
		^nil].

	^currentDictionary bindingFor: aVariable variableName.
! !

! CodeGenerator methodsFor: 'testing' !
isGlobalVariable: aVariable

	| variableSymbol |

	aVariable isGlobalVariable ifFalse: [^false].
	variableSymbol := aVariable variableName asSymbol.
	^globalDictionaries anySatisfy: [:each | each includesKey: variableSymbol]! !

! CodeGenerator methodsFor: 'testing' !
isInlined

	^false! !

! CodeGenerator methodsFor: 'testing' !
isInstanceVariable: aVariable

	targetClass isNil ifTrue: [^false].
	aVariable isInstanceVariable ifFalse: [^false].
	^targetClass allInstVarNames includes: aVariable variableName asString! !

! CodeGenerator methodsFor: 'testing' !
isLocalVariable: aVariableNode

	aVariableNode isLocalVariable ifFalse: [^false].
	^(self scopeForLocalVariable: aVariableNode) notNil! !

! CodeGenerator methodsFor: 'testing' !
isNamespaceGlobal: anArray

	^(self namespaceGlobalAssociationFor: anArray) notNil! !

! CodeGenerator methodsFor: 'testing' !
isSpecialSelector: aSymbol

	^self class specialSelectors includes: aSymbol! !

! CodeGenerator methodsFor: 'testing' !
namespaceGlobalAssociationFor: anArray

	| currentDictionary association |

	currentDictionary := globalDictionaries detect: [:dictionary | dictionary includesKey: anArray first asSymbol] ifNone: [^nil].
	1 to: anArray size - 1 do: [:each |
		currentDictionary := currentDictionary at: (anArray at: each) asSymbol ifAbsent: [^nil]].

	(currentDictionary includesKey: anArray last asSymbol) ifFalse: [^nil].
	^currentDictionary associationAt: anArray last asSymbol! !

! CodeGenerator methodsFor: 'variables' !
pushGlobalReference: aVariable

	| variableNumber association |

	association := self globalAssociationFor: aVariable.
	association isNil ifTrue: [
		self compileWarning: 'Undeclared variable: ', aVariable variableName.
		Undeclared at: aVariable variableName ifAbsentPut: [nil].
		association := Undeclared associationAt: aVariable variableName.
		].
	
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals size].

	variableNumber := variableNumber.

	variableNumber <= 16 ifTrue: [^self pushShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references'! !

! CodeGenerator methodsFor: 'variables' !
pushGlobalReference: aVariable node: aNode

	| variableNumber association |

	association := self globalAssociationFor: aVariable.
	association isNil ifTrue: [
		Undeclared at: aVariable variableName ifAbsentPut: [nil].
		association := Undeclared associationAt: aVariable variableName.
		self compileError: 'Undeclared variable: ', aVariable variableName node: aNode].
	
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals size].

	variableNumber := variableNumber.

	variableNumber <= 16 ifTrue: [^self pushShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references'! !

! CodeGenerator methodsFor: 'variables' !
pushIndirectLocalVariableReference: anArray

	self
		addBytecode: self bytecodePushLocalIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1! !

! CodeGenerator methodsFor: 'variables' !
pushIndirectVariableArrayFor: aScopeAnalysisResult

	aScopeAnalysisResult indirectVariables variables isEmpty ifTrue: [^self].

	(aScopeAnalysisResult indirectVariables variables size = 0
		or: [aScopeAnalysisResult temporaryVariables size = 0]) ifTrue: [self compileError: 'Compile error 2'].

	self
		addBytecode: self bytecodeStoreNewArray;
		addBytecode: aScopeAnalysisResult indirectVariables variables size;
		addBytecode: (aScopeAnalysisResult variableNumberOf: aScopeAnalysisResult indirectVariables) - 1! !

! CodeGenerator methodsFor: 'variables' !
pushInstVarReference: aVariable

	| variableNumber |

	variableNumber := targetClass allInstVarNames indexOf: aVariable variableName asString.
	(self nodeStack notEmpty and: [self nodeStack last isBlockNode]) ifTrue: [
		| selfVariableNumber |
		selfVariableNumber := self methodLocalVariableAnalysis variableNumberOf: self selfVariable inNode: self nodeStack last.
		^self pushSelfInstanceVariableReference: (Array with: selfVariableNumber with: variableNumber)].

	variableNumber <= 16 ifTrue: [^self pushShortInstVar: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteInstVar: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteInstVar: variableNumber].

	self compileError: 'Too many instance variables'! !

! CodeGenerator methodsFor: 'variables' !
pushLocalVariableNumber: aVariableNumber

	aVariableNumber <= 16 ifTrue: [^self pushShortLocalVar: aVariableNumber].
	aVariableNumber <= 256 ifTrue: [^self pushOneByteLocalVar: aVariableNumber].

	self compileError: 'Too many temp vars'! !

! CodeGenerator methodsFor: 'variables' !
pushLocalVariableReference: aVariable

	| variableNumber |

	variableNumber := self methodLocalVariableAnalysis variableNumberOf: aVariable inNode: self nodeStack last.
	variableNumber = 0 ifTrue: [^self compileError: 'Compiler error - can''t find variable ', aVariable variableName].
	variableNumber isCollection ifTrue: [^self pushIndirectLocalVariableReference: variableNumber].

	self pushLocalVariableNumber: variableNumber! !

! CodeGenerator methodsFor: 'variables' !
pushNamespaceGlobalReference: anArray

	| variableNumber association |

	association := self namespaceGlobalAssociationFor: anArray.
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals indexOf: association].

	variableNumber <= 16 ifTrue: [^self pushShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references'! !

! CodeGenerator methodsFor: 'variables' !
pushOneByteGlobal: variableNumber

	self
		addBytecode: self bytecodePushOneByteGlobal;
		addBytecode: variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
pushOneByteInstVar: variableNumber

	self
		addBytecode: self bytecodePushOneByteInstanceVariable;
		addBytecode: variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
pushOneByteLocalVar: variableNumber

	self
		addBytecode: self bytecodePushOneByteLocalVariable;
		addBytecode: variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
pushSelfInstanceVariableReference: anArray

	self
		addBytecode: self bytecodePushSelfInstvarIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1! !

! CodeGenerator methodsFor: 'variables' !
pushShortGlobal: variableNumber

	self addBytecode: self bytecodePushShortGlobal + variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
pushShortInstVar: variableNumber

	self
		addBytecode: self bytecodePushShortInstanceVariable + variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
pushShortLocalVar: variableNumber

	self
		addBytecode: self bytecodePushShortLocalVariable + variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
pushTwoByteGlobal: variableNumber

	self
		addBytecode: self bytecodePushTwoByteGlobal;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256! !

! CodeGenerator methodsFor: 'variables' !
pushTwoByteInstVar: variableNumber

	self
		addBytecode: self bytecodePushTwoByteInstanceVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256! !

! CodeGenerator methodsFor: 'variables' !
storeGlobalVariableAssignment: aVariable node: aGlobalVariableAssignmentNode

	| variableNumber association |

	association := self globalAssociationFor: aVariable.
	association isNil ifTrue: [^self compileError: 'Undeclared variable: ', aVariable variableName node: aGlobalVariableAssignmentNode].
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals size].

	variableNumber <= 16 ifTrue: [^self storeShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self storeOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self storeTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references'! !

! CodeGenerator methodsFor: 'variables' !
storeIndirectLocalVariableAssignment: anArray

	self
		addBytecode: self bytecodeStoreLocalIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1! !

! CodeGenerator methodsFor: 'variables' !
storeInstanceVariableAssignment: aVariable

	| variableNumber |

	variableNumber := (targetClass allInstVarNames indexOf: aVariable variableName asString).

	(self nodeStack notEmpty and: [self nodeStack last isBlockNode]) ifTrue: [
		| selfVariableNumber |
		selfVariableNumber := self methodLocalVariableAnalysis variableNumberOf: self selfVariable inNode: self nodeStack last.
		^self storeSelfInstvarAssignment: (Array with: selfVariableNumber with: variableNumber)].

	variableNumber <= 16 ifTrue: [^self storeShortInstanceVariable: variableNumber].
	variableNumber <= 256 ifTrue: [^self storeOneByteInstanceVariable: variableNumber].
	variableNumber <= 65536 ifTrue: [^self storeTwoByteInstanceVariable: variableNumber].

	self compileError: 'Too many instance variables'! !

! CodeGenerator methodsFor: 'variables' !
storeLocalVariableAssignment: aVariable

	| variableNumber |

	variableNumber := self methodLocalVariableAnalysis variableNumberOf: aVariable inNode: self nodeStack last.
	variableNumber = 0 ifTrue: [^self compileError: 'Compiler error - can''t find variable ', aVariable variableName].

	variableNumber isCollection ifTrue: [^self storeIndirectLocalVariableAssignment: variableNumber].

	variableNumber <= 16 ifTrue: [^self storeShortLocalVar: variableNumber].
	variableNumber <= 256 ifTrue: [^self storeOneByteLocalVar: variableNumber].
	variableNumber <= 65536 ifTrue: [^self storeTwoByteLocalVar: variableNumber].

	self compileError: 'Too many local vars'! !

! CodeGenerator methodsFor: 'variables' !
storeNamespaceGlobalAssignment: aNode

	| variableNumber association |

	association := self namespaceGlobalAssociationFor: aNode nameComponents.
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals indexOf: association].

	variableNumber = 0 ifTrue: [^self compileError: 'Global isn''t a literal'].

	self recordSourceOffsetsFor: aNode.

	variableNumber <= 16 ifTrue: [^self storeShortGlobal: variableNumber].
	variableNumber < 256 ifTrue: [^self storeOneByteGlobal: variableNumber].
	variableNumber < 65536 ifTrue: [^self storeTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references'! !

! CodeGenerator methodsFor: 'variables' !
storeOneByteGlobal: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteGlobal;
		addBytecode: variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
storeOneByteInstanceVariable: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteInstanceVariable;
		addBytecode: variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
storeOneByteLocalVar: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteLocalVariable;
		addBytecode: variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
storeSelfInstvarAssignment: anArray

	self
		addBytecode: self bytecodeStoreSelfInstvarIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1! !

! CodeGenerator methodsFor: 'variables' !
storeShortGlobal: variableNumber

	self addBytecode: self bytecodeStoreShortGlobalVariable + variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
storeShortInstanceVariable: variableNumber

	self
		addBytecode: self bytecodeStoreShortInstanceVariable + variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
storeShortLocalVar: variableNumber

	self
		addBytecode: self bytecodeStoreShortLocalVariable + variableNumber - 1! !

! CodeGenerator methodsFor: 'variables' !
storeTwoByteGlobal: variableNumber

	self
		addBytecode: self bytecodeStoreTwoByteGlobalVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256! !

! CodeGenerator methodsFor: 'variables' !
storeTwoByteInstanceVariable: variableNumber

	self
		addBytecode: self bytecodeStoreTwoByteInstanceVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256! !

! CodeGenerator methodsFor: 'variables' !
storeTwoByteLocalVar: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteLocalVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256! !

! CodeGenerator methodsFor: 'visitor handling' !
recordSourceOffsetsFor: aNode

	self sourceOffsets
		add: self bytecodeStream position;
		add: aNode startSourceOffset;
		add: aNode endSourceOffset.! !

! CodeGenerator methodsFor: 'visitor handling' !
visitArgument: aNode

	^aNode acceptVisitor: self! !

! CodeGenerator methodsFor: 'visitor handling' !
visitBinaryHeader: aNode

	self selector: aNode selector.! !

! CodeGenerator methodsFor: 'visitor handling' !
visitBlockLiteralNode: aNode

	| newCodeGenerator variablesToCopy nodeScope block scope |

	newCodeGenerator := self class new
		methodLocalVariableAnalysis: self methodLocalVariableAnalysis;
		targetClass: self targetClass;
		selector: self selector;
		globalDictionaries: self globalDictionaries;
		literals: OrderedCollection new;
		returnLevel: self returnLevel + 1;
		yourself.

	newCodeGenerator pushNode: aNode.
	"self log: 'Start block analysis'."
	aNode acceptVisitor: newCodeGenerator.
	"self log: 'End block analysis'."

	nodeScope := self methodLocalVariableAnalysis scopeFor: aNode.
	variablesToCopy := nodeScope copiedVariables.

	nodeScope hasReturn ifTrue: [
		^self pushFullBlock: newCodeGenerator variablesToCopy: variablesToCopy].
	
	variablesToCopy notEmpty ifTrue: [
		^self pushCopyBlock: newCodeGenerator variablesToCopy: variablesToCopy].

	scope := newCodeGenerator methodLocalVariableAnalysis scopeFor: aNode.

	block := (CompiledBlock new: newCodeGenerator literals size)
			numberOfTemporaries: scope temporaryVariables size;
			numberOfArguments: scope arguments size;
			bytecodes: newCodeGenerator bytecodeStream contents;
			localVariableNames: scope localVariableNames asArray;
			sourceOffsets: (newCodeGenerator sourceOffsets asArray);
			mclass: self targetClass;
			yourself.

	newCodeGenerator
		writeLiteralsInto: block;
		writePICInto: block.

	self pushLiteral: (BlockClosure new
		method: block;
		copiedValues: Array new;
		yourself).! !

! CodeGenerator methodsFor: 'visitor handling' !
visitBlockNode: aNode

	self isInlinedBlock ifTrue: [^self].
	self hasReturned ifFalse: [
		self addBytecode: self bytecodeBlockReturn]! !

! CodeGenerator methodsFor: 'visitor handling' !
visitBlockNodeStart: aNode

	self isInlinedBlock ifTrue: [^self].
	self pushIndirectVariableArrayFor: (self methodLocalVariableAnalysis scopeFor: aNode)! !

! CodeGenerator methodsFor: 'visitor handling' !
visitBlockParameterListNode: aNode! !

! CodeGenerator methodsFor: 'visitor handling' !
visitCascadeEnd: aNode

	self addBytecode: self bytecodeDropCascadeReceiver! !

! CodeGenerator methodsFor: 'visitor handling' !
visitCascadeInterMessage: aNode

	self
		addPop;
		addDup! !

! CodeGenerator methodsFor: 'visitor handling' !
visitCascadeStart: aNode

	self addDup! !

! CodeGenerator methodsFor: 'visitor handling' !
visitEmptyMethodNode: aNode

	self pushSelf.
	self pushReturn! !

! CodeGenerator methodsFor: 'visitor handling' !
visitEmptyStatements

	self pushSelf! !

! CodeGenerator methodsFor: 'visitor handling' !
visitGlobalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.
	self recordSourceOffsetsFor: aNode.

	self storeGlobalVariableAssignment: aNode variable node: aNode! !

! CodeGenerator methodsFor: 'visitor handling' !
visitGlobalVariableReferenceNode: aNode

	self pushGlobalReference: aNode variable node: aNode! !

! CodeGenerator methodsFor: 'visitor handling' !
visitInstanceVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.
	self recordSourceOffsetsFor: aNode.

	self storeInstanceVariableAssignment: aNode variable! !

! CodeGenerator methodsFor: 'visitor handling' !
visitInstanceVariableReferenceNode: aNode

	self pushInstVarReference: aNode variable! !

! CodeGenerator methodsFor: 'visitor handling' !
visitKeywordHeader: aNode

	self selector: aNode selector.! !

! CodeGenerator methodsFor: 'visitor handling' !
visitLiteralNode: aNode

	aNode value isInteger ifTrue: [^self pushInteger: aNode value].
	self pushLiteral: aNode value! !

! CodeGenerator methodsFor: 'visitor handling' !
visitLocalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.
	self recordSourceOffsetsFor: aNode.

	self storeLocalVariableAssignment: aNode variable! !

! CodeGenerator methodsFor: 'visitor handling' !
visitLocalVariableReferenceNode: aNode

	self pushLocalVariableReference: aNode variable! !

! CodeGenerator methodsFor: 'visitor handling' !
visitMessageNodeEnd: aNode

	| literalNumber |

	(self isSpecialSelector: aNode selector) ifTrue: [
		self recordSourceOffsetsFor: aNode.
		^self callSpecialSelector: aNode selector].

	literalNumber := self addLiteral: aNode selector.

	((aNode receiver isMemberOf: SpecialNode) and: [aNode receiver special = 'super']) ifTrue: [
		| numberOfArguments |
		numberOfArguments := (literals at: literalNumber) numArgs.
		self pushLiteral: targetClass.
		self recordSourceOffsetsFor: aNode.
		^self callSuperLiteral: literalNumber args: aNode selector numArgs].

	self recordSourceOffsetsFor: aNode.
	self callLiteral: literalNumber args: aNode selector numArgs! !

! CodeGenerator methodsFor: 'visitor handling' !
visitMessageNodeStart: aNode! !

! CodeGenerator methodsFor: 'visitor handling' !
visitMethodNode: aNode

	self hasReturned ifFalse: [
		self
			addPop;
			pushSelf;
			pushReturn]! !

! CodeGenerator methodsFor: 'visitor handling' !
visitMethodNodeStart: aNode

	self pushNode: aNode.
	self methodLocalVariableAnalysis: MethodLocalVariableAnalysisVisitor new.
	aNode acceptVisitor: self methodLocalVariableAnalysis.
	self pushIndirectVariableArrayFor: (self methodLocalVariableAnalysis scopeFor: aNode)! !

! CodeGenerator methodsFor: 'visitor handling' !
visitNamespaceVariableAssignmentNode: aNode

	| variableName |
	
	variableName := aNode nameComponents.

	(self isNamespaceGlobal: variableName) ifTrue: [^self storeNamespaceGlobalAssignment: aNode ].

	self compileError: 'Undeclared variable: ', variableName! !

! CodeGenerator methodsFor: 'visitor handling' !
visitNamespaceVariableReferenceNode: aNode

	| nameComponents |
	
	nameComponents := aNode nameComponents.

	(self isNamespaceGlobal: nameComponents) ifTrue: [^self pushNamespaceGlobalReference: nameComponents].

	self compileError: 'Undeclared variable: ', nameComponents printString! !

! CodeGenerator methodsFor: 'visitor handling' !
visitPragma: aNode

	self pragmas add: (Array with: aNode selector with: aNode arguments).
	aNode selector = #primitive: ifTrue: [
		self
			addBytecode: self bytecodePrimitive;
			addBytecode: aNode arguments first // 256;
			addBytecode: aNode arguments first \\ 256;
			addBytecode: self bytecodePrimitiveReturn].! !

! CodeGenerator methodsFor: 'visitor handling' !
visitReceiver: aNode

	^aNode acceptVisitor: self! !

! CodeGenerator methodsFor: 'visitor handling' !
visitReturnNode: aNode

	self recordSourceOffsetsFor: aNode.
	self nodeStack last isBlockNode
		ifTrue: [self addBytecode: self bytecodeNonLocalReturn]
		ifFalse: [self pushReturn].
	self hasReturned: true! !

! CodeGenerator methodsFor: 'visitor handling' !
visitSpecialNode: aNode

	| specialName |
	
	specialName := aNode special.

	specialName = 'true' ifTrue: [^self pushTrue].
	specialName = 'false' ifTrue: [^self pushFalse].
	specialName = 'nil' ifTrue: [^self pushNil].
	specialName = 'self' ifTrue: [^self pushSelf].
	specialName = 'super' ifTrue: [^self pushSelf].
	specialName = 'thisContext' ifTrue: [^self pushThisContext].

	self compileError: 'Unknown special word ', specialName! !

! CodeGenerator methodsFor: 'visitor handling' !
visitStatementListEnd: aNode! !

! CodeGenerator methodsFor: 'visitor handling' !
visitStatementListStart: aNode! !

! CodeGenerator methodsFor: 'visitor handling' !
visitStatementSeparator

	self hasReturned ifFalse: [self addPop]! !

! CodeGenerator methodsFor: 'visitor handling' !
visitUnaryHeader: aNode

	self selector: aNode selector.! !

! CodeGenerator class methodsFor: 'class initialization' !
bytecodesByIndex

	^bytecodesByIndex ifNil: [self initialize. bytecodesByIndex]! !

! CodeGenerator class methodsFor: 'class initialization' !
bytecodesByName

	^bytecodesByName ifNil: [self initialize. bytecodesByName]! !

! CodeGenerator class methodsFor: 'class initialization' !
initialize

	| bytecodeTable |

	bytecodesByIndex := Array new: 256.
	bytecodesByName := IdentityDictionary new.
	bytecodeTable := self bytecodeTable.
	BeagleSystem wellKnownAt: 27 put: bytecodeTable.

	1 to: bytecodeTable size by: 3 do: [:index |
		| bytecodeSpec argumentSpec |
		
		argumentSpec := bytecodeTable at: index + 2.
		bytecodeSpec := BytecodeSpec new
			number: index - 1 // 3;
			name: (bytecodeTable at: index);
			decompileString: (bytecodeTable at: index + 1);
			argumentSpec: argumentSpec;
			type: (argumentSpec at: 1);
			numberOfBytes: (argumentSpec at: 2);
			yourself.
		bytecodesByIndex at: bytecodeSpec number + 1 put: bytecodeSpec.
		bytecodesByName at: bytecodeSpec name put: bytecodeSpec]! !

! CodeGenerator class methodsFor: 'instance creation' !
bytecodeTable

	^#(
"00"		#pushInstVar1					'Push inst var 0  %0i'							#(#pushInstVar 1 #instVarImplicit 0)
"01"		#pushInstVar2					'Push inst var 1  %1i'							#(#pushInstVar 1 #instVarImplicit 1)
"02"		#pushInstVar3					'Push inst var 2  %2i'							#(#pushInstVar 1 #instVarImplicit 2)
"03"		#pushInstVar4					'Push inst var 3  %3i'							#(#pushInstVar 1 #instVarImplicit 3)
"04"		#pushInstVar5					'Push inst var 4  %4i'							#(#pushInstVar 1 #instVarImplicit 4)
"05"		#pushInstVar6					'Push inst var 5  %5i'							#(#pushInstVar 1 #instVarImplicit 5)
"06"		#pushInstVar7					'Push inst var 6  %6i'							#(#pushInstVar 1 #instVarImplicit 6)
"07"		#pushInstVar8					'Push inst var 7  %7i'							#(#pushInstVar 1 #instVarImplicit 7)
"08"		#pushInstVar9					'Push inst var 8  %8i'							#(#pushInstVar 1 #instVarImplicit 8)
"09"		#pushInstVar10					'Push inst var 9  %9i'							#(#pushInstVar 1 #instVarImplicit 9)
"0A"		#pushInstVar11					'Push inst var 10  %10i'						#(#pushInstVar 1 #instVarImplicit 10)
"0B"		#pushInstVar12					'Push inst var 11  %11i'						#(#pushInstVar 1 #instVarImplicit 11)
"0C"		#pushInstVar13					'Push inst var 12  %12i'						#(#pushInstVar 1 #instVarImplicit 12)
"0D"		#pushInstVar14					'Push inst var 13  %13i'						#(#pushInstVar 1 #instVarImplicit 13)
"0E"		#pushInstVar15					'Push inst var 14  %14i'						#(#pushInstVar 1 #instVarImplicit 14)
"0F"		#pushInstVar16					'Push inst var 15  %15i'						#(#pushInstVar 1 #instVarImplicit 15)
"10"		#storeInstVar1					'Store inst var 0  %0i'							#(#storeInstVar 1 #instVarImplicit 0)
"11"		#storeInstVar2					'Store inst var 1  %1i'							#(#storeInstVar 1 #instVarImplicit 1)
"12"		#storeInstVar3					'Store inst var 2  %2i'							#(#storeInstVar 1 #instVarImplicit 2)
"13"		#storeInstVar4					'Store inst var 3  %3i'							#(#storeInstVar 1 #instVarImplicit 3)
"14"		#storeInstVar5					'Store inst var 4  %4i'							#(#storeInstVar 1 #instVarImplicit 4)
"15"		#storeInstVar6					'Store inst var 5  %5i'							#(#storeInstVar 1 #instVarImplicit 5)
"16"		#storeInstVar7					'Store inst var 6  %6i'							#(#storeInstVar 1 #instVarImplicit 6)
"17"		#storeInstVar8					'Store inst var 7  %7i'							#(#storeInstVar 1 #instVarImplicit 7)
"18"		#storeInstVar9					'Store inst var 8  %8i'							#(#storeInstVar 1 #instVarImplicit 8)
"19"		#storeInstVar10					'Store inst var 9  %9i'							#(#storeInstVar 1 #instVarImplicit 9)
"1A"		#storeInstVar11					'Store inst var 10  %10i'						#(#storeInstVar 1 #instVarImplicit 10)
"1B"		#storeInstVar12					'Store inst var 11  %11i'						#(#storeInstVar 1 #instVarImplicit 11)
"1C"		#storeInstVar13					'Store inst var 12  %12i'						#(#storeInstVar 1 #instVarImplicit 12)
"1D"		#storeInstVar14					'Store inst var 13  %13i'						#(#storeInstVar 1 #instVarImplicit 13)
"1E"		#storeInstVar15					'Store inst var 14  %14i'						#(#storeInstVar 1 #instVarImplicit 14)
"1F"		#storeInstVar16					'Store inst var 15  %15i'						#(#storeInstVar 1 #instVarImplicit 15)
"20"		#pushLocal1						'Push local 0    %0t'							#(#pushLocal 1 #localImplicit 0)
"21"		#pushLocal2						'Push local 1    %1t'							#(#pushLocal 1 #localImplicit 1)
"22"		#pushLocal3						'Push local 2    %2t'							#(#pushLocal 1 #localImplicit 2)
"23"		#pushLocal4						'Push local 3    %3t'							#(#pushLocal 1 #localImplicit 3)
"24"		#pushLocal5						'Push local 4    %4t'							#(#pushLocal 1 #localImplicit 4)
"25"		#pushLocal6						'Push local 5    %5t'							#(#pushLocal 1 #localImplicit 5)
"26"		#pushLocal7						'Push local 6    %6t'							#(#pushLocal 1 #localImplicit 6)
"27"		#pushLocal8						'Push local 7    %7t'							#(#pushLocal 1 #localImplicit 7)
"28"		#pushLocal9						'Push local 8    %8t'							#(#pushLocal 1 #localImplicit 8)
"29"		#pushLocal10					'Push local 9    %9t'							#(#pushLocal 1 #localImplicit 9)
"2A"		#pushLocal11					'Push local 10    %10t'							#(#pushLocal 1 #localImplicit 10)
"2B"		#pushLocal12					'Push local 11    %11t'							#(#pushLocal 1 #localImplicit 11)
"2C"		#pushLocal13					'Push local 12    %12t'							#(#pushLocal 1 #localImplicit 12)
"2D"		#pushLocal14					'Push local 13    %13t'							#(#pushLocal 1 #localImplicit 13)
"2E"		#pushLocal15					'Push local 14    %14t'							#(#pushLocal 1 #localImplicit 14)
"2F"		#pushLocal16					'Push local 15    %15t'							#(#pushLocal 1 #localImplicit 15)
"30"		#storeLocal1					'Store local 0    %0t'							#(#storeLocal 1 #localImplicit 0)
"31"		#storeLocal2					'Store local 1    %1t'							#(#storeLocal 1 #localImplicit 1)
"32"		#storeLocal3					'Store local 2    %2t'							#(#storeLocal 1 #localImplicit 2)
"33"		#storeLocal4					'Store local 3    %3t'							#(#storeLocal 1 #localImplicit 3)
"34"		#storeLocal5					'Store local 4    %4t'							#(#storeLocal 1 #localImplicit 4)
"35"		#storeLocal6					'Store local 5    %5t'							#(#storeLocal 1 #localImplicit 5)
"36"		#storeLocal7					'Store local 6    %6t'							#(#storeLocal 1 #localImplicit 6)
"37"		#storeLocal8					'Store local 7    %7t'							#(#storeLocal 1 #localImplicit 7)
"38"		#storeLocal9					'Store local 8    %8t'							#(#storeLocal 1 #localImplicit 8)
"39"		#storeLocal10					'Store local 9    %9t'							#(#storeLocal 1 #localImplicit 9)
"3A"		#storeLocal11					'Store local 10    %10t'						#(#storeLocal 1 #localImplicit 10)
"3B"		#storeLocal12					'Store local 11    %11t'						#(#storeLocal 1 #localImplicit 11)
"3C"		#storeLocal13					'Store local 12    %12t'						#(#storeLocal 1 #localImplicit 12)
"3D"		#storeLocal14					'Store local 13    %13t'						#(#storeLocal 1 #localImplicit 13)
"3E"		#storeLocal15					'Store local 14    %14t'						#(#storeLocal 1 #localImplicit 14)
"3F"		#storeLocal16					'Store local 15    %15t'						#(#storeLocal 1 #localImplicit 15)
"40"		#pushGlobal1					'Push global 0    %0g'							#(#pushGlobal 1 #globalImplicit 0)
"41"		#pushGlobal2					'Push global 1    %1g'							#(#pushGlobal 1 #globalImplicit 1)
"42"		#pushGlobal3					'Push global 2    %2g'							#(#pushGlobal 1 #globalImplicit 2)
"43"		#pushGlobal4					'Push global 3    %3g'							#(#pushGlobal 1 #globalImplicit 3)
"44"		#pushGlobal5					'Push global 4    %4g'							#(#pushGlobal 1 #globalImplicit 4)
"45"		#pushGlobal6					'Push global 5    %5g'							#(#pushGlobal 1 #globalImplicit 5)
"46"		#pushGlobal7					'Push global 6    %6g'							#(#pushGlobal 1 #globalImplicit 6)
"47"		#pushGlobal8					'Push global 7    %7g'							#(#pushGlobal 1 #globalImplicit 7)
"48"		#pushGlobal9					'Push global 8    %8g'							#(#pushGlobal 1 #globalImplicit 8)
"49"		#pushGlobal10					'Push global 9    %9g'							#(#pushGlobal 1 #globalImplicit 9)
"4A"		#pushGlobal11					'Push global 10    %10g'						#(#pushGlobal 1 #globalImplicit 10)
"4B"		#pushGlobal12					'Push global 11    %11g'						#(#pushGlobal 1 #globalImplicit 11)
"4C"		#pushGlobal13					'Push global 12    %12g'						#(#pushGlobal 1 #globalImplicit 12)
"4D"		#pushGlobal14					'Push global 13    %13g'						#(#pushGlobal 1 #globalImplicit 13)
"4E"		#pushGlobal15					'Push global 14    %14g'						#(#pushGlobal 1 #globalImplicit 14)
"4F"		#pushGlobal16					'Push global 15    %15g'						#(#pushGlobal 1 #globalImplicit 15)
"50"		#storeGlobal1					'Store global 0    %0g'							#(#storeGlobal 1 #globalImplicit 0)
"51"		#storeGlobal2					'Store global 1    %1g'							#(#storeGlobal 1 #globalImplicit 1)
"52"		#storeGlobal3					'Store global 2    %2g'							#(#storeGlobal 1 #globalImplicit 2)
"53"		#storeGlobal4					'Store global 3    %3g'							#(#storeGlobal 1 #globalImplicit 3)
"54"		#storeGlobal5					'Store global 4    %4g'							#(#storeGlobal 1 #globalImplicit 4)
"55"		#storeGlobal6					'Store global 5    %5g'							#(#storeGlobal 1 #globalImplicit 5)
"56"		#storeGlobal7					'Store global 6    %6g'							#(#storeGlobal 1 #globalImplicit 6)
"57"		#storeGlobal8					'Store global 7    %7g'							#(#storeGlobal 1 #globalImplicit 7)
"58"		#storeGlobal9					'Store global 8    %8g'							#(#storeGlobal 1 #globalImplicit 8)
"59"		#storeGlobal10					'Store global 9    %9g'							#(#storeGlobal 1 #globalImplicit 9)
"5A"		#storeGlobal11					'Store global 10    %10g'						#(#storeGlobal 1 #globalImplicit 10)
"5B"		#storeGlobal12					'Store global 11    %11g'						#(#storeGlobal 1 #globalImplicit 11)
"5C"		#storeGlobal13					'Store global 12    %12g'						#(#storeGlobal 1 #globalImplicit 12)
"5D"		#storeGlobal14					'Store global 13    %13g'						#(#storeGlobal 1 #globalImplicit 13)
"5E"		#storeGlobal15					'Store global 14    %14g'						#(#storeGlobal 1 #globalImplicit 14)
"5F"		#storeGlobal16					'Store global 15    %15g'						#(#storeGlobal 1 #globalImplicit 15)
"60"		#pushInteger1					'Push integer 1'								#(#pushInteger 1 #integerImplicit 1)
"61"		#pushInteger2					'Push integer 2'								#(#pushInteger 1 #integerImplicit 2)
"62"		#pushInteger3					'Push integer 3'								#(#pushInteger 1 #integerImplicit 3)
"63"		#pushInteger4					'Push integer 4'								#(#pushInteger 1 #integerImplicit 4)
"64"		#pushInteger5					'Push integer 5'								#(#pushInteger 1 #integerImplicit 5)
"65"		#pushInteger6					'Push integer 6'								#(#pushInteger 1 #integerImplicit 6)
"66"		#pushInteger7					'Push integer 7'								#(#pushInteger 1 #integerImplicit 7)
"67"		#pushInteger8					'Push integer 8'								#(#pushInteger 1 #integerImplicit 8)
"68"		#pushInteger9					'Push integer 9'								#(#pushInteger 1 #integerImplicit 9)
"69"		#pushInteger10					'Push integer 10'								#(#pushInteger 1 #integerImplicit 10)
"6A"		#pushInteger11					'Push integer 11'								#(#pushInteger 1 #integerImplicit 11)
"6B"		#pushInteger12					'Push integer 12'								#(#pushInteger 1 #integerImplicit 12)
"6C"		#pushInteger13					'Push integer 13'								#(#pushInteger 1 #integerImplicit 13)
"6D"		#pushInteger14					'Push integer 14'								#(#pushInteger 1 #integerImplicit 14)
"6E"		#pushInteger15					'Push integer 15'								#(#pushInteger 1 #integerImplicit 15)
"6F"		#pushInteger16					'Push integer 16'								#(#pushInteger 1 #integerImplicit 16)
"70"		#pushInteger0					'Push integer 0'								#(#pushInteger 1 #integerImplicit 0)
"71"		#'pushInteger-1'				'Push integer -1'								#(#pushInteger 1 #integerImplicit -1)
"72"		#'pushInteger-2'				'Push integer -2'								#(#pushInteger 1 #integerImplicit -2)
"73"		#'pushInteger-3'				'Push integer -3'								#(#pushInteger 1 #integerImplicit -3)
"74"		#'pushInteger-4'				'Push integer -4'								#(#pushInteger 1 #integerImplicit -4)
"75"		#'pushInteger-5'				'Push integer -5'								#(#pushInteger 1 #integerImplicit -5)
"76"		#'pushInteger-6'				'Push integer -6'								#(#pushInteger 1 #integerImplicit -6)
"77"		#'pushInteger-7'				'Push integer -7'								#(#pushInteger 1 #integerImplicit -7)
"78"		#'pushInteger-8'				'Push integer -8'								#(#pushInteger 1 #integerImplicit -8)
"79"		#'pushInteger-9'				'Push integer -9'								#(#pushInteger 1 #integerImplicit -9)
"7A"		#'pushInteger-10'				'Push integer -10'								#(#pushInteger 1 #integerImplicit -10)
"7B"		#'pushInteger-11'				'Push integer -11'								#(#pushInteger 1 #integerImplicit -11)
"7C"		#'pushInteger-12'				'Push integer -12'								#(#pushInteger 1 #integerImplicit -12)
"7D"		#'pushInteger-13'				'Push integer -13'								#(#pushInteger 1 #integerImplicit -13)
"7E"		#'pushInteger-14'				'Push integer -14'								#(#pushInteger 1 #integerImplicit -14)
"7F"		#'pushInteger-15'				'Push integer -15'								#(#pushInteger 1 #integerImplicit -15)
"80"		#pushLiteral1					'Push %0l'										#(#pushLiteral 1 #literalImplicit 0)
"81"		#pushLiteral2					'Push %1l'										#(#pushLiteral 1 #literalImplicit 1)
"82"		#pushLiteral3					'Push %2l'										#(#pushLiteral 1 #literalImplicit 2)
"83"		#pushLiteral4					'Push %3l'										#(#pushLiteral 1 #literalImplicit 3)
"84"		#pushLiteral5					'Push %4l'										#(#pushLiteral 1 #literalImplicit 4)
"85"		#pushLiteral6					'Push %5l'										#(#pushLiteral 1 #literalImplicit 5)
"86"		#pushLiteral7					'Push %6l'										#(#pushLiteral 1 #literalImplicit 6)
"87"		#pushLiteral8					'Push %7l'										#(#pushLiteral 1 #literalImplicit 7)
"88"		#pushLiteral9					'Push %8l'										#(#pushLiteral 1 #literalImplicit 8)
"89"		#pushLiteral10					'Push %9l'										#(#pushLiteral 1 #literalImplicit 9)
"8A"		#pushLiteral11					'Push %10l'										#(#pushLiteral 1 #literalImplicit 10)
"8B"		#pushLiteral12					'Push %11l'										#(#pushLiteral 1 #literalImplicit 11)
"8C"		#pushLiteral13					'Push %12l'										#(#pushLiteral 1 #literalImplicit 12)
"8D"		#pushLiteral14					'Push %13l'										#(#pushLiteral 1 #literalImplicit 13)
"8E"		#pushLiteral15					'Push %14l'										#(#pushLiteral 1 #literalImplicit 14)
"8F"		#pushLiteral16					'Push %15l'										#(#pushLiteral 1 #literalImplicit 15)
"90"		#pushTrue						'Push true'										#(pushTrue 1)
"91"		#pushFalse						'Push false'									#(pushFalse 1)
"92"		#pushNil						'Push nil'										#(pushNil 1)
"93"		#pushSelf						'Push self'										#(pushSelf 1)
"94"		#pushInstVar					'Push inst var %1ui'							#(pushInstVar 2 #instVarOneByte)
"95"		#pushInstVarExtended			'Push inst var %2ui'							#(pushInstVar 3 #instVarTwoBytes)
"96"		#pushLocal						'Push local %1ut'								#(pushLocal 2 #localOneByte)
"97"		#pushLocalExtended				'Push local %2ut'								#(pushLocal 3 #localTwoBytes)
"98"		#pushLocalIndirect				'Push local indirect %1uI %1uI'					#(pushLocalIndirect 3 #indirectLocalOneByte #indirectLocalVariableOneByte)
"99"		#pushLocalIndirectExtended		'Push Local Indirect %4L'						#(pushLocalIndirect 5 #indirectLocalTwoBytes #indirectLocalVariableTwoBytes)
"9A"		#pushGlobal						'Push global %1ug'								#(pushGlobal 2 #globalOneByte)
"9B"		#pushGlobalExtended				'Push global %2ug'								#(pushGlobal 3 #globalTwoBytes)
"9C"		#pushLiteral					'Push %1ul'										#(pushLiteral 2 #literalOneByte)
"9D"		#pushLiteralExtended			'Push %2ul'										#(pushLiteral 3 #literalTwoBytes)
"9E"		#pushOneByteInteger				'Push integer %1bI'								#(pushInteger 2 #integerOneByte)
"9F"		#pushTwoByteInteger				'Push integer %2bI'								#(pushInteger 3 #integerTwoBytes)
"A0"		#pushFourByteInteger			'Push integer %4bI'								#(pushInteger 5 #integerFourBytes)

"A1"		#pushCopyingBlock				'Push Copying Block %1ul %1uI'					#(pushCopyingBlock 3 #literalOneByte #unsignedOneByte)
"A2"		#pushFullBlock					'Push Full Block %1ul %1uI'						#(pushFullBlock 3 #literalOneByte #unsignedOneByte)

"A3"		#storeInstVar					'Store inst var %ui'							#(storeInstVar 2 #instVarOneByte)
"A4"		#storeInstVarExtended			'Store inst var %2ui'							#(storeInstVar 3 #instVarTwoBytes)
"A5"		#storeLocal						'Store local %ut'								#(storeLocal 2 #localOneByte)
"A6"		#storeLocalExtended				'Store local %u2t'								#(storeLocal 2 #localTwoBytes)
"A7"		#storeLocalIndirect				'Store Local Indirect local %1uI index %1uI'	#(storeLocalIndirect 3 #indirectLocalOneByte #unsignedOneByte)
"A8"		#storeLocalIndirectExtended		'Store Local Indirect %2uI %2uI'				#(storeLocalIndirect 5 #indirectLocalTwoBytes #unsignedTwoBytes)
"A9"		#storeGlobal					'Store global %ug'								#(storeGlobal 2 #globalOneByte)
"AA"		#storeGlobalExtended			'Store global %2ug'								#(storeGlobal 2 #globalTwoBytes)
"AB"		#storeNewArray					'Store New Array size %1uI local %1uI'			#(storeNewArray 3 #sizeOneByte #localOneByte)

"AC"		#pop							'Pop'											#(pop 1)
"AD"		#dup							'Dup'											#(dup 1)
"AE"		#dropCascadeReceiver			'Drop Cascade Receiver'							#(dropCascadeReceiver 1)
"AF"		#undefined						'' 									#(undefined 0)
"B0"		#jump							'Jump %bo'										#(jump 2 #offsetOneByte)
"B1"		#jumpExtended					'Jump %2bo'										#(jump 3 #offsetTwoBytes)
"B2"		#jumpIfTrue						'Jump if true %bo'								#(jumpIfTrue 2 #offsetOneByte)
"B3"		#jumpIfTrueExtended				'Jump if true %2bo'								#(jumpIfTrue 3 #offsetTwoBytes)
"B4"		#jumpIfFalse					'Jump if false %bo'								#(jumpIfFalse 2 #offsetOneByte)
"B5"		#jumpIfFalseExtended			'Jump if false %2bo'							#(jumpIfFalse 3 #offsetTwoBytes)
"B6"		#pushThisContext				'Push this context'								#(pushThisContext 1)
"B7"		#pushSelfInstvarIndirect			'Push self instvar indirect %1uI %1uI' 			#(pushSelfInstvarIndirect 3 #indirectLocalOneByte #indirectLocalVariableOneByte)
"B8"		#undefined						'' 									#(undefined 0)
"B9"		#storeSelfInstVarIndirect			'Store self instvar indirect %1uI %1uI' 			#(storeSelfInstvarIndirect 3 #indirectLocalOneByte #indirectLocalVariableOneByte)
"BA"		#undefined						'' 									#(undefined 0)
"BB"		#undefined						'' 									#(undefined 0)
"BC"		#undefined						'' 									#(undefined 0)
"BD"		#undefined						'' 									#(undefined 0)
"BE"		#undefined						'' 									#(undefined 0)
"BF"		#undefined						'' 									#(undefined 0)

"C0"		#callLiteral1					'Call %0l args %1bI'							#(#call 2 #literalImplicit 0 #argumentOneByte)
"C1"		#callLiteral2					'Call %1l args %1bI'							#(#call 2 #literalImplicit 1 #argumentOneByte)
"C2"		#callLiteral3					'Call %2l args %1bI'							#(#call 2 #literalImplicit 2 #argumentOneByte)
"C3"		#callLiteral4					'Call %3l args %1bI'							#(#call 2 #literalImplicit 3 #argumentOneByte)
"C4"		#callLiteral5					'Call %4l args %1bI'							#(#call 2 #literalImplicit 4 #argumentOneByte)
"C5"		#callLiteral6					'Call %5l args %1bI'							#(#call 2 #literalImplicit 5 #argumentOneByte)
"C6"		#callLiteral7					'Call %6l args %1bI'							#(#call 2 #literalImplicit 6 #argumentOneByte)
"C7"		#callLiteral8					'Call %7l args %1bI'							#(#call 2 #literalImplicit 7 #argumentOneByte)
"C8"		#callLiteral9					'Call %8l args %1bI'							#(#call 2 #literalImplicit 8 #argumentOneByte)
"C9"		#callLiteral10					'Call %9l args %1bI'							#(#call 2 #literalImplicit 9 #argumentOneByte)
"CA"		#callLiteral11					'Call %10l args %1bI'							#(#call 2 #literalImplicit 10 #argumentOneByte)
"CB"		#callLiteral12					'Call %11l args %1bI'							#(#call 2 #literalImplicit 11 #argumentOneByte)
"CC"		#callLiteral13					'Call %12l args %1bI'							#(#call 2 #literalImplicit 12 #argumentOneByte)
"CD"		#callLiteral14					'Call %13l args %1bI'							#(#call 2 #literalImplicit 13 #argumentOneByte)
"CE"		#callLiteral15					'Call %14l args %1bI'							#(#call 2 #literalImplicit 14 #argumentOneByte)
"CF"		#callLiteral16					'Call %15l args %1bI'							#(#call 2 #literalImplicit 15 #argumentOneByte)
"D0"		#superCallLiteral1				'Super call %0l args %1bI'						#(#super 2 #literalImplicit 0 #argumentOneByte)
"D1"		#superCallLiteral2				'Super call %1l args %1bI'						#(#super 2 #literalImplicit 1 #argumentOneByte)
"D2"		#superCallLiteral3				'Super call %2l args %1bI'						#(#super 2 #literalImplicit 2 #argumentOneByte)
"D3"		#superCallLiteral4				'Super call %3l args %1bI'						#(#super 2 #literalImplicit 3 #argumentOneByte)
"D4"		#superCallLiteral5				'Super call %4l args %1bI'						#(#super 2 #literalImplicit 4 #argumentOneByte)
"D5"		#superCallLiteral6				'Super call %5l args %1bI'						#(#super 2 #literalImplicit 5 #argumentOneByte)
"D6"		#callWellKnown					'Call well known %1bw'							#(callWellKnown 2 #oneByteWellKnown)
"D7"		#callLiteral					'Call %1ul args %1bI'							#(call 3 #literalOneByte #argumentOneByte)
"D8"		#callLiteralExtended			'Call literal %2ul args %1bI'					#(call 4 #literalTwoBytes #argumentOneByte)
"D9"		#callSuperLiteral				'Super call %ul args %1bI'						#(super 3 #literalOneByte #argumentOneByte)
"DA"		#superCallLiteralExtended		'Super call %2ul args %1bI'						#(super 4 #literalTwoBytes #argumentOneByte)
"DB"		#callPrimitive					'Primitive %2uI'								#(primitive 3 #unsignedTwoBytes)
"DC"		#return							'Return'										#(return 1)
"DD"		#blockReturn					'Block Return'									#(blockReturn 1)
"DE"		#nonLocalReturn					'Non local return' 								#(nonLocalReturn 1)
"DF"		#primitiveReturn				'Primitive Return'								#(primitiveReturn 1)

"E0"		#callLiteralBreak1				'Call with break %0l args %1bI'					#(#call 2 #literalImplicit 0 #argumentOneByte)
"E1"		#callLiteralBreak2				'Call with break %1l args %1bI'					#(#call 2 #literalImplicit 1 #argumentOneByte)
"E2"		#callLiteralBreak3				'Call with break %2l args %1bI'					#(#call 2 #literalImplicit 2 #argumentOneByte)
"E3"		#callLiteralBreak4				'Call with break %3l args %1bI'					#(#call 2 #literalImplicit 3 #argumentOneByte)
"E4"		#callLiteralBreak5				'Call with break %4l args %1bI'					#(#call 2 #literalImplicit 4 #argumentOneByte)
"E5"		#callLiteralBreak6				'Call with break %5l args %1bI'					#(#call 2 #literalImplicit 5 #argumentOneByte)
"E6"		#callLiteralBreak7				'Call with break %6l args %1bI'					#(#call 2 #literalImplicit 6 #argumentOneByte)
"E7"		#callLiteralBreak8				'Call with break %7l args %1bI'					#(#call 2 #literalImplicit 7 #argumentOneByte)
"E8"		#callLiteralBreak9				'Call with break %8l args %1bI'					#(#call 2 #literalImplicit 8 #argumentOneByte)
"E9"		#callLiteralBreak10				'Call with break %9l args %1bI'					#(#call 2 #literalImplicit 9 #argumentOneByte)
"EA"		#callLiteralBreak11				'Call with break %10l args %1bI'				#(#call 2 #literalImplicit 10 #argumentOneByte)
"EB"		#callLiteralBreak12				'Call with break %11l args %1bI'				#(#call 2 #literalImplicit 11 #argumentOneByte)
"EC"		#callLiteralBreak13				'Call with break %12l args %1bI'				#(#call 2 #literalImplicit 12 #argumentOneByte)
"ED"		#callLiteralBreak14				'Call with break %13l args %1bI'				#(#call 2 #literalImplicit 13 #argumentOneByte)
"EE"		#callLiteralBreak15				'Call with break %14l args %1bI'				#(#call 2 #literalImplicit 14 #argumentOneByte)
"EF"		#callLiteralBreak16				'Call with break %15l args %1bI'				#(#call 2 #literalImplicit 15 #argumentOneByte)
"F0"		#superCallLiteralBreak1			'Super call with break %0l args %1bI'			#(#super 2 #literalImplicit 0 #argumentOneByte)
"F1"		#superCallLiteralBreak2			'Super call with break %1l args %1bI'			#(#super 2 #literalImplicit 1 #argumentOneByte)
"F2"		#superCallLiteralBreak3			'Super call with break %2l args %1bI'			#(#super 2 #literalImplicit 2 #argumentOneByte)
"F3"		#superCallLiteralBreak4			'Super call with break %3l args %1bI'			#(#super 2 #literalImplicit 3 #argumentOneByte)
"F4"		#superCallLiteralBreak5			'Super call with break %4l args %1bI'			#(#super 2 #literalImplicit 4 #argumentOneByte)
"F5"		#superCallLiteralBreak6			'Super call with break %5l args %1bI'			#(#super 2 #literalImplicit 5 #argumentOneByte)
"F6"		#callWellKnownBreak				'Call well known with break %1bw'				#(callWellKnown 2 #oneByteWellKnown)
"F7"		#callLiteralBreak				'Call with break %1ul args %1bI'				#(call 3 #literalOneByte #argumentOneByte)
"F8"		#callLiteralExtendedBreak		'Call literal with break %2ul args %1bI'		#(call 4 #literalTwoBytes #argumentOneByte)
"F9"		#callSuperLiteralBreak			'Super call with break %ul args %1bI'			#(super 3 #literalOneByte #argumentOneByte)
"FA"		#superCallLiteralExtendedBreak	'Super call with break %2ul args %1bI'			#(super 4 #literalTwoBytes #argumentOneByte)
"FB"		#callPrimitiveBreak				'Primitive with break %2uI'						#(primitive 3 #unsignedTwoBytes)
"FC"		#returnBreak					'Return with break'								#(return 1)
"FD"		#blockReturnBreak				'Block Return with break'						#(blockReturn 1)
"FE"		#nonLocalReturnBreak			'Non local return with break' 					#(nonLocalReturn 1)
"FF"		#primitiveReturnBreak			'Primitive Return with break'					#(primitiveReturn 1)
	)! !

! CodeGenerator class methodsFor: 'instance creation' !
new

	^super new initialize! !

! CodeGenerator class methodsFor: 'instance creation' !
specialSelectors

	^#(
"00"		+
"01"		-
"02"		*
"03"		not
"04"		==
"05"		~~
"06"		=
"07"		~=
"08"		isNil
"09"		notNil
"0A"		>
"0B"		<
"0C"		>=
"0D"		<=
"0E"		evaluate:
"0F"		printString
"10"		raiseSignal
"11"		perform:withArguments:
"12"		primitiveHalt
"13"		debugIt:
"14"		evaluateJsonString:
)! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
numArgs

	^self rootNode header selector numArgs! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
numTempsOnly

	^self localsNeededFor: self rootNode! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
rootNode

	^rootNode! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
rootNode: anObject

	rootNode := anObject! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopeStack

	^scopeStack! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopeStack: anObject

	scopeStack := anObject! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopes

	^scopes! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopes: anObject

	scopes := anObject! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'initialize-release' !
initialize

	scopes := Dictionary new.
	scopeStack := OrderedCollection new.! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
argumentsFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope arguments! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
copiedVariablesFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope copiedVariables! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
findVariableDefinition: aVariable

	^self scopes detect: [:eachScope | eachScope definesVariable: aVariable]! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
localsNeededFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope localsNeeded! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
localsToCopyFor: aNode! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
scopeFor: aNode

	^self scopes at: aNode! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
temporariesFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope temporaryVariables! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
variableNumberOf: aVariable! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
variableNumberOf: aVariable inNode: aNode

	^(self scopeFor: aNode) variableNumberOf: aVariable! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
declareSelf

	| scope variable |

	variable := SelfVariable new.
	scope := self findVariableDefinition: variable.
	scope = scopeStack last
		ifFalse: [scopeStack last addCopiedVariable: variable]! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
endBlockNode: aNode

	self scopeStack removeLast! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
startBlockNode: aNode

	self scopeStack add: (ScopeAnalysisResult new 
		parent: self scopeStack last;
		node: aNode;
		yourself).
	self scopes at: aNode put: self scopeStack last! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBinaryHeader: aNode

	self scopeStack last addArgument: aNode argument! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBlockLiteralNode: aNode

	self startBlockNode: aNode.
	aNode acceptVisitor: self.
	self endBlockNode: aNode! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBlockNode: aNode

	(aNode statements isNil or: [aNode statements statements isEmpty]) ifTrue: [
		self declareSelf]! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBlockParameterListNode: aNode

	aNode variables do: [:eachVariable | self scopeStack last addArgument: eachVariable]! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitInstanceVariableAssignmentNode: aNode

	self declareSelf.
	super visitInstanceVariableAssignmentNode: aNode.! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitInstanceVariableReferenceNode: aNode

	self declareSelf! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitKeywordHeader: aNode

	aNode arguments do: [:eachArgument |
		self scopeStack last addArgument: eachArgument]! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitLocalVariableAssignmentNode: aNode

	| variable scope |

	aNode value acceptVisitor: self.
	variable := aNode variable.
	variable isArgument ifTrue: [
		^self error: 'Can''t assign to an argument'].

	scope := self findVariableDefinition: variable.
	scope = scopeStack last ifFalse: [
		scopeStack last makeIndirect: variable inScope: scope]! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitLocalVariableReferenceNode: aNode

	| variable scope |

	variable := aNode variable.

	scope := self findVariableDefinition: variable.
	scope = scopeStack last ifTrue: [^self].
	
	variable isArgument
		ifTrue: [^scopeStack last addCopiedVariable: variable].

	scopeStack last makeIndirect: variable inScope: scope! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitMethodNodeStart: aNode

	self scopeStack add: (ScopeAnalysisResult new node: aNode; yourself).
	self scopes at: aNode put: self scopeStack last.
	self rootNode: aNode! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitReturnNode: aNode

	self scopeStack size = 1 ifTrue: [^self].
	self scopeStack last markReturns! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitSpecialNode: aNode

	| specialName |

	specialName := aNode special.
	(specialName = 'self' or: [specialName = 'super']) ifFalse: [^self].

	self declareSelf! !

! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitStatementListStart: aNode

	aNode variables do: [:eachVariable |
		self scopeStack last addTemporaryVariable: eachVariable]! !

! Parser methodsFor: 'accessing' !
currentRule

	^currentRule! !

! Parser methodsFor: 'accessing' !
currentRule: anObject

	currentRule := anObject! !

! Parser methodsFor: 'accessing' !
errorMessage

	^self currentRule errorString! !

! Parser methodsFor: 'accessing' !
result

	^self currentRule result! !

! Parser methodsFor: 'error handling' !
commitAndFailWithMessage: aString if: aBlock

	self currentRule commitAndFailWithMessage: aString if: aBlock! !

! Parser methodsFor: 'error handling' !
commitWithMessage: aString if: aBlock

	self currentRule commitWithMessage: aString if: aBlock! !

! Parser methodsFor: 'helping' !
oneOf: aBlock

	self currentRule choice: [
		self
			rule: OneOfParserRule new;
			process: aBlock]! !

! Parser methodsFor: 'helping' !
oneOrMore: aBlock

	self currentRule choice: [
		self
			rule: OneOrMoreParserRule new;
			process: aBlock]! !

! Parser methodsFor: 'helping' !
optional: aBlock

	self currentRule choice: [
		self
			rule: OptionalParserRule new;
			process: aBlock]! !

! Parser methodsFor: 'helping' !
parse: aBlock

	self currentRule parse: aBlock! !

! Parser methodsFor: 'helping' !
produce: aBlock

	self currentRule produceBlock: aBlock! !

! Parser methodsFor: 'helping' !
sequence: aBlock

	self currentRule choice: [
		self
			rule: SequenceParserRule new;
			process: aBlock]! !

! Parser methodsFor: 'helping' !
token: aClass

	self currentRule choice: [
		self rule: (TokenRule new
			tokenStream: self currentRule tokenStream;
			yourself).
		self currentRule token: aClass]! !

! Parser methodsFor: 'helping' !
token: aClass produce: aBlock

	self currentRule choice: [
		self rule: (TokenRule new produceBlock: aBlock; yourself).
		self currentRule token: aClass]! !

! Parser methodsFor: 'helping' !
zeroOrMore: aBlock

	self currentRule choice: [
		self
			rule: ZeroOrMoreParserRule new;
			process: aBlock]! !

! Parser methodsFor: 'rules' !
fail

	self currentRule parentRule isNil ifTrue: [^self].

	self currentRule parentRule fail: self currentRule.
	self currentRule: self currentRule parentRule! !

! Parser methodsFor: 'rules' !
initialRule: aHelper

	aHelper parser: self.
		
	self currentRule: aHelper! !

! Parser methodsFor: 'rules' !
pass

	self currentRule parentRule pass: self currentRule.
	self currentRule: self currentRule parentRule! !

! Parser methodsFor: 'rules' !
process: aBlock

	self currentRule process: aBlock! !

! Parser methodsFor: 'rules' !
rule: aRule

	aRule
		parser: self;
		parentRule: self currentRule;
		tokenStream: (self currentRule tokenStream) copy.

	self currentRule: aRule! !

! Parser methodsFor: 'setup' !
tokens: anArray

	self initialRule: (RootRule new
		tokenStream: anArray readStream;
		yourself)! !

! Parser methodsFor: 'testing' !
atEnd

	^self currentRule tokenStream atEnd! !

! Parser methodsFor: 'testing' !
isFinished

	^self atEnd and: [self isRootRule]! !

! Parser methodsFor: 'testing' !
isRootRule

	^self currentRule isMemberOf: RootRule! !

! JSONParser methodsFor: 'parsing' !
parseArray
	"array ::= OPENSQUAREBRACKET objectSequence CLOSESQUAREBRACKET"

	self sequence: 
			[self
				token: OpenSquareBracketToken;
				zeroOrMore: [self parse: [self parseObjectSequence]];
				token: CloseSquareBracketToken;
				produce: [:rule | (rule sequence at: 2) sequence first asArray]]! !

! JSONParser methodsFor: 'parsing' !
parseDictionary
	"dictionary ::= OPENBRACE keyValueSequence CLOSEBRACE"

	self sequence: 
			[self
				token: OpenBraceToken;
				parse: [self parseOptionalKeyValueSequence];
				token: CloseBraceToken;
				produce: [:rule |
					| dictionary |
					dictionary := Dictionary new.
					(rule sequence at: 2) do: [:assoc | dictionary at: assoc key put: assoc value].
					dictionary]]! !

! JSONParser methodsFor: 'parsing' !
parseKeyValuePair
	"keyValuePair ::= STRING COLON object"

	self sequence: 
			[self
				token: StringToken;
				token: ColonToken;
				parse: [self parseObject];
				produce: [:rule | rule sequence first token value -> (rule sequence at: 3)]]! !

! JSONParser methodsFor: 'parsing' !
parseKeyValueSequence
	"keyValuePair (COMMA keyValuePair)*"

	self sequence: 
			[self
				parse: [self parseKeyValuePair];
				optional: [
					self sequence: [
						self token: CommaToken;
						parse: [self parseKeyValueSequence]]];
				produce: [:rule |
					rule sequence size = 1
						ifTrue: [rule sequence]
						ifFalse: [((rule sequence at: 2) sequence at: 2) addFirst: rule sequence first; yourself]]]! !

! JSONParser methodsFor: 'parsing' !
parseObject
	"object ::= primitiveObject | array | dictionary"

	self oneOf: 
			[self
				parse: [self parsePrimitiveObject];
				parse: [self parseArray];
				parse: [self parseDictionary];
				produce: [:rule | rule result]]! !

! JSONParser methodsFor: 'parsing' !
parseObjectSequence
	"objectSequence ::= object (COMMA object)*"

	self sequence: 
			[self
				parseObject;
				optional: [
					self sequence: [
						self token: CommaToken;
							parse: [self parseObjectSequence]]];
				produce: [:rule |
					rule sequence size = 1
						ifTrue: [rule sequence]
						ifFalse: [((rule sequence at: 2) sequence at: 2) addFirst: rule sequence first; yourself]]]! !

! JSONParser methodsFor: 'parsing' !
parseOptionalKeyValueSequence
	"parseKeyValueSequence?"

	self
		optional: [self parseKeyValueSequence];
		produce: [:rule | rule result]! !

! JSONParser methodsFor: 'parsing' !
parsePrimitiveObject
	"primitiveObject ::= special | integer | float | string"

	self oneOf: 
			[self
				token: SpecialWordToken;
				token: IntegerToken;
				token: FloatToken;
				token: StringToken;
				produce: [:rule | rule result token value]]! !

! JSONParser class methodsFor: 'evaluating' !
evaluate: aCollection

	^JSONEvaluator new evaluate: aCollection! !

! JSONParser class methodsFor: 'evaluating' !
evaluate: aCollection inSession: aSession

	^JSONEvaluator new
		webSession: aSession;
		evaluate: aCollection! !

! JSONParser class methodsFor: 'evaluating' !
evaluateJsonString: aString

	^self evaluate: (self parseString: aString)! !

! JSONParser class methodsFor: 'instance creation' !
parseString: aString
	^(self new
		tokens: (JSONLexicalAnalyzer on: aString readStream) tokens;
		parseObject) result! !

! ParserRule methodsFor: 'accessing' !
errorString

	^errorString! !

! ParserRule methodsFor: 'accessing' !
errorString: anObject

	errorString := anObject! !

! ParserRule methodsFor: 'accessing' !
parentRule

	^parentRule! !

! ParserRule methodsFor: 'accessing' !
parentRule: anObject

	parentRule := anObject! !

! ParserRule methodsFor: 'accessing' !
parser

	^parser! !

! ParserRule methodsFor: 'accessing' !
parser: anObject

	parser := anObject! !

! ParserRule methodsFor: 'accessing' !
produceBlock

	^produceBlock! !

! ParserRule methodsFor: 'accessing' !
produceBlock: anObject

	produceBlock := anObject! !

! ParserRule methodsFor: 'accessing' !
result

	^result! !

! ParserRule methodsFor: 'accessing' !
result: anObject

	result := anObject! !

! ParserRule methodsFor: 'accessing' !
tokenStream

	^tokenStream! !

! ParserRule methodsFor: 'accessing' !
tokenStream: anObject

	tokenStream := anObject! !

! ParserRule methodsFor: 'error handling' !
commitAndFailWithMessage: aString if: aBlock

	(aBlock value: self) ifTrue: [
		| start end affectedToken |
		start := end := 0.
		affectedToken := tokenStream peek ifNil: [tokenStream previous].

		(affectedToken notNil and: [affectedToken startSourceOffset notNil]) ifTrue: [
			start := affectedToken startSourceOffset].

		(affectedToken notNil and: [affectedToken endSourceOffset notNil]) ifTrue: [
			end := affectedToken endSourceOffset].

		CompileError new
			startSourceOffset: start;
			endSourceOffset: end;			
			message: (aString copyReplaceAll: '%t' with: affectedToken value asString);
			raiseSignal.

		self fail: self] ! !

! ParserRule methodsFor: 'error handling' !
commitWithMessage: aString if: aBlock

	| affectedToken start end |

	start := end := 0.
	affectedToken := tokenStream previous ifNil: [tokenStream peek].

	(affectedToken notNil and: [affectedToken startSourceOffset notNil]) ifTrue: [
		start := affectedToken startSourceOffset].

	(affectedToken notNil and: [affectedToken endSourceOffset notNil]) ifTrue: [
		end := affectedToken endSourceOffset].

	(aBlock value: self) ifTrue: [self errorString: (CompileError new
		message: aString;
		startSourceOffset: start;
		endSourceOffset: end;
		yourself)] ! !

! ParserRule methodsFor: 'pass and fail' !
fail

	self parser fail! !

! ParserRule methodsFor: 'pass and fail' !
fail: aRule

	aRule errorString notNil ifTrue: [
		self errorString: aRule errorString]! !

! ParserRule methodsFor: 'pass and fail' !
pass

	self produceBlock ifNotNil: [:block | self result: (block value: self)].
	self parser pass! !

! ParserRule methodsFor: 'pass and fail' !
pass: aRule! !

! ParserRule methodsFor: 'processing' !
choice: aBlock

	aBlock value! !

! ParserRule methodsFor: 'processing' !
parse: aBlock

	self choice: aBlock! !

! ParserRule methodsFor: 'processing' !
produce: aBlock

	self result notNil ifTrue: [self result: aBlock value]! !

! ParserRule methodsFor: 'rules' !
finished

	self errorString notNil ifTrue: [^self fail].! !

! ParserRule methodsFor: 'rules' !
process: aBlock

	aBlock value.
	self finished! !

! OneOfParserRule methodsFor: 'pass and fail' !
pass: aRule

	self
		result: aRule result;
		tokenStream: aRule tokenStream! !

! OneOfParserRule methodsFor: 'processing' !
choice: aBlock

	self result isNil ifTrue: [aBlock value]! !

! OneOfParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self result isNil
		ifTrue: [self fail]
		ifFalse: [self pass]! !

! OneOrMoreParserRule methodsFor: 'accessing' !
nodes

	^nodes! !

! OneOrMoreParserRule methodsFor: 'accessing' !
nodes: anObject

	nodes := anObject! !

! OneOrMoreParserRule methodsFor: 'accessing' !
passed

	^passed! !

! OneOrMoreParserRule methodsFor: 'accessing' !
passed: anObject

	passed := anObject! !

! OneOrMoreParserRule methodsFor: 'initialize-release' !
initialize

	self nodes: OrderedCollection new! !

! OneOrMoreParserRule methodsFor: 'pass and fail' !
fail: aRule

	self passed: false.
	super fail: aRule! !

! OneOrMoreParserRule methodsFor: 'pass and fail' !
pass: aRule

	aRule result ifNotNil: [self nodes add: aRule result].
	self passed: true.
	self tokenStream: aRule tokenStream! !

! OneOrMoreParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self result: (SequenceNode sequence: self nodes).
	self nodes size >= 1
		ifTrue: [self pass]
		ifFalse: [self fail]! !

! OneOrMoreParserRule methodsFor: 'rules' !
process: aBlock

	[aBlock value. self passed] whileTrue: [].
	self finished! !

! OneOrMoreParserRule class methodsFor: 'instance creation' !
new

	^super new initialize! !

! OptionalParserRule methodsFor: 'pass and fail' !
pass: aRule

	self
		result: aRule result;
		tokenStream: aRule tokenStream! !

! OptionalParserRule methodsFor: 'processing' !
choice: aBlock

	self result isNil ifTrue: [aBlock value]! !

! OptionalParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self pass! !

! ParseMethodRule methodsFor: 'pass and fail' !
pass

	self parser pass! !

! PragmaNode methodsFor: 'accessing' !
arguments

	^arguments! !

! PragmaNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject! !

! PragmaNode methodsFor: 'accessing' !
selector

	^selector! !

! PragmaNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! PragmaNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitPragma: self! !

! PragmaNode class methodsFor: 'instance creation' !
selector: selector arguments: arguments

	^self new
		selector: selector;
		arguments: arguments;
		yourself! !

! ReturnNode methodsFor: 'accessing' !
returnLevel

	^returnLevel! !

! ReturnNode methodsFor: 'accessing' !
returnLevel: anObject

	returnLevel := anObject! !

! ReturnNode methodsFor: 'accessing' !
value

	^value! !

! ReturnNode methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! ReturnNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self value acceptVisitor: anObject.
	anObject visitReturnNode: self! !

! ReturnNode class methodsFor: 'instance creation' !
value: anObject

	^self new
		value: anObject;
		yourself! !

! RootRule methodsFor: 'pass and fail' !
pass

	self parser pass! !

! RootRule methodsFor: 'pass and fail' !
pass: aRule

	result := aRule result.
	self tokenStream: aRule tokenStream! !

! Scope methodsFor: 'accessing' !
addVariable: aVariable

	self variables add: aVariable.
	aVariable scope: self! !

! Scope methodsFor: 'accessing' !
addVariables: aCollection

	aCollection do: [:eachVariable | self addVariable: eachVariable]! !

! Scope methodsFor: 'accessing' !
childScopes

	^childScopes! !

! Scope methodsFor: 'accessing' !
childScopes: anObject

	childScopes := anObject! !

! Scope methodsFor: 'accessing' !
parentScope

	^parentScope! !

! Scope methodsFor: 'accessing' !
parentScope: anObject

	parentScope := anObject! !

! Scope methodsFor: 'accessing' !
scopeNumber

	^scopeNumber! !

! Scope methodsFor: 'accessing' !
scopeNumber: anObject

	scopeNumber := anObject! !

! Scope methodsFor: 'accessing' !
variableNamed: aString

	| symbol |

	symbol := aString asSymbol.
	^self variables detect: [:each | each variableName = symbol] ifNone: [nil]! !

! Scope methodsFor: 'accessing' !
variableNumber: aVariable

	^self variables indexOf: aVariable! !

! Scope methodsFor: 'accessing' !
variables

	^variables! !

! Scope methodsFor: 'accessing' !
variables: anObject

	variables := anObject! !

! Scope methodsFor: 'adding' !
addScope: aScope

	self childScopes add: aScope.
	aScope parentScope: self! !

! Scope methodsFor: 'initialize-release' !
initialize

	variables := OrderedCollection new.
	childScopes := OrderedCollection new! !

! Scope class methodsFor: 'instance creation' !
new

	^super new initialize! !

! ScopeAnalysisResult methodsFor: 'accessing' !
allLocals

	^self arguments, self copiedVariables, self temporaryVariables! !

! ScopeAnalysisResult methodsFor: 'accessing' !
arguments

	^arguments! !

! ScopeAnalysisResult methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
children

	^children! !

! ScopeAnalysisResult methodsFor: 'accessing' !
children: anObject

	children := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
copiedVariables

	^copiedVariables! !

! ScopeAnalysisResult methodsFor: 'accessing' !
copiedVariables: anObject

	copiedVariables := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
hasReturn

	^hasReturn! !

! ScopeAnalysisResult methodsFor: 'accessing' !
hasReturn: anObject

	hasReturn := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
indirectVariables

	^indirectVariables! !

! ScopeAnalysisResult methodsFor: 'accessing' !
indirectVariables: anObject

	indirectVariables := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
localVariableNames

	^self localVariables asArray collect: [:eachVariable |
		eachVariable isIndirectVariableList
			ifTrue: [eachVariable variables asArray collect: [:eachIndirectVariable | eachIndirectVariable variableName]]
			ifFalse: [eachVariable variableName]]! !

! ScopeAnalysisResult methodsFor: 'accessing' !
localVariables

	^self arguments, self copiedVariables, self temporaryVariables! !

! ScopeAnalysisResult methodsFor: 'accessing' !
node

	^node! !

! ScopeAnalysisResult methodsFor: 'accessing' !
node: anObject

	node := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
numberOfArguments

	^self arguments size! !

! ScopeAnalysisResult methodsFor: 'accessing' !
parent

	^parent! !

! ScopeAnalysisResult methodsFor: 'accessing' !
parent: anObject

	parent := anObject! !

! ScopeAnalysisResult methodsFor: 'accessing' !
temporaryVariables

	^temporaryVariables! !

! ScopeAnalysisResult methodsFor: 'accessing' !
temporaryVariables: anObject

	temporaryVariables := anObject! !

! ScopeAnalysisResult methodsFor: 'adding' !
addArgument: aVariable

	(self arguments includes: aVariable) ifTrue: [^self].
	self arguments add: aVariable.! !

! ScopeAnalysisResult methodsFor: 'adding' !
addCopiedVariable: aVariable

	(self localVariables includes: aVariable) ifTrue: [^self].
	self parent isNil ifTrue: [^self].

	self parent addCopiedVariable: aVariable.

	self copiedVariables add: aVariable! !

! ScopeAnalysisResult methodsFor: 'adding' !
addTemporaryVariable: aVariable

	self temporaryVariables add: aVariable! !

! ScopeAnalysisResult methodsFor: 'initialize-release' !
initialize

	temporaryVariables := OrderedCollection new.
	copiedVariables := OrderedCollection new.
	indirectVariables := IndirectVariableList new.
	arguments := OrderedCollection new.
	hasReturn := false! !

! ScopeAnalysisResult methodsFor: 'testing' !
definesVariable: aVariable

	(self parent isNil and: [aVariable isSelf]) ifTrue: [^true].

	aVariable isIndirectList ifTrue: [^self indirectVariables == aVariable].

	(self temporaryVariables includes: aVariable) ifTrue: [^true].
	(self arguments includes: aVariable) ifTrue: [^true].
	(self indirectVariables variables includes: aVariable) ifTrue: [^true].
	(self copiedVariables includes: aVariable) ifTrue: [^true].
	^false! !

! ScopeAnalysisResult methodsFor: 'testing' !
variableNumberOf: aVariable

	self localVariables keysAndValuesDo: [:index :eachVariable |
		eachVariable == aVariable ifTrue: [^index].
		eachVariable isIndirectList
			ifTrue: [
				| indexInIndirect |
				indexInIndirect := eachVariable variables indexOf: aVariable.
				indexInIndirect > 0 ifTrue: [^Array with: index with: indexInIndirect] ] ].
		^0! !

! ScopeAnalysisResult methodsFor: 'utility' !
localsNeeded

	^self temporaryVariables size! !

! ScopeAnalysisResult methodsFor: 'utility' !
makeIndirect: aVariable inScope: aScope

	(self indirectVariables variables includes: aVariable) ifTrue: [^self].
	(self temporaryVariables includes: aVariable) ifTrue: [
		self temporaryVariables remove: aVariable.
		self indirectVariables variables add: aVariable.
		(self temporaryVariables includes: self indirectVariables) ifFalse: [
			self temporaryVariables add: self indirectVariables].
		^aVariable indirect: true].

	aVariable isSelf ifTrue: [
		^self addCopiedVariable: aVariable].

	self parent makeIndirect: aVariable inScope: aScope.
	self addCopiedVariable: aScope indirectVariables.! !

! ScopeAnalysisResult methodsFor: 'utility' !
markReturns

	self hasReturn: true.
	self parent notNil ifTrue: [
		self parent markReturns].! !

! ScopeAnalysisResult class methodsFor: 'instance creation' !
new

	^super new initialize! !

! SequenceNode methodsFor: 'accessing' !
sequence

	^sequence! !

! SequenceNode methodsFor: 'accessing' !
sequence: anObject

	sequence := anObject! !

! SequenceNode methodsFor: 'testing' !
isSequence

	^true! !

! SequenceNode class methodsFor: 'instance creation' !
sequence: aCollection

	^self new
		sequence: aCollection;
		yourself! !

! SequenceParserRule methodsFor: 'accessing' !
errorString: aString

	errorString := aString! !

! SequenceParserRule methodsFor: 'accessing' !
rulesRun

	^rulesRun! !

! SequenceParserRule methodsFor: 'accessing' !
rulesRun: anObject

	rulesRun := anObject! !

! SequenceParserRule methodsFor: 'accessing' !
sequence

	^sequence! !

! SequenceParserRule methodsFor: 'accessing' !
sequence: anObject

	sequence := anObject! !

! SequenceParserRule methodsFor: 'initialize-release' !
initialize

	allPassed := true.
	sequence := OrderedCollection new.
	rulesRun := 0! !

! SequenceParserRule methodsFor: 'pass and fail' !
fail: aRule

	allPassed := false.
	super fail: aRule! !

! SequenceParserRule methodsFor: 'pass and fail' !
pass: aRule

	aRule result ifNotNil: [sequence add: aRule result].
	self tokenStream: aRule tokenStream! !

! SequenceParserRule methodsFor: 'pass and fail' !
tokensToExpect
	^#(#PeriodToken #CloseParenthesisToken #CloseSquareBracketToken) ,
					(self parser tokensToExpect isEmpty ifTrue: [#()] ifFalse: [Array with: self parser tokensToExpect last])! !

! SequenceParserRule methodsFor: 'processing' !
choice: aBlock

	rulesRun := rulesRun + 1.
	allPassed ifFalse: [^self].
	aBlock value! !

! SequenceParserRule methodsFor: 'processing' !
finished

	self result: (SequenceNode sequence: sequence).
	allPassed
		ifTrue: [
			errorString := nil.
			self pass]
		ifFalse: [self fail]! !

! SequenceParserRule methodsFor: 'processing' !
parse: aBlock

	allPassed ifTrue: [self choice: aBlock]! !

! SequenceParserRule methodsFor: 'testing' !
allPassedSoFar

	^self sequence size = self rulesRun! !

! SequenceParserRule methodsFor: 'testing' !
lastZeroOrMoreProducedResult

	^self sequence notEmpty
			and: [self sequence last sequence notEmpty]! !

! SequenceParserRule class methodsFor: 'instance creation' !
new

	^super new initialize! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
binaryCharacters

	^'~`@%&*-+=|\?,/<>'! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
nextToken

	self skipSeparators.
	self next = self finishedCharacter ifTrue: [^nil].
	self next isAlphabetic | (self next = $_) ifTrue: [^self parseWord].
	self next = $( ifTrue: [^self parseOpenParenthesis].
	self next = $) ifTrue: [^self parseCloseParenthesis].
	self next = $[ ifTrue: [^self parseOpenSquareBracket].
	self next = $] ifTrue: [^self parseCloseSquareBracket].
	(self next = $: and: [self next2 isAlphabetic])
		ifTrue: [^self parseBlockArgument].
	(self next = $: and: [self next2 = $=]) ifTrue: [^self parseAssignment].
	(self next isDigit or: [self next = $- and: [self next2 isDigit]])
		ifTrue: [^self parseNumber].
	self next = $$ ifTrue: [^self parseCharacterLiteral].
	self next = $' ifTrue: [^self parseStringLiteral].
	(self next = $# and: [self next2 isAlphabetic or: [self next2 = $_]])
		ifTrue: [^self parseSymbolLiteral].
	(self next = $# and: [self binaryCharacters includes: self next2])
		ifTrue: [^self parseBinarySymbolLiteral].
	(self next = $# and: [self next2 = $'])
		ifTrue: [^self parseQuotedSymbolLiteral].
	(self next = $# and: [self next2 = $(]) ifTrue: [^self parseArrayLiteral].
	(self next = $# and: [self next2 = $[])
		ifTrue: [^self parseByteArrayLiteral].
	(self next = $| and: [(self binaryCharacters includes: self next2) not])
		ifTrue: [^self parseBar].
	(self next = $< and: [(self binaryCharacters includes: self next2) not])
		ifTrue: [^self parseLeftAngle].
	(self next = $> and: [(self binaryCharacters includes: self next2) not])
		ifTrue: [^self parseRightAngle].
	(self binaryCharacters includes: self next) ifTrue: [^self parseBinary].
	self next = $. ifTrue: [^self parsePeriod].
	self next = $; ifTrue: [^self parseSemicolon].
	self next = $^ ifTrue: [^self parseReturn].
	self log: 'Unknown token - ' , self next printString.
	self log: 'Parsed tokens: ' , tokens asArray printString.
	self log: 'Next: ' , (stream nextAvailable: 200).
	^self reportError: 'Unknown token' start: self position end: self position! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseArrayLiteral

	| elements |
	^self captureOffsetsIn: 
			[
			| startOffset |
			startOffset := self startSourceOffset + 1.
			self
				advance;
				advance.
			elements := self readArrayLiteralElements.
			self next = $)
				ifFalse: 
					[^self reportError: 'Missing end parenthesis' start: startOffset end: startOffset].
			self advance]
		creating: [ArrayLiteralToken new value: elements asArray] ! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseAssignment

	^self captureOffsetsIn: 
			[self
				advance;
				advance]
		creating: [AssignToken new value: ':=']! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBar

	^self captureOffsetsIn: [self advance] creating: [BarToken new value: #|]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBinary

	| binary |
	^self captureOffsetsIn: [binary := self readBinary]
		creating: [BinaryToken new value: binary asSymbol]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBinarySymbolLiteral

	| binary |
	^self captureOffsetsIn: 
			[self advance.
			binary := self readBinary]
		creating: [SymbolToken new value: binary asSymbol]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBlockArgument

	| word |
	^self captureOffsetsIn: 
			[self advance.
			word := self readAlphaNumericWord]
		creating: [BlockArgumentToken new value: word]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseByteArrayLiteral

	| elements |
	^self captureOffsetsIn: [
			| startOffset |
			startOffset := self startSourceOffset + 1.
			self
				advance;
				advance.
			elements := self readByteArrayLiteralElements.
			self next = $]
				ifFalse: 
					[^self reportError: 'Missing end square bracket' start: startOffset  end: startOffset ].
			self advance]
		creating: [ByteArrayLiteralToken new value: (ByteArray withAll: elements)]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseCharacterLiteral

	| character |
	^self captureOffsetsIn: 
			[self advance.
			self next = self finishedCharacter
				ifTrue: 
					[^self reportError: 'Expected a character' start: self startSourceOffset end: self position].
			character := self next.
			self advance]
		creating: [CharacterToken new value: character]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseCloseParenthesis

	^self captureOffsetsIn: [self advance]
		creating: [CloseParenthesisToken new value: $)]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseCloseSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [CloseSquareBracketToken new value: $]]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseLeftAngle

	^self captureOffsetsIn: [self advance]
		creating: [LeftAngleToken new value: #<]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseNumber

	| number |
	^self captureOffsetsIn: [number := self readNumber]
		creating: 
			[(number isInteger ifTrue: [IntegerToken new] ifFalse: [FloatToken new])
				value: number;
				yourself]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseOpenParenthesis

	^self captureOffsetsIn: [self advance]
		creating: [OpenParenthesisToken new value: $(]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseOpenSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [OpenSquareBracketToken new value: $[]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parsePeriod

	^self captureOffsetsIn: [self advance]
		creating: [PeriodToken new value: '.']! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseQuotedSymbolLiteral

	| string |
	^self captureOffsetsIn: 
			[self advance.
			string := self readStringLiteral.
			string isNil
				ifTrue: 
					[^self reportError: 'Missing end quote' start: self startSourceOffset end: self startSourceOffset]]
		creating: [SymbolToken new value: string asSymbol]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseReturn

	^self captureOffsetsIn: [self advance]
		creating: [ReturnToken new value: $^]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseRightAngle

	^self captureOffsetsIn: [self advance]
		creating: [RightAngleToken new value: #>]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseSemicolon

	^self captureOffsetsIn: [self advance]
		creating: [SemicolonToken new value: ';']! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseStringLiteral

	| string |
	^self captureOffsetsIn: 
			[string := self readStringLiteral.
			string isNil
				ifTrue: 
					[self reportError: 'Missing end quote' start: self startSourceOffset end: self startSourceOffset]]
		creating: [StringToken new value: string]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseSymbolLiteral

	| word |
	^self captureOffsetsIn: 
			[self advance.
			word := self readSymbolWord]
		creating: [SymbolToken new value: word asSymbol]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseWord

	| word |
	^self captureOffsetsIn: [word := self readWord]
		creating: [self wordTokenFor: word]! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
readAlphaNumericWord

	| wordStream |
	wordStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^wordStream contents].
	self next isAlphaNumeric or: [self next = $_]]
			whileTrue: 
				[wordStream nextPut: self next.
				self advance].
	^wordStream contents! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
skipComment

	self advance.
	
	[self next = self finishedCharacter ifTrue: [^false].
	self next = $" and: [self next2 ~= $"]]
			whileFalse: [self advance].
	self advance.
	^true! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
skipSeparator

	self next = self finishedCharacter ifTrue: [^false].
	self next isSeparator ifTrue: [self advance. ^true].
	self next = $" ifTrue: [^self skipComment].
	^false! !

! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
wordTokenFor: word

	(word includes: $:) ifTrue: [^KeywordToken new value: word].
	(word includes: $.)
		ifTrue: [^CompoundWordToken new value: (word tokensBasedOn: $.) asArray].
	word = 'self' ifTrue: [^SpecialWordToken new value: 'self'].
	word = 'super' ifTrue: [^SpecialWordToken new value: 'super'].
	word = 'nil' ifTrue: [^SpecialWordToken new value: 'nil'].
	word = 'true' ifTrue: [^SpecialWordToken new value: 'true'].
	word = 'false' ifTrue: [^SpecialWordToken new value: 'false'].
	word = 'thisContext' ifTrue: [^SpecialWordToken new value: 'thisContext'].
	^WordToken new value: word! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readArrayLiteralElement

	(self next isDigit or: [self next = $- and: [self next2 isDigit]])
		ifTrue: [^self parseNumber value].
	self next = $$ ifTrue: [^self parseCharacterLiteral value].
	self next = $' ifTrue: [^self parseStringLiteral value].
	(self next = $# and: [self next2 isAlphabetic])
		ifTrue: [^self parseSymbolLiteral value].
	(self next = $# and: [self next2 = $'])
		ifTrue: [^self parseQuotedSymbolLiteral value].
	(self next = $# and: [self next2 = $(])
		ifTrue: [^self parseArrayLiteral value].
	self next = $( ifTrue: [^self readSubArrayLiteral].
	self next isAlphabetic ifTrue: [
		| word |
		word := self parseWord value.
		word = 'nil' ifTrue: [^nil].
		word = 'true' ifTrue: [^true].
		word = 'false' ifTrue: [^false].
		^word asSymbol].
	(self binaryCharacters includes: self next)
		ifTrue: [^self parseBinary value asSymbol].
	^self! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readArrayLiteralElements

	| elements element |
	elements := OrderedCollection new.
	
	[self skipSeparators.
	(element := self readArrayLiteralElement) ~~ self]
			whileTrue: [elements add: element].
	^elements! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readBinary

	| binaryStream |
	binaryStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^binaryStream contents].
	self binaryCharacters includes: self next]
			whileTrue: 
				[binaryStream nextPut: self next.
				self advance].
	^binaryStream contents! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readByteArrayLiteralElement

	self next isDigit
		ifTrue: 
			[| value |
			value := self parseNumber value.
			(value between: 0 and: 255) ifTrue: [^value]].
	^nil! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readByteArrayLiteralElements

	| elements element |
	elements := OrderedCollection new.
	
	[self skipSeparators.
	(element := self readByteArrayLiteralElement) notNil]
			whileTrue: 
				["self log: 'readByteArrayLiteralElements ', element printString, ' size: ', elements size printString."
				elements add: element].
	^elements! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readCompoundWordOn: aStream

	[self next = $. and: [self next2 isAlphabetic or: [self next2 = $_]]]
		whileTrue: 
			[self advance.
			aStream
				nextPut: $.;
				nextPutAll: self readAlphaNumericWord].
	^aStream contents! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readDecimalPart: integerPart

	| value digits |
	digits := OrderedCollection new: 20.

	[self next isDigit] whileTrue: [
		digits add: self next digitValue.
		self advance].

	value := 0 asFloat.

	digits reverseDo: [:eachDigit |
		value := value / 10 asFloat + eachDigit asFloat].

	^integerPart positive
		ifTrue: [integerPart asFloat + (value / 10 asFloat)]
		ifFalse: [integerPart asFloat - (value / 10 asFloat)]! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readExponent

	| value negated |
	value := 0.
	
	negated := 1.
	self next = $- ifTrue: [
		negated := -1.
		self advance].
	
	[self next isDigit] whileTrue: 
			[value := value * 10 + self next digitValue.
			self advance].
	^value * negated! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readFloatStartingWith: aNumber

	| value |
	value := aNumber asFloat.
	(self next = $. and: [self next2 isDigit])
		ifTrue: 
			[self advance.
			value := self readDecimalPart: aNumber].
	self next = $e ifFalse: [^value].
	self advance.
	^value asFloat * (10 asFloat raisedToInteger: self readExponent)! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readFloatStartingWith: aNumber sign: signNumber
	| value |
	value := aNumber asFloat.
	(self next = $. and: [self next2 isDigit])
		ifTrue: 
			[self advance.
			value := self readDecimalPart: aNumber].
	self next = $e ifFalse: [^value * signNumber].
	self advance.
	^value asFloat * (10 asFloat raisedToInteger: self readExponent) * signNumber! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readInteger

	| number sign |
	number := 0.
	sign := 1.
	self next = $-
		ifTrue: 
			[sign := -1.
			self advance].
	[self next isDigit] whileTrue: 
			[number := number * 10 + self next digitValue.
			self advance].
	^sign * number! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readKeywordOn: aStream

	[self next = $: and: [self next2 ~= $=]] whileTrue: 
			[| nextWord |
			self advance.
			aStream nextPut: $:.
			nextWord := self readAlphaNumericWord.
			nextWord isEmpty ifTrue: [^aStream contents].
			aStream nextPutAll: nextWord].
	^aStream contents! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readNumber

	| number sign |
	sign := self next = $- ifTrue: [-1.0] ifFalse: [1.0].

	number := self readInteger.
	self next = self finishedCharacter ifTrue: [^number].
	((self next = $. and: [self next2 isDigit]) or: [self next = $e])
		ifTrue: [^self readFloatStartingWith: number abs sign: sign].
	self next = $r ifTrue: [^self readNumberRadix: number].
	^number! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readNumberRadix: radixNumber

	| radix sign number |
	self advance.
	sign := radixNumber sign.
	radix := radixNumber abs.
	number := 0.
	[self isDigit: self next radix: radix] whileTrue: 
			[number := number * radix + self next digitValue.
			self advance].
	^sign * number! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readStringLiteral

	| literalStream |
	self advance.
	literalStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^nil].
	self next = $' and: [self next2 ~= $']]
			whileFalse: 
				[literalStream nextPut: self next.
				self next = $' ifTrue: [self advance].
				self advance].
	self advance.
	^literalStream contents! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readSubArrayLiteral

	| elements |
	self advance.
	elements := self readArrayLiteralElements.
	self next = $) ifFalse: [^nil].
	self advance.
	^elements asArray! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readSymbolWord

	| wordStream |
	wordStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^wordStream contents].
	self next isAlphaNumeric or: [self next = $_ or: [self next = $:]]]
			whileTrue: 
				[wordStream nextPut: self next.
				self advance].
	^wordStream contents! !

! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readWord

	| wordStream |
	wordStream := WriteStream on: (String new: 100).
	wordStream nextPutAll: self readAlphaNumericWord.
	(self next = $: and: [self next2 ~= $=])
		ifTrue: [^self readKeywordOn: wordStream].
	(self next = $. and: [self next2 isAlphabetic or: [self next2 = $_]])
		ifTrue: [^self readCompoundWordOn: wordStream].
	^wordStream contents! !

! SmalltalkParser methodsFor: 'accessing' !
addScope: aScope

	self scopeStack notEmpty ifTrue: [self scopeStack last addScope: aScope].
	self scopeStack add: aScope.
	self scopes add: aScope.
	aScope scopeNumber: self scopeStack size! !

! SmalltalkParser methodsFor: 'accessing' !
addScopeVariable: aScopeVariable

	self scopeStack last addVariable: aScopeVariable.
	aScopeVariable scopeNumber: self scopeStack last scopeNumber.
	^aScopeVariable! !

! SmalltalkParser methodsFor: 'accessing' !
globalDictionaries

	^globalDictionaries! !

! SmalltalkParser methodsFor: 'accessing' !
globalDictionaries: anObject

	globalDictionaries := anObject! !

! SmalltalkParser methodsFor: 'accessing' !
newScope

	self addScope: Scope new! !

! SmalltalkParser methodsFor: 'accessing' !
popScope

	scopeStack removeLast! !

! SmalltalkParser methodsFor: 'accessing' !
scopeStack

	^scopeStack! !

! SmalltalkParser methodsFor: 'accessing' !
scopeStack: anObject

	scopeStack := anObject! !

! SmalltalkParser methodsFor: 'accessing' !
scopes

	^scopes! !

! SmalltalkParser methodsFor: 'accessing' !
scopes: anObject

	scopes := anObject! !

! SmalltalkParser methodsFor: 'accessing' !
targetClass

	^targetClass! !

! SmalltalkParser methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject! !

! SmalltalkParser methodsFor: 'accessing' !
tokensToExpect

	^tokensToExpect! !

! SmalltalkParser methodsFor: 'accessing' !
tokensToExpect: anObject

	tokensToExpect := anObject! !

! SmalltalkParser methodsFor: 'building' !
buildAssignStatementList: rule

	| nextStatement |
	rule sequence size = 1 ifTrue: [^StatementListNode new
			statements: (Array with: rule sequence first);
			yourself].

	nextStatement := (rule sequence at: 2) sequence size >= 2
			ifTrue: [(rule sequence at: 2) sequence at: 2]
			ifFalse: [^StatementListNode new
				statements: (Array with: rule sequence first);
				yourself].
	(nextStatement isKindOf: StatementListNode) ifFalse: [
		^StatementListNode new
			statements: (Array with: rule sequence first with: nextStatement) ].

	^StatementListNode new
			statements: (OrderedCollection new
				add: rule sequence first;
				addAll: nextStatement statements;
				yourself) asArray! !

! SmalltalkParser methodsFor: 'building' !
buildBinaryExpression: rule

	| argument |
	rule result isSequence ifFalse: [^rule result].
	rule result sequence size = 1 ifTrue: [^rule result sequence first].

	argument := (rule sequence at: 2) sequence at: 2.

	^(BinaryMessageNode
			receiver: rule sequence first 
			selector: (rule sequence at: 2) sequence first token value
			argument: argument)
		startSourceOffset: (rule sequence at: 2) sequence first startSourceOffset;
		endSourceOffset: (rule sequence at: 2) sequence first endSourceOffset;
		yourself! !

! SmalltalkParser methodsFor: 'building' !
buildBinaryMessageHeader: aRule

	| variable methodName |

	variable := self addScopeVariable: (LocalVariable argumentNamed: (aRule result sequence at: 2) token value asSymbol).

	methodName := aRule result sequence first token value asSymbol.
	self currentMethodName: methodName.
	^BinaryHeaderNode selector: methodName argument: variable! !

! SmalltalkParser methodsFor: 'building' !
buildBlock: rule

	| newNode |

	newNode := BlockNode new
		scope: scopes last;
		yourself.

	rule sequence do: [:node |
		node isBlockParameterListNode ifTrue: [
			newNode arguments: node].
		(node isKindOf: StatementListNode) ifTrue: [
			newNode statements: node].
		].
	
	^newNode! !

! SmalltalkParser methodsFor: 'building' !
buildBlockParameters: aRule

	| parameterNames variables |

	parameterNames := OrderedCollection new.
	variables:= OrderedCollection new.

	aRule sequence first sequence do: [:node |
		| variable |
		parameterNames add: node token value.
		variable := LocalVariable argumentNamed: node token value.
		variables add: variable.
		self addScopeVariable: variable].
	
	^BlockParameterListNode new
		variables: variables;
		yourself! !

! SmalltalkParser methodsFor: 'building' !
buildCascadeNode: aRule

	| receiver messages |

	(aRule sequence at: 2) sequence isEmpty ifTrue: [^aRule sequence first].

	receiver := aRule sequence first receiver.
	messages := OrderedCollection new.

	messages add: aRule sequence first.
	messages first receiver: nil.

	(aRule sequence at: 2) sequence do: [:sequenceNode |
		| message |
		message := sequenceNode sequence at: 2.
		message receiver: nil.
		messages add: message].

	^CascadeNode receiver: receiver messages: messages! !

! SmalltalkParser methodsFor: 'building' !
buildKeywordExpression: rule

	| keywordStream arguments keywordSequence |
	(keywordSequence := rule sequence at: 2) sequence isEmpty ifTrue: [^rule sequence first].

	keywordStream := WriteStream on: (String new).
	arguments := OrderedCollection new.

	keywordSequence sequence do: [:keyWordArgument |
		keywordStream nextPutAll: keyWordArgument sequence first token value.
		arguments add: (keyWordArgument sequence at: 2)].

	^(KeywordMessageNode
			receiver: rule sequence first 
			selector: keywordStream contents asSymbol
			arguments: arguments)
		startSourceOffset: keywordSequence sequence first sequence first startSourceOffset;
		endSourceOffset: keywordSequence sequence first sequence first endSourceOffset;
		yourself! !

! SmalltalkParser methodsFor: 'building' !
buildKeywordMessageFrom: aRule

	| keywordStream arguments |

	keywordStream := WriteStream on: (String new).
	arguments := OrderedCollection new.
	
	aRule result sequence do: [:sequenceNode |
		keywordStream nextPutAll: sequenceNode sequence first token value.
		arguments add: (sequenceNode sequence at: 2)].

	^KeywordMessageNode
		selector: keywordStream contents asSymbol
		arguments: arguments asArray! !

! SmalltalkParser methodsFor: 'building' !
buildKeywordMethodHeaderFrom: aRule

	| keywordStream arguments methodName |
	arguments := OrderedCollection new.
	keywordStream := WriteStream on: String new.

	aRule nodes do: 
			[:node |
			| argument |
			argument := LocalVariable argumentNamed: (node sequence at: 2) token value.
			keywordStream nextPutAll: node sequence first token value.
			arguments add: argument.
			self addScopeVariable: argument].

	methodName := keywordStream contents asSymbol.
	self currentMethodName: methodName.
	^KeywordHeaderNode
		selector: methodName
		arguments: arguments asArray! !

! SmalltalkParser methodsFor: 'building' !
buildLeftToRightBinaryExpression: rule

	| binaryMessageNode |

	rule result isBinaryMessageNode ifFalse: [^rule result].

	binaryMessageNode := rule result.
	
	binaryMessageNode argument isBinaryMessageNode ifFalse: [
		^binaryMessageNode].

	[binaryMessageNode argument isBinaryMessageNode]
		whileTrue: [
			binaryMessageNode := BinaryMessageNode
				receiver: (BinaryMessageNode
					receiver:  binaryMessageNode receiver
					selector: binaryMessageNode selector
					argument: binaryMessageNode argument receiver
					startSourceOffset: binaryMessageNode startSourceOffset
					endSourceOffset:  binaryMessageNode endSourceOffset)
				selector: binaryMessageNode argument selector
				argument: binaryMessageNode argument argument
				startSourceOffset: binaryMessageNode argument startSourceOffset
				endSourceOffset: binaryMessageNode argument endSourceOffset].

	^binaryMessageNode! !

! SmalltalkParser methodsFor: 'building' !
buildPragma: rule

	self halt! !

! SmalltalkParser methodsFor: 'building' !
buildPragmaMessage: rule

	| keywordStream arguments |

	(rule result isKindOf: TokenNode) ifTrue: [
		^PragmaNode selector: rule result token value asSymbol arguments: #()].

	keywordStream := WriteStream on: String new.
	arguments := OrderedCollection new.

	rule result sequence do: [:keywordPair |
		keywordStream nextPutAll: keywordPair sequence first token value.
		arguments add: (keywordPair sequence at: 2) token value].

	^PragmaNode selector: keywordStream contents asSymbol arguments: arguments asArray! !

! SmalltalkParser methodsFor: 'building' !
buildStatementBody: rule

	rule sequence isEmpty ifTrue: [^nil].
	rule sequence size = 1 ifTrue: [^rule sequence first].

	^(rule sequence at: 2)
		variables: rule sequence first variables;
		yourself! !

! SmalltalkParser methodsFor: 'building' !
buildTempVar: aRule

	| variables |

	variables := (aRule nodes collect: [:each | LocalVariable named: each token value]) asArray.
	scopes last addVariables: variables.
	^TempVarListNode variables: variables! !

! SmalltalkParser methodsFor: 'building' !
buildUnaryMessageFor: aRule

	| object messages |

	object := aRule sequence first.
	messages := aRule sequence at: 2.
	^messages sequence isEmpty
		ifTrue: [object]
		ifFalse: 
			[messages sequence inject: object
				into: 
					[:node :each |
					(UnaryMessageNode receiver: node selector: each token value asSymbol)
						startSourceOffset: each token startSourceOffset;
						endSourceOffset: each token endSourceOffset;
						yourself]]! !

! SmalltalkParser methodsFor: 'building' !
buildVariableAssignNode: aRule

	| value assignmentNode |

	value := aRule sequence at: 2.

	aRule sequence first sequence reverseDo: [:assignment |
		| variableNameToken handled |
		handled := false.
		variableNameToken := assignment sequence first token.
		(self isNamespaceVariable: variableNameToken) ifTrue: [
			value := NamespaceVariableAssignmentNode nameComponents: variableNameToken value value: value.
			value
				startSourceOffset: (assignment sequence at: 1) startSourceOffset;
				endSourceOffset: (assignment sequence at: 1) endSourceOffset.
			assignmentNode := value.
			handled := true].

		(handled not and: [self isLocalVariable: variableNameToken]) ifTrue: [
			| scopeAndVariable |
			scopeAndVariable := self findLocalVariableNamed: variableNameToken value.
			value := LocalVariableAssignmentNode variable: scopeAndVariable value value: value.
			value
				startSourceOffset: (assignment sequence at: 1) startSourceOffset;
				endSourceOffset: (assignment sequence at: 1) endSourceOffset.

			scopeAndVariable key == scopeStack last ifFalse: [scopeAndVariable value indirect: true].
			assignmentNode := value.
			handled := true].

		(handled not and: [self isInstanceVariable: variableNameToken]) ifTrue: [
			value := InstanceVariableAssignmentNode variable: (InstanceVariable named: variableNameToken value) value: value.
			value
				startSourceOffset: (assignment sequence at: 1) startSourceOffset;
				endSourceOffset: (assignment sequence at: 1) endSourceOffset.
			assignmentNode := value.
			handled := true].

		(handled not and: [self isGlobalVariable: variableNameToken])
			ifTrue: [
				value := GlobalVariableAssignmentNode variable: (GlobalVariable named: variableNameToken value) value: value.
				value
					startSourceOffset: (assignment sequence at: 1) startSourceOffset;
					endSourceOffset: (assignment sequence at: 1) endSourceOffset.
				assignmentNode := value.
				handled := true] ].

	^value! !

! SmalltalkParser methodsFor: 'expecting' !
expectToken: aTokenClass

	self currentRule allPassedSoFar ifFalse: [^self].
	self tokensToExpect add: aTokenClass! !

! SmalltalkParser methodsFor: 'expecting' !
stopExpectingToken: aTokenClass

	self tokensToExpect removeLast! !

! SmalltalkParser methodsFor: 'initialize-release' !
initialize

	self scopeStack: OrderedCollection new.
	self scopes: OrderedCollection new.
	self globalDictionaries: OrderedCollection new.
	self tokensToExpect: OrderedCollection new! !

! SmalltalkParser methodsFor: 'parsing' !
currentMethodName
	^currentMethodName! !

! SmalltalkParser methodsFor: 'parsing' !
currentMethodName: aSymbol
	currentMethodName := aSymbol! !

! SmalltalkParser methodsFor: 'parsing' !
parseAssignStatement
	"assignStatement ::= ((WORD | COMPOUNDWORD) ASSIGN)* cascadeExpression"

	self sequence: [
		self zeroOrMore: [
			self sequence: [
				self
					oneOf: [
							self token: WordToken;
								token: CompoundWordToken];
					token: AssignToken]];
		commitWithMessage: 'Bad assignment' if: [:rule | rule lastZeroOrMoreProducedResult];
		parse: [self parseCascadeExpression];
		commitAndFailWithMessage: '%t not expected' if: [:rule |
			rule errorString isNil and: [
			rule tokenStream atEnd not and: [
				(rule tokensToExpect includes: rule tokenStream peek class name) not]]];
		produce: [:rule | self buildVariableAssignNode: rule] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseAssignStatementList
	"assignStatementList ::= assignStatement | (PERIOD statementList)* "

	self sequence: [self
			parse: [self parseAssignStatement];
			optional: [self
				sequence: [self
					token: PeriodToken;
					parse: [self parseStatementList ] ] ];
		produce: [:rule | self buildAssignStatementList: rule] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseBinaryExpression
	"binaryExpression ::= unaryExpression ((BINARY | BAR | LEFTANGLE | RIGHTANGLE) binaryExpression)?"

	self
		sequence: [
			self parse: [self parseUnaryExpression];
				optional: [
					self sequence: [
						self oneOf: [
							self token: BinaryToken;
								token: BarToken;
								token: LeftAngleToken;
								token: RightAngleToken];
							parse: [self parseBinaryExpression] ] ];
				produce: [:rule | self buildBinaryExpression: rule] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseBinaryMethodHeader
	"binaryMethodHeader ::= (BAR | LEFTANGLE | RIGHTANGLE | BINARY) WORD"

	self sequence: 
			[self
				oneOf: 
						[self
							token: BarToken;
							token: LeftAngleToken;
							token: RightAngleToken;
							token: BinaryToken];
				commitWithMessage: 'Invalid method header' if: [:rule | rule allPassedSoFar];
				token: WordToken;
				produce: 
						[:rule | self buildBinaryMessageHeader: rule]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseBlock
	"block ::= OPENSQUARE  (blockParams)? statementBody CLOSESQUARE"

	self sequence: 
			[self
				token: OpenSquareBracketToken produce: [:rule | self newScope. rule result];
				commitWithMessage: 'Unmatched square bracket' if: [:rule | rule allPassedSoFar];
				optional: [self parse: [self parseBlockParams]];
				parse: [self parseStatementBody];
				token: CloseSquareBracketToken produce: [:rule | rule result];
				produce: [:rule |
					| blockNode |
					blockNode := self buildBlock: rule.
					self popScope.
					blockNode]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseBlockParams
	"blockParams ::= (BLOCKPARAM)+ BAR"

	self sequence: 
			[self
				oneOrMore: [self token: BlockArgumentToken];
				token: BarToken;
				produce: [:rule | self buildBlockParameters: rule]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseCascadeExpression
	"cascadeExpression ::= keywordExpression (SEMICOLON cascadeMessage)*"

	self sequence: [
			self parse: [self parseKeywordExpression];
				zeroOrMore: [
					self sequence: [
						self token: SemicolonToken;
							parse: [self parseCascadeMessage] ] ];
				produce: [:rule | self buildCascadeNode: rule]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseCascadeMessage
	"cascadeMessage ::= WORD | BAR unaryExpression | LEFTANGLE unaryExpression | RIGHTANGLE unaryExpression |
		BINARY unaryExpression | (KEYWORD leftToRightBinaryExpression)+"

	self oneOf: [
			self oneOf: [
				self token: WordToken
					produce: [:rule | 
						(UnaryMessageNode selector: rule result token value asSymbol)
						startSourceOffset: rule result token startSourceOffset;
						endSourceOffset: rule result token endSourceOffset;
						yourself] ];
			sequence: [
				self token: BarToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			sequence: [
				self token: LeftAngleToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			sequence: [
				self token: RightAngleToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			sequence: [
				self token: BinaryToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			oneOrMore: [
				self sequence: [
					self token: KeywordToken;
						parse: [self parseLeftToRightBinaryExpression] ];
				produce: [:rule |
					(self buildKeywordMessageFrom: rule)
							startSourceOffset: rule result sequence first sequence first token startSourceOffset;
							endSourceOffset: rule result sequence first sequence first token endSourceOffset;
							yourself
					] ] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseExpression

	self parseCascadeExpression! !

! SmalltalkParser methodsFor: 'parsing' !
parseKeywordExpression
	"keywordExpression ::= leftToRightBinaryExpression (KEYWORD leftToRightBinaryExpression)*"

	self
		sequence: [
			self parse: [self parseLeftToRightBinaryExpression];
				zeroOrMore: [
					self sequence: [
						self token: KeywordToken;
							parse: [self parseLeftToRightBinaryExpression] ] ];
				produce: [:rule | self buildKeywordExpression: rule] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseKeywordMethodHeader
	"keywordMethodHeader ::= (KEYWORD WORD)+"

	self oneOrMore: 
			[self
				sequence: 
						[self
							token: KeywordToken;
							commitWithMessage: 'Invalid method header' if: [:rule | rule allPassedSoFar];
							token: WordToken];
				produce: [:rule | self buildKeywordMethodHeaderFrom: rule]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseLeftToRightBinaryExpression
	"leftToRightBinaryExpression ::= binaryExpression"

	self
		oneOf: [
			self parse: [self parseBinaryExpression];
				produce: [:rule | self buildLeftToRightBinaryExpression: rule] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseLiteral
	"literal ::= INTEGER | FLOAT | CHARACTER | ARRAY | BYTEARRAY | STRING | SYMBOL | block"

	self oneOf: 
			[self
				token: IntegerToken;
				token: FloatToken;
				token: CharacterToken;
				token: ArrayLiteralToken;
				token: ByteArrayLiteralToken;
				token: StringToken;
				token: SymbolToken;
				parse: [self parseBlock];
				produce: [:rule |
					rule result isBlockNode
						ifTrue: [BlockLiteralNode value: rule result]
						ifFalse: [(LiteralNode value: rule result token value)							startSourceOffset: rule result token startSourceOffset;							endSourceOffset: rule result token endSourceOffset;							yourself]]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseMethod
	"method ::= methodHeader pragma * statementBody"

	self newScope.

	self sequence: 
			[self
				parse: [self parseMethodHeader];
				zeroOrMore: [self parse: [self parsePragma]];
				parse: [self parseStatementBody];
				produce: [:rule |
					MethodNode
						header: rule sequence first
						pragmas: (rule sequence at: 2) sequence asArray
						body: (rule sequence size >= 3 ifTrue: [rule sequence at: 3] ifFalse: [nil])]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseMethodHeader
	"methodHeader ::= unaryMethodHeader | binaryMethodHeader | keywordMethodHeader"

	self
		oneOf: [self
				parse: [self parseUnaryMethodHeader];
				parse: [self parseBinaryMethodHeader];
				parse: [self parseKeywordMethodHeader]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseObject
	"object ::= literal | WORD | COMPOUNDWORD | SPECIALWORD | parenthesisExpression"

	self oneOf: 
			[self
				parse: [self parseLiteral];
				token: WordToken
					produce: [:rule | self createVariableReferenceFor: rule];
				token: CompoundWordToken
					produce: [:rule | NamespaceVariableReferenceNode new nameComponents: rule result token value];
				token: SpecialWordToken
					produce: [:rule |
						| token |
						token := rule result token.
						(SpecialNode special: rule result token value)
							startSourceOffset: token startSourceOffset;
							endSourceOffset: token endSourceOffset;
							yourself];
				parse: [self parseParenthesisExpression];
				produce: [:rule | rule result]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseParenthesisExpression
	"parenthesisExpression ::= OPENPAREN assignStatementList CLOSEPAREN"

	self sequence: [self
			token: OpenParenthesisToken;
			commitWithMessage: 'Unmatched parenthesis' if: [:rule | rule allPassedSoFar];
			parse: [self parseAssignStatementList];
			token: CloseParenthesisToken;
			produce: [:rule | ParenthesisNode expression: (rule sequence at: 2)] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parsePragma

	"pragma ::= LEFTANGLE pragmaMessage RIGHTANGLE"

	self sequence: [
		self token: LeftAngleToken;
			commitWithMessage: 'Bad pragma' if: [:rule | rule allPassedSoFar];
			parse: [self pragmaMessage];
			token: RightAngleToken;
			produce: [:rule | rule sequence at: 2]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseReturnStatement
	"returnStatement ::= RETURN assignStatement (PERIOD)?"

	self sequence: 
			[self
				token: ReturnToken;
				commitWithMessage: 'Bad return' if: [:rule | rule allPassedSoFar];
				parse: [self parseAssignStatement];
				optional: [self token: PeriodToken];
				produce: [:rule |
					| returnToken |
					returnToken := (rule sequence at: 2).
					(ReturnNode value: returnToken)
						startSourceOffset: rule sequence first startSourceOffset;
						endSourceOffset: rule sequence first endSourceOffset;
						yourself]] ! !

! SmalltalkParser methodsFor: 'parsing' !
parseStatementBody
	"statementBody ::= (tempVars)? statementList"

	self sequence: [
		self optional: [
			self parse: [self parseTempVars]];
		parse: [self parseStatementList];
		produce: [:rule | self buildStatementBody: rule]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseStatementList
	"statementList ::= returnStatement | assignStatementList "

	self optional: [self oneOf: [self
			parse: [self parseReturnStatement
				produce: [:rule | StatementListNode statements: (Array with: rule result)] ];
			parse: [self parseAssignStatementList
				produce: [:rule | rule result] ] ] ]! !

! SmalltalkParser methodsFor: 'parsing' !
parseTempVars
	"tempVars ::= BAR (WORD)* BAR"

	self sequence: 
			[self
				token: BarToken;
				zeroOrMore: 
						[self
							token: WordToken;
							produce: [:rule | self buildTempVar: rule] ];
				token: BarToken;
				produce: [:rule | rule sequence at: 2]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseUnaryExpression
	"unaryExpression ::= object (WORD)*"

	self sequence: 
			[self
				parse: [self parseObject];
				zeroOrMore: [self token: WordToken];
				produce: [:rule | self buildUnaryMessageFor: rule]]! !

! SmalltalkParser methodsFor: 'parsing' !
parseUnaryMethodHeader
	"unaryMethodHeader ::= WORD"

	self token: WordToken
		produce: [:rule |
			| methodName |
			methodName := rule result token value asSymbol.
			self currentMethodName: methodName.
			UnaryHeaderNode selector: methodName]! !

! SmalltalkParser methodsFor: 'parsing' !
pragmaLiteral

	"pragmaLiteral ::= INTEGER | FLOAT | CHARACTER | ARRAY | BYTEARRAY | STRING | SYMBOL"

	self oneOf: [
		self token: IntegerToken;
			token: FloatToken;
			token: CharacterToken;
			token: ArrayLiteralToken;
			token: ByteArrayLiteralToken;
			token: StringToken;
			token: SymbolToken]! !

! SmalltalkParser methodsFor: 'parsing' !
pragmaMessage

	"pragmaMessage ::= WORD | (KEYWORD pragmaLiteral)+"

	self oneOf: [
		self token: WordToken;
			oneOrMore: [self
				sequence: [self
					token: KeywordToken;
					parse: [self pragmaLiteral]]];
			produce: [:rule | self buildPragmaMessage: rule]]! !

! SmalltalkParser methodsFor: 'testing' !
isGlobalVariable: aToken

	(globalDictionaries anySatisfy: [:eachDictionary |
		eachDictionary notNil and: [eachDictionary includesKey: aToken value asSymbol] ]) ifTrue: [^true].

	Undeclared at: aToken value asSymbol ifAbsentPut: [nil].

	^true! !

! SmalltalkParser methodsFor: 'testing' !
isInstanceVariable: aToken

	^self targetClass
		ifNil: [false]
		ifNotNil: [:class | class allInstVarNames includes: aToken value asString]! !

! SmalltalkParser methodsFor: 'testing' !
isLocalVariable: aToken

	^(self scopeAndLocalVariableFor: aToken) notNil! !

! SmalltalkParser methodsFor: 'testing' !
isNamespaceVariable: aToken

	| value |

	(aToken isMemberOf: CompoundWordToken) ifFalse: [^false].

	value := globalDictionaries
		detect: [:eachDictionary | eachDictionary includesKey: aToken value first asSymbol ]
		ifNone: [nil].

	value isNil ifTrue: [^false].

	aToken value do: [:eachVariableName |
		value isLikeNameSpace ifFalse: [^false].
		value := value at: eachVariableName asSymbol].

	^true! !

! SmalltalkParser methodsFor: 'testing' !
scopeAndLocalVariableFor: aToken

	scopes do: [:eachScope |
			eachScope variables do: [:eachVariable |
				eachVariable variableName = aToken value asSymbol
					ifTrue: [^eachScope -> eachVariable] ] ].
	^nil! !

! SmalltalkParser methodsFor: 'variables' !
createVariableReferenceFor: aRule

	| variableName localVariable |

	variableName := aRule result token value asSymbol.

	localVariable := self findLocalVariableNamed: variableName.

	localVariable notNil ifTrue: [^LocalVariableReferenceNode new
		scopeNumber: localVariable key;
		variable: localVariable value;
		startSourceOffset: aRule result token startSourceOffset;
		endSourceOffset: aRule result token endSourceOffset;
		yourself].

	self targetClass ifNotNil: [
		| index variable |
		index := self targetClass allInstVarNames indexOf: variableName asString.
		variable := InstanceVariable named: variableName.
		index > 0 ifTrue: [^(InstanceVariableReferenceNode new variable: variable)
					startSourceOffset: aRule result token startSourceOffset;
					endSourceOffset: aRule result token endSourceOffset;
					yourself] ].

	^GlobalVariableReferenceNode new
		variable: (GlobalVariable named: variableName);
		startSourceOffset: aRule result token startSourceOffset;
		endSourceOffset: aRule result token endSourceOffset;
		yourself! !

! SmalltalkParser methodsFor: 'variables' !
findLocalVariableNamed: variableName

	self scopeStack reverseDo: [:scope |
		(scope variableNamed: variableName) ifNotNil: [:variable |
			^scope -> variable]].

	^nil! !

! SmalltalkParser class methodsFor: 'evaluating' !
debugIt: aString

	self
		compile: 'doit ^[self halt. [', aString, '] value'
		inClass: Doit class
		organization: 'doit'.
	^Doit perform: #doit! !

! SmalltalkParser class methodsFor: 'evaluating' !
evaluate: aString

	self
		compile: 'doit ^[', aString, '] value'
		inClass: Doit class
		organization: 'doit'.
	^Doit perform: #doit! !

! SmalltalkParser class methodsFor: 'evaluating' !
evaluate: aString for: anObject

	| result |

	self
		compile: 'doit ^[', aString, '] value'
		inClass: anObject class
		organization: 'doit'.

	result := anObject perform: #doit.
	anObject class removeSelector: #doit.
	^result ! !

! SmalltalkParser class methodsFor: 'instance creation' !
new

	^super new initialize! !

! SmalltalkParser class methodsFor: 'parsing' !
compile: aString inClass: aClass organization: organizationString

	| method |

	method := self
		generateForClass: aClass
		methodString: aString
		organization: organizationString.
		
	(method isKindOf: String) ifTrue: [^self error: method].

	aClass methodDictionary at: method selector put: method! !

! SmalltalkParser class methodsFor: 'parsing' !
fileoutMethod: aString forClass: aClass on: changesFile

	| offset1 offset2 sourceString |
	
	aClass ifNil: [^Array with: 0 with: 0].

	changesFile
		nextPutAll: '! ', aClass name, ' methods !'; cr.

	sourceString := aString.

	offset1 := changesFile position.
	changesFile
		nextPutAll: (sourceString convertLineEndingsTo: #cr).
	
	offset2 := changesFile position.
	changesFile
		nextPutAll: ' ! !'; cr.

	^Array with: offset1 with: offset2! !

! SmalltalkParser class methodsFor: 'parsing' !
fileoutMethod: aString forClass: aClass organization: organizationString on: changesFile

	| offset1 offset2 sourceString |
	
	aClass ifNil: [^Array with: 0 with: 0].

	changesFile
		nextPutAll: '! ', aClass name, ' methodsFor: ', organizationString printString, ' !'; cr.

	sourceString := aString.

	offset1 := changesFile position.
	changesFile
		nextPutAll: (sourceString convertLineEndingsTo: #cr).
	
	offset2 := changesFile position.
	changesFile
		nextPutAll: ' ! !'; cr.

	^Array with: offset1 with: offset2! !

! SmalltalkParser class methodsFor: 'parsing' !
generateForClass: aClass globals: aCollection methodString: aString organization: organizationString writeChangesInto: aFile

	| codeGenerator parser methodOffsets |

	codeGenerator := CodeGenerator new
		targetClass: aClass;
		globalDictionaries: aCollection;
		yourself.

	parser := self parseForClass: aClass globals: aCollection methodString: aString.
	parser errorMessage isNil ifFalse: [
		^parser errorMessage raiseSignal].

	parser isFinished ifFalse: [
		| token |
		token := parser currentRule tokenStream peek.
		CompileError new
			message: (token value asString, ' not expected');
			startSourceOffset: token startSourceOffset;
			endSourceOffset: token endSourceOffset;
			raiseSignal].

	parser result acceptVisitor: codeGenerator.

	aFile isNil ifFalse: [
		methodOffsets := self fileoutMethod: aString forClass: aClass organization: organizationString on: aFile.
		aFile flush].

	^codeGenerator method
		sourceOffsets: codeGenerator sourceOffsets asArray;
		writeMethodOffsets: methodOffsets;
		yourself! !

! SmalltalkParser class methodsFor: 'parsing' !
generateForClass: aClass globals: aCollection organization: organizationString methodString: aString

	^self generateForClass: aClass
		globals: aCollection
		methodString: aString
		organization: organizationString
		writeChangesInto: BeagleSystem changesFile! !

! SmalltalkParser class methodsFor: 'parsing' !
generateForClass: aClass methodString: aString organization: organizationString

	^self
		generateForClass: aClass
		globals: (aClass ifNil: [nil] ifNotNil: [:class | class globalDictionaries])
		organization: organizationString
		methodString: aString! !

! SmalltalkParser class methodsFor: 'parsing' !
parseBlockBody: tokens

	^self new
		tokens: tokens;
		parseStatementBody! !

! SmalltalkParser class methodsFor: 'parsing' !
parseBlockBodyString: aString

	^self parseBlockBody: (SmalltalkLexicalAnalyzer on: aString) tokens! !

! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass globals: aCollection method: tokens

	^self new
		targetClass: aClass;
		globalDictionaries: (aCollection ifNil: [#()]);
		tokens: tokens;
		parseMethod! !

! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass globals: aCollection methodString: aString

	^self
		parseForClass: aClass
		globals: aCollection
		method: (SmalltalkLexicalAnalyzer on: aString readStream) tokens! !

! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass method: tokens

	^self parseForClass: aClass globals: nil method: tokens! !

! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass methodString: aString

	^self parseForClass: aClass globals: nil methodString: aString! !

! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass selector: aSymbol

	^self parseForClass: aClass globals: nil methodString: (aClass compiledMethodAt: aSymbol) getSource! !

! SmalltalkParser class methodsFor: 'parsing' !
parseMethod: tokens

	^self parseForClass: nil method: tokens! !

! SmalltalkParser class methodsFor: 'parsing' !
parseMethodString: aString

	^self parseForClass: nil methodString: aString! !

! SmalltalkParser class methodsFor: 'parsing' !
quietGenerateForClass: aClass globals: aCollection methodString: aString organization: organization

	^self generateForClass: aClass
		globals: aCollection
		methodString: aString
		organization: organization
		writeChangesInto: nil! !

! SmalltalkParser class methodsFor: 'parsing' !
quietGenerateForClass: aClass methodString: aString organization: organization

	^self
		quietGenerateForClass: aClass
		globals: (aClass ifNil: [nil] ifNotNil: [:class | class globalDictionaries])
		methodString: aString
		organization: organization! !

! SmalltalkParser class methodsFor: 'parsing' !
quietRecompileMethod: aCompiledMethod inClass: aClass

	| method |

	[method := self	
			quietGenerateForClass: aClass
			methodString: aCompiledMethod getSource
			organization: aCompiledMethod organization]
	on: CompileWarning
	do: [:ex | ex resume].
		
	(method isKindOf: String) ifTrue: [^self error: method].

	method writeMethodOffsets: aCompiledMethod methodOffsets.
	aClass methodDictionary at: method selector put: method! !

! StatementListNode methodsFor: 'accessing' !
statements

	^statements! !

! StatementListNode methodsFor: 'accessing' !
statements: anObject

	statements := anObject! !

! StatementListNode methodsFor: 'accessing' !
variables

	^variables ifNil: [#()]! !

! StatementListNode methodsFor: 'accessing' !
variables: anObject

	variables := anObject! !

! StatementListNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitStatementListStart: self.
	self statements
		do: [:statement | statement acceptVisitor: anObject]
		separatedBy: [anObject visitStatementSeparator].
	anObject visitStatementListEnd: self! !

! StatementListNode class methodsFor: 'instance creation' !
statements: aCollection

	^self new
		statements: aCollection;
		yourself! !

! StatementListNode class methodsFor: 'instance creation' !
variables: variables statements: statements

	^self new
		variables: variables;
		statements: statements;
		yourself! !

! TempVarListNode methodsFor: 'accessing' !
variableNames

	^(self variables collect: #variableName) asArray! !

! TempVarListNode methodsFor: 'accessing' !
variables

	^variables! !

! TempVarListNode methodsFor: 'accessing' !
variables: anObject

	variables := anObject! !

! TempVarListNode class methodsFor: 'instance creation' !
variables: aCollection

	^self new
		variables: aCollection;
		yourself! !

! TestParser methodsFor: 'accessing' !
parseOneOfRule

	self sequence: [
		self oneOf: [
			self token: IntegerToken;
				token: BinaryToken;
				token: WordToken].
		self token: BarToken]! !

! TestParser methodsFor: 'accessing' !
parseOneOrMoreRule

	self sequence: [
		self oneOrMore: [
			self token: IntegerToken].
		self token: BarToken]! !

! TestParser methodsFor: 'accessing' !
parseOptionalRule

	self sequence: [
		self optional: [
			self token: IntegerToken].
		self token: BarToken]! !

! TestParser methodsFor: 'accessing' !
parseSequenceRule

	self sequence: [
		self token: IntegerToken;
			token: BinaryToken;
			token: WordToken]! !

! TestParser methodsFor: 'accessing' !
parseZeroOrMoreRule

	self sequence: [
		self zeroOrMore: [
			self token: IntegerToken].
		self token: BarToken]! !

! Token methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset! !

! Token methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject! !

! Token methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset! !

! Token methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject! !

! Token methodsFor: 'accessing' !
value

	^value! !

! Token methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! Token methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream space; print: self value printString! !

! CompoundWordToken methodsFor: 'accessing' !
words

	^self value! !

! TokenNode methodsFor: 'accessing' !
token

	^token! !

! TokenNode methodsFor: 'accessing' !
token: anObject

	token := anObject.
	startSourceOffset := token startSourceOffset.
	endSourceOffset := token endSourceOffset! !

! TokenNode methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream space nextPutAll: self token printString! !

! TokenNode class methodsFor: 'instance creation' !
token: anObject

	^(self new)
		token: anObject;
		yourself! !

! TokenRule methodsFor: 'matching' !
token: aClass

	(self tokenStream peek isMemberOf: aClass)
		ifFalse: [^self fail].
	
	self result: (TokenNode token: self tokenStream next).
	self pass! !

! UnaryHeaderNode methodsFor: 'accessing' !
selector

	^selector! !

! UnaryHeaderNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! UnaryHeaderNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitUnaryHeader: self! !

! UnaryHeaderNode class methodsFor: 'instance creation' !
selector: aToken

	^self new
		selector: aToken;
		yourself! !

! UnaryMessageNode methodsFor: 'accessing' !
arguments

	^#()! !

! UnaryMessageNode methodsFor: 'accessing' !
receiver

	^receiver! !

! UnaryMessageNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject! !

! UnaryMessageNode methodsFor: 'accessing' !
selector

	^selector! !

! UnaryMessageNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! UnaryMessageNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitMessageNodeStart: self.
	self receiver ifNotNil: [self receiver acceptVisitor: anObject].
	anObject visitMessageNodeEnd: self! !

! UnaryMessageNode class methodsFor: 'instance creation' !
receiver: anObject selector: aToken

	^self new
		receiver: anObject;
		selector: aToken;
		yourself! !

! UnaryMessageNode class methodsFor: 'instance creation' !
selector: aToken

	^self new
		selector: aToken;
		yourself! !

! ValueNode methodsFor: 'accessing' !
value

	^value! !

! ValueNode methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! ValueNode class methodsFor: 'instance creation' !
value: anObject

	^self new
		value: anObject;
		yourself! !

! LiteralNode methodsFor: 'printing' !
isLiteralNode

	^true! !

! LiteralNode methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream space.
	self value printOn: aStream! !

! LiteralNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitLiteralNode: self! !

! BlockLiteralNode methodsFor: 'testing' !
isBlockLiteralNode

	^true! !

! BlockLiteralNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBlockLiteralNode: self value.! !

! SpecialNode methodsFor: 'accessing' !
special

	^special! !

! SpecialNode methodsFor: 'accessing' !
special: anObject

	special := anObject! !

! SpecialNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitSpecialNode: self! !

! SpecialNode class methodsFor: 'instance creation' !
special: aToken

	^self new
		special: aToken;
		yourself! !

! Variable methodsFor: 'accessing' !
variableName

	^variableName! !

! Variable methodsFor: 'accessing' !
variableName: anObject

	variableName := anObject! !

! Variable methodsFor: 'comparing' !
= aVariable

	aVariable class = self class ifFalse: [^false].
	^self variableName = aVariable variableName! !

! Variable methodsFor: 'comparing' !
hash

	^self variableName hash! !

! Variable methodsFor: 'initialize-release' !
initialize! !

! Variable methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' named: ';
		print: self variableName! !

! Variable methodsFor: 'testing' !
isGlobalVariable

	^false! !

! Variable methodsFor: 'testing' !
isIndirectList

	^false! !

! Variable methodsFor: 'testing' !
isIndirectVariableList

	^false! !

! Variable methodsFor: 'testing' !
isInstanceVariable

	^false! !

! Variable methodsFor: 'testing' !
isLocalVariable

	^false! !

! Variable methodsFor: 'testing' !
isReturnContext

	^false! !

! Variable methodsFor: 'testing' !
isSelf

	^false! !

! Variable class methodsFor: 'instance creation' !
named: aSymbol

	^self new
		variableName: aSymbol asSymbol;
		yourself! !

! Variable class methodsFor: 'instance creation' !
new

	^super new initialize! !

! GlobalVariable methodsFor: 'testing' !
isGlobalVariable

	^true! !

! InstanceVariable methodsFor: 'testing' !
isInstanceVariable

	^true! !

! LocalVariable methodsFor: 'accessing' !
indirect

	^indirect! !

! LocalVariable methodsFor: 'accessing' !
indirect: anObject

	indirect := anObject! !

! LocalVariable methodsFor: 'accessing' !
isArgument

	^isArgument! !

! LocalVariable methodsFor: 'accessing' !
isArgument: anObject

	isArgument := anObject! !

! LocalVariable methodsFor: 'accessing' !
scope

	^scope! !

! LocalVariable methodsFor: 'accessing' !
scope: anObject

	scope := anObject.
	scopeNumber := anObject scopeNumber! !

! LocalVariable methodsFor: 'accessing' !
scopeNumber

	^scopeNumber! !

! LocalVariable methodsFor: 'accessing' !
scopeNumber: anObject

	scopeNumber := anObject! !

! LocalVariable methodsFor: 'initialize-release' !
initialize

	self indirect: false.
	self isArgument: false! !

! LocalVariable methodsFor: 'testing' !
isLocalVariable

	^true! !

! LocalVariable class methodsFor: 'instance creation' !
argumentNamed: aSymbol

	^(self named: aSymbol)
		isArgument: true;
		yourself! !

! NamespaceVariable methodsFor: 'accessing' !
namespaceComponents

	^namespaceComponents! !

! NamespaceVariable methodsFor: 'accessing' !
namespaceComponents: anObject

	namespaceComponents := anObject! !

! SelfVariable methodsFor: 'accessing' !
variableName

	^'self'! !

! SelfVariable methodsFor: 'testing' !
isSelf

	^true! !

! WordToken methodsFor: 'accessing' !
words

	^Array with: self value! !

! ZeroOrMoreParserRule methodsFor: 'accessing' !
nodes

	^nodes! !

! ZeroOrMoreParserRule methodsFor: 'accessing' !
nodes: anObject

	nodes := anObject! !

! ZeroOrMoreParserRule methodsFor: 'accessing' !
passed

	^passed! !

! ZeroOrMoreParserRule methodsFor: 'accessing' !
passed: anObject

	passed := anObject! !

! ZeroOrMoreParserRule methodsFor: 'initialize-release' !
initialize

	self nodes: OrderedCollection new! !

! ZeroOrMoreParserRule methodsFor: 'pass and fail' !
fail: aRule

	self passed: false.
	super fail: aRule! !

! ZeroOrMoreParserRule methodsFor: 'pass and fail' !
pass: aRule

	aRule result ifNotNil: [self nodes add: aRule result].
	self passed: true.
	self tokenStream: aRule tokenStream! !

! ZeroOrMoreParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self result: (SequenceNode sequence: self nodes).
	self pass! !

! ZeroOrMoreParserRule methodsFor: 'rules' !
process: aBlock

	[aBlock value. self passed] whileTrue: [].
	self finished! !

! ZeroOrMoreParserRule class methodsFor: 'instance creation' !
new

	^super new initialize! !

! ClassCreator methodsFor: 'creating' !
recompileClass

	oldClass selectors do: [:selector |
		SmalltalkParser
			quietRecompileMethod: (oldClass compiledMethodAt: selector) inClass: newClass].

	oldClass class selectors do: [:selector |
		SmalltalkParser
			quietRecompileMethod: (oldClass class compiledMethodAt: selector) inClass: newClass class]

! !

KitManager default currentKit addMethod: (ClassCreator compiledMethodAt: #recompileClass) !

! ClassDescription methodsFor: 'fileIn/Out' !
methodsFor: aString

	^ClassFileinReader new
		targetClass: self;
		organization: aString;
		yourself! !

KitManager default currentKit addMethod: (ClassDescription compiledMethodAt: #methodsFor:) !

! CompiledCode methodsFor: 'accessing' !
decompile

	^Decompiler new
		literals: self literals;
		targetClass: self mclass;
		numberOfTemporaries: self numberOfTemporaries;
		numberOfArguments: self numberOfArguments;
		numberOfCopiedVariables: 0;
		decompile: self bytecodes! !

KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #decompile) !

! CompiledCode methodsFor: 'accessing' !
decompileNoBytes

	^Decompiler new
		literals: self literals;
		targetClass: self mclass;
		numberOfTemporaries: self numberOfTemporaries;
		numberOfArguments: self numberOfArguments;
		numberOfCopiedVariables: 0;
		decompileNoBytes: self bytecodes! !

KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #decompileNoBytes) !

! CompiledCode methodsFor: 'accessing' !
decompileSingleBytecodeStartingAt: offset

	^Decompiler new
		literals: self literals;
		targetClass: self mclass;
		numberOfTemporaries: self numberOfTemporaries;
		numberOfArguments: self numberOfArguments;
		numberOfCopiedVariables: 0;
		decompileSingleBytecodeFrom: self bytecodes startingAt: offset ! !

KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #decompileSingleBytecodeStartingAt:) !

! CompiledCode methodsFor: 'accessing' !
polymorphicInlineCache

	^polymorphicInlineCache! !

KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #polymorphicInlineCache) !

! CompiledCode methodsFor: 'accessing' !
polymorphicInlineCache: anObject

	polymorphicInlineCache := anObject! !

KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #polymorphicInlineCache:) !

! CompiledCode methodsFor: 'accessing' !
sourceOffsetsDictionaryForNonCurrentFrame

	| dictionary |
	dictionary := Dictionary new.
	4 to: self sourceOffsets size by: 3 do: [:index |
		| pcOffset spec |
		pcOffset := self sourceOffsets at: index.
		spec := (CodeGenerator bytecodesByIndex at: (bytecodes at: pcOffset + 1) + 1).
		dictionary
			at: pcOffset + (spec argumentSpec at: 2)
			put: (Array
					with: (self sourceOffsets at: index + 1)
					with: (self sourceOffsets at: index + 2))].
	^dictionary! !

KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #sourceOffsetsDictionaryForNonCurrentFrame) !

KitManager default currentKit allDefinedClasses: #(ArrayLiteralToken AssignToken BarToken BinaryHeaderNode BinaryMessageNode BinaryToken BlockArgumentToken BlockLiteralNode BlockNode BlockParameterListNode ByteArrayLiteralToken BytecodeSpec CascadeNode CharacterToken ClassFileinReader CloseBraceToken CloseParenthesisToken CloseSquareBracketToken CodeContext CodeGenerator CodeSimulator ColonToken CommaToken CommandHandler CompileError CompileWarning CompoundWordToken DecompileStream Decompiler DevelopmentCommandHandler ErrorToken FileinReader FloatToken GlobalVariable GlobalVariableAssignmentNode GlobalVariableReferenceNode IndirectVariableList InstanceVariable InstanceVariableAssignmentNode InstanceVariableReferenceNode IntegerToken JSONLexicalAnalyzer JSONParser KeywordHeaderNode KeywordMessageNode KeywordToken LeftAngleToken LexicalAnalyzer LiteralNode LocalVariable LocalVariableAssignmentNode LocalVariableReferenceNode MethodLocalVariableAnalysisVisitor MethodNode NamespaceVariable NamespaceVariableAssignmentNode NamespaceVariableReferenceNode ObjectNode OneOfParserRule OneOrMoreParserRule OpenBraceToken OpenParenthesisToken OpenSquareBracketToken OptionalParserRule ParenthesisNode ParseMethodRule ParseTreeNode ParseTreeVisitor Parser ParserRule PeriodToken PragmaNode ReturnNode ReturnToken RightAngleToken RootRule Scope ScopeAnalysisResult SelfVariable SemicolonToken SequenceNode SequenceParserRule SmalltalkLexicalAnalyzer SmalltalkParser SpecialNode SpecialWordToken StatementListNode StringToken SymbolToken TempVarListNode TestParser Token TokenNode TokenRule UnaryHeaderNode UnaryMessageNode ValueNode Variable WordToken ZeroOrMoreParserRule) andMethods: #(#(ClassCreator #recompileClass) #(ClassDescription #'methodsFor:') #(CompiledCode #decompile) #(CompiledCode #decompileNoBytes) #(CompiledCode #'decompileSingleBytecodeStartingAt:') #(CompiledCode #polymorphicInlineCache) #(CompiledCode #'polymorphicInlineCache:') #(CompiledCode #sourceOffsetsDictionaryForNonCurrentFrame)) !

KitManager default currentKit allDefinedMethodsFor: CompileError methods: #(#endSourceOffset #'endSourceOffset:' #startSourceOffset #'startSourceOffset:') !

KitManager default currentKit allDefinedMethodsFor: CompileError class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Variable methods: #(#'=' #hash #initialize #isGlobalVariable #isIndirectList #isIndirectVariableList #isInstanceVariable #isLocalVariable #isReturnContext #isSelf #'printOn:' #variableName #'variableName:') !

KitManager default currentKit allDefinedMethodsFor: Variable class methods: #(#'named:' #new) !

KitManager default currentKit allDefinedMethodsFor: NamespaceVariable methods: #(#namespaceComponents #'namespaceComponents:') !

KitManager default currentKit allDefinedMethodsFor: NamespaceVariable class methods: #() !

KitManager default currentKit allDefinedMethodsFor: InstanceVariable methods: #(#isInstanceVariable) !

KitManager default currentKit allDefinedMethodsFor: InstanceVariable class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LocalVariable methods: #(#indirect #'indirect:' #initialize #isArgument #'isArgument:' #isLocalVariable #scope #'scope:' #scopeNumber #'scopeNumber:') !

KitManager default currentKit allDefinedMethodsFor: LocalVariable class methods: #(#'argumentNamed:') !

KitManager default currentKit allDefinedMethodsFor: SelfVariable methods: #(#isSelf #variableName) !

KitManager default currentKit allDefinedMethodsFor: SelfVariable class methods: #() !

KitManager default currentKit allDefinedMethodsFor: GlobalVariable methods: #(#isGlobalVariable) !

KitManager default currentKit allDefinedMethodsFor: GlobalVariable class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ParseTreeNode methods: #(#'acceptVisitor:' #endSourceOffset #'endSourceOffset:' #isBinaryHeaderNode #isBinaryMessageNode #isBlockLiteralNode #isBlockNode #isBlockParameterListNode #isCascadeNode #isKeywordHeaderNode #isKeywordMessageNode #isLiteralNode #isMethodNode #isParenthesisNode #isSequence #startSourceOffset #'startSourceOffset:') !

KitManager default currentKit allDefinedMethodsFor: ParseTreeNode class methods: #(#'on:') !

KitManager default currentKit allDefinedMethodsFor: KeywordHeaderNode methods: #(#'acceptVisitor:' #arguments #'arguments:' #isKeywordHeaderNode #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: KeywordHeaderNode class methods: #(#'selector:arguments:') !

KitManager default currentKit allDefinedMethodsFor: NamespaceVariableReferenceNode methods: #(#'acceptVisitor:' #nameComponents #'nameComponents:') !

KitManager default currentKit allDefinedMethodsFor: NamespaceVariableReferenceNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: UnaryMessageNode methods: #(#'acceptVisitor:' #arguments #receiver #'receiver:' #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: UnaryMessageNode class methods: #(#'receiver:selector:' #'selector:') !

KitManager default currentKit allDefinedMethodsFor: BlockNode methods: #(#'acceptVisitor:' #'addVariableAssignment:' #'addVariableReference:' #arguments #'arguments:' #hasReturn #'hasReturn:' #isBlockNode #parent #'parent:' #scope #'scope:' #statements #'statements:') !

KitManager default currentKit allDefinedMethodsFor: BlockNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: PragmaNode methods: #(#'acceptVisitor:' #arguments #'arguments:' #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: PragmaNode class methods: #(#'selector:arguments:') !

KitManager default currentKit allDefinedMethodsFor: CascadeNode methods: #(#'acceptVisitor:' #isCascadeNode #messages #'messages:' #receiver #'receiver:') !

KitManager default currentKit allDefinedMethodsFor: CascadeNode class methods: #(#'receiver:messages:') !

KitManager default currentKit allDefinedMethodsFor: LocalVariableReferenceNode methods: #(#'acceptVisitor:' #scopeNumber #'scopeNumber:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: LocalVariableReferenceNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: NamespaceVariableAssignmentNode methods: #(#'acceptVisitor:' #nameComponents #'nameComponents:' #value #'value:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: NamespaceVariableAssignmentNode class methods: #(#'nameComponents:value:' #'variable:value:') !

KitManager default currentKit allDefinedMethodsFor: TokenNode methods: #(#'printOn:' #token #'token:') !

KitManager default currentKit allDefinedMethodsFor: TokenNode class methods: #(#'token:') !

KitManager default currentKit allDefinedMethodsFor: BinaryMessageNode methods: #(#'acceptVisitor:' #argument #'argument:' #arguments #isBinaryMessageNode #receiver #'receiver:' #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: BinaryMessageNode class methods: #(#'receiver:selector:argument:' #'receiver:selector:argument:startSourceOffset:endSourceOffset:' #'selector:argument:') !

KitManager default currentKit allDefinedMethodsFor: LocalVariableAssignmentNode methods: #(#'acceptVisitor:' #value #'value:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: LocalVariableAssignmentNode class methods: #(#'variable:value:') !

KitManager default currentKit allDefinedMethodsFor: KeywordMessageNode methods: #(#'acceptVisitor:' #arguments #'arguments:' #'isInlinedSelector:' #isKeywordMessageNode #receiver #'receiver:' #selector #'selector:' #'visitIfFalse:' #'visitIfFalseIfTrue:' #'visitIfTrue:' #'visitIfTrueIfFalse:' #'visitInlinedObject:' #'visitWhileFalse:' #'visitWhileTrue:') !

KitManager default currentKit allDefinedMethodsFor: KeywordMessageNode class methods: #(#'receiver:selector:arguments:' #'selector:arguments:') !

KitManager default currentKit allDefinedMethodsFor: BinaryHeaderNode methods: #(#'acceptVisitor:' #argument #'argument:' #isBinaryHeaderNode #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: BinaryHeaderNode class methods: #(#'selector:argument:') !

KitManager default currentKit allDefinedMethodsFor: GlobalVariableReferenceNode methods: #(#'acceptVisitor:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: GlobalVariableReferenceNode class methods: #(#'variable:') !

KitManager default currentKit allDefinedMethodsFor: InstanceVariableAssignmentNode methods: #(#'acceptVisitor:' #value #'value:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: InstanceVariableAssignmentNode class methods: #(#'variable:value:') !

KitManager default currentKit allDefinedMethodsFor: GlobalVariableAssignmentNode methods: #(#'acceptVisitor:' #value #'value:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: GlobalVariableAssignmentNode class methods: #(#'variable:value:') !

KitManager default currentKit allDefinedMethodsFor: ReturnNode methods: #(#'acceptVisitor:' #returnLevel #'returnLevel:' #value #'value:') !

KitManager default currentKit allDefinedMethodsFor: ReturnNode class methods: #(#'value:') !

KitManager default currentKit allDefinedMethodsFor: BlockParameterListNode methods: #(#'acceptVisitor:' #isBlockParameterListNode #variables #'variables:') !

KitManager default currentKit allDefinedMethodsFor: BlockParameterListNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: MethodNode methods: #(#'acceptVisitor:' #body #'body:' #header #'header:' #isMethodNode #pragmas #'pragmas:') !

KitManager default currentKit allDefinedMethodsFor: MethodNode class methods: #(#'header:body:' #'header:pragmas:body:') !

KitManager default currentKit allDefinedMethodsFor: TempVarListNode methods: #(#variableNames #variables #'variables:') !

KitManager default currentKit allDefinedMethodsFor: TempVarListNode class methods: #(#'variables:') !

KitManager default currentKit allDefinedMethodsFor: SequenceNode methods: #(#isSequence #sequence #'sequence:') !

KitManager default currentKit allDefinedMethodsFor: SequenceNode class methods: #(#'sequence:') !

KitManager default currentKit allDefinedMethodsFor: ParenthesisNode methods: #(#'acceptVisitor:' #expression #'expression:' #isParenthesisNode) !

KitManager default currentKit allDefinedMethodsFor: ParenthesisNode class methods: #(#'expression:') !

KitManager default currentKit allDefinedMethodsFor: StatementListNode methods: #(#'acceptVisitor:' #statements #'statements:' #variables #'variables:') !

KitManager default currentKit allDefinedMethodsFor: StatementListNode class methods: #(#'statements:' #'variables:statements:') !

KitManager default currentKit allDefinedMethodsFor: InstanceVariableReferenceNode methods: #(#'acceptVisitor:' #variable #'variable:') !

KitManager default currentKit allDefinedMethodsFor: InstanceVariableReferenceNode class methods: #(#'variable:') !

KitManager default currentKit allDefinedMethodsFor: ValueNode methods: #(#value #'value:') !

KitManager default currentKit allDefinedMethodsFor: ValueNode class methods: #(#'value:') !

KitManager default currentKit allDefinedMethodsFor: ObjectNode methods: #() !

KitManager default currentKit allDefinedMethodsFor: ObjectNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LiteralNode methods: #(#'acceptVisitor:' #isLiteralNode #'printOn:') !

KitManager default currentKit allDefinedMethodsFor: LiteralNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: BlockLiteralNode methods: #(#'acceptVisitor:' #isBlockLiteralNode) !

KitManager default currentKit allDefinedMethodsFor: BlockLiteralNode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SpecialNode methods: #(#'acceptVisitor:' #special #'special:') !

KitManager default currentKit allDefinedMethodsFor: SpecialNode class methods: #(#'special:') !

KitManager default currentKit allDefinedMethodsFor: IndirectVariableList methods: #(#initialize #isIndirectList #isIndirectVariableList #isReturnContext #isSelf #'printOn:' #variables #'variables:') !

KitManager default currentKit allDefinedMethodsFor: IndirectVariableList class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: Scope methods: #(#'addScope:' #'addVariable:' #'addVariables:' #childScopes #'childScopes:' #initialize #parentScope #'parentScope:' #scopeNumber #'scopeNumber:' #'variableNamed:' #'variableNumber:' #variables #'variables:') !

KitManager default currentKit allDefinedMethodsFor: Scope class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: LexicalAnalyzer methods: #(#advance #'captureOffsetsIn:creating:' #endSourceOffset #'endSourceOffset:' #finishedCharacter #'isDigit:radix:' #next #next2 #'next2:' #'next:' #nextCharacter #nextToken #position #'position:' #'reportError:start:end:' #skipComment #skipSeparator #skipSeparators #start #startSourceOffset #'startSourceOffset:' #stream #'stream:' #tokens) !

KitManager default currentKit allDefinedMethodsFor: LexicalAnalyzer class methods: #(#'on:') !

KitManager default currentKit allDefinedMethodsFor: ParserRule methods: #(#'choice:' #'commitAndFailWithMessage:if:' #'commitWithMessage:if:' #errorString #'errorString:' #fail #'fail:' #finished #parentRule #'parentRule:' #'parse:' #parser #'parser:' #pass #'pass:' #'process:' #'produce:' #produceBlock #'produceBlock:' #result #'result:' #tokenStream #'tokenStream:') !

KitManager default currentKit allDefinedMethodsFor: ParserRule class methods: #() !

KitManager default currentKit allDefinedMethodsFor: OneOrMoreParserRule methods: #(#'fail:' #finished #initialize #nodes #'nodes:' #'pass:' #passed #'passed:' #'process:') !

KitManager default currentKit allDefinedMethodsFor: OneOrMoreParserRule class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: ZeroOrMoreParserRule methods: #(#'fail:' #finished #initialize #nodes #'nodes:' #'pass:' #passed #'passed:' #'process:') !

KitManager default currentKit allDefinedMethodsFor: ZeroOrMoreParserRule class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: OneOfParserRule methods: #(#'choice:' #finished #'pass:') !

KitManager default currentKit allDefinedMethodsFor: OneOfParserRule class methods: #() !

KitManager default currentKit allDefinedMethodsFor: OptionalParserRule methods: #(#'choice:' #finished #'pass:') !

KitManager default currentKit allDefinedMethodsFor: OptionalParserRule class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SequenceParserRule methods: #(#allPassedSoFar #'choice:' #'errorString:' #'fail:' #finished #initialize #lastZeroOrMoreProducedResult #'parse:' #'pass:' #rulesRun #'rulesRun:' #sequence #'sequence:' #tokensToExpect) !

KitManager default currentKit allDefinedMethodsFor: SequenceParserRule class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: TokenRule methods: #(#'token:') !

KitManager default currentKit allDefinedMethodsFor: TokenRule class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ParseMethodRule methods: #(#pass) !

KitManager default currentKit allDefinedMethodsFor: ParseMethodRule class methods: #() !

KitManager default currentKit allDefinedMethodsFor: RootRule methods: #(#pass #'pass:') !

KitManager default currentKit allDefinedMethodsFor: RootRule class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Token methods: #(#endSourceOffset #'endSourceOffset:' #'printOn:' #startSourceOffset #'startSourceOffset:' #value #'value:') !

KitManager default currentKit allDefinedMethodsFor: Token class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LeftAngleToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: LeftAngleToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ArrayLiteralToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: ArrayLiteralToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: BarToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: BarToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CloseSquareBracketToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: CloseSquareBracketToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ErrorToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: ErrorToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CharacterToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: CharacterToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SemicolonToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: SemicolonToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ByteArrayLiteralToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: ByteArrayLiteralToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: AssignToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: AssignToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: KeywordToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: KeywordToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SymbolToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: SymbolToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SpecialWordToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: SpecialWordToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ReturnToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: ReturnToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: StringToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: StringToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: RightAngleToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: RightAngleToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CloseParenthesisToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: CloseParenthesisToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: WordToken methods: #(#words) !

KitManager default currentKit allDefinedMethodsFor: WordToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: OpenParenthesisToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: OpenParenthesisToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: OpenSquareBracketToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: OpenSquareBracketToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: BinaryToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: BinaryToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CompoundWordToken methods: #(#words) !

KitManager default currentKit allDefinedMethodsFor: CompoundWordToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: FloatToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: FloatToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: PeriodToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: PeriodToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: BlockArgumentToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: BlockArgumentToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: IntegerToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: IntegerToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ScopeAnalysisResult methods: #(#'addArgument:' #'addCopiedVariable:' #'addTemporaryVariable:' #allLocals #arguments #'arguments:' #children #'children:' #copiedVariables #'copiedVariables:' #'definesVariable:' #hasReturn #'hasReturn:' #indirectVariables #'indirectVariables:' #initialize #localVariableNames #localVariables #localsNeeded #'makeIndirect:inScope:' #markReturns #node #'node:' #numberOfArguments #parent #'parent:' #temporaryVariables #'temporaryVariables:' #'variableNumberOf:') !

KitManager default currentKit allDefinedMethodsFor: ScopeAnalysisResult class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: BytecodeSpec methods: #(#argumentSpec #'argumentSpec:' #decompileString #'decompileString:' #name #'name:' #number #'number:' #numberOfBytes #'numberOfBytes:' #'printOn:' #type #'type:') !

KitManager default currentKit allDefinedMethodsFor: BytecodeSpec class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Decompiler methods: #(#decompile #'decompile:' #decompileNextBytecode #decompileNoBytes #'decompileNoBytes:' #decompileSingleBytecode #'decompileSingleBytecodeFrom:startingAt:' #finishLine #finishLineNoBytes #initialize #literals #'literals:' #numberOfArguments #'numberOfArguments:' #numberOfCopiedVariables #'numberOfCopiedVariables:' #numberOfTemporaries #'numberOfTemporaries:' #'readEscapeSequenceFrom:' #resetLineStreams #result #targetClass #'targetClass:' #writeHeader #writeNextBytecode #writeOffset) !

KitManager default currentKit allDefinedMethodsFor: Decompiler class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: ParseTreeVisitor methods: #(#initialize #'visit:' #'visitArgument:' #'visitBinaryHeader:' #'visitBlockLiteralNode:' #'visitBlockNode:' #'visitBlockNodeStart:' #'visitBlockParameterListNode:' #'visitCascadeEnd:' #'visitCascadeInterMessage:' #'visitCascadeStart:' #'visitEmptyMethodNode:' #visitEmptyStatements #'visitGlobalVariableAssignmentNode:' #'visitGlobalVariableReferenceNode:' #'visitIfFalseBlock:' #'visitIfFalseBlock:ifTrueBlock:' #'visitIfTrueBlock:' #'visitIfTrueBlock:ifFalseBlock:' #'visitInstanceVariableAssignmentNode:' #'visitInstanceVariableReferenceNode:' #'visitKeywordHeader:' #'visitLiteralNode:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMessageNode:' #'visitMessageNodeEnd:' #'visitMessageNodeStart:' #'visitMethodNode:' #'visitMethodNodeStart:' #'visitNamespaceVariableAssignmentNode:' #'visitNamespaceVariableReferenceNode:' #'visitPragma:' #'visitReceiver:' #'visitReturnNode:' #'visitSpecialNode:' #'visitStatementList:' #visitStatementListEnd #'visitStatementListEnd:' #'visitStatementListStart:' #visitStatementSeparator #'visitUnaryHeader:' #'visitWhileFalseBlock:doBlock:' #'visitWhileTrueBlock:doBlock:') !

KitManager default currentKit allDefinedMethodsFor: ParseTreeVisitor class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: MethodLocalVariableAnalysisVisitor methods: #(#'argumentsFor:' #'copiedVariablesFor:' #declareSelf #'endBlockNode:' #'findVariableDefinition:' #initialize #'localsNeededFor:' #'localsToCopyFor:' #numArgs #numTempsOnly #rootNode #'rootNode:' #'scopeFor:' #scopeStack #'scopeStack:' #scopes #'scopes:' #'startBlockNode:' #'temporariesFor:' #'variableNumberOf:' #'variableNumberOf:inNode:' #'visitBinaryHeader:' #'visitBlockLiteralNode:' #'visitBlockNode:' #'visitBlockParameterListNode:' #'visitInstanceVariableAssignmentNode:' #'visitInstanceVariableReferenceNode:' #'visitKeywordHeader:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMethodNodeStart:' #'visitReturnNode:' #'visitSpecialNode:' #'visitStatementListStart:') !

KitManager default currentKit allDefinedMethodsFor: MethodLocalVariableAnalysisVisitor class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CodeGenerator methods: #(#'addBytecode:' #addDup #'addGlobalDictionary:' #'addLiteral:' #addPop #bytecodeBlockReturn #bytecodeCallOneByte #bytecodeCallOneByteSuper #bytecodeCallShort #bytecodeCallShortSuper #bytecodeCallSuperTwoBytes #bytecodeCallTwoBytes #bytecodeCallWellKnown #bytecodeDropCascadeReceiver #bytecodeDup #'bytecodeFor:' #bytecodeJumpIfFalseOneByte #bytecodeJumpIfFalseTwoBytes #bytecodeJumpIfTrueOneByte #bytecodeJumpIfTrueTwoBytes #bytecodeJumpOneByte #bytecodeJumpTwoBytes #bytecodeNonLocalReturn #bytecodePop #bytecodePrimitive #bytecodePrimitiveReturn #bytecodePushCopyingBlock #bytecodePushFalse #bytecodePushFourByteInteger #bytecodePushFullBlock #bytecodePushLocalIndirect #bytecodePushNil #bytecodePushOneByteGlobal #bytecodePushOneByteInstanceVariable #bytecodePushOneByteInteger #bytecodePushOneByteLiteral #bytecodePushOneByteLocalVariable #bytecodePushSelf #bytecodePushSelfInstvarIndirect #bytecodePushShortGlobal #bytecodePushShortInstanceVariable #bytecodePushShortLocalVariable #bytecodePushSmallLiteral #bytecodePushSmallNegativeInteger #bytecodePushSmallPositiveInteger #bytecodePushThisContext #bytecodePushTrue #bytecodePushTwoByteGlobal #bytecodePushTwoByteInstanceVariable #bytecodePushTwoByteInteger #bytecodePushTwoByteLiteral #bytecodeReturn #bytecodeStoreLocalIndirect #bytecodeStoreNewArray #bytecodeStoreOneByteGlobal #bytecodeStoreOneByteInstanceVariable #bytecodeStoreOneByteLocalVariable #bytecodeStoreSelfInstvarIndirect #bytecodeStoreShortGlobalVariable #bytecodeStoreShortInstanceVariable #bytecodeStoreShortLocalVariable #bytecodeStoreTwoByteGlobalVariable #bytecodeStoreTwoByteInstanceVariable #bytecodeStoreTwoByteLocalVariable #bytecodeStream #'bytecodeStream:' #bytecodes #'callLiteral:args:' #'callOffsetsDo:' #'callOneByteLiteral:args:' #'callShortLiteral:args:' #'callSpecialSelector:' #'callSuperLiteral:args:' #'callSuperOneByteLiteral:args:' #'callSuperShortLiteral:args:' #'callSuperTwoByteLiteral:args:' #'callTwoByteLiteral:args:' #'compileError:' #'compileError:node:' #'compileWarning:' #'compileWarning:node:' #'createBlockFor:variablesToCopy:' #decompile #decompileNoBytes #'globalAssociationFor:' #globalDictionaries #'globalDictionaries:' #hasReturned #'hasReturned:' #initialize #'isGlobalVariable:' #isInlined #isInlinedBlock #'isInlinedBlock:' #'isInstanceVariable:' #'isLocalVariable:' #'isNamespaceGlobal:' #'isSpecialSelector:' #literals #'literals:' #method #methodLocalVariableAnalysis #'methodLocalVariableAnalysis:' #'namespaceGlobalAssociationFor:' #nodeStack #'nodeStack:' #numberOfSends #outerMethod #'outerMethod:' #popNode #pragmas #'pragmas:' #pushCopiedSelf #'pushCopyBlock:variablesToCopy:' #pushFalse #'pushFourByteInteger:' #'pushFullBlock:variablesToCopy:' #'pushGlobalReference:' #'pushGlobalReference:node:' #'pushIndirectLocalVariableReference:' #'pushIndirectVariableArrayFor:' #'pushInstVarReference:' #'pushInteger:' #'pushLiteral:' #'pushLocalVariableNumber:' #'pushLocalVariableReference:' #'pushNamespaceGlobalReference:' #pushNil #'pushNode:' #'pushOneByteGlobal:' #'pushOneByteInstVar:' #'pushOneByteInteger:' #'pushOneByteLiteral:' #'pushOneByteLocalVar:' #pushReturn #pushSelf #'pushSelfInstanceVariableReference:' #'pushShortGlobal:' #'pushShortInstVar:' #'pushShortLiteral:' #'pushShortLocalVar:' #'pushSmallNegativeInteger:' #'pushSmallPositiveInteger:' #pushThisContext #pushTrue #'pushTwoByteGlobal:' #'pushTwoByteInstVar:' #'pushTwoByteInteger:' #'pushTwoByteLiteral:' #'recordSourceOffsetsFor:' #returnLevel #'returnLevel:' #selector #'selector:' #selfVariable #sourceOffsets #'sourceOffsets:' #'storeGlobalVariableAssignment:node:' #'storeIndirectLocalVariableAssignment:' #'storeInstanceVariableAssignment:' #'storeLocalVariableAssignment:' #'storeNamespaceGlobalAssignment:' #'storeOneByteGlobal:' #'storeOneByteInstanceVariable:' #'storeOneByteLocalVar:' #'storeSelfInstvarAssignment:' #'storeShortGlobal:' #'storeShortInstanceVariable:' #'storeShortLocalVar:' #'storeTwoByteGlobal:' #'storeTwoByteInstanceVariable:' #'storeTwoByteLocalVar:' #targetClass #'targetClass:' #'visitArgument:' #'visitBinaryHeader:' #'visitBlockLiteralNode:' #'visitBlockNode:' #'visitBlockNodeStart:' #'visitBlockParameterListNode:' #'visitCascadeEnd:' #'visitCascadeInterMessage:' #'visitCascadeStart:' #'visitEmptyMethodNode:' #visitEmptyStatements #'visitGlobalVariableAssignmentNode:' #'visitGlobalVariableReferenceNode:' #'visitIfFalseBlock:' #'visitIfFalseBlock:ifTrueBlock:' #'visitIfFalseBlock:ifTrueBlock:useLongJumps:' #'visitIfFalseBlock:useLongJumps:' #'visitIfTrueBlock:' #'visitIfTrueBlock:ifFalseBlock:' #'visitIfTrueBlock:ifFalseBlock:useLongJumps:' #'visitIfTrueBlock:useLongJumps:' #'visitInstanceVariableAssignmentNode:' #'visitInstanceVariableReferenceNode:' #'visitKeywordHeader:' #'visitLiteralNode:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMessageNodeEnd:' #'visitMessageNodeStart:' #'visitMethodNode:' #'visitMethodNodeStart:' #'visitNamespaceVariableAssignmentNode:' #'visitNamespaceVariableReferenceNode:' #'visitPragma:' #'visitReceiver:' #'visitReturnNode:' #'visitSpecialNode:' #'visitStatementListEnd:' #'visitStatementListStart:' #visitStatementSeparator #'visitUnaryHeader:' #'visitWhileFalseBlock:doBlock:' #'visitWhileFalseBlock:doBlock:useLongJumps:' #'visitWhileTrueBlock:doBlock:' #'visitWhileTrueBlock:doBlock:useLongJumps:' #'whileEmbeddedBlockDo:' #'writeLiteralsInto:' #'writePICInto:') !

KitManager default currentKit allDefinedMethodsFor: CodeGenerator class methods: #(#bytecodeTable #bytecodesByIndex #bytecodesByName #initialize #new #specialSelectors) !

KitManager default currentKit allDefinedMethodsFor: Parser methods: #(#atEnd #'commitAndFailWithMessage:if:' #'commitWithMessage:if:' #currentRule #'currentRule:' #errorMessage #fail #'initialRule:' #isFinished #isRootRule #'oneOf:' #'oneOrMore:' #'optional:' #'parse:' #pass #'process:' #'produce:' #result #'rule:' #'sequence:' #'token:' #'token:produce:' #'tokens:' #'zeroOrMore:') !

KitManager default currentKit allDefinedMethodsFor: Parser class methods: #() !

KitManager default currentKit allDefinedMethodsFor: TestParser methods: #(#parseOneOfRule #parseOneOrMoreRule #parseOptionalRule #parseSequenceRule #parseZeroOrMoreRule) !

KitManager default currentKit allDefinedMethodsFor: TestParser class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SmalltalkParser methods: #(#'addScope:' #'addScopeVariable:' #'buildAssignStatementList:' #'buildBinaryExpression:' #'buildBinaryMessageHeader:' #'buildBlock:' #'buildBlockParameters:' #'buildCascadeNode:' #'buildKeywordExpression:' #'buildKeywordMessageFrom:' #'buildKeywordMethodHeaderFrom:' #'buildLeftToRightBinaryExpression:' #'buildPragma:' #'buildPragmaMessage:' #'buildStatementBody:' #'buildTempVar:' #'buildUnaryMessageFor:' #'buildVariableAssignNode:' #'createVariableReferenceFor:' #currentMethodName #'currentMethodName:' #'expectToken:' #'findLocalVariableNamed:' #globalDictionaries #'globalDictionaries:' #initialize #'isGlobalVariable:' #'isInstanceVariable:' #'isLocalVariable:' #'isNamespaceVariable:' #newScope #parseAssignStatement #parseAssignStatementList #parseBinaryExpression #parseBinaryMethodHeader #parseBlock #parseBlockParams #parseCascadeExpression #parseCascadeMessage #parseExpression #parseKeywordExpression #parseKeywordMethodHeader #parseLeftToRightBinaryExpression #parseLiteral #parseMethod #parseMethodHeader #parseObject #parseParenthesisExpression #parsePragma #parseReturnStatement #parseStatementBody #parseStatementList #parseTempVars #parseUnaryExpression #parseUnaryMethodHeader #popScope #pragmaLiteral #pragmaMessage #'scopeAndLocalVariableFor:' #scopeStack #'scopeStack:' #scopes #'scopes:' #'stopExpectingToken:' #targetClass #'targetClass:' #tokensToExpect #'tokensToExpect:') !

KitManager default currentKit allDefinedMethodsFor: SmalltalkParser class methods: #(#'compile:inClass:organization:' #'debugIt:' #'evaluate:' #'evaluate:for:' #'fileoutMethod:forClass:on:' #'fileoutMethod:forClass:organization:on:' #'generateForClass:globals:methodString:organization:writeChangesInto:' #'generateForClass:globals:organization:methodString:' #'generateForClass:methodString:organization:' #new #'parseBlockBody:' #'parseBlockBodyString:' #'parseForClass:globals:method:' #'parseForClass:globals:methodString:' #'parseForClass:method:' #'parseForClass:methodString:' #'parseForClass:selector:' #'parseMethod:' #'parseMethodString:' #'quietGenerateForClass:globals:methodString:organization:' #'quietGenerateForClass:methodString:organization:' #'quietRecompileMethod:inClass:') !

KitManager default currentKit allDefinedMethodsFor: UnaryHeaderNode methods: #(#'acceptVisitor:' #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: UnaryHeaderNode class methods: #(#'selector:') !

KitManager default currentKit allDefinedMethodsFor: SmalltalkLexicalAnalyzer methods: #(#binaryCharacters #nextToken #parseArrayLiteral #parseAssignment #parseBar #parseBinary #parseBinarySymbolLiteral #parseBlockArgument #parseByteArrayLiteral #parseCharacterLiteral #parseCloseParenthesis #parseCloseSquareBracket #parseLeftAngle #parseNumber #parseOpenParenthesis #parseOpenSquareBracket #parsePeriod #parseQuotedSymbolLiteral #parseReturn #parseRightAngle #parseSemicolon #parseStringLiteral #parseSymbolLiteral #parseWord #readAlphaNumericWord #readArrayLiteralElement #readArrayLiteralElements #readBinary #readByteArrayLiteralElement #readByteArrayLiteralElements #'readCompoundWordOn:' #'readDecimalPart:' #readExponent #'readFloatStartingWith:' #'readFloatStartingWith:sign:' #readInteger #'readKeywordOn:' #readNumber #'readNumberRadix:' #readStringLiteral #readSubArrayLiteral #readSymbolWord #readWord #skipComment #skipSeparator #'wordTokenFor:') !

KitManager default currentKit allDefinedMethodsFor: SmalltalkLexicalAnalyzer class methods: #() !

KitManager default currentKit allDefinedMethodsFor: JSONLexicalAnalyzer methods: #(#nextToken #parseCloseBrace #parseCloseSquareBracket #parseColon #parseComma #parseNumber #parseOpenBrace #parseOpenSquareBracket #parseStringLiteral #parseWord #readAlphaNumericWord #'readDecimalPart:' #readExponent #'readFloatStartingWith:' #readInteger #readNumber #readStringLiteral #'readStringQuotedCharacterInto:' #readWord #skipSeparator #'wordTokenFor:') !

KitManager default currentKit allDefinedMethodsFor: JSONLexicalAnalyzer class methods: #() !

KitManager default currentKit allDefinedMethodsFor: FileinReader methods: #(#'captureCharacter:' #fileIn #fileInChunk #readChunk #'runDoit:' #stream #'stream:') !

KitManager default currentKit allDefinedMethodsFor: FileinReader class methods: #(#'fileIn:' #'on:') !

KitManager default currentKit allDefinedMethodsFor: OpenBraceToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: OpenBraceToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CloseBraceToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: CloseBraceToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ColonToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: ColonToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CommaToken methods: #() !

KitManager default currentKit allDefinedMethodsFor: CommaToken class methods: #() !

KitManager default currentKit allDefinedMethodsFor: JSONParser methods: #(#parseArray #parseDictionary #parseKeyValuePair #parseKeyValueSequence #parseObject #parseObjectSequence #parseOptionalKeyValueSequence #parsePrimitiveObject) !

KitManager default currentKit allDefinedMethodsFor: JSONParser class methods: #(#'evaluate:' #'evaluate:inSession:' #'evaluateJsonString:' #'parseString:') !

KitManager default currentKit allDefinedMethodsFor: ClassFileinReader methods: #(#'fileInFrom:' #'fixLineEndConventionsIn:' #organization #'organization:' #targetClass #'targetClass:') !

KitManager default currentKit allDefinedMethodsFor: ClassFileinReader class methods: #() !

KitManager default currentKit allDefinedMethodsFor: DecompileStream methods: #(#atEnd #byteStream #'byteStream:' #compiledCode #'compiledCode:' #next) !

KitManager default currentKit allDefinedMethodsFor: DecompileStream class methods: #(#'on:') !

KitManager default currentKit allDefinedMethodsFor: CompileWarning methods: #(#endSourceOffset #'endSourceOffset:' #startSourceOffset #'startSourceOffset:') !

KitManager default currentKit allDefinedMethodsFor: CompileWarning class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CodeContext methods: #(#allFrames #allLocalNames #'basicLocalAt:' #'basicLocalAt:put:' #contextId #'contextId:' #'doBytecode:' #dropCascadeReceiver #dup #'findCompiledMethod:startingAt:' #frame #'frame:' #getSelf #grow #initialize #isBlockContext #'jump:' #'jumpIfFalse:' #'jumpIfTrue:' #'localAt:' #method #'method:' #methodClass #methodContext #'methodContext:' #nextBytecode #nextFourBytecodes #nextFourSignedBytes #nextSignedByte #nextTwoBytecodes #nextTwoSignedBytes #pcOffset #'pcOffset:' #peek #'peek:' #peekBytecode #pop #'printOn:' #'push:' #'pushCopyingBlock:copiedVariables:' #'pushFullBlock:copiedVariables:' #'pushGlobal:' #'pushInstVar:' #'pushLiteral:' #'pushLocal:' #'pushLocal:indirect:' #pushSelf #'pushSelfInstVar:' #receiver #restart #rootContext #rootMethod #rootMethodClass #'rootSelfFor:' #sender #'stackAt:' #stackNames #stackOffset #'stackOffset:' #'storeGlobal:' #'storeInstVar:' #'storeLocal:' #'storeLocal:indirect:' #'storeNewArray:local:' #'storeSelfInstVar:' #walkback) !

KitManager default currentKit allDefinedMethodsFor: CodeContext class methods: #(#'bytecodeBlockAt:' #'bytecodeBlockAt:put:' #bytecodeBlocks #callReturnBytecodes #clearBytecodeBlocks #jumpBytecodes #new #pushGlobalBytecodes #pushInstVarBytecodes #pushIntegerBytecodes #pushLiteralBytecodes #pushLocalBytecodes #setupBytecodeBlocks #setupMiscBytecodes #storeGlobalBytecodes #storeInstVarBytecodes #storeLocalBytecodes) !

KitManager default currentKit allDefinedMethodsFor: CodeSimulator methods: #(#blockReturn #'buildFrameFor:' #'call:arguments:' #'callSelector:arguments:' #'callWellKnown:' #currentContext #'currentContext:' #frames #'frames:' #getMethodStartFrame #into #'invoke:on:selector:arguments:' #'invokeBlock:method:arguments:' #'isImportantBytecode:' #'isReturnBytecode:' #nonLocalReturn #over #primitiveReturn #reinvokeMethod #restart #return #returnToCurrentFrame #'returnToFrame:' #'runBytecode:' #runBytecodes #'runToContext:' #runToImportantBytecode #shouldContinueRunning #stepBytecode #stopFrame #'stopFrame:' #stopMethod #'stopMethod:' #'superCall:arguments:' #through) !

KitManager default currentKit allDefinedMethodsFor: CodeSimulator class methods: #(#headerSize) !

KitManager default currentKit allDefinedMethodsFor: CommandHandler methods: #(#'processMessage:onWebSocket:') !

KitManager default currentKit allDefinedMethodsFor: CommandHandler class methods: #() !

KitManager default currentKit allDefinedMethodsFor: DevelopmentCommandHandler methods: #(#'processMessage:onWebSocket:') !

KitManager default currentKit allDefinedMethodsFor: DevelopmentCommandHandler class methods: #() !

KitManager default finishFileinKit !
