KitManager default currentKitNamed: 'Core' !

KitManager default currentKit ensureLoaded: #() !

nil subclassNamed: #Object
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Association
	instVarNames: 'key value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Base64Encoder
	instVarNames: 'inputStream outputStream isFinished'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #BeagleSystem
	instVarNames: ''
	classInstVarNames: 'current imageName sourceFiles sourceFileNames specialSelectors'
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Behavior
	instVarNames: 'superclass methodDictionary flags subclasses instVarNames'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #BlockClosure
	instVarNames: 'method methodContext copiedValues'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Boolean
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #CachedValue
	instVarNames: 'value block'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #ClassCreator
	instVarNames: 'name oldClass newClass superclass instanceVariableNames classVariableNames classInstanceVariableNames flags environment kitName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Behavior subclassNamed: #ClassDescription
	instVarNames: 'organization'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ClassDescription subclassNamed: #Class
	instVarNames: 'name kit environment'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Collection
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object variableSubclassNamed: #CompiledCode
	instVarNames: 'bytecodes numberOfArguments numberOfTemporaries localVariableNames stackNeeded polymorphicInlineCache sourceOffsets mclass'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

CompiledCode variableSubclassNamed: #CompiledBlock
	instVarNames: 'outerMethod dummy'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

CompiledCode variableSubclassNamed: #CompiledMethod
	instVarNames: 'selector kit'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #ComputedField
	instVarNames: 'name action'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Collection variableSubclassNamed: #Dictionary
	instVarNames: 'values tally'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Doit
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #EventBase
	instVarNames: 'eventRegistry'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Exception
	instVarNames: 'message action result'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Exception subclassNamed: #Error
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #ExceptionBase
	instVarNames: 'catchBlock finallyBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #ExceptionHandler
	instVarNames: 'catchBlock finallyBlock exceptionClass'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #ExceptionList
	instVarNames: 'exceptions'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Boolean subclassNamed: #False
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Filename
	instVarNames: 'path'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Error subclassNamed: #HaltException
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Dictionary variableSubclassNamed: #IdentityDictionary
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object variableSubclassNamed: #JunkClass
	instVarNames: 'instVar1 instVar2'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Kit
	instVarNames: 'name requiredKitNames definedClasses extendedMethods subKits versionName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #KitManager
	instVarNames: 'kits currentKit'
	classInstVarNames: 'default'
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #LineEndConvention
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

LineEndConvention subclassNamed: #LineEndConventionCR
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

LineEndConvention subclassNamed: #LineEndConventionCRLF
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

LineEndConvention subclassNamed: #LineEndConventionLF
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Magnitude
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Magnitude subclassNamed: #Character
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Magnitude subclassNamed: #DateTime
	instVarNames: 'day month year time'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Matrix
	instVarNames: 'elements rows columns'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object byteSubclassNamed: #MemorySpace
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Error subclassNamed: #MessageNotUnderstood
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ClassDescription subclassNamed: #Metaclass
	instVarNames: 'thisClass'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

IdentityDictionary variableSubclassNamed: #MethodDictionary
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Magnitude subclassNamed: #Number
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Number subclassNamed: #Fraction
	instVarNames: 'numerator denominator'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Number subclassNamed: #Integer
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Integer subclassNamed: #LargeInteger
	instVarNames: 'bytes componentSize'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

LargeInteger subclassNamed: #LargeNegativeInteger
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

LargeInteger subclassNamed: #LargePositiveInteger
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Number byteSubclassNamed: #LimitedPrecisionReal
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

LimitedPrecisionReal byteSubclassNamed: #Float
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object byteSubclassNamed: #OSHandle
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Point
	instVarNames: 'x y'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Error subclassNamed: #PrimitiveFailedError
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Random
	instVarNames: 'seed'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #SHA1
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Collection subclassNamed: #SequenceableCollection
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

SequenceableCollection subclassNamed: #ArrayedCollection
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ArrayedCollection variableSubclassNamed: #Array
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ArrayedCollection subclassNamed: #IntegerArray
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

IntegerArray byteSubclassNamed: #ByteArray
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

SequenceableCollection subclassNamed: #OrderedCollection
	instVarNames: 'firstIndex lastIndex values'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Collection subclassNamed: #Set
	instVarNames: 'values numberOfElements'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Integer subclassNamed: #SmallInteger
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Socket
	instVarNames: 'handle readStream writeStream handleBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

EventBase subclassNamed: #SocketDispatcher
	instVarNames: 'socketHandles events revents handlers timeoutHandler timeoutInterval running'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #SocketHandler
	instVarNames: 'socket dispatcher'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

SocketHandler subclassNamed: #SocketAcceptHandler
	instVarNames: 'portNumber clientHandler'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #SocketLauncher
	instVarNames: 'screenHandlerClass commandHandlerClass startupReceiver startupSelector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

SocketHandler subclassNamed: #SocketTimeoutHandler
	instVarNames: 'timeoutBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

SocketHandler subclassNamed: #SocketUIScreenHandler
	instVarNames: 'webSocket socketState uiScreen commandHandler startupReceiver startupSelector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Sorter
	instVarNames: 'sortBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Stream
	instVarNames: 'position readLimit'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Stream subclassNamed: #InternalStream
	instVarNames: 'collection'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

InternalStream subclassNamed: #ReadStream
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ReadStream subclassNamed: #ReadWriteStream
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ReadWriteStream subclassNamed: #FileStream
	instVarNames: 'handle isBinary lineEndConvention'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ReadWriteStream subclassNamed: #SocketStream
	instVarNames: 'socket internalStream'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

ArrayedCollection subclassNamed: #String
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

String byteSubclassNamed: #ByteString
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #StringMatcher
	instVarNames: 'submatchers pattern parent index'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

String subclassNamed: #Symbol
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Symbol byteSubclassNamed: #ByteSymbol
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Magnitude subclassNamed: #Time
	instVarNames: 'milliseconds'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Boolean subclassNamed: #True
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

String byteSubclassNamed: #TwoByteString
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Symbol byteSubclassNamed: #TwoByteSymbol
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #UndefinedObject
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

SequenceableCollection byteSubclassNamed: #UninterpretedBytes
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Object subclassNamed: #Vector
	instVarNames: 'elements'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

Exception subclassNamed: #Warning
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

EventBase subclassNamed: #WebSocket
	instVarNames: 'socket stream messageStream random isConnecting'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

InternalStream subclassNamed: #WriteStream
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core' !

! Object methodsFor: 'accessing' !
at: index 

	<primitive: 60>
	self primitiveFailed! !

! Object methodsFor: 'accessing' !
at: index put: anObject 

	<primitive: 61>
	self primitiveFailed! !

! Object methodsFor: 'accessing' !
basicAt: index 

	<primitive: 60>
	self primitiveFailed! !

! Object methodsFor: 'accessing' !
basicAt: index put: anObject 

	<primitive: 61>
	self primitiveFailed! !

! Object methodsFor: 'accessing' !
basicSize

	<primitive: 62>
	self primitiveFailed! !

! Object methodsFor: 'accessing' !
become: anObject

	<primitive: 555>
	self primitiveFailed! !

! Object methodsFor: 'accessing' !
size

	^self class instSize! !

! Object methodsFor: 'accessing' !
yourself

	^self! !

! Object methodsFor: 'class membership' !
class

	<primitive: 111>
	self primitiveFailed! !

! Object methodsFor: 'class membership' !
isKindOf: aClass

	self class == aClass ifTrue: [^true].
	^self class inheritsFrom: aClass! !

! Object methodsFor: 'class membership' !
isMemberOf: aClass

	^self class == aClass! !

! Object methodsFor: 'comparing' !
= anObject 

	^self == anObject! !

! Object methodsFor: 'comparing' !
hash

	^self identityHash! !

! Object methodsFor: 'comparing' !
identityHash

	<primitive: 75>
	self primitiveFailed! !

! Object methodsFor: 'comparing' !
~= t1 

	^(self = t1) not! !

! Object methodsFor: 'controlling' !
ifNil: aBlock 

	^self! !

! Object methodsFor: 'controlling' !
ifNil: nilBlock ifNotNil: notNilBlock 

	^notNilBlock cull: self! !

! Object methodsFor: 'controlling' !
ifNotNil: aBlock 

	^aBlock cull: self! !

! Object methodsFor: 'converting' !
-> anObject 

	^Association key: self value: anObject! !

! Object methodsFor: 'copying' !
copy

	^self shallowCopy postCopy; yourself! !

! Object methodsFor: 'copying' !
postCopy

	^self! !

! Object methodsFor: 'copying' !
shallowCopy

	| copy |
	copy := self class basicNew: self basicSize.
	self shallowCopyTo: copy.
	^copy! !

! Object methodsFor: 'copying' !
shallowCopyTo: copy

	1 to: self class instSize do: [:index |
		copy instVarAt: index put: (self instVarAt: index)].
	
	1 to: self basicSize do: [:index |
		copy basicAt: index put: (self basicAt: index)].
	^copy! !

! Object methodsFor: 'displaying' !
displayString

	^self printString! !

! Object methodsFor: 'error handling' !
error: aString 

	Error signal: aString! !

! Object methodsFor: 'error handling' !
primitiveFailed

	self walkback.
	PrimitiveFailedError signal! !

! Object methodsFor: 'initialize-release' !
initialize
	^self! !

! Object methodsFor: 'logging' !
log: aString

	BeagleSystem log: aString! !

! Object methodsFor: 'migrating' !
migrateFrom: anObject instVarMapping: anArray
	"Migrate instance variables from anObject to self.
	The instVarMapping is an array that matches the new instance size.  The elements are integers or blocks or nil.
	Integers represent the index of the instance variable of the old object to copy over.
	nil represents no mapping = leave the new instance variable nil.
	Providing a block runs the block on the old object to compute the value to write into the instance variable of the new object."

	1 to: anArray size do: [:instVarNumber |
		| oldIndex value |
		oldIndex := anArray at: instVarNumber.
		oldIndex notNil ifTrue: [
			value := oldIndex isInteger
				ifTrue: [anObject instVarAt: oldIndex]
				ifFalse: [oldIndex cull: anObject].
			self instVarAt: instVarNumber put: value]].
	
	1 to: (anObject basicSize min: self basicSize) do: [:indexedInstVarNumber |
		self basicAt: indexedInstVarNumber put: (anObject basicAt: indexedInstVarNumber)]! !

! Object methodsFor: 'navigating' !
allOwners

	| owners |

	owners := OrderedCollection new.

	Class allSubclasses do: [:eachMetaclass |
		eachMetaclass allInstances do: [:metaclass |
			metaclass thisClass allInstances do: [:inst |
				(inst ~~ owners and: [inst ~~ owners privateValues]) ifTrue: [
					1 to: inst basicSize do: [:indexedVarNum | (inst basicAt: indexedVarNum) == self ifTrue: [owners add: inst]].
					1 to: inst class allInstVarNames size do: [:namedVarNum | (inst instVarAt: namedVarNum) == self ifTrue: [owners add: inst]]].
			]
		]
	].

	^owners ! !

! Object methodsFor: 'printing' !
asString

	^self printString! !

! Object methodsFor: 'printing' !
basicPrintOn: aStream 

	self class name first isVowel
		ifTrue: [aStream nextPutAll: 'an ']
		ifFalse: [aStream nextPutAll: 'a '].

	aStream nextPutAll: self class name! !

! Object methodsFor: 'printing' !
basicPrintString

	| stream |
	stream := WriteStream on: (ByteString new: 30).
	self basicPrintOn: stream.
	^stream contents! !

! Object methodsFor: 'printing' !
printOn: aStream 

	self class name first isVowel
		ifTrue: [aStream nextPutAll: 'an']
		ifFalse: [aStream nextPutAll: 'a'].

	aStream nextPutAll: self class name! !

! Object methodsFor: 'printing' !
printString

	| stream |
	stream := WriteStream on: (ByteString new: 30).
	self printOn: stream.
	^stream contents! !

! Object methodsFor: 'printing' !
storeOn: aStream 

	^self printOn: aStream! !

! Object methodsFor: 'printing' !
storeString

	| stream |
	stream := WriteStream on: (ByteString new: 30).
	self storeOn: stream.
	^stream contents! !

! Object methodsFor: 'private' !
markNewVersion

	<primitive: 701>
	self primitiveFailed! !

! Object methodsFor: 'private' !
setClass: newClass

	<primitive: 702>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
halt

	HaltException signal: 'Halt' ! !

! Object methodsFor: 'system primitives' !
instVarAt: index 

	<primitive: 420>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
instVarAt: index put: anObject 

	<primitive: 421>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
isVMMigrationNew
	<primitive: 703>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
markVMMigrationNew
	<primitive: 701>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
perform: aSelector

	^self perform: aSelector withArguments: #()! !

! Object methodsFor: 'system primitives' !
perform: aSelector with: anArgument

	^self perform: aSelector withArguments: (Array with: anArgument)! !

! Object methodsFor: 'system primitives' !
perform: aSelector with: anArgument with: arg2

	^self perform: aSelector withArguments: (Array with: anArgument with: arg2)! !

! Object methodsFor: 'system primitives' !
perform: aSelector with: anArgument with: arg2 with: arg3

	^self perform: aSelector withArguments: (Array with: anArgument with: arg2 with: arg3)! !

! Object methodsFor: 'system primitives' !
perform: aSelector withArguments: anArray

	<primitive: 552>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
primitiveHalt

	<primitive: 407>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
remote_instVarAt: index 

	<primitive: 420>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
remote_instVarAt: index put: anObject 

	<primitive: 421>
	self primitiveFailed! !

! Object methodsFor: 'system primitives' !
walkback

	<primitive: 557>
	self primitiveFailed! !

! Object methodsFor: 'testing' !
== anObject

	<primitive: 110>
	self primitiveFailed! !

! Object methodsFor: 'testing' !
isArray

	^false! !

! Object methodsFor: 'testing' !
isBlock

	^false! !

! Object methodsFor: 'testing' !
isBlockClosure

	^false! !

! Object methodsFor: 'testing' !
isCollection

	^false! !

! Object methodsFor: 'testing' !
isCompiledBlock

	^false! !

! Object methodsFor: 'testing' !
isDictionary

	^false! !

! Object methodsFor: 'testing' !
isFloat

	^false! !

! Object methodsFor: 'testing' !
isIndexed

	^(self class flags bitAnd: 2) ~= 0! !

! Object methodsFor: 'testing' !
isInteger

	^false! !

! Object methodsFor: 'testing' !
isLargeInteger

	^false! !

! Object methodsFor: 'testing' !
isNil

	^false! !

! Object methodsFor: 'testing' !
isNumber

	^false! !

! Object methodsFor: 'testing' !
isReal

	^false! !

! Object methodsFor: 'testing' !
isString

	^false! !

! Object methodsFor: 'testing' !
isSymbol

	^false! !

! Object methodsFor: 'testing' !
isUI

	^false! !

! Object methodsFor: 'testing' !
notNil

	^true! !

! Object methodsFor: 'testing' !
~~ anObject

	^(self == anObject) not! !

! Object class methodsFor: 'logging' !
log: aString

	BeagleSystem log: aString! !

! Object class methodsFor: 'migrating' !
systemDictionary

	<primitive: 553>
	self primitiveFailed! !

! Association methodsFor: 'accessing' !
key

	^key! !

! Association methodsFor: 'accessing' !
key: anObject 

	key := anObject! !

! Association methodsFor: 'accessing' !
value

	^value! !

! Association methodsFor: 'accessing' !
value: anObject 

	value := anObject! !

! Association methodsFor: 'printing' !
printOn: aStream

	self key printOn: aStream.
	aStream nextPutAll: '->'.
	self value printOn: aStream! !

! Association methodsFor: 'testing' !
= anAssociation

	self class == anAssociation class ifFalse: [^false].
	self key == anAssociation key ifFalse: [^false].
	self value == anAssociation value ifFalse: [^false].
	^true
! !

! Association methodsFor: 'testing' !
hash

	^(self key identityHash + self value identityHash) abs

! !

! Association class methodsFor: 'instance creation' !
key: key value: value 

	^self new
		key: key;
		value: value;
		yourself! !

! Base64Encoder methodsFor: 'accessing' !
base64Characters

	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'! !

! Base64Encoder methodsFor: 'accessing' !
base64ToInteger: aCharacter

	(aCharacter between: $A and: $Z) ifTrue: [^aCharacter asInteger - $A asInteger].
	(aCharacter between: $a and: $z) ifTrue: [^aCharacter asInteger - $a asInteger + 26].
	(aCharacter between: $0 and: $9) ifTrue: [^aCharacter asInteger - $0 asInteger + 52].
	aCharacter = $+ ifTrue: [^62].
	aCharacter = $/ ifTrue: [^63].

	self error: 'Base64 error'! !

! Base64Encoder methodsFor: 'accessing' !
decodeBlock

	| bits byteNumber |

	bits := 0.
	byteNumber := 0.

	[inputStream atEnd] whileFalse: [
		| character decodedBits |
		character := inputStream next.
		character = $= ifTrue: [^self].
		decodedBits := self base64ToInteger: character.
		bits := bits * 64 + decodedBits.
		byteNumber = 1 ifTrue: [
			outputStream nextPut: bits // 16.
			bits := bits \\ 16].
		byteNumber = 2 ifTrue: [
			outputStream nextPut: bits // 4.
			bits := bits \\ 4].
		byteNumber = 3 ifTrue: [
			outputStream nextPut: bits.
			bits := 0].
		byteNumber := (byteNumber + 1) \\ 4.
		].! !

! Base64Encoder methodsFor: 'accessing' !
decodeStream: aStream

	isFinished := false.
	inputStream := aStream.
	outputStream := WriteStream on: (ByteArray new: 10).

	self decodeBlock.

	^outputStream contents! !

! Base64Encoder methodsFor: 'accessing' !
encode1: aCharacter

	| integer result |
	integer := aCharacter asInteger * 16.

	result := Array new: 4.
	result
		at: 3 put: $=;
		at: 4 put: $=.

	2 to: 1 by: -1 do: [:index |
		result at: index put: (self integerToBase64: integer \\ 64).
		integer := integer // 64].

	result do: [:eachCharacter |
		outputStream nextPut: eachCharacter].

	isFinished := true.! !

! Base64Encoder methodsFor: 'accessing' !
encode2: character1 with: character2

	| integer result |
	integer := character1 asInteger * 256 + character2 asInteger * 4.

	result := Array new: 4.
	result at: 4 put: $=.

	3 to: 1 by: -1 do: [:index |
		result at: index put: (self integerToBase64: integer \\ 64).
		integer := integer // 64].

	result do: [:eachCharacter |
		outputStream nextPut: eachCharacter].

	isFinished := true! !

! Base64Encoder methodsFor: 'accessing' !
encode3: character1 with: character2 with: character3

	| integer result |
	integer := character1 asInteger * 256 + character2 asInteger * 256 + character3 asInteger.

	result := Array new: 4.

	4 to: 1 by: -1 do: [:index |
		result at: index put: (self integerToBase64: integer \\ 64).
		integer := integer // 64].

	result do: [:eachCharacter |
		outputStream nextPut: eachCharacter]! !

! Base64Encoder methodsFor: 'accessing' !
encodeStream: aStream

	isFinished := false.
	inputStream := aStream.
	outputStream := WriteStream on: (String new: 10).

	[inputStream atEnd] whileFalse: [
		self encodeTriple].

	isFinished ifFalse: [outputStream nextPut: $=].
	^outputStream contents! !

! Base64Encoder methodsFor: 'accessing' !
encodeTriple

	| character1 character2 character3 |

	character1 := inputStream next.

	character2 := inputStream atEnd
		ifTrue: [nil]
		ifFalse: [inputStream next].

	character3 := inputStream atEnd
		ifTrue: [nil]
		ifFalse: [inputStream next].

	character3 isNil ifFalse: [^self encode3: character1 with: character2 with: character3].
	character2 isNil ifFalse: [^self encode2: character1 with: character2].
	self encode1: character1! !

! Base64Encoder methodsFor: 'accessing' !
integerToBase64: integer

	^self base64Characters at: integer + 1! !

! BeagleSystem class methodsFor: 'accessing' !
imageName

	^imageName! !

! BeagleSystem class methodsFor: 'accessing' !
imageName: aString

	imageName := aString! !

! BeagleSystem class methodsFor: 'accessing' !
imageNameNoExtension

	^self imageName copyFrom: 1 to: (self imageName lastIndexOf: $.) - 1! !

! BeagleSystem class methodsFor: 'accessing' !
specialSelectors

	^specialSelectors ifNil: [specialSelectors := #(#'+' 1 #'-' 1 #'*' 1 #not 0 #'==' 1 #'~~' 1 #'=' 1 #'~=' 1 #isNil 0 #notNil 0 #'>' 1 #'<' 1 #'>=' 1 #'<=' 1 #'evaluate:' 1 #printString 0 #'raiseSignal' 0 #'perform:withArguments:' 2 #halt 0 #'debugIt:' 1 #'evaluateJsonString:' 1)]! !

! BeagleSystem class methodsFor: 'accessing' !
specialSelectors: anArray

	specialSelectors := anArray! !

! BeagleSystem class methodsFor: 'checking' !
checkClasses

	| allMetaclasses badMetaclasses |

	badMetaclasses := OrderedCollection new.

	BeagleSystem globalGarbageCollect.
	allMetaclasses := Metaclass allInstances.
	allMetaclasses do: [:metaclass |
		| class |
		(metaclass superclass subclasses includes: metaclass) ifFalse: [
			badMetaclasses add: metaclass.
			self log: 'Metaclass not in superclasses'' subclass list: ', metaclass printString].

		metaclass thisClass superclass isNil ifFalse: [
			(metaclass thisClass superclass subclasses includes: metaclass thisClass) ifFalse: [
				badMetaclasses add: metaclass.
				self log: 'Class not in superclasses'' subclass list: ', metaclass thisClass printString]].

		(class := Smalltalk at: metaclass thisClass name ifAbsent: [nil]) == metaclass thisClass ifFalse: [
			badMetaclasses add: metaclass.
			class isNil
				ifTrue: [self log: 'Class not in globals: ' , metaclass thisClass name]
				ifFalse: [self log: 'Class not the same as global: ', metaclass thisClass name]]].

	self allClasses do: [:eachClass |
		(Smalltalk at: eachClass name ifAbsent: [nil]) == eachClass ifFalse: [
			badMetaclasses add: eachClass.
			self log: 'Subclass not in globals: ', eachClass printString]].

	^badMetaclasses


		! !

! BeagleSystem class methodsFor: 'checking' !
checkClassesReferences

	BeagleSystem allClasses do: [:eachClass |
		eachClass selectors do: [:selector |
			(eachClass compiledMethodAt: selector) allNestedLiterals do: [:literal |
				(literal isMemberOf: Association) ifTrue: [
					(Smalltalk associationAt: literal key) == literal ifFalse: [
						self log: 'Class reference doesn''t use the same association: ', literal key, ' in ', eachClass printString, '>>', selector]]]].

		eachClass class selectors do: [:selector |
			(eachClass class compiledMethodAt: selector) allNestedLiterals do: [:literal |
				(literal isMemberOf: Association) ifTrue: [
					(Smalltalk associationAt: literal key) == literal ifFalse: [
						self log: 'Class reference doesn''t use the same association: ', literal key, ' in ', eachClass printString, '>>', selector]]]]].
! !

! BeagleSystem class methodsFor: 'checking' !
checkGlobals

	| correct incorrect |
	correct := 0.
	incorrect := 0.
	Object withAllSubclasses do: [:class |
		class selectors do: [:selector |
			(class compiledMethodAt: selector) allNestedLiterals do: [:literal |
				(literal isMemberOf: Association) ifTrue: [
					literal == (Smalltalk associationAt: literal key)
						ifTrue: [correct := correct + 1]
						ifFalse: [incorrect := incorrect + 1.
							self log: class printString, ' > ', selector, ' === ', literal key]]]]].

	^Array with: correct with: incorrect! !

! BeagleSystem class methodsFor: 'checking' !
checkKits

	KitManager current kits do: [:eachKit |
		eachKit definedClasses do: [:eachClass |
			eachClass == (Smalltalk at: eachClass name ifAbsent: [nil]) ifFalse: [
				self log: 'Bad class ', eachClass name, ' in Kit: ', eachKit name]]]! !

! BeagleSystem class methodsFor: 'checking' !
checkSystem

	| badGlobals |

	self log: 'Start check system'.
	badGlobals := self checkGlobals.
	badGlobals last = 0 ifFalse: [
		self error: 'Bad globals: ', badGlobals last].

	self checkClasses.
	self checkClassesReferences.
	self checkKits.

	self log: 'Finished check system'
! !

! BeagleSystem class methodsFor: 'checking' !
fixClassReferences

	BeagleSystem allClasses do: [:eachClass |
		eachClass selectors do: [:selector |
			self fixClassReferencesIn: (eachClass compiledMethodAt: selector)].

		eachClass class selectors do: [:selector |
			self fixClassReferencesIn: (eachClass class compiledMethodAt: selector)]].
! !

! BeagleSystem class methodsFor: 'checking' !
fixClassReferencesIn: aCompiledCode

	aCompiledCode literals keysAndValuesDo: [:number :literal |
		literal isCompiledBlock ifTrue: [self fixClassReferencesIn: literal].
		literal isBlockClosure ifTrue: [self fixClassReferencesIn: literal method].
		(literal isMemberOf: Association) ifTrue: [
			| global |
			global := Smalltalk associationAt: literal key.
			global isNil ifFalse: [
				literal == global ifFalse: [
					aCompiledCode at: number put: global]]]
		]
! !

! BeagleSystem class methodsFor: 'garbage collecting' !
auditImage

	<primitive: 300>
	! !

! BeagleSystem class methodsFor: 'garbage collecting' !
globalGarbageCollect

	<primitive: 559>
	! !

! BeagleSystem class methodsFor: 'garbage collecting' !
reallocateObjectSpaces

	<primitive: 301>
	! !

! BeagleSystem class methodsFor: 'image saving' !
primSaveImage: aString

	<primitive: 558>
	self primitiveFailed! !

! BeagleSystem class methodsFor: 'image saving' !
saveImage

	^self saveImage: self imageNameNoExtension! !

! BeagleSystem class methodsFor: 'image saving' !
saveImage: aString

	self sourceFiles: nil.
	WebSession current closeAllWindows.

	self primSaveImage: aString.

	self log: 'Saved image as: ', aString printString.
	self changesFileName = (aString, '.cha') ifTrue: [^self].

	self changesFileName asFilename copyTo: aString, '.cha'.
	self sourceFileNames at: 2 put: aString, '.cha'.
! !

! BeagleSystem class methodsFor: 'instance creation' !
clearCurrent

	current := nil! !

! BeagleSystem class methodsFor: 'instance creation' !
current

	^current ifNil: [
		current := self basicNew.
		current initialize.
		current]! !

! BeagleSystem class methodsFor: 'instance creation' !
new

	^super new initialize! !

! BeagleSystem class methodsFor: 'logging' !
log: aString

	self primitiveLog: aString! !

! BeagleSystem class methodsFor: 'logging' !
logObject: anObject

	| string |
	string := anObject printString.
	(string asSimtalkString splitOn: Character cr) do: [:line |
		self log: line]! !

! BeagleSystem class methodsFor: 'navigating' !
allClasses

	^((Class withAllSubclasses copyWithout: Class) collect: [:each | each thisClass]) asArray sortedBy: [:a :b | a name < b name]! !

! BeagleSystem class methodsFor: 'navigating' !
clearUndeclared

	Undeclared keys do: [:each | Undeclared removeKey: each]! !

! BeagleSystem class methodsFor: 'navigating' !
fileinAllClasses

	'stSource\allFiles.st' asFilename fileIn ! !

! BeagleSystem class methodsFor: 'navigating' !
fileoutAllClasses

	self allClasses do: [:each | each fileoutSource].
	self writeAllFiles! !

! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inCompiledCode: aCompiledCode into: aCollection

	| stream |

	stream := DecompileStream on: aCompiledCode.
	[stream atEnd] whileFalse: [
		| bytecodeInfo |
		bytecodeInfo := stream next.
		(self matchesBytecodeInfo: bytecodeInfo with: bytecodeSequence) ifTrue: [
			| rootMethod |
			rootMethod := aCompiledCode rootMethod.
			aCollection add: (Array with: rootMethod mclass with: (rootMethod mclass organizationFor: rootMethod selector) with: rootMethod selector with: rootMethod kit)] ]
  ! !

! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inMethod: aMethod into: aCollection

	self findBytecodeSequence: bytecodeSequence inCompiledCode: aMethod into: aCollection.

	aMethod allNestedLiterals do: [:eachLiteral |
		eachLiteral isBlock ifTrue: [
			self findBytecodeSequence: bytecodeSequence inCompiledCode: eachLiteral into: aCollection]]
! !

! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection

	aBehavior methodDictionary do: [:eachMethod |
		self findBytecodeSequence: bytecodeSequence inMethod: eachMethod into: aCollection]! !

! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inMethodsOfClassOrSubclasses: aBehavior into: aCollection

	aBehavior withAllSubclasses do: [:eachClass |
		self findBytecodeSequence: bytecodeSequence inMethodsOfClass: eachClass into: aCollection].

	^aCollection! !

! BeagleSystem class methodsFor: 'navigating' !
gettersOfInstanceVariable: aString inClass: aBehavior

	| methods |

	methods := OrderedCollection new.
	self gettersOfInstanceVariable:  aString inClass: aBehavior into: methods.
	^methods  ! !

! BeagleSystem class methodsFor: 'navigating' !
gettersOfInstanceVariable: aString inClass: aBehavior into: aCollection

	| bytecodeSequence methods variableNumber |

	(aBehavior allInstVarNames includes: aString) ifFalse: [
		self error: 'Instance variable ', aString, ' not found in class ', aBehavior printString].

	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		pushInstVarReference: (InstanceVariable new variableName: aString);
		yourself) bytecodeStream contents.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	variableNumber := aBehavior allInstVarNames indexOf: aString.
	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		pushSelfInstanceVariableReference: (Array with: 0 with: variableNumber);
		yourself) bytecodeStream contents asArray at: 2 put: nil; yourself.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	^aCollection! !

! BeagleSystem class methodsFor: 'navigating' !
implementersOf: aSymbol
	| result |
	result := OrderedCollection new.
	Object withAllSubclasses do: [:eachClass |
		(eachClass methodDictionary includesKey: aSymbol) ifTrue: [
			result add: (Array with: eachClass with: (eachClass organizationFor: aSymbol) with: aSymbol with: (eachClass compiledMethodAt: aSymbol) kit)]].
	^result! !

! BeagleSystem class methodsFor: 'navigating' !
matchesBytecodeInfo: bytecodeInfo with: bytecodeSequence

	| bytecodeArgs |

	(bytecodeInfo at: 2) = bytecodeSequence first ifFalse: [^false].

	bytecodeArgs := bytecodeInfo last.

	bytecodeArgs size = (bytecodeSequence size - 1) ifFalse: [^false].
	1 to: bytecodeArgs size do: [:index |
		(bytecodeSequence at: index + 1) isNil ifFalse: [
			(bytecodeArgs at: index) = (bytecodeSequence at: index + 1) ifFalse: [^false].
			] ].

	^true

 ! !

! BeagleSystem class methodsFor: 'navigating' !
referencesToAssociation: anAssociation

	| result |
	result := OrderedCollection new.

	Object withAllSubclasses do: [:eachClass |
		eachClass methodDictionary keysAndValuesDo: [:selector :method |
			(method allNestedLiterals includes: anAssociation) ifTrue: [
				result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]].
	^result! !

! BeagleSystem class methodsFor: 'navigating' !
referencesToClass: aClass
	| result association |
	result := Set new.
	association := aClass environment associationAt: aClass name.

	Object withAllSubclasses do: [:eachClass |
		eachClass methodDictionary keysAndValuesDo: [:selector :method |
			(method allNestedLiterals includes: association) ifTrue: [
				result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]].
	^result asArray! !

! BeagleSystem class methodsFor: 'navigating' !
referencesToInstanceVariable: aString inClass: aBehavior

	| methods |

	methods := Set new.
	self
		gettersOfInstanceVariable:  aString inClass: aBehavior into: methods;
		settersOfInstanceVariable:  aString inClass: aBehavior into: methods.
	^methods  asArray! !

! BeagleSystem class methodsFor: 'navigating' !
referencesToUndeclared: aSymbol
	| result association |
	result := OrderedCollection new.
	association := Undeclared associationAt: aSymbol.

	Object withAllSubclasses do: [:eachClass |
		eachClass methodDictionary keysAndValuesDo: [:selector :method |
			(method allNestedLiterals includes: association) ifTrue: [
				result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]].
	^result! !

! BeagleSystem class methodsFor: 'navigating' !
sendersOf: aSymbol
	| result |
	result := Set new.
	Object withAllSubclasses do: [:eachClass |
		eachClass = Doit class ifFalse: [
			eachClass methodDictionary keysAndValuesDo: [:selector :method |
				(method allNestedLiterals includes: aSymbol) ifTrue: [
					result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]]].
	^result asArray! !

! BeagleSystem class methodsFor: 'navigating' !
settersOfInstanceVariable: aString inClass: aBehavior

	| methods |

	methods := OrderedCollection new.
	self settersOfInstanceVariable:  aString inClass: aBehavior into: methods.
	^methods  ! !

! BeagleSystem class methodsFor: 'navigating' !
settersOfInstanceVariable: aString inClass: aBehavior into: aCollection

	| bytecodeSequence methods variableNumber |

	(aBehavior allInstVarNames includes: aString) ifFalse: [
		self error: 'Instance variable ', aString, ' not found in class ', aBehavior printString].

	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		storeInstanceVariableAssignment: (InstanceVariable new variableName: aString);
		yourself) bytecodeStream contents.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	variableNumber := aBehavior allInstVarNames indexOf: aString.
	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		storeSelfInstvarAssignment: (Array with: 0 with: variableNumber);
		yourself) bytecodeStream contents asArray at: 2 put: nil; yourself.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	^aCollection! !

! BeagleSystem class methodsFor: 'navigating' !
writeAllFiles

	| stream |

	stream := 'stSource\allFiles.st' asFilename writeStream.
	self allClasses do: [:class |
		stream
			nextPutAll: '''stSource\';
			nextPutAll: class name;
			nextPutAll: '.st'' asFilename fileIn!';
			cr].

	stream close
! !

! BeagleSystem class methodsFor: 'primitive' !
primitiveLog: aString

	<primitive: 406>
	^self! !

! BeagleSystem class methodsFor: 'sources' !
changesFile

	^(self sourceFiles at: 2) ifNil: [
		| file |
		file := self changesFileName asFilename appendStream.
		self sourceFiles at: 2 put: file.
		file]! !

! BeagleSystem class methodsFor: 'sources' !
changesFileName

	^self sourceFileNames at: 2! !

! BeagleSystem class methodsFor: 'sources' !
clearSources

	self allClasses do: [:class |
		class selectors do: [:selector |
			(class compiledMethodAt: selector) sourceOffsets: nil].
		class class selectors do: [:selector |
			(class class compiledMethodAt: selector) sourceOffsets: nil]].
		
	! !

! BeagleSystem class methodsFor: 'sources' !
closeSourceFiles

	self sourceFiles keysAndValuesDo: [:key :value |
		value notNil ifTrue: [
			value close.
			self sourceFiles at: key put: nil]]! !

! BeagleSystem class methodsFor: 'sources' !
getSource: anArray
	| stream theClass |
	stream := WriteStream on: (String new: 1000).
	theClass := Smalltalk at: anArray first.
	anArray size = 3 ifTrue: [theClass := theClass class].
	theClass fileoutMethodNamed: anArray last on: stream.
	^stream contents! !

! BeagleSystem class methodsFor: 'sources' !
methodsWithNoSources

	| methods |

	methods := OrderedCollection new.
	self allClasses do: [:class |
		class selectors do: [:selector |
			(class compiledMethodAt: selector) sourceOffsets isNil ifTrue: [methods add: (Array with: class with: selector)]].
		class class selectors do: [:selector |
			(class class compiledMethodAt: selector) sourceOffsets isNil ifTrue: [methods add: (Array with: class class with: selector)]]].
	
	^methods
	! !

! BeagleSystem class methodsFor: 'sources' !
openSourceFiles

	self sourceFileNames keysAndValuesDo: [:key :value |
		value notNil ifTrue: [
			self sourceFiles at: key put: ((Filename named: value) appendStream)]]! !

! BeagleSystem class methodsFor: 'sources' !
sourceFileName

	^self sourceFiles at: 1! !

! BeagleSystem class methodsFor: 'sources' !
sourceFileNames

	^sourceFileNames! !

! BeagleSystem class methodsFor: 'sources' !
sourceFileNames: anArray

	sourceFileNames := anArray! !

! BeagleSystem class methodsFor: 'sources' !
sourceFiles

	^sourceFiles ifNil: [sourceFiles := Array new: 16]! !

! BeagleSystem class methodsFor: 'sources' !
sourceFiles: anArray

	sourceFiles := anArray! !

! BeagleSystem class methodsFor: 'sources' !
sourcesFile

	^(self sourceFiles at: 1) ifNil: [
		| file |
		file := self changesFileName asFilename readStream.
		self sourceFiles at: 1 put: file.
		file]! !

! BeagleSystem class methodsFor: 'sources' !
sourcesFileName

	^self sourceFileNames at: 1! !

! BeagleSystem class methodsFor: 'startup' !
finish

	<primitive: 409>! !

! BeagleSystem class methodsFor: 'startup' !
shutdown

	self log: 'Shutdown'.
	CurrentSocketDispatcher shutdown
! !

! BeagleSystem class methodsFor: 'startup' !
start

	Exception exceptionHandlers removeAllSuchThat: [:each | true].
	self startAcceptSocket
! !

! BeagleSystem class methodsFor: 'startup' !
startAcceptSocket

	Smalltalk at: #CurrentSocketDispatcher put: SocketDispatcher new.
	(Smalltalk at: #CurrentSocketDispatcher)
		addHandler: (SocketAcceptHandler new
			portNumber: 5000;
			clientHandler: (SocketLauncher new
				screenHandlerClass: SocketUIScreenHandler;
				commandHandlerClass: DevelopmentCommandHandler;
				yourself);
			yourself);
		timeoutHandler: (SocketTimeoutHandler new
			timeoutBlock: [];
			yourself);
		startPollLoop.

! !

! BeagleSystem class methodsFor: 'system' !
badMetaclasses

	^self allClasses select: [:eachClass |
		(eachClass environment at: eachClass name) ~~ eachClass]! !

! BeagleSystem class methodsFor: 'system' !
becomeSystem

	<primitive: 302>
	! !

! BeagleSystem class methodsFor: 'system' !
cleanupOrganizations

	self allClasses do: [:eachClass |
		eachClass cleanupOrganization]! !

! BeagleSystem class methodsFor: 'system' !
fixBadMetaclasses

	^self badMetaclasses do: [:eachClass |
		eachClass class superclass subclasses: (eachClass class superclass subclasses copyWithout: eachClass class)]! !

! BeagleSystem class methodsFor: 'system' !
reallocateSpace: spaceNumber size: size

	<primitive: 303>! !

! BeagleSystem class methodsFor: 'system' !
runJavaScript: aString

	(Smalltalk at: #CurrentScreen) webSocket send: '`', aString! !

! BeagleSystem class methodsFor: 'system' !
runJavaScriptWithReturn: aString

	| result |
	(Smalltalk at: #CurrentScreen) webSocket send: '`connection.send(', aString, ');'.
	[result := (Smalltalk at: #CurrentScreen) webSocket readContentMessage.
		result isNil] whileTrue: [].

	^result! !

! BeagleSystem class methodsFor: 'system' !
spaceSize16

	<primitive: 304>! !

! BeagleSystem class methodsFor: 'system' !
webSocketPortNumber

	<primitive: 220>
	self primitiveFailed! !

! BeagleSystem class methodsFor: 'system' !
wellKnownAt: index

	<primitive: 610>! !

! BeagleSystem class methodsFor: 'system' !
wellKnownAt: index put: value

	<primitive: 611>! !

! BeagleSystem class methodsFor: 'system' !
wellKnownSize

	<primitive: 612>! !

! BeagleSystem class methodsFor: 'testing' !
isEmscripten

	<primitive: 600>
	^false! !

! Behavior methodsFor: 'accessing' !
allInstVarNames

	| collection |

	collection := OrderedCollection new.
	^self allInstVarNamesInto: collection! !

! Behavior methodsFor: 'accessing' !
allInstVarNamesInto: aCollection

	self superclass isNil ifFalse: [self superclass allInstVarNamesInto: aCollection].
	aCollection addAll: self instVarNames.
	^aCollection! !

! Behavior methodsFor: 'accessing' !
allInstances

	<primitive: 556>
	self primitiveFailed! !

! Behavior methodsFor: 'accessing' !
allSubclasses

	^self allSubclassesInto: OrderedCollection new! !

! Behavior methodsFor: 'accessing' !
allSubclassesInto: aCollection 

	subclasses isNil ifFalse: [subclasses do: [:subclass | subclass withAllSubclassesInto: aCollection]].
	^aCollection! !

! Behavior methodsFor: 'accessing' !
basicNew

	<primitive: 70>
	self primitiveFailed! !

! Behavior methodsFor: 'accessing' !
basicNew: size 

	<primitive: 71>
	self primitiveFailed! !

! Behavior methodsFor: 'accessing' !
compiledMethodAt: selector

	^self methodDictionary at: selector! !

! Behavior methodsFor: 'accessing' !
flags

	^flags! !

! Behavior methodsFor: 'accessing' !
flags: aNumber 

	flags := aNumber! !

! Behavior methodsFor: 'accessing' !
globalDictionaries

	^Array with: Object systemDictionary! !

! Behavior methodsFor: 'accessing' !
instSize

	superclass isNil ifTrue: [^instVarNames size].
	^superclass instSize + instVarNames size! !

! Behavior methodsFor: 'accessing' !
instVarNameForIndex: aNumber 

	aNumber > self instSize ifTrue: [^nil].
	superclass isNil ifTrue: [^instVarNames at: aNumber].
	^(superclass instVarNameForIndex: aNumber)
		ifNil: [instVarNames at: aNumber - superclass instSize]! !

! Behavior methodsFor: 'accessing' !
instVarNames

	^instVarNames! !

! Behavior methodsFor: 'accessing' !
instVarNames: anArray 

	instVarNames := anArray! !

! Behavior methodsFor: 'accessing' !
methodDictionary

	^methodDictionary! !

! Behavior methodsFor: 'accessing' !
methodDictionary: aDictionary 

	methodDictionary := aDictionary! !

! Behavior methodsFor: 'accessing' !
new

	<primitive: 70>
	self primitiveFailed! !

! Behavior methodsFor: 'accessing' !
new: size 

	<primitive: 71>
	self primitiveFailed! !

! Behavior methodsFor: 'accessing' !
selectors

	^self methodDictionary keys! !

! Behavior methodsFor: 'accessing' !
subclasses

	^subclasses! !

! Behavior methodsFor: 'accessing' !
subclasses: anObject

	subclasses := anObject! !

! Behavior methodsFor: 'accessing' !
superclass

	^superclass! !

! Behavior methodsFor: 'accessing' !
superclass: aClass 

	superclass := aClass! !

! Behavior methodsFor: 'accessing' !
withAllSubclasses

	^self withAllSubclassesInto: OrderedCollection new! !

! Behavior methodsFor: 'accessing' !
withAllSubclassesInto: aCollection 

	aCollection add: self.
	subclasses isNil ifFalse: [subclasses do: [:subclass | subclass withAllSubclassesInto: aCollection]].
	^aCollection! !

! Behavior methodsFor: 'accessing' !
withAllSuperclasses

	^self withAllSuperclassesInto: OrderedCollection new! !

! Behavior methodsFor: 'accessing' !
withAllSuperclassesInto: aCollection 

	aCollection add: self.
	superclass isNil ifFalse: [superclass withAllSuperclassesInto: aCollection].
	^aCollection! !

! Behavior methodsFor: 'fileIn/Out' !
fileoutMethodNamed: aMethodName on: aStream

	self organization keysAndValuesDo: [:organizationName :methodNames |
		methodNames do: [:eachMethodName |
			eachMethodName = aMethodName ifTrue: [
				aStream nextPutAll: '! ';
					nextPutAll: self printString;
					nextPutAll: ' methodsFor: ';
					nextPutAll: organizationName printString;
					nextPutAll: ' !';
					cr.
				(self compiledMethodAt: eachMethodName) fileoutOn: aStream.
				aStream
					nextPutAll: '! !';
					cr; cr]]]! !

! Behavior methodsFor: 'fileIn/Out' !
fileoutMethodsOn: aStream

	(self organization keys asArray sortedBy: [:a :b | a < b]) do: [:organizationName |
		| methodNames |
		methodNames := (self organization at: organizationName) asArray sortedBy: [:a :b | a < b].
		methodNames do: [:eachMethodName |
		
			aStream nextPutAll: '! ';
				nextPutAll: self printString;
				nextPutAll: ' methodsFor: ';
				nextPutAll: organizationName printString;
				nextPutAll: ' !';
				cr.
			(self compiledMethodAt: eachMethodName) fileoutOn: aStream.
			aStream
				nextPutAll: '! !';
				cr; cr]]! !

! Behavior methodsFor: 'fileIn/Out' !
fileoutMethodsOn: aStream forKit: aKit

	(self organization keys asArray sortedBy: [:a :b | a < b]) do: [:organizationName |
		| methodNames |
		methodNames := (self organization at: organizationName) asArray sortedBy: [:a :b | a < b].
		methodNames do: [:eachMethodName |
			| method |
			method := self compiledMethodAt: eachMethodName.
			method definingKit == aKit ifTrue: [
				aStream nextPutAll: '! ';
					nextPutAll: self printString;
					nextPutAll: ' methodsFor: ';
					nextPutAll: organizationName printString;
					nextPutAll: ' !';
					cr.
				method fileoutOn: aStream.
				aStream
					nextPutAll: '! !';
					cr; cr] ] ]! !

! Behavior methodsFor: 'initialize-release' !
initialize

	subclasses := #()! !

! Behavior methodsFor: 'removing' !
basicRemoveSubclass: aClass

	^self subclasses: (self subclasses copyWithout: aClass)! !

! Behavior methodsFor: 'removing' !
removeSelector: aSymbol

	| method |
	method := self compiledMethodAt: aSymbol.
	method kit isNil ifFalse: [
		method kit removeMethod: method].

	self methodDictionary removeKey: aSymbol.
	! !

! Behavior methodsFor: 'testing' !
canUnderstand: aSymbol 

	(methodDictionary includesKey: aSymbol) ifTrue: [^true].
	superclass isNil ifTrue: [^false].
	^superclass canUnderstand: aSymbol! !

! Behavior methodsFor: 'testing' !
inheritsFrom: aClass

	self == aClass ifTrue: [^true].
	self superclass isNil ifTrue: [^false].
	^self superclass inheritsFrom: aClass! !

! Behavior class methodsFor: 'instance creation' !
new

	^super new initialize! !

! BlockClosure methodsFor: 'accessing' !
allNestedLiterals

	^self method allNestedLiterals! !

! BlockClosure methodsFor: 'accessing' !
bytecodes

	^self method bytecodes! !

! BlockClosure methodsFor: 'accessing' !
cache

	| oldBlock cachedValue |
	oldBlock := self.
	cachedValue := CachedValue new.
	oldBlock become: cachedValue.
	oldBlock block: cachedValue; resetValue.
	^oldBlock
! !

! BlockClosure methodsFor: 'accessing' !
copiedValues

	^copiedValues! !

! BlockClosure methodsFor: 'accessing' !
copiedValues: anArray

	copiedValues := anArray! !

! BlockClosure methodsFor: 'accessing' !
method

	^method! !

! BlockClosure methodsFor: 'accessing' !
method: anObject

	method := anObject.
	copiedValues := Array new! !

! BlockClosure methodsFor: 'accessing' !
methodContext

	^methodContext! !

! BlockClosure methodsFor: 'accessing' !
methodContext: anObject

	methodContext:= anObject! !

! BlockClosure methodsFor: 'accessing' !
numberOfArguments

	^self method numberOfArguments! !

! BlockClosure methodsFor: 'evaluating' !
cull: anObject

	self numberOfArguments = 1 ifTrue: [
		^self value: anObject].
	self numberOfArguments = 0 ifTrue: [
		^self value].
	self error: 'Improper number of arguments'! !

! BlockClosure methodsFor: 'evaluating' !
cull: anObject cull: object2

	self numberOfArguments = 2 ifTrue: [
		^self value: anObject value: object2].
	self numberOfArguments = 1 ifTrue: [
		^self value: anObject].
	self numberOfArguments = 0 ifTrue: [
		^self value].
	self error: 'Improper number of arguments'! !

! BlockClosure methodsFor: 'evaluating' !
cull: anObject cull: object2 cull: object3

	self numberOfArguments = 3 ifTrue: [
		^self value: anObject value: object2 value: object3].
	self numberOfArguments = 2 ifTrue: [
		^self value: anObject value: object2].
	self numberOfArguments = 1 ifTrue: [
		^self value: anObject].
	self numberOfArguments = 0 ifTrue: [
		^self value].
	self error: 'Improper number of arguments'! !

! BlockClosure methodsFor: 'evaluating' !
ensure: aBlock

	^Exception
		try: [self value]
		finally: [aBlock value]
! !

! BlockClosure methodsFor: 'evaluating' !
on: anExceptionClass do: handlerBlock

	^anExceptionClass
		try: self
		catch: handlerBlock
		finally: []
! !

! BlockClosure methodsFor: 'evaluating' !
value

	<primitive: 501>
	self primitiveFailed! !

! BlockClosure methodsFor: 'evaluating' !
value: object 

	<primitive: 502>
	self primitiveFailed! !

! BlockClosure methodsFor: 'evaluating' !
value: object1 value: object2 

	<primitive: 503>
	self primitiveFailed! !

! BlockClosure methodsFor: 'evaluating' !
whileFalse

	[self value] whileFalse: [nil]! !

! BlockClosure methodsFor: 'evaluating' !
whileFalse: aBlock

	self value
		ifFalse:
			[aBlock value.
			[self value] whileFalse: [aBlock value]]! !

! BlockClosure methodsFor: 'evaluating' !
whileTrue

	[self value] whileTrue: [nil]! !

! BlockClosure methodsFor: 'evaluating' !
whileTrue: aBlock

	self value
		ifTrue:
			[aBlock value.
			[self value] whileTrue: [aBlock value]]! !

! BlockClosure methodsFor: 'testing' !
isBlock

	^true! !

! BlockClosure methodsFor: 'testing' !
isBlockClosure

	^true! !

! CachedValue methodsFor: 'accessing' !
block

	^block! !

! CachedValue methodsFor: 'accessing' !
block: anObject

	block := anObject! !

! CachedValue methodsFor: 'accessing' !
resetValue

	self value: self block value! !

! CachedValue methodsFor: 'accessing' !
value

	^value! !

! CachedValue methodsFor: 'accessing' !
value: anObject

	value := anObject! !

! CachedValue class methodsFor: 'instance creation' !
block: aBlock

	^self new
		block: aBlock;
		resetValue;
		yourself
! !

! ClassCreator methodsFor: 'accessing' !
classInstanceVariableNames

	| names |
	classInstanceVariableNames isString ifTrue: [
		^((classInstanceVariableNames splitBy: Character space) select: [:each | each notEmpty]) asArray].

	names := OrderedCollection new.
	classInstanceVariableNames do: [:name |
		names addAll: ((name splitBy: Character space) select: [:each | each notEmpty])].
	^names asArray! !

! ClassCreator methodsFor: 'accessing' !
classInstanceVariableNames: anArray

	classInstanceVariableNames := anArray! !

! ClassCreator methodsFor: 'accessing' !
classVariableNames

	^classVariableNames! !

! ClassCreator methodsFor: 'accessing' !
classVariableNames: anArray

	classVariableNames := anArray! !

! ClassCreator methodsFor: 'accessing' !
environment

	^environment! !

! ClassCreator methodsFor: 'accessing' !
environment: anObject

	environment := anObject! !

! ClassCreator methodsFor: 'accessing' !
flags

	^flags! !

! ClassCreator methodsFor: 'accessing' !
flags: anInteger

	flags := anInteger! !

! ClassCreator methodsFor: 'accessing' !
instanceVariableNames

	| names |
	instanceVariableNames isString ifTrue: [
		^((instanceVariableNames splitBy: Character space) select: [:each | each notEmpty]) asArray].

	names := OrderedCollection new.
	instanceVariableNames do: [:name |
		names addAll: ((name splitBy: Character space) select: [:each | each notEmpty])].
	^names asArray
! !

! ClassCreator methodsFor: 'accessing' !
instanceVariableNames: anArray

	instanceVariableNames := anArray! !

! ClassCreator methodsFor: 'accessing' !
kitName

	^kitName! !

! ClassCreator methodsFor: 'accessing' !
kitName: aSymbol

	kitName := aSymbol! !

! ClassCreator methodsFor: 'accessing' !
name

	^name! !

! ClassCreator methodsFor: 'accessing' !
name: aClass

	name := aClass! !

! ClassCreator methodsFor: 'accessing' !
newClass

	^newClass! !

! ClassCreator methodsFor: 'accessing' !
newClass: aClass

	newClass := aClass! !

! ClassCreator methodsFor: 'accessing' !
oldClass

	^oldClass! !

! ClassCreator methodsFor: 'accessing' !
oldClass: aClass

	oldClass := aClass! !

! ClassCreator methodsFor: 'accessing' !
superclass

	^superclass! !

! ClassCreator methodsFor: 'accessing' !
superclass: aClass

	superclass := aClass! !

! ClassCreator methodsFor: 'creating' !
addClassToEnvironment

	self newClass environment: self environment.
	self environment at: self name put: self newClass! !

! ClassCreator methodsFor: 'creating' !
addClassToKit

	| kit |

	self kitName isNil ifTrue: [^self].
	kit := KitManager current kitNamed: self kitName.
	kit isNil ifTrue: [^self].

	(KitManager current kitForClass: self newClass) ifNotNil: [:oldKit | oldKit removeClass: self newClass].
	kit addClass: self newClass! !

! ClassCreator methodsFor: 'creating' !
buildClass

	self oldClass: (self environment at: self name ifAbsent: [nil]).
	self oldClass ifNotNil: [^self modifyClass].

	self createClass.
	self
		linkToSuperclass;
		addClassToEnvironment;
		addClassToKit! !

! ClassCreator methodsFor: 'creating' !
createClass

	| oldMetaclass newMetaclass swapTemp |

	newMetaclass := Metaclass new
		flags: ((superclass class allInstVarNames size + self classInstanceVariableNames size) bitShift: 16);
		superclass: superclass class;
		instVarNames: self classInstanceVariableNames;
		methodDictionary: (oldClass ifNil: [MethodDictionary new] ifNotNil: [oldClass class methodDictionary copy]);
		subclasses: #();
		organization: (oldClass ifNil: [Dictionary new] ifNotNil: [oldClass class organization copy]);
		yourself.

	oldClass notNil ifTrue: [
		oldMetaclass := oldClass class.
		oldMetaclass become: newMetaclass.
		swapTemp := oldMetaclass.
		oldMetaclass := newMetaclass.
		newMetaclass := swapTemp.
	
		oldClass setClass: oldMetaclass].

	newClass := ((newMetaclass new)
		name: self name;
		flags: ((superclass allInstVarNames size + self instanceVariableNames size) bitShift: 16) + self flags;
		methodDictionary: (oldClass ifNil: [MethodDictionary new] ifNotNil: [oldClass methodDictionary copy]);
		instVarNames: self instanceVariableNames;
		"classVarNames: self classVariableNames;"
		organization: (oldClass ifNil: [Dictionary new] ifNotNil: [oldClass organization copy]);
		superclass: superclass;
		subclasses: #();
		environment: self environment;
		yourself).

	oldClass notNil ifTrue: [
		oldClass become: newClass.
		swapTemp := oldClass.
		oldClass := newClass.
		newClass := swapTemp.
		oldClass subclasses ifNotNil: [:subclasses |
			subclasses do: [:eachSubclass |
				eachSubclass class superclass: oldMetaclass.
				eachSubclass superclass: oldClass]]].

	newMetaclass thisClass: newClass.

	^self newClass! !

! ClassCreator methodsFor: 'creating' !
linkToSuperclass

	self superclass isNil ifTrue: [
		"If we don't have a superclass, our metaclasses superclass is Class"
		Class subclasses: (Class subclasses copyWith: self newClass class).
		^self].

	self superclass class subclasses: ((self superclass class subclasses ifNil: [#()]) copyWith: self newClass class).
	self superclass subclasses: ((self superclass subclasses ifNil: [#()]) copyWith: self newClass)! !

! ClassCreator methodsFor: 'creating' !
migrateInstances
	| newInstVarNames oldInstVarNames mapping |
	
	newInstVarNames := newClass allInstVarNames.
	oldInstVarNames := oldClass allInstVarNames.

	mapping := Array new: newInstVarNames size.
	1 to: newInstVarNames size do: [:newInstVarNumber |
		| index |
		index := oldInstVarNames indexOf: (newInstVarNames at: newInstVarNumber).
		index ~= 0 ifTrue: [
			mapping at: newInstVarNumber put: index]].

	newClass allInstances do: [:oldInstance |
		| newInstance |
		oldInstance setClass: oldClass.
		newInstance := newClass basicNew: oldInstance basicSize.
		newInstance migrateFrom: oldInstance instVarMapping: mapping.
		oldInstance become: newInstance]! !

! ClassCreator methodsFor: 'creating' !
modifyClass

	self hasDefinitionChanged ifFalse: [^self oldClass].

	self
		createClass;
		unlinkFromSuperclass;
		linkToSuperclass;
		addClassToEnvironment;
		addClassToKit;
		migrateInstances;
		recompileClass;
		modifySubclasses! !

! ClassCreator methodsFor: 'creating' !
modifySubclasses

	oldClass subclasses do: [:eachSubclass |
		self class new
			name: eachSubclass name;
			flags: (oldClass flags bitAnd: 16r3);
			oldClass: eachSubclass;
			superclass: self newClass;
			instanceVariableNames: eachSubclass instVarNames;
			classInstanceVariableNames: eachSubclass class instVarNames;
			"classVariableNames: oldClass classVarNames;"
			environment: oldClass environment;
			modifyClass] ! !

! ClassCreator methodsFor: 'creating' !
removeClassFromEnvironment

	self removeClassFromEnvironment: self oldClass! !

! ClassCreator methodsFor: 'creating' !
removeClassFromEnvironment: aClass

	aClass environment removeKey: aClass name.
	(KitManager current kitForClass: aClass ifNone: [nil]) ifNotNil: [:kit |
		kit removeClass: aClass].

	aClass methodDictionary do: [:method |
		method kit notNil ifTrue: [method kit removeMethod: method]].

	aClass class methodDictionary do: [:method |
		method kit notNil ifTrue: [method kit removeMethod: method]].! !

! ClassCreator methodsFor: 'creating' !
unlinkFromSuperclass

	oldClass superclass isNil ifTrue: [
		"If the old class has a nil superclass, we still have to unlink the metaclass from Object"
		Class subclasses: (Class subclasses copyWithout: self newClass class).
		^self].

	oldClass superclass class subclasses ifNotNil: [:collection |
		oldClass superclass class subclasses: (collection copyWithout: self newClass class)].

	oldClass superclass subclasses ifNotNil: [:collection |
		oldClass superclass subclasses: (collection copyWithout: self newClass)]! !

! ClassCreator methodsFor: 'removing' !
removeClass: aClass

	aClass withAllSubclasses do: [:each |
		self removeClassFromEnvironment: each].
	aClass superclass removeSubclass: aClass! !

! ClassCreator methodsFor: 'testing' !
hasDefinitionChanged

	self superclass == self oldClass superclass ifFalse: [^true].
	self instanceVariableNames = self oldClass instVarNames ifFalse: [^true].
	self classInstanceVariableNames = self oldClass class instVarNames ifFalse: [^true].
	self flags = (self oldClass flags bitAnd: 16rF) ifFalse: [^true].
	^false
! !

! ClassDescription methodsFor: 'accessing' !
newOrganization: aString


	^self organization at: aString ifAbsentPut: [Set new]! !

! ClassDescription methodsFor: 'accessing' !
organization

	^organization ifNil: [organization := Dictionary new]! !

! ClassDescription methodsFor: 'accessing' !
organization: aDictionary

	^organization := aDictionary! !

! ClassDescription methodsFor: 'accessing' !
organizationAt: aString add: aSymbol

	(self organizationFor: aSymbol) ifNotNil: [:organizationName |
		(self organization at: organizationName) remove: aSymbol].

	(self newOrganization: aString) add: aSymbol! !

! ClassDescription methodsFor: 'accessing' !
organizationFor: aSymbol

	self organization keysAndValuesDo: [:key :value |
		(value includes: aSymbol) ifTrue: [^key]].

	^nil! !

! ClassDescription methodsFor: 'organization' !
basicCleanupOrganization

	| selectors badOrganizations |

	badOrganizations := OrderedCollection new.

	self organization keysAndValuesDo: [:key :set |
		key isSymbol ifTrue: [
			set do: [:selector | self organizationAt: key asString add: selector].
			badOrganizations add: key]].

	badOrganizations do: [:each | self organization removeKey: each].

	selectors := self selectors.
	self organization keysAndValuesDo: [:key :collection |
		collection copy do: [:eachSelector |
			(selectors includes: eachSelector)
				ifTrue: [selectors remove: eachSelector]
				ifFalse: [
					collection remove: eachSelector]]].

	selectors isEmpty ifFalse: [
		(self organization at: 'uncategorized' ifAbsentPut: [Set new]) addAll: selectors].
	
	self organization copy keysAndValuesDo: [:key :value |
		value isEmpty ifTrue: [self organization removeKey: key]]
	! !

! ClassDescription methodsFor: 'organization' !
cleanupOrganization

	self basicCleanupOrganization.
	self class basicCleanupOrganization! !

! ClassDescription methodsFor: 'organization' !
methodsInOrganization: aString

	^(organization at: aString ifAbsent: [^#()]) collect: [:eachSelector | self compiledMethodAt: eachSelector]! !

! ClassDescription methodsFor: 'removing' !
removeSelector: aSymbol

	| oldProtocol |
	oldProtocol := self organizationFor: aSymbol.
	super removeSelector: aSymbol.
	(self organization at: oldProtocol ifAbsent: [^self])
		remove: aSymbol ifAbsent: []! !

! Class methodsFor: 'accessing' !
classDictionaries

	^#()! !

! Class methodsFor: 'accessing' !
classTypeFlags

	^self flags bitAnd: 3! !

! Class methodsFor: 'accessing' !
classVarNames: aCollection

	! !

! Class methodsFor: 'accessing' !
environment

	^environment! !

! Class methodsFor: 'accessing' !
environment: anObject

	environment := anObject! !

! Class methodsFor: 'accessing' !
globalDictionaries

	^super globalDictionaries , self classDictionaries! !

! Class methodsFor: 'accessing' !
isBytesClass

	^(self classTypeFlags bitAnd: 1) = 1! !

! Class methodsFor: 'accessing' !
isVariableClass

	^(self classTypeFlags bitAnd: 2) = 2! !

! Class methodsFor: 'accessing' !
kit

	^kit ifNil: [kit := KitManager current kitForClass: self]! !

! Class methodsFor: 'accessing' !
kit: aKit

	kit := aKit! !

! Class methodsFor: 'accessing' !
name

	^name! !

! Class methodsFor: 'accessing' !
name: anObject

	name := anObject! !

! Class methodsFor: 'accessing' !
thisClass

	^self! !

! Class methodsFor: 'creating' !
byteSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 3
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
! !

! Class methodsFor: 'creating' !
byteSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 3
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
! !

! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitString

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitString;
		buildClass;
		newClass! !

! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitString

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classVariableNames: classVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitString;
		buildClass;
		newClass! !

! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
! !

! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
! !

! Class methodsFor: 'creating' !
variableSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: kitSymbol

	^self subclassNamed: aSymbol
		flags: 2
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: kitSymbol! !

! Class methodsFor: 'creating' !
variableSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: kitSymbol

	^self subclassNamed: aSymbol
		flags: 2
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: kitSymbol! !

! Class methodsFor: 'fileIn/Out' !
classInstVarNamesString

	| stream |
	stream := WriteStream on: (String new: 100).
	self class instVarNames
		do: [:name | stream nextPutAll: name]
		separatedBy: [stream space].
	^stream contents! !

! Class methodsFor: 'fileIn/Out' !
fileoutBytesDefinitionOn: aStream

	| kit |

	kit := KitManager current kitForClass: self.
	kit isNil ifTrue: [kit := KitManager current kitNamed: 'Core'].
 
	self superclass printOn: aStream.
	aStream
		nextPutAll: ' byteSubclassNamed: ';
		print: self name;
		cr; tab; nextPutAll: 'instVarNames: '; print: self instVarNamesString;
		cr; tab; nextPutAll: 'classInstVarNames: '; print: self classInstVarNamesString;
		cr; tab; nextPutAll: 'environment: Object systemDictionary';
		cr; tab; nextPutAll: 'kitName: '''; nextPutAll: kit name; nextPutAll: ''' !'! !

! Class methodsFor: 'fileIn/Out' !
fileoutDefinitionOn: aStream

	self isBytesClass ifTrue: [^self fileoutBytesDefinitionOn: aStream].
	self isVariableClass ifTrue: [^self fileoutVariableDefinitionOn: aStream].
	self fileoutPlainClassDefinitionOn: aStream! !

! Class methodsFor: 'fileIn/Out' !
fileoutPlainClassDefinitionOn: aStream

	| kit |

	kit := KitManager current kitForClass: self.
	kit isNil ifTrue: [kit := KitManager current kitNamed: 'Core'].
 
	self superclass printOn: aStream.
	aStream
		nextPutAll: ' subclassNamed: ';
		print: self name;
		cr; tab; nextPutAll: 'instVarNames: '; print: self instVarNamesString;
		cr; tab; nextPutAll: 'classInstVarNames: '; print: self classInstVarNamesString;
		cr; tab; nextPutAll: 'environment: Object systemDictionary';
		cr; tab; nextPutAll: 'kitName: '''; nextPutAll: kit name; nextPutAll: ''' !'! !

! Class methodsFor: 'fileIn/Out' !
fileoutSource

	| stream |

	self log: 'fileout: ', self name.

	stream := ('stSource' asFilename construct: self name asString, '.st') writeStream.
	self fileoutSourceOn: stream.
	stream close! !

! Class methodsFor: 'fileIn/Out' !
fileoutSourceOn: aStream

	self fileoutDefinitionOn: aStream.
	aStream cr; cr.
	self fileoutMethodsOn: aStream.
	self class fileoutMethodsOn: aStream.
! !

! Class methodsFor: 'fileIn/Out' !
fileoutVariableDefinitionOn: aStream
	| kit |

	kit := KitManager current kitForClass: self.
	kit isNil ifTrue: [kit := KitManager current kitNamed: 'Core'].
 
	self superclass printOn: aStream.
	aStream
		nextPutAll: ' variableSubclassNamed: ';
		print: self name;
		cr; tab; nextPutAll: 'instVarNames: '; print: self instVarNamesString;
		cr; tab; nextPutAll: 'classInstVarNames: '; print: self classInstVarNamesString;
		cr; tab; nextPutAll: 'environment: Object systemDictionary';
		cr; tab; nextPutAll: 'kitName: '''; nextPutAll: kit name; nextPutAll: ''' !'! !

! Class methodsFor: 'fileIn/Out' !
instVarNamesString

	| stream |
	stream := WriteStream on: (String new: 100).
	self instVarNames
		do: [:name | stream nextPutAll: name]
		separatedBy: [stream space].
	^stream contents! !

! Class methodsFor: 'migrating' !
migrateAllInstancesFrom: oldClass
	
	| newInstVarNames oldInstVarNames mapping |
	
	newInstVarNames := self allInstVarNames.
	oldInstVarNames := oldClass allInstVarNames.

	mapping := Array new: newInstVarNames size.
	1 to: newInstVarNames size do: [:newInstVarNumber |
		| index |
		index := oldInstVarNames indexOf: (newInstVarNames at: newInstVarNumber).
		index ~= 0 ifTrue: [
			mapping at: newInstVarNumber put: index]].

	oldClass allInstances do: [:oldInstance |
		| newInstance |
		newInstance := self basicNew: oldInstance basicSize.
		newInstance migrateFrom: oldInstance instVarMapping: mapping.
		oldInstance become: newInstance].
	! !

! Class methodsFor: 'migrating' !
migrateClassFrom: oldClass

	| newInstVarNames oldInstVarNames mapping |
	
	newInstVarNames := self class allInstVarNames.
	oldInstVarNames := oldClass class allInstVarNames.

	oldInstVarNames = newInstVarNames ifTrue: [^self].
	
	mapping := Array new: newInstVarNames size.
	1 to: newInstVarNames size do: [:newInstVarNumber |
		| index |
		index := oldInstVarNames indexOf: (newInstVarNames at: newInstVarNumber).
		index ~= 0 ifTrue: [
			mapping at: newInstVarNumber put: index]].

	self migrateFrom: oldClass instVarMapping: mapping! !

! Class methodsFor: 'printing' !
printOn: aStream

	^aStream nextPutAll: self name! !

! Class methodsFor: 'removing' !
removeSubclass: aClass

	self class basicRemoveSubclass: aClass class.
	self basicRemoveSubclass: aClass! !

! Collection methodsFor: 'accessing' !
includes: anObject 

	self do: [:each | 
		each = anObject ifTrue: [^true]].
	
	^false! !

! Collection methodsFor: 'accessing' !
size

	^self basicSize! !

! Collection methodsFor: 'converting' !
asArray
	| array index |

	(self isMemberOf: Array) ifTrue: [^self].
	
	array := Array new: self size.
	index := 1.
	self do: [:each |
		array at: index put: each.
		index := index + 1].
	^array
	! !

! Collection methodsFor: 'converting' !
asByteArray
	| array index |

	(self isMemberOf: ByteArray) ifTrue: [^self].
	
	array := ByteArray new: self size.
	index := 1.
	self do: [:each |
		array at: index put: each.
		index := index + 1].
	^array
	! !

! Collection methodsFor: 'converting' !
asOrderedCollection
	| orderedCollection |

	(self isMemberOf: OrderedCollection) ifTrue: [^self].
	
	orderedCollection := OrderedCollection new: self size.
	self do: [:each |
		orderedCollection add: each].
	^orderedCollection
	! !

! Collection methodsFor: 'converting' !
asSet
	| set |

	(self isMemberOf: Set) ifTrue: [^self].
	
	set := Set new: self size.
	self do: [:each |
		set add: each].
	^set
	! !

! Collection methodsFor: 'enumerating' !
allSatisfy: aBlock 

	self do: [:each | (aBlock value: each) = true
			ifFalse: [^false]].
	^true! !

! Collection methodsFor: 'enumerating' !
anySatisfy: aBlock 

	self do: [:each | 
		(aBlock value: each) = true ifTrue: [^true].
		nil].
	
	^false! !

! Collection methodsFor: 'enumerating' !
collect: aBlock 

	| result |
	result := self species new: self size.
	self do: [:each | result add: (aBlock value: each)].
	^result! !

! Collection methodsFor: 'enumerating' !
detect: aBlock

	^self detect: aBlock ifNone: [self halt]! !

! Collection methodsFor: 'enumerating' !
detect: aBlock ifNone: noneBlock

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^noneBlock value! !

! Collection methodsFor: 'enumerating' !
do: aBlock 

	self subclassResponsibility! !

! Collection methodsFor: 'enumerating' !
do: aBlock separatedBy: aBlock2

	| hasStarted |

	hasStarted := false.
	self do: [:each |
		hasStarted ifTrue: [aBlock2 value].
		hasStarted := true.
		aBlock value: each]! !

! Collection methodsFor: 'enumerating' !
inject: anObject into: aBlock

	| result |
	result := anObject.
	self do: [:each | result := aBlock value: result value: each].
	^result! !

! Collection methodsFor: 'enumerating' !
occurrencesOf: anObject

	| occurrences |

	occurrences := 0.
	self do: [:each | each = anObject ifTrue: [occurrences := occurrences + 1]].
	^occurrences! !

! Collection methodsFor: 'enumerating' !
reject: aBlock 

	^self select: [:each | (aBlock value: each) not]! !

! Collection methodsFor: 'enumerating' !
select: aBlock 

	| result |
	result := self species new: self size.
	self do: [:each | (aBlock value: each)
			ifTrue: [result add: each]
			ifFalse: [nil]].
	^result! !

! Collection methodsFor: 'printing' !
printCollectionEndOn: aStream
	aStream nextPut: $)! !

! Collection methodsFor: 'printing' !
printCollectionStartOn: aStream
	aStream
		nextPutAll: self class name;
		nextPutAll: ' ('! !

! Collection methodsFor: 'printing' !
printOn: aStream

	| count |
	count := 0.

	self printCollectionStartOn: aStream.
	self
		do: [:each |
			each printOn: aStream.
			count := count + 1.
			count > 100 ifTrue: [
				aStream nextPutAll: '...'.
				self printCollectionEndOn: aStream.
				^self]]
		separatedBy: [aStream space].

	self printCollectionEndOn: aStream
	 ! !

! Collection methodsFor: 'printing' !
printOn: aStream limit: aNumber

	| count |
	count := 0.
	self printCollectionStartOn: aStream.
	self
		do: [:each |
			each printOn: aStream.
			count := count + 1.
			count > aNumber ifTrue: [
				aStream nextPutAll: '...'.
				self printCollectionEndOn: aStream.
				^self]]
		separatedBy: [aStream space].

	self printCollectionEndOn: aStream
	! !

! Collection methodsFor: 'printing' !
storeOn: aStream

	self printCollectionStartOn: aStream.
	self
		do: [:each | each printOn: aStream]
		separatedBy: [aStream space].

	self printCollectionEndOn: aStream
	! !

! Collection methodsFor: 'private' !
species

	^self subclassResponsibility! !

! Collection methodsFor: 'removing' !
remove: anObject

	self subclassResponsibility! !

! Collection methodsFor: 'removing' !
removeAll: aCollection

	aCollection do: [:each | self remove: each]! !

! Collection methodsFor: 'testing' !
isCollection

	^true! !

! Collection methodsFor: 'testing' !
isEmpty

	^self size = 0! !

! Collection methodsFor: 'testing' !
notEmpty

	^self isEmpty not! !

! CompiledCode methodsFor: 'accessing' !
allNestedLiterals

	| literals |

	literals := OrderedCollection new: self basicSize.
	1 to: self basicSize do: [:index |
		literals add: (self at: index).
		(self at: index) isBlock ifTrue: [
			literals addAll: (self at: index) allNestedLiterals]].

	^literals asArray! !

! CompiledCode methodsFor: 'accessing' !
bytecodes

	^bytecodes! !

! CompiledCode methodsFor: 'accessing' !
bytecodes: anObject

	bytecodes := anObject! !

! CompiledCode methodsFor: 'accessing' !
callOffsetsIn: anObject do: aBlock

	| decompileStream line matchNext offset|

	matchNext := false.

	decompileStream := anObject decompileNoBytes readStream.
	[decompileStream atEnd] whileFalse: [
		line := decompileStream upTo: Character cr.
		matchNext ifTrue: [
			offset := line trimSeparators readStream upTo: $:.
			aBlock value: (Integer readHexFrom: offset readStream).
			matchNext := false].
		('*call*' match: line) ifTrue: [matchNext := true]
		]! !

! CompiledCode methodsFor: 'accessing' !
getSource

	| stream |

	stream := (BeagleSystem sourceFileNames at: (self sourceOffsets at: 1)) asFilename readStream.
	^[stream position: (self sourceOffsets at: 2).
		stream next: (self sourceOffsets at: 3) - (self sourceOffsets at: 2)]
		ensure: [stream close] ! !

! CompiledCode methodsFor: 'accessing' !
literals

	| literals |

	literals := Array new: self basicSize.
	1 to: self basicSize do: [:index |
		literals at: index put: (self at: index)].

	^literals! !

! CompiledCode methodsFor: 'accessing' !
localVariableNames

	^localVariableNames! !

! CompiledCode methodsFor: 'accessing' !
localVariableNames: anObject

	localVariableNames := anObject! !

! CompiledCode methodsFor: 'accessing' !
mclass

	^mclass! !

! CompiledCode methodsFor: 'accessing' !
mclass: anObject

	mclass := anObject! !

! CompiledCode methodsFor: 'accessing' !
methodOffsets

	^self sourceOffsets copyFrom: 2 to: 3! !

! CompiledCode methodsFor: 'accessing' !
numberOfArguments

	^numberOfArguments! !

! CompiledCode methodsFor: 'accessing' !
numberOfArguments: anObject

	numberOfArguments := anObject! !

! CompiledCode methodsFor: 'accessing' !
numberOfLocals

	^self numberOfArguments + self numberOfTemporaries! !

! CompiledCode methodsFor: 'accessing' !
numberOfSendsIn: anObject

	| numberOfSends |
	numberOfSends := 0.
	self callOffsetsIn: anObject do: [:offset |
		numberOfSends := numberOfSends + 1].

	^numberOfSends! !

! CompiledCode methodsFor: 'accessing' !
numberOfTemporaries

	^numberOfTemporaries! !

! CompiledCode methodsFor: 'accessing' !
numberOfTemporaries: anObject

	numberOfTemporaries := anObject! !

! CompiledCode methodsFor: 'accessing' !
sourceOffsets

	^sourceOffsets! !

! CompiledCode methodsFor: 'accessing' !
sourceOffsets: anObject

	sourceOffsets := anObject! !

! CompiledCode methodsFor: 'accessing' !
sourceOffsetsDictionary

	| dictionary |
	dictionary := Dictionary new.
	4 to: self sourceOffsets size by: 3 do: [:index |
		dictionary
			at: (self sourceOffsets at: index)
			put: (Array
					with: (self sourceOffsets at: index + 1)
					with: (self sourceOffsets at: index + 2))].
	^dictionary! !

! CompiledCode methodsFor: 'accessing' !
writeMethodOffsets: anArray

	anArray isNil ifTrue: [^self].

	self sourceOffsets
		at: 1 put: 2;
		at: 2 put: (anArray at: 1);
		at: 3 put: (anArray at: 2).

	self literals do: [:eachLiteral |
		eachLiteral isCompiledBlock ifTrue: [
			eachLiteral writeMethodOffsets: anArray].
		eachLiteral isBlockClosure ifTrue: [
			eachLiteral method writeMethodOffsets: anArray].
		]! !

! CompiledCode methodsFor: 'navigating' !
findSendWithOffset: aNumber

	4 to: self sourceOffsets size by: 3 do: [:offset |
		| bytecodeOffset sourceStart sourceEnd |
		bytecodeOffset := self sourceOffsets at: offset.
		sourceStart := self sourceOffsets at: offset + 1.
		sourceEnd := self sourceOffsets at: offset + 2.

		(aNumber between: sourceStart and: sourceEnd) ifTrue: [
			| stream |
			stream := self decompile readStream.
			[stream atEnd] whileFalse: [
				| line lineStream |
				line := stream upTo: Character cr.
				lineStream := line readStream.
				(lineStream upTo: $:) trimSeparators = bytecodeOffset hex ifTrue: [
					lineStream upToAll: 'literal '.
					^self at: (Integer readFrom: lineStream) + 1]
				]
			]
		].

	self literals do: [:literal |
		literal isBlockClosure ifTrue: [
			| selector |
			selector := literal method findSendWithOffset: aNumber.
			selector isNil ifFalse: [^selector]].
		literal isCompiledBlock ifTrue: [
			| selector |
			selector := literal findSendWithOffset: aNumber.
			selector isNil ifFalse: [^selector]].
	].

	^nil! !

! CompiledBlock methodsFor: 'accessing' !
outerMethod

	^outerMethod! !

! CompiledBlock methodsFor: 'accessing' !
outerMethod: anObject

	outerMethod := anObject.
	1 to: self basicSize do: [:index |
		| literal |
		literal := self basicAt: index.
		literal isCompiledBlock ifTrue: [literal outerMethod: anObject].
		literal isBlockClosure ifTrue: [literal method outerMethod: anObject] ]! !

! CompiledBlock methodsFor: 'accessing' !
rootMethod

	^self outerMethod rootMethod! !

! CompiledBlock methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: '[] in ';
		print: self outerMethod! !

! CompiledBlock methodsFor: 'running' !
value

	<primitive: 501>
	self primitiveFailed! !

! CompiledBlock methodsFor: 'running' !
value: anObject

	<primitive: 502>
	self primitiveFailed! !

! CompiledBlock methodsFor: 'running' !
value: anObject value: anotherObject

	<primitive: 503>
	self primitiveFailed! !

! CompiledBlock methodsFor: 'testing' !
isBlock

	^true! !

! CompiledBlock methodsFor: 'testing' !
isCompiledBlock

	^true! !

! CompiledMethod methodsFor: 'accessing' !
allMessages

	| selectors |
	selectors := Set new.
	self allNestedLiterals do: [:literal |
		literal isSymbol ifTrue: [
			selectors add: literal]].

	^selectors asOrderedCollection sorted addFirst: self selector; yourself! !

! CompiledMethod methodsFor: 'accessing' !
definingKit

	^self kit ifNil: [KitManager current kitForClass: self mclass thisClass]! !

! CompiledMethod methodsFor: 'accessing' !
kit

	^kit! !

! CompiledMethod methodsFor: 'accessing' !
kit: aKit

	kit := aKit! !

! CompiledMethod methodsFor: 'accessing' !
organization

	^self mclass organizationFor: self selector! !

! CompiledMethod methodsFor: 'accessing' !
rootMethod

	^self! !

! CompiledMethod methodsFor: 'accessing' !
selector

	^selector! !

! CompiledMethod methodsFor: 'accessing' !
selector: anObject

	selector := anObject! !

! CompiledMethod methodsFor: 'fileout' !
fileoutOn: aStream

	aStream nextPutAll: self getSource! !

! CompiledMethod methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: self mclass name;
		nextPutAll: ' >> ';
		nextPutAll: self selector! !

! CompiledMethod methodsFor: 'testing' !
isPrimitive

	^self bytecodes first = 16rDB! !

! ComputedField methodsFor: 'accessing' !
action

	^action! !

! ComputedField methodsFor: 'accessing' !
action: anObject

	action := anObject! !

! ComputedField methodsFor: 'accessing' !
name

	^name! !

! ComputedField methodsFor: 'accessing' !
name: anObject

	name := anObject! !

! ComputedField methodsFor: 'converting' !
asString

	^'- ', self name! !

! ComputedField methodsFor: 'evaluating' !
valueFor: anObject

	^self action value: anObject! !

! ComputedField methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: self name;
		nextPutAll: ' ==> ';
		print: self action! !

! ComputedField methodsFor: 'testing' !
isComputedField

	^true! !

! ComputedField class methodsFor: 'instance creation' !
name: aString action: aValueModel

	^self new
		name: aString;
		action: aValueModel;
		yourself! !

! Dictionary methodsFor: 'accessing' !
addAssociation: anAssociation 

	| foundValue index |
	index := self findIndex: anAssociation key.
	(foundValue := values at: index) notNil ifTrue: [
		foundValue value: anAssociation value.
		^anAssociation value].
	tally := tally + 1.
	values at: index put: anAssociation.
	self growIfNeeded.
	^anAssociation value! !

! Dictionary methodsFor: 'accessing' !
associationAt: aKey

	| index |
	
	index := self findIndex: aKey.
	index = 0 ifTrue: [^nil].
	^values at: index! !

! Dictionary methodsFor: 'accessing' !
associationAt: aKey ifAbsent: aBlock

	| index |
	
	index := self findIndex: aKey.
	index = 0 ifTrue: [^aBlock value].
	^values at: index! !

! Dictionary methodsFor: 'accessing' !
associations

	| collection |
	collection := OrderedCollection new: self size.
	self associationsDo: [:assoc | collection add: assoc].
	^collection
! !

! Dictionary methodsFor: 'accessing' !
at: anObject 

	| association index |
	index := self findIndex: anObject.
	(association := values at: index) isNil ifTrue: [^self error: 'Key [' , anObject printString, '] not found'].
	^association value! !

! Dictionary methodsFor: 'accessing' !
at: key ifAbsent: aBlock 

	| association index |
	index := self findIndex: key.
	(association := values at: index) isNil ifTrue: [^aBlock value].
	^association value! !

! Dictionary methodsFor: 'accessing' !
at: key ifAbsentPut: aBlock 

	| association index |
	index := self findIndex: key.
	(association := values at: index) isNil ifTrue: [^self at: key put: aBlock value].
	^association value! !

! Dictionary methodsFor: 'accessing' !
at: key put: value 

	| association index |
	index := self findIndex: key.
	index = 0 ifTrue: [
		self growIfNeeded.
		index := self findIndex: key].
	(association := values at: index) notNil
		ifTrue: 
			[association value: value.
			^value].
	tally := tally + 1.
	values at: index put: (Association key: key value: value).
	self growIfNeeded.
	^value! !

! Dictionary methodsFor: 'accessing' !
basicValues
	^values! !

! Dictionary methodsFor: 'accessing' !
bindingFor: aKey

	^self associationAt: aKey! !

! Dictionary methodsFor: 'accessing' !
doesKey: key match: anObject

	^key = anObject! !

! Dictionary methodsFor: 'accessing' !
findIndex: anObject 

	| probe association initialProbe |

	initialProbe := probe := self initialProbeFor: anObject.
	initialProbe = 0 ifTrue: [^0].

	[(association := values at: probe) isNil ifTrue: [^probe].
	(self doesKey: association key match: anObject) ifTrue: [^probe].
	(probe := probe + 1) > values size ifTrue: [probe := 1].
	probe = initialProbe ifTrue: [^self error: self class printString , ' is completely full'].
	true] whileTrue.
	^0! !

! Dictionary methodsFor: 'accessing' !
growIfNeeded

	| oldValues newDictionary |
	(values size > 0 and: [
		tally * 100 // values size <= 70]) ifTrue: [^self].

	oldValues := values.
	newDictionary := self class new: (values size max: 5) * 2.

	oldValues do: [:each | each isNil
			ifFalse: [newDictionary addAssociation: each]].
	
	values := newDictionary basicValues! !

! Dictionary methodsFor: 'accessing' !
includesKey: anObject 
	| index |
	index := self findIndex: anObject.
	index = 0 ifTrue: [^false].
	^(values at: index) notNil! !

! Dictionary methodsFor: 'accessing' !
initialProbeFor: anObject 
	values isEmpty ifTrue: [^0].
	^anObject hash \\ values size + 1! !

! Dictionary methodsFor: 'accessing' !
keys

	| set |
	set := Set new: values size.
	values do: [:each | each notNil
			ifTrue: [set add: each key]].
	^set! !

! Dictionary methodsFor: 'accessing' !
rehash

	| newDictionary |

	newDictionary := self class new: values size.
	self associationsDo: [:each |
		newDictionary addAssociation: each].

	self become: newDictionary
! !

! Dictionary methodsFor: 'accessing' !
size

	^tally! !

! Dictionary methodsFor: 'accessing' !
values

	| result |
	result := OrderedCollection new: self size.
	values do: [:each | each notNil
			ifTrue: [result add: each value]].
	^result! !

! Dictionary methodsFor: 'copying' !
copy

	| copy |
	copy := self class new: values size.
	self keysAndValuesDo: [:key :value |
		copy at: key put: value].
	
	^copy! !

! Dictionary methodsFor: 'copying' !
copyWithAssociations

	| copy |
	copy := self class new: values size.
	self associationsDo: [:assoc |
		copy addAssociation: assoc].
	
	^copy! !

! Dictionary methodsFor: 'enumerating' !
associationsDo: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each]
			ifFalse: [nil]]! !

! Dictionary methodsFor: 'enumerating' !
do: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each value]]! !

! Dictionary methodsFor: 'enumerating' !
keysAndValuesDo: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each key value: each value]]! !

! Dictionary methodsFor: 'enumerating' !
keysDo: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each key]]! !

! Dictionary methodsFor: 'initialize-release' !
initialize: size 

	tally := 0.
	values := Array new: (size max: 10)! !

! Dictionary methodsFor: 'removing' !
privateRemoveKey: anObject 

	| probe initialProbe valuesToReHash rehashProbe oldObject |

	oldObject := self at: anObject.
	initialProbe := self initialProbeFor: anObject.
	probe := self findIndex: anObject.
	values at: probe put: nil.
	tally := tally - 1.

	"A poor man's rehash."
	self become: self copyWithAssociations.

	"valuesToReHash := OrderedCollection new.

	rehashProbe := initialProbe + 1.
	rehashProbe > values size ifTrue: [rehashProbe := 1].

	[(values at: rehashProbe) isNil] whileFalse: [
		valuesToReHash add: (values at: rehashProbe).
		values at: rehashProbe put: nil.
		tally := tally - 1.
		(rehashProbe := rehashProbe + 1) > values size ifTrue: [rehashProbe := 1].
		rehashProbe = initialProbe ifTrue: [self error: 'No nils left in set'. ^nil]].

	valuesToReHash do: [:eachAssociation | self addAssociation: eachAssociation]."

	^oldObject! !

! Dictionary methodsFor: 'removing' !
removeKey: anObject

	| newDictionary oldObject |

	newDictionary := self copyWithAssociations.
	oldObject := newDictionary privateRemoveKey: anObject.
	values := newDictionary basicValues.
	tally := newDictionary size.
	^oldObject
! !

! Dictionary methodsFor: 'removing' !
removeKey: anObject ifAbsent: aBlock

	(self includesKey: anObject) ifFalse: [^aBlock value].
	^self removeKey: anObject! !

! Dictionary methodsFor: 'testing' !
isDictionary

	^true! !

! Dictionary class methodsFor: 'instance creation' !
new

	^self new: 20! !

! Dictionary class methodsFor: 'instance creation' !
new: size 

	^self basicNew initialize: size! !

! Dictionary class methodsFor: 'instance creation' !
rehashAllDictionaries

	(self withAllSubclasses) do: [:class |
		class allInstances do: [:instance | instance rehash].
		].
! !

! Doit class methodsFor: 'uncategorized' !
doit ^[KitManager current fileoutAllKits] value! !

! EventBase methodsFor: 'accessing' !
eventRegistry
	^eventRegistry! !

! EventBase methodsFor: 'initializing' !
initialize

	eventRegistry := Dictionary new! !

! EventBase methodsFor: 'initializing' !
onEvent: anEventKey do: aBlock

	(eventRegistry at: anEventKey ifAbsentPut: [OrderedCollection new])
		add: aBlock ! !

! EventBase methodsFor: 'raising' !
raiseEvent: anEvent

	(eventRegistry at: anEvent eventKey ifAbsent: [^false])
		do: [:eachBlock | eachBlock cull: anEvent].
	^true! !

! EventBase class methodsFor: 'instance creation' !
new
	^super new initialize; yourself! !

! Exception methodsFor: 'accessing' !
action

	^action! !

! Exception methodsFor: 'accessing' !
action: anObject

	action := anObject! !

! Exception methodsFor: 'accessing' !
asString

	^self message! !

! Exception methodsFor: 'accessing' !
message

	^message! !

! Exception methodsFor: 'accessing' !
message: anObject

	message := anObject! !

! Exception methodsFor: 'accessing' !
result

	^result! !

! Exception methodsFor: 'accessing' !
result: anObject

	result := anObject! !

! Exception methodsFor: 'handling' !
pass

	action := #pass! !

! Exception methodsFor: 'handling' !
raiseSignal

	| handler |

	handler := self class handlerFor: self before: nil.

	[handler notNil and: [
		handler catchBlock cull: self.
		self action = #resume ifTrue: [^self].
		self action = #pass]] whileTrue: [
		handler := self class handlerFor: self before: handler]! !

! Exception methodsFor: 'handling' !
resume

	action := #resume! !

! Exception methodsFor: 'handling' !
retry

	action := #retry! !

! Exception methodsFor: 'handling' !
return

	result := self.
	action := #return! !

! Exception methodsFor: 'handling' !
return: anObject

	result := anObject.
	action := #return! !

! Exception methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' - ';
		nextPutAll: self message! !

! Exception class methodsFor: 'accessing' !
try: tryBlock catch: catchBlock

	^self try: tryBlock catch: catchBlock finally: nil! !

! Exception class methodsFor: 'accessing' !
try: tryBlock catch: catchBlock finally: finallyBlock

	| wrappedCatchBlock result handler |

	handler := ExceptionHandler new
		exceptionClass: (catchBlock ifNil: [nil] ifNotNil: [self]);
		finallyBlock: finallyBlock;
		yourself.

	wrappedCatchBlock := catchBlock ifNil: [nil] ifNotNil: [[:ex |
		catchBlock cull: ex.
		ex action = #return ifTrue: [
			handler unwind.
			^ex result].
		ex action = #retry ifTrue: [
			result := tryBlock value] ] ].
	
	handler catchBlock: wrappedCatchBlock.

	self exceptionHandlers add: handler.

	result := tryBlock value.
	handler unwind.

	^result! !

! Exception class methodsFor: 'accessing' !
try: tryBlock finally: finallyBlock

	^self try: tryBlock catch: nil finally: finallyBlock! !

! Exception class methodsFor: 'instance creation' !
, anException

	^ExceptionList new
		addException: self;
		addException: anException;
		yourself! !

! Exception class methodsFor: 'instance creation' !
exceptionHandlers

	<primitive: 554>
	self primitiveFailed! !

! Exception class methodsFor: 'instance creation' !
handlerFor: anException before: aHandler

	| startingHandlerIndex |

	startingHandlerIndex := aHandler isNil
		ifTrue: [self exceptionHandlers size]
		ifFalse: [self exceptionHandlers indexOf: aHandler].

	startingHandlerIndex to: 1 by: -1 do: [:index |
		| handler |
		handler := self exceptionHandlers at: index.
		(handler exceptionClass notNil and: [handler exceptionClass handlesException: anException]) ifTrue: [^handler]].

	^nil.! !

! Exception class methodsFor: 'signalling' !
defaultErrorString

	^'Unhandled Exception'! !

! Exception class methodsFor: 'signalling' !
findSendWithOffset: aNumber

	4 to: self sourceOffsets size by: 3 do: [:offset |
		| bytecodeOffset sourceStart sourceEnd |
		bytecodeOffset := self sourceOffsets at: offset.
		sourceStart := self sourceOffsets at: offset + 1.
		sourceEnd := self sourceOffsets at: offset + 2.

		(aNumber between: sourceStart and: sourceEnd) ifTrue: [
			| stream |
			stream := self decompile readStream.
			[stream atEnd] whileFalse: [
				| line |
				line := stream upTo: Character cr.
				(line readStream upTo: $:) trimSeparators = bytecodeOffset hex ifTrue: [
					self log: line]
				]
			]
		].

	^#gotIt
! !

! Exception class methodsFor: 'signalling' !
handlesException: anException

	^anException isKindOf: self! !

! Exception class methodsFor: 'signalling' !
signal

	self signal: self defaultErrorString! !

! Exception class methodsFor: 'signalling' !
signal: aString

	self new
		message: aString;
		raiseSignal! !

! Exception class methodsFor: 'signalling' !
unwindTo: aHandler

	| index |

	index := self exceptionHandlers indexOf: aHandler.
	index = 0 ifTrue: [^self].
	self exceptionHandlers size to: index by: -1 do: [:eachIndex |
		(self exceptionHandlers at: eachIndex) finallyBlock ifNotNil: [:block |
				block value].
		self exceptionHandlers removeLast]! !

! ExceptionBase methodsFor: 'accessing' !
catchBlock

	^catchBlock! !

! ExceptionBase methodsFor: 'accessing' !
catchBlock: anObject

	catchBlock := anObject! !

! ExceptionBase methodsFor: 'accessing' !
finallyBlock

	^finallyBlock! !

! ExceptionBase methodsFor: 'accessing' !
finallyBlock: anObject

	finallyBlock := anObject! !

! ExceptionBase methodsFor: 'handling' !
unwind

	Exception unwindTo: self! !

! ExceptionHandler methodsFor: 'accessing' !
catchBlock

	^catchBlock! !

! ExceptionHandler methodsFor: 'accessing' !
catchBlock: anObject

	catchBlock := anObject! !

! ExceptionHandler methodsFor: 'accessing' !
exceptionClass

	^exceptionClass! !

! ExceptionHandler methodsFor: 'accessing' !
exceptionClass: anObject

	exceptionClass := anObject! !

! ExceptionHandler methodsFor: 'accessing' !
finallyBlock

	^finallyBlock! !

! ExceptionHandler methodsFor: 'accessing' !
finallyBlock: anObject

	finallyBlock := anObject! !

! ExceptionHandler methodsFor: 'handling' !
handlesException: anException

	^self exceptionClass notNil and: [anException isKindOf: self exceptionClass]! !

! ExceptionHandler methodsFor: 'handling' !
unwind

	Exception unwindTo: self! !

! ExceptionList methodsFor: 'accessing' !
exceptions

	^exceptions! !

! ExceptionList methodsFor: 'accessing' !
exceptions: anObject

	exceptions := anObject! !

! ExceptionList methodsFor: 'adding' !
, anException

	self addException: anException
! !

! ExceptionList methodsFor: 'adding' !
addException: anException

	exceptions add: anException
! !

! ExceptionList methodsFor: 'handling' !
exceptionHandlers

	^Exception exceptionHandlers! !

! ExceptionList methodsFor: 'handling' !
handlesException: anException

	^self exceptions anySatisfy: [:each | each handlesException: anException]! !

! ExceptionList methodsFor: 'handling' !
try: tryBlock catch: catchBlock

	^Exception try: tryBlock catch: catchBlock! !

! ExceptionList methodsFor: 'handling' !
try: tryBlock catch: catchBlock finally: finallyBlock

	^Exception try: tryBlock catch: catchBlock finally: finallyBlock! !

! ExceptionList methodsFor: 'handling' !
try: tryBlock finally: finallyBlock

	^Exception try: tryBlock finally: finallyBlock! !

! ExceptionList methodsFor: 'initializing' !
initialize

	exceptions := OrderedCollection new! !

! ExceptionList class methodsFor: 'instance creation' !
new

	^super new initialize! !

! False methodsFor: 'accessing' !
& aBoolean 

	^false! !

! False methodsFor: 'accessing' !
and: aBlock 

	^false! !

! False methodsFor: 'accessing' !
ifFalse: aBlock 

	^aBlock value! !

! False methodsFor: 'accessing' !
ifFalse: falseBlock ifTrue: trueBlock 

	^falseBlock value! !

! False methodsFor: 'accessing' !
ifTrue: aBlock 

	^nil! !

! False methodsFor: 'accessing' !
ifTrue: trueBlock ifFalse: falseBlock 

	^falseBlock value! !

! False methodsFor: 'accessing' !
not

	^true! !

! False methodsFor: 'accessing' !
or: aBlock 

	^aBlock value! !

! False methodsFor: 'accessing' !
| aBoolean 

	^aBoolean! !

! False methodsFor: 'printing' !
printOn: aStream 

	aStream nextPutAll: 'false'! !

! Filename methodsFor: 'accessing' !
appendStream

	^(FileStream new open: self path mode: FileStream append)! !

! Filename methodsFor: 'accessing' !
asFilename

	^self! !

! Filename methodsFor: 'accessing' !
path

	^path! !

! Filename methodsFor: 'accessing' !
path: anObject

	path := anObject! !

! Filename methodsFor: 'accessing' !
readStream

	^(FileStream new open: self path mode: FileStream read)! !

! Filename methodsFor: 'accessing' !
writeStream

	^(FileStream new open: self path mode: FileStream write)! !

! Filename methodsFor: 'fileIn/Out' !
fileIn

	| file |

	BeagleSystem log: 'Filing in ', self path.
	file := self readStream.
	file fileIn.
	file close! !

! Filename methodsFor: 'operations' !
/ aString

	^self construct: aString
! !

! Filename methodsFor: 'operations' !
\ aString

	^self construct: aString
! !

! Filename methodsFor: 'operations' !
asCoreFilename

	^path asVWString asFilename! !

! Filename methodsFor: 'operations' !
asString

	^path! !

! Filename methodsFor: 'operations' !
construct: aString

	^self class named: self path, self class pathDelimiterString, aString! !

! Filename methodsFor: 'operations' !
copyTo: destinationPathString

	| file1 file2 |

	file1 := self readStream.
	file2 := destinationPathString asFilename writeStream.
	[file1 atEnd] whileFalse: [
		file2 nextPut: file1 next].
	file1 close.
	file2 close! !

! Filename methodsFor: 'operations' !
fileSize

	^self class sizeOfFile: path! !

! Filename methodsFor: 'operations' !
renameTo: destinationPathString

	^self class rename: path to: destinationPathString! !

! Filename methodsFor: 'testing' !
exists

	^self class fileExists: path! !

! Filename class methodsFor: 'instance creation' !
getInternalPath

	<primitive: 800>
	self primitiveFailed! !

! Filename class methodsFor: 'instance creation' !
internalPath

	^self named: (self getInternalPathX)! !

! Filename class methodsFor: 'instance creation' !
named: aString

	^self new
		path: aString;
		yourself! !

! Filename class methodsFor: 'operations' !
fileExists: aString

	<primitive: 1403>
	self primitiveFailed! !

! Filename class methodsFor: 'operations' !
pathDelimiterString

	<primitive: 1513>
	^'/'! !

! Filename class methodsFor: 'operations' !
rename: originPathString to: destinationPathString

	<primitive: 1405>
	^self! !

! Filename class methodsFor: 'operations' !
sizeOfFile: aZeroTerminatedString
	
	<primitive: 1404>
	self primitiveFailed! !

! Filename class methodsFor: 'operations' !
unpackAssetToInternalPath: aString

	<primitive: 801>
	self primitiveFailed! !

! HaltException methodsFor: 'signaling' !
raiseSignal2

	self raiseSignal
! !

! HaltException class methodsFor: 'signalling' !
signal: aString

	self new
		message: aString;
		raiseSignal2! !

! IdentityDictionary methodsFor: 'accessing' !
doesKey: key match: anObject

	^key == anObject! !

! IdentityDictionary methodsFor: 'accessing' !
initialProbeFor: anObject 
	values isEmpty ifTrue: [^0].
	^anObject identityHash \\ values size + 1! !

! JunkClass methodsFor: 'junk' !
ifFalseIfTrueTest

	| result |

	self isNil
		ifFalse: [result := 5]
		ifTrue: [result := 6].

	^result! !

! JunkClass methodsFor: 'junk' !
ifFalseReturnTest

	| result |

	self isNil
		ifFalse: [^result := 5].

	^result! !

! JunkClass methodsFor: 'junk' !
ifFalseTest

	| result |

	self isNil
		ifFalse: [result := 5].

	^result! !

! JunkClass methodsFor: 'junk' !
ifTrueIfFalseTest

	| result |

	self isNil
		ifTrue: [
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
]
		ifFalse: [result := 6].

	^result! !

! JunkClass methodsFor: 'junk' !
initialize

	instVar1 := 5.
	instVar2 := 7

! !

! JunkClass methodsFor: 'junk' !
junkMethod

	| factorial hash |

	factorial := 1.
	hash := super hash.

	1 to: 5 do: [:x |	factorial := factorial * x].

	^factorial * 5
	! !

! JunkClass methodsFor: 'junk' !
junkMethod10

	^[CompileError new raiseSignal.  3 + 4]
		on: CompileError
		do: [:ex | ex resume].
! !

! JunkClass methodsFor: 'junk' !
junkMethod2

	self initialize.
	^[instVar1 := 6] value.! !

! JunkClass methodsFor: 'junk' !
junkMethod3

	^(3 + 4)! !

! JunkClass methodsFor: 'junk' !
junkMethod4

	self halt.
	^super isKindOf: Object! !

! JunkClass methodsFor: 'junk' !
junkMethod5

	"Junk"

	self halt.
	^self perform: #junkMethod! !

! JunkClass methodsFor: 'junk' !
junkMethod6

	| y |

	"Junk xxxx"

	y := 0.
	instVar1 := 3.

	^[:x | x ifNotNil: [self halt. instVar1 * x + y]] value: 5 ! !

! JunkClass methodsFor: 'junk' !
junkMethod7

	| a |
	a := 0! !

! JunkClass methodsFor: 'junk' !
junkMethod8

	self
		basicAt: 3 - 1 * 2 + 1;
		basicAt: 3 - 1 * 2 + 2! !

! JunkClass methodsFor: 'junk' !
method2: aNumber

	^aNumber cos + instVar1 + instVar2! !

! JunkClass methodsFor: 'junk' !
nonLocalReturn

	self ifNotNil: [:object | ^self].
! !

! JunkClass methodsFor: 'junk' !
nonLocalReturnA

	self nonLocalReturnB: [^self]
! !

! JunkClass methodsFor: 'junk' !
nonLocalReturnB: aBlock

	self halt.
	aBlock value

! !

! JunkClass methodsFor: 'junk' !
nonLocalReturnC

	self nonLocalReturnA.
	^5
! !

! JunkClass class methodsFor: 'junk' !
classVar1Variable

	^[nil] cache! !

! Kit methodsFor: 'accessing' !
definedClasses
	^definedClasses! !

! Kit methodsFor: 'accessing' !
definedClasses: aCollection
	definedClasses := aCollection! !

! Kit methodsFor: 'accessing' !
extendedClasses

	^(self extendedMethods collect: [:each | each first thisClass]) asSet! !

! Kit methodsFor: 'accessing' !
extendedMethods
	^extendedMethods! !

! Kit methodsFor: 'accessing' !
extendedMethods: aCollection
	extendedMethods := aCollection! !

! Kit methodsFor: 'accessing' !
name
	^name! !

! Kit methodsFor: 'accessing' !
name: aCollection
	name := aCollection! !

! Kit methodsFor: 'accessing' !
requiredKitNames
	^requiredKitNames! !

! Kit methodsFor: 'accessing' !
requiredKitNames: aCollection
	requiredKitNames := aCollection asOrderedCollection! !

! Kit methodsFor: 'accessing' !
subKits
	^subKits! !

! Kit methodsFor: 'accessing' !
subKits: aCollection
	subKits := aCollection! !

! Kit methodsFor: 'accessing' !
versionName
	^versionName! !

! Kit methodsFor: 'accessing' !
versionName: aString

	versionName := aString! !

! Kit methodsFor: 'adding and removing' !
addClass: aClass
	(self definesClass: aClass) ifTrue: [^self].
	self definedClasses add: aClass.
	aClass kit: self.

	aClass methodDictionary do: [:method |
		method kit == self ifTrue: [self removeMethod: method]].


	aClass class methodDictionary do: [:method |
		method kit == self ifTrue: [self removeMethod: method]].! !

! Kit methodsFor: 'adding and removing' !
addMethod: aMethod
	self extendedMethods add: (Array with: aMethod mclass with: aMethod selector).
	aMethod kit: (aMethod mclass kit == self
		ifTrue: [nil]
		ifFalse: [self])! !

! Kit methodsFor: 'adding and removing' !
addRequiredKit: aKit
	self requiredKitNames add: aKit name! !

! Kit methodsFor: 'adding and removing' !
includedClasses: aCollection

	| classesToRemove |

	classesToRemove := self definedClasses copy.
	aCollection do: [:each | classesToRemove removeAllSuchThat: [:eachClass | eachClass name = each] ].

	classesToRemove copy reverseDo: [:eachClass |
		self removeClass: eachClass.
		ClassCreator new removeClass: eachClass]

! !

! Kit methodsFor: 'adding and removing' !
partialSortDefinedClassesDo: aBlock

	| sortedClasses superclasses classesToProcess |

	sortedClasses := self definedClasses copy sortedBy: [:a :b | a name < b name].

	superclasses := Dictionary new.
	sortedClasses do: [:eachClass |
		superclasses at: eachClass put: ((eachClass withAllSuperclasses) remove: eachClass; yourself)].

	classesToProcess := Set new addAll: self definedClasses; yourself.

	[sortedClasses notEmpty] whileTrue: [
		| class |
		class := sortedClasses detect: [:eachClass | ((superclasses at: eachClass) anySatisfy: [:each | classesToProcess includes: each]) not] ifNone: [nil].
		class isNil ifTrue: [^self].
		aBlock value: class.
		classesToProcess remove: class.
self log: class name.
		sortedClasses remove: class]  ! !

! Kit methodsFor: 'adding and removing' !
removeClass: aClass

	self definedClasses remove: aClass! !

! Kit methodsFor: 'adding and removing' !
removeMethod: aMethod
	self extendedMethods remove: (Array with: aMethod mclass with: aMethod selector).
	aMethod kit: nil! !

! Kit methodsFor: 'adding and removing' !
removeRequiredKit: aKit
	self requiredKitNames remove: aKit name! !

! Kit methodsFor: 'adding and removing' !
sortDefinedClasses

	self definedClasses: (self definedClasses sortedBy: [:a :b | a name < b name])! !

! Kit methodsFor: 'fileout' !
allDefinedClasses: classArray andMethods: methodArray! !

! Kit methodsFor: 'fileout' !
allDefinedMethodsFor: aClass methods: aCollection

	| methodsToDelete |

	methodsToDelete := OrderedCollection new.

	aClass methodDictionary keysAndValuesDo: [:selector :method |
		((aCollection includes: selector) not and: [method kit isNil]) ifTrue: [methodsToDelete add: selector] ].

	methodsToDelete do: [:eachSelector |
		aClass removeSelector: eachSelector]
! !

! Kit methodsFor: 'fileout' !
ensureLoaded: aCollection

	self requiredKitNames: aCollection asOrderedCollection.

	aCollection do: [:each |
		(KitManager current hasKitNamed: each) ifFalse: [
			('kits' asFilename construct: (each , '.kit')) fileIn ] ].

	KitManager default currentKit: self
! !

! Kit methodsFor: 'fileout' !
fileout

	| folder stream |
	
	folder := 'kits' asFilename.
	stream := (folder construct: self name, '.kit') writeStream.
	[self fileoutOn: stream] ensure: [stream close]
	! !

! Kit methodsFor: 'fileout' !
fileoutDefinedClassesOn: aStream

	self partialSortDefinedClassesDo: [:eachClass |
		eachClass fileoutDefinitionOn: aStream.
		aStream cr; cr].
! !

! Kit methodsFor: 'fileout' !
fileoutDefinedMethodsOn: aStream

	self partialSortDefinedClassesDo: [:eachClass |
		eachClass fileoutMethodsOn: aStream forKit: self.
		eachClass class fileoutMethodsOn: aStream forKit: self].
 ! !

! Kit methodsFor: 'fileout' !
fileoutExtendedMethodsOn: aStream

	(self extendedMethods asArray sortedBy: [:array1:array2 |
			array1 first name < array2 first name or: [
				(array1 first = array2 first) and: [array1 last < array2 last]]]) do: [:eachMethod |
		eachMethod first fileoutMethodNamed: eachMethod last on: aStream.
		aStream nextPutAll: 'KitManager default currentKit addMethod: (';
			nextPutAll: eachMethod first name;
			nextPutAll: ' compiledMethodAt: #';
			nextPutAll: eachMethod last;
			nextPutAll: ') !';
			cr; cr].
 ! !

! Kit methodsFor: 'fileout' !
fileoutInventoryOn: aStream

	aStream
		nextPutAll: 'KitManager default currentKit allDefinedClasses: ';
		print: (self definedClasses asArray sortedBy: [:class1 :class2 | class1 name < class2 name]) limit: 1000000000;
		nextPutAll: ' andMethods: ';
		print: (self extendedMethods asArray sortedBy: [:array1 :array2 |
			array1 first name < array2 first name or: [
				(array1 first = array2 first) and: [array1 last < array2 last]]]) limit: 100000000;
		nextPutAll: ' !';
		cr; cr.

	self definedClasses do: [:eachClass |
		aStream nextPutAll: 'KitManager default currentKit allDefinedMethodsFor: ';
			nextPutAll: eachClass name;
			nextPutAll: ' methods: ';
			print: (eachClass selectors asArray sorted select: [:eachMethod | (eachClass compiledMethodAt: eachMethod) kit isNil]) limit: 100000000;
			nextPutAll: ' !';
			cr; cr.

		aStream nextPutAll: 'KitManager default currentKit allDefinedMethodsFor: ';
			nextPutAll: eachClass name;
			nextPutAll: ' class methods: ';
			print: (eachClass class selectors asArray sorted select: [:eachMethod | (eachClass class compiledMethodAt: eachMethod) kit isNil]) limit: 100000000;
			nextPutAll: ' !';
			cr; cr.
		].

	 ! !

! Kit methodsFor: 'fileout' !
fileoutOn: aStream

	aStream nextPutAll: 'KitManager default currentKitNamed: ', self name printString, ' !'; cr; cr.
	
	self
		writeLoadRequiredKitsOn: aStream;
		fileoutDefinedClassesOn: aStream;
		fileoutDefinedMethodsOn: aStream;
		fileoutExtendedMethodsOn: aStream;
		fileoutInventoryOn: aStream.

	aStream nextPutAll: 'KitManager default finishFileinKit !'; cr

! !

! Kit methodsFor: 'fileout' !
writeLoadRequiredKitsOn: aStream

	aStream
		nextPutAll: 'KitManager default currentKit ensureLoaded: ', self requiredKitNames asArray printString, ' !'; cr; cr.
! !

! Kit methodsFor: 'initialize-release' !
initialize

	definedClasses := OrderedCollection new.
	extendedMethods := Set new.
	requiredKitNames := OrderedCollection new! !

! Kit methodsFor: 'loading and unloading' !
unload

	 | classes |

	self extendedMethods copy do: [:methodClassAndSelector |
		methodClassAndSelector first removeSelector: methodClassAndSelector last].

	classes := OrderedCollection new.
	self partialSortDefinedClassesDo: [:class | classes add: class].

	classes reverseDo: [:class | ClassCreator new removeClass: class].

	KitManager current removeKit: self! !

! Kit methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' (';
		print: self name;
		nextPut: $)! !

! Kit methodsFor: 'testing' !
cantUnloadReason

	| requiringKits |
	requiringKits := KitManager current kits asArray select: [:each | each requiredKitNames includes: self name].
	requiringKits notEmpty ifTrue: [^'There are kits that require this one: ', (requiringKits asArray collect: [:each | each name]) printString].

	^nil! !

! Kit methodsFor: 'testing' !
definesClass: aClass
	aClass isNil ifTrue: [^false].
	^self definedClasses includes: aClass! !

! Kit methodsFor: 'testing' !
extendsMethodNamed: methodName inClass: aClass
	^self extendedMethods includes: (Array with: aClass name with: methodName)! !

! Kit class methodsFor: 'instance creation' !
new

	^super new initialize! !

! KitManager methodsFor: 'accessing' !
classesNotInKit
	^((Class withAllSubclasses copyWithout: Class) collect: [:each | each thisClass]) select: [:each |
		(self kitForClass: each) name = 'Other']
! !

! KitManager methodsFor: 'accessing' !
currentKit
	^currentKit! !

! KitManager methodsFor: 'accessing' !
currentKit: aKit
	currentKit := aKit! !

! KitManager methodsFor: 'accessing' !
currentKitNamed: aString
	self currentKit: (self kits detect: [:each | each name = aString] ifNone: [self addKitNamed: aString])! !

! KitManager methodsFor: 'accessing' !
kitForClass: aClass

	^self kitForClass: aClass ifNone: [self kitNamedIfAbsentAdd: 'Other']
! !

! KitManager methodsFor: 'accessing' !
kitForClass: aClass ifNone: aBlock

	^self kits
		detect: [:kit | kit definesClass: aClass]
		ifNone: aBlock
! !

! KitManager methodsFor: 'accessing' !
kitNamed: aString

	^self kits detect: [:kit | kit name = aString] ifNone: [nil]! !

! KitManager methodsFor: 'accessing' !
kitNamedIfAbsentAdd: aString

	^(self kitNamed: aString) ifNil: [
		self addKitNamed: aString]
! !

! KitManager methodsFor: 'accessing' !
kits
	^kits
! !

! KitManager methodsFor: 'accessing' !
kitsInLoadOrder

	| processedKits kitsToProcess orderedKits |

	processedKits := Set new.
	kitsToProcess := self kits values sortedBy: [:a :b | a name < b name].
	orderedKits := OrderedCollection new.

	[kitsToProcess isEmpty] whileFalse: [
		| kit |
		kit := kitsToProcess detect: [:each | 
				each requiredKitNames isEmpty or: [each requiredKitNames allSatisfy: [:eachKitName | processedKits includes: eachKitName] ] ]
			ifNone: [self error: 'Circular kit list'].
		orderedKits add: kit.
		processedKits add: kit name.
		kitsToProcess remove: kit].

	^orderedKits


	
 ! !

! KitManager methodsFor: 'adding and removing' !
addKit: aKit

	self kits at: aKit name put: aKit! !

! KitManager methodsFor: 'adding and removing' !
addKitNamed: aString

	| kit |

	self addKit: (kit := Kit new name: aString; yourself).
	^kit! !

! KitManager methodsFor: 'adding and removing' !
removeKit: aKit

	self kits removeKey: aKit name! !

! KitManager methodsFor: 'file in and out' !
allDefinedClasses: classes andMethods: methods

	self definedClasses copy do: [:class |
		(classes includes: class name) ifFalse: [
			ClassCreator new removeClass: class]].

	self extendedMethods copy do: [:methodDescriptor |
		methodDescriptor first  methodDictionary removeKey: methodDescriptor last]
! !

! KitManager methodsFor: 'file in and out' !
allDefinedMethodsFor: classes methods: methods
! !

! KitManager methodsFor: 'file in and out' !
fileinAllKits

	BeagleSystem changesFileName asFilename exists ifFalse: [
		BeagleSystem changesFileName asFilename writeStream; close].

	('kits' asFilename construct: 'allKits.st') fileIn! !

! KitManager methodsFor: 'file in and out' !
fileoutAllKits

	self kits do: [:each |
		self log: 'Fileout kit: ', each name.
		each fileout].
	self writeAllKits! !

! KitManager methodsFor: 'file in and out' !
finishFileinKit
	self currentKit: nil! !

! KitManager methodsFor: 'file in and out' !
writeAllKits

	| stream |

	stream := ('kits' asFilename construct: 'allKits.st') writeStream.
	[self kitsInLoadOrder do: [:kit |
		stream
			nextPutAll: '(''kits'' asFilename construct: ''', kit name, '.kit'') fileIn !'; cr] ]
		ensure: [stream close]
! !

! KitManager methodsFor: 'initialize-release' !
initialize

	kits := Dictionary new! !

! KitManager methodsFor: 'testing' !
hasKitNamed: aString

	^kits includesKey: aString! !

! KitManager class methodsFor: 'accessing' !
clearDefault
	^default := nil! !

! KitManager class methodsFor: 'accessing' !
default
	^default ifNil: [default := self new]! !

! KitManager class methodsFor: 'instance creation' !
current
	^self default! !

! KitManager class methodsFor: 'instance creation' !
new
	^super new initialize! !

! LineEndConvention methodsFor: 'reading' !
next: aNumber for: aFileStream
	self subclassResponsibility! !

! LineEndConvention methodsFor: 'reading' !
nextFor: aFileStream
	self subclassResponsibility! !

! LineEndConvention methodsFor: 'reading' !
skip: aNumber for: aFileStream
	self subclassResponsibility! !

! LineEndConvention methodsFor: 'reading' !
upToEndFor: aFileStream
	self subclassResponsibility! !

! LineEndConvention methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	self subclassResponsibility! !

! LineEndConvention methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	self subclassResponsibility! !

! LineEndConventionCR methodsFor: 'reading' !
next: aNumber for: aFileStream
	^aFileStream primNext: aNumber! !

! LineEndConventionCR methodsFor: 'reading' !
nextFor: aFileStream
	^aFileStream primNext! !

! LineEndConventionCR methodsFor: 'reading' !
skip: aNumber for: aFileStream
	^aFileStream primSkip: aNumber! !

! LineEndConventionCR methodsFor: 'reading' !
upToEndFor: aFileStream
	^aFileStream primUpToEnd! !

! LineEndConventionCR methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	^aFileStream primNextPut: anInteger! !

! LineEndConventionCR methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	^aFileStream primNextPutAll: aCollection! !

! LineEndConventionCRLF methodsFor: 'reading' !
next: aNumber for: aFileStream
	| bytes |
	bytes := aFileStream primNext: aNumber.
	bytes last = 13 ifTrue: [
		| lf |
		lf := aFileStream primNext.
		lf = 10 ifFalse: [aFileStream primSkip: -1]].
		
	^bytes copyReplaceAll: #(13 10) with: #(13)! !

! LineEndConventionCRLF methodsFor: 'reading' !
nextFor: aFileStream
	| character |
	character := aFileStream primNext.
	character = 13 ifTrue: [
		| lf |
		lf := aFileStream primNext.
		lf = 10 ifFalse: [aFileStream primSkip: -1]].
	^character! !

! LineEndConventionCRLF methodsFor: 'reading' !
skip: aNumber for: aFileStream
	aFileStream primSkip: aNumber.
	aFileStream primNext asInteger = 10
		ifTrue: [aFileStream primSkip: -2]
		ifFalse: [aFileStream primSkip: -1]! !

! LineEndConventionCRLF methodsFor: 'reading' !
upToEndFor: aFileStream
	^aFileStream primUpToEnd copyReplaceAll: #(13 10) with: #(13)! !

! LineEndConventionCRLF methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	anInteger asInteger = 13 ifTrue: [
		^aFileStream
			primNextPut: 13;
			primNextPut: 10].
	^aFileStream primNextPut: anInteger! !

! LineEndConventionCRLF methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	^aFileStream primNextPutAll: (aCollection asByteArray copyReplaceAll: #(13) with: #(13 10))! !

! LineEndConventionLF methodsFor: 'reading' !
next: aNumber for: aFileStream
	| bytes |
	bytes := aFileStream primNext: aNumber.
	^bytes copyReplacing: 10 with: 13! !

! LineEndConventionLF methodsFor: 'reading' !
nextFor: aFileStream
	| character |
	character := aFileStream primNext.
	character = 10
		ifTrue: [^13]
		ifFalse: [^character]! !

! LineEndConventionLF methodsFor: 'reading' !
skip: aNumber for: aFileStream
	^aFileStream primSkip: aNumber! !

! LineEndConventionLF methodsFor: 'reading' !
upToEndFor: aFileStream
	^aFileStream primUpToEnd copyReplacing: 10 with: 13! !

! LineEndConventionLF methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	anInteger = 13 ifTrue: [^aFileStream nextPut: 10].
	^aFileStream primNextPut: anInteger! !

! LineEndConventionLF methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	^aFileStream primNextPutAll: (aCollection copyReplacing: 13 with: 10)! !

! Magnitude methodsFor: 'comparing' !
< value1

	self subclassResponsibility! !

! Magnitude methodsFor: 'comparing' !
<= value1

	^self < value1 or: [self = value1]! !

! Magnitude methodsFor: 'comparing' !
> value1

	^(self <= value1) not! !

! Magnitude methodsFor: 'comparing' !
>= value1

	^(self < value1) not! !

! Magnitude methodsFor: 'comparing' !
between: value1 and: value2 

	self < value1 ifTrue: [^false].
	^self <= value2! !

! Magnitude methodsFor: 'comparing' !
max: aMagnitude 

	self > aMagnitude ifTrue: [^self].
	^aMagnitude! !

! Magnitude methodsFor: 'comparing' !
min: aMagnitude 

	self < aMagnitude ifTrue: [^self].
	^aMagnitude! !

! Character methodsFor: 'accessing' !
asInteger

	<primitive: 410>
	self primitiveFailed! !

! Character methodsFor: 'accessing' !
isVowel

	^self class vowels includes: self! !

! Character methodsFor: 'comparing' !
< aCharacter

	^self asInteger < aCharacter asInteger! !

! Character methodsFor: 'comparing' !
<= aCharacter

	^self asInteger <= aCharacter asInteger! !

! Character methodsFor: 'comparing' !
= aCharacter

	self class = aCharacter class ifFalse: [^false].
	^self asInteger = aCharacter asInteger! !

! Character methodsFor: 'comparing' !
> aCharacter

	^self asInteger > aCharacter asInteger! !

! Character methodsFor: 'comparing' !
>= aCharacter

	^self asInteger >= aCharacter asInteger! !

! Character methodsFor: 'comparing' !
digitValue

	(self asLowercase between: $a and: $z) ifTrue: [
		^self asLowercase asInteger - $a asInteger + 10].

	(self asLowercase between: $0 and: $9) ifTrue: [
		^self asInteger - $0 asInteger].

	^-1! !

! Character methodsFor: 'comparing' !
hash

	^self asInteger hash! !

! Character methodsFor: 'converting' !
asLowercase

	self isUppercase ifFalse: [^self].
	^Character value: self asInteger + 16r20! !

! Character methodsFor: 'converting' !
asString

	^String with: self! !

! Character methodsFor: 'converting' !
asUppercase

	self isLowercase ifFalse: [^self].
	^Character value: self asInteger - 16r20! !

! Character methodsFor: 'printing' !
printOn: aStream 

	(self asInteger between: 32 and: 127)
		ifTrue: [aStream nextPut: $$; nextPut: self]
		ifFalse: [aStream nextPutAll: '$<'; nextPutAll: self asInteger hex; nextPut: $>] ! !

! Character methodsFor: 'testing' !
isAlphaNumeric

	self isAlphabetic ifTrue: [^true].
	^self isDigit! !

! Character methodsFor: 'testing' !
isAlphabetic

	self isUppercase ifTrue: [^true].
	self isLowercase ifTrue: [^true].
	^false! !

! Character methodsFor: 'testing' !
isDigit

	(self between: $0 and: $9) ifTrue: [^true].
	^false! !

! Character methodsFor: 'testing' !
isLowercase

	^self between: $a and: $z! !

! Character methodsFor: 'testing' !
isNonBinarySelectorCharacter

	self isAlphaNumeric ifTrue: [^true].
	self = $_ ifTrue: [^true].
	self = $: ifTrue: [^true].
	^false! !

! Character methodsFor: 'testing' !
isSeparator

	self = Character space ifTrue: [^true].
	self = Character cr ifTrue: [^true].
	self = Character lf ifTrue: [^true].
	self = Character tab ifTrue: [^true].
	^false! !

! Character methodsFor: 'testing' !
isUppercase

	^self between: $A and: $Z! !

! Character class methodsFor: 'constants' !
backspace

	^Character value: 8! !

! Character class methodsFor: 'constants' !
cr

	^Character value: 13! !

! Character class methodsFor: 'constants' !
lf

	^Character value: 10! !

! Character class methodsFor: 'constants' !
space

	^Character value: 32! !

! Character class methodsFor: 'constants' !
tab

	^Character value: 9! !

! Character class methodsFor: 'instance creation' !
digitValue: aNumber 

	^self value:
		(aNumber < 10
			ifTrue: [48 + aNumber]
			ifFalse: [55 + aNumber])! !

! Character class methodsFor: 'instance creation' !
value: aNumber 

	<primitive: 411>
	self primitiveFailed! !

! Character class methodsFor: 'instance creation' !
vowels

	^'aAeEiIoOuU'! !

! DateTime methodsFor: 'accessing' !
asMilliseconds

	| yearIndex absDays seconds |
	yearIndex := self year - 1901.
	absDays := yearIndex * 365 + (yearIndex // 4) + ((yearIndex + 300) // 400)
				- (yearIndex // 100) + self day
				- 1 + (self firstDayOf: self month).	"elapsed years"	"ordinary leap years"	"leap centuries, first one is 2000, i.e. yearIndex = 99"	"non-leap centuries"
	seconds := (self hours * 60 + self minutes) * 60
				+ self seconds.
	"do it this way to minimize large arithmetic"
	^(absDays * 86400 + seconds) * 1000 + self milliseconds! !

! DateTime methodsFor: 'accessing' !
day

	^day! !

! DateTime methodsFor: 'accessing' !
day: anObject

	day := anObject! !

! DateTime methodsFor: 'accessing' !
hours

	^self time hours! !

! DateTime methodsFor: 'accessing' !
milliseconds

	^self time milliseconds! !

! DateTime methodsFor: 'accessing' !
minutes

	^self time minutes! !

! DateTime methodsFor: 'accessing' !
month

	^month! !

! DateTime methodsFor: 'accessing' !
month: anObject

	month := anObject! !

! DateTime methodsFor: 'accessing' !
seconds

	^self time seconds! !

! DateTime methodsFor: 'accessing' !
time

	^time! !

! DateTime methodsFor: 'accessing' !
time: aTime

	time := aTime! !

! DateTime methodsFor: 'accessing' !
year

	^year! !

! DateTime methodsFor: 'accessing' !
year: anObject

	year := anObject! !

! DateTime methodsFor: 'comparing' !
< aDateTime

	self year < aDateTime year ifTrue: [^true].
	self year > aDateTime year ifTrue: [^false].
	self month < aDateTime month ifTrue: [^true].
	self month > aDateTime month ifTrue: [^false].
	self day < aDateTime day  ifTrue: [^true].
	self day  > aDateTime day  ifTrue: [^false].
	self time < aDateTime time  ifTrue: [^true].
	self time  > aDateTime time  ifTrue: [^false].
	^false! !

! DateTime methodsFor: 'comparison' !
addMilliseconds: aNumber

	| total daysInMonth |
	total := time milliseconds + aNumber.
	time milliseconds: total \\ 86400000. "1000* 3600 * 24 "
	total := total // 86400000.
	day := day + total.
	[day > (daysInMonth := self daysIn: self month forYear: self year)] whileTrue: [
		day := day - daysInMonth.
		month := month + 1.
		month > 12 ifTrue: [month := 1. year := year + 1]].! !

! DateTime methodsFor: 'comparison' !
difference: aHexlinkDate
	| difference carryOver |
	difference := DateTime new.
	
	carryOver := 0.
	self time milliseconds >= aHexlinkDate time milliseconds ifTrue: [difference time: (Time new setMilliseconds: self time milliseconds - aHexlinkDate time milliseconds)]
		 ifFalse: [difference time: (Time new setMilliseconds: (1000 * 60 * 60 * 24) - (aHexlinkDate time milliseconds - self time milliseconds)). carryOver := 1].

	self day >= aHexlinkDate day ifTrue: [difference day: self day - aHexlinkDate day - carryOver. carryOver := 0.]
						ifFalse: [
							| lastMonth yearCheck |
							self month = 1 ifTrue: [lastMonth := 12. yearCheck := self year - 1.] ifFalse: [lastMonth := self month - 1. yearCheck := self year].
							difference day: (self daysIn: lastMonth forYear: yearCheck) - (aHexlinkDate day - self day) - carryOver.
							carryOver := 1.
						].

	self month >= aHexlinkDate month ifTrue: [difference month: self month - aHexlinkDate month - carryOver. carryOver := 0.]
							ifFalse: [difference month: 12 - (aHexlinkDate month - self month) - carryOver. carryOver := 1.].

	difference year: self year - aHexlinkDate year - carryOver.
	
	^difference! !

! DateTime methodsFor: 'initialize-release' !
initFromSystemFormat: aNumber

	time := Time new setMilliseconds: aNumber \\ 100000000.
	year := aNumber // 100000000 \\ 10000.
	month := aNumber // 1000000000000 \\ 100.
	day := aNumber // 100000000000000 \\ 100.! !

! DateTime methodsFor: 'internal' !
daysIn: monthNumeric forYear: yearNumeric

	(monthNumeric = 1) |  (monthNumeric = 3) | (monthNumeric = 5) | (monthNumeric = 7) | (monthNumeric = 8) | (monthNumeric = 10) | (monthNumeric = 12)
		ifTrue: [^31].
	(monthNumeric = 4) |  (monthNumeric = 6) | (monthNumeric = 9) | (monthNumeric = 11)
		ifTrue: [^30].
	(monthNumeric = 2) ifTrue: [
			(self isLeap: yearNumeric) ifTrue: [^29] ifFalse: [^28].
	].
		
		^31! !

! DateTime methodsFor: 'internal' !
isLeap: yearNumeric
	| condition1 condition2 |
	
	condition2 := true.
	
	(yearNumeric \\ 4 = 0) ifTrue: [condition1 := true] ifFalse: [condition1 := false] .
	
	(yearNumeric \\ 100 = 0) & (yearNumeric \\ 400 = 0) ifTrue: [condition2 := false].
	
	condition1 & condition2 ifTrue: [^true] ifFalse: [^false]! !

! DateTime methodsFor: 'printing' !
minutesAndSecondsPrintString

	^time minutes printString, ':', (time seconds < 10 ifTrue: ['0', time seconds printString] ifFalse: [time seconds printString])! !

! DateTime methodsFor: 'printing' !
printOn: aStream

	self year printOn: aStream.
	aStream nextPut: $/.
	self month < 10 ifTrue: [aStream nextPut: $0].
	self month printOn: aStream.
	aStream nextPut: $/.
	self day < 10 ifTrue: [aStream nextPut: $0].
	self day printOn: aStream.
	aStream nextPut: Character space.
	self time printOn: aStream! !

! DateTime methodsFor: 'printing' !
writeBinaryOn: aStream

	aStream
		nextPutInt16: self year;
		nextPut: self month;
		nextPut: self day;
		write: self time! !

! DateTime class methodsFor: 'instance creation' !
fromSystemFormat: aNumber
	"Takes in a date in the form of an integer. The integer value represents the digits of the date in the format DDMMYYYYZZZZZZZZ, where Z is milliseconds from midnight"
	^super new initFromSystemFormat: aNumber! !

! DateTime class methodsFor: 'primitives' !
now

	^self fromSystemFormat: self systemDate! !

! DateTime class methodsFor: 'primitives' !
readBinaryFrom: 	aStream

	^self new
		year: aStream nextInt16;
		month: aStream next;
		day: aStream next;
		time: (Time readBinaryFrom: aStream);
		yourself! !

! DateTime class methodsFor: 'primitives' !
systemDate

	<primitive: 700>
	self primitiveFailed! !

! Matrix methodsFor: 'accessing' !
as2DPoint

	^(self atRow: 1 column: 1) @ (self atRow: 2 column: 1)! !

! Matrix methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber

	^elements at: (rowNumber - 1) * columns + columnNumber! !

! Matrix methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber put: value

	elements at: (rowNumber - 1) * columns + columnNumber put: value! !

! Matrix methodsFor: 'accessing' !
columns

	^columns! !

! Matrix methodsFor: 'accessing' !
elements

	^elements! !

! Matrix methodsFor: 'accessing' !
rows

	^rows! !

! Matrix methodsFor: 'accessing' !
w

	^self atRow: 4 column: 1! !

! Matrix methodsFor: 'accessing' !
x

	^self atRow: 1 column: 1! !

! Matrix methodsFor: 'accessing' !
y

	^self atRow: 2 column: 1! !

! Matrix methodsFor: 'accessing' !
z

	^self atRow: 3 column: 1! !

! Matrix methodsFor: 'arithmetic' !
* aMatrix

	| newMatrix |

	self columns = aMatrix rows ifFalse: [^self error: 'Matrices are the wrong sizes to multiply.'].

	newMatrix := Matrix rows: self rows columns: aMatrix columns.
	1 to: self rows do: [:rowNumber |
		1 to: aMatrix columns do: [:columnNumber |
			| total |
			total := 0.0.
			1 to: self columns do: [:i |
				total := total + ((self atRow: rowNumber column: i) * (aMatrix atRow: i column: columnNumber))].
			newMatrix atRow: rowNumber column: columnNumber put: total]].

	^newMatrix
! !

! Matrix methodsFor: 'arithmetic' !
+ aMatrix

	| newMatrix |

	(self rows = aMatrix rows and: [self columns = aMatrix columns])
		ifFalse: [^self error: 'Matrices are the wrong sizes to add.'].

	newMatrix := Matrix rows: self rows columns: self columns.
	1 to: self rows do: [:rowNumber |
		1 to: aMatrix columns do: [:columnNumber |
			newMatrix atRow: rowNumber column: columnNumber put: (self atRow: rowNumber column: columnNumber) + (aMatrix atRow: rowNumber column: columnNumber)]].

	^newMatrix
! !

! Matrix methodsFor: 'arithmetic' !
- aMatrix

	| newMatrix |

	(self rows = aMatrix rows and: [self columns = aMatrix columns])
		ifFalse: [^self error: 'Matrices are the wrong sizes to subtract.'].

	newMatrix := Matrix rows: self rows columns: self columns.
	1 to: self rows do: [:rowNumber |
		1 to: aMatrix columns do: [:columnNumber |
			newMatrix atRow: rowNumber column: columnNumber put: (self atRow: rowNumber column: columnNumber) - (aMatrix atRow: rowNumber column: columnNumber)]].

	^newMatrix
! !

! Matrix methodsFor: 'initializing' !
from3x3Array: anArray

	self rows: 3 columns: 3.

	1 to: 3 do: [:rowNumber |
		1 to: 3 do: [:columnNumber |
			self atRow: rowNumber column: columnNumber put: (anArray at: (rowNumber - 1) * 3 + columnNumber)]].

	^self! !

! Matrix methodsFor: 'initializing' !
from4x4Array: anArray

	self rows: 4 columns: 4.

	1 to: 4 do: [:rowNumber |
		1 to: 4 do: [:columnNumber |
			self atRow: rowNumber column: columnNumber put: (anArray at: (rowNumber - 1) * 4 + columnNumber)]].

	^self! !

! Matrix methodsFor: 'initializing' !
fromArray: anArray

	self rows: anArray size columns: (anArray first size).

	anArray keysAndValuesDo: [:rowNumber :subarray |
		subarray keysAndValuesDo: [:columnNumber :value |
			self atRow: rowNumber column: columnNumber put: value]].

	^self! !

! Matrix methodsFor: 'initializing' !
rows: rowsInteger columns: columnsInteger

	rows := rowsInteger.
	columns := columnsInteger.
	elements := Array new: rows * columns.
	1 to: rows * columns do: [:i | elements at: i put: 0.0]! !

! Matrix methodsFor: 'inverse' !
a00

	^self atRow: 1 column: 1! !

! Matrix methodsFor: 'inverse' !
a01

	^self atRow: 1 column: 2! !

! Matrix methodsFor: 'inverse' !
a02

	^self atRow: 1 column: 3! !

! Matrix methodsFor: 'inverse' !
a03

	^self atRow: 1 column: 4! !

! Matrix methodsFor: 'inverse' !
a10

	^self atRow: 2 column: 1! !

! Matrix methodsFor: 'inverse' !
a11

	^self atRow: 2 column: 2! !

! Matrix methodsFor: 'inverse' !
a12

	^self atRow: 2 column: 3! !

! Matrix methodsFor: 'inverse' !
a13

	^self atRow: 2 column: 4! !

! Matrix methodsFor: 'inverse' !
a20

	^self atRow: 3 column: 1! !

! Matrix methodsFor: 'inverse' !
a21

	^self atRow: 3 column: 2! !

! Matrix methodsFor: 'inverse' !
a22

	^self atRow: 3 column: 3! !

! Matrix methodsFor: 'inverse' !
a23

	^self atRow: 3 column: 4! !

! Matrix methodsFor: 'inverse' !
a30

	^self atRow: 4 column: 1! !

! Matrix methodsFor: 'inverse' !
a31

	^self atRow: 4 column: 2! !

! Matrix methodsFor: 'inverse' !
a32

	^self atRow: 4 column: 3! !

! Matrix methodsFor: 'inverse' !
a33

	^self atRow: 4 column: 4! !

! Matrix methodsFor: 'inverse' !
b00

	^(self a11 * self a22 * self a33)
		+ (self a12 * self a23 * self a31)
		+ (self a13 * self a21 * self a32)
		- (self a11 * self a23 * self a32)
		- (self a12 * self a21 * self a33)
		- (self a13 * self a22 * self a31)! !

! Matrix methodsFor: 'inverse' !
b01

	^(self a01 * self a23 * self a32)
		+ (self a02 * self a21 * self a33)
		+ (self a03 * self a22 * self a31)
		- (self a01 * self a22 * self a33)
		- (self a02 * self a23 * self a31)
		- (self a03 * self a21 * self a32)! !

! Matrix methodsFor: 'inverse' !
b02

	^(self a01 * self a12 * self a33)
		+ (self a02 * self a13 * self a31)
		+ (self a03 * self a11 * self a32)
		- (self a01 * self a13 * self a32)
		- (self a02 * self a11 * self a33)
		- (self a03 * self a12 * self a31)! !

! Matrix methodsFor: 'inverse' !
b03

	^(self a01 * self a13 * self a22)
		+ (self a02 * self a11 * self a23)
		+ (self a03 * self a12 * self a21)
		- (self a01 * self a12 * self a23)
		- (self a02 * self a13 * self a21)
		- (self a03 * self a11 * self a22)! !

! Matrix methodsFor: 'inverse' !
b10

	^(self a10 * self a23 * self a32)
		+ (self a12 * self a20 * self a33)
		+ (self a13 * self a22 * self a30)
		- (self a10 * self a22 * self a33)
		- (self a12 * self a23 * self a30)
		- (self a13 * self a20 * self a32)! !

! Matrix methodsFor: 'inverse' !
b11

	^(self a00 * self a22 * self a33)
		+ (self a02 * self a23 * self a30)
		+ (self a03 * self a20 * self a32)
		- (self a00 * self a23 * self a32)
		- (self a02 * self a20 * self a33)
		- (self a03 * self a22 * self a30)! !

! Matrix methodsFor: 'inverse' !
b12

	^(self a00 * self a13 * self a32)
		+ (self a02 * self a10 * self a33)
		+ (self a03 * self a12 * self a30)
		- (self a00 * self a12 * self a33)
		- (self a02 * self a13 * self a30)
		- (self a03 * self a10 * self a32)! !

! Matrix methodsFor: 'inverse' !
b13

	^(self a00 * self a12 * self a23)
		+ (self a02 * self a13 * self a20)
		+ (self a03 * self a10 * self a22)
		- (self a00 * self a13 * self a22)
		- (self a02 * self a10 * self a23)
		- (self a03 * self a12 * self a20)! !

! Matrix methodsFor: 'inverse' !
b20

	^(self a10 * self a21 * self a33)
		+ (self a11* self a23 * self a30)
		+ (self a13 * self a20 * self a31)
		- (self a10 * self a23 * self a31)
		- (self a11 * self a20 * self a33)
		- (self a13 * self a21 * self a30)! !

! Matrix methodsFor: 'inverse' !
b21

	^(self a00 * self a23 * self a31)
		+ (self a01* self a20 * self a33)
		+ (self a03 * self a21 * self a30)
		- (self a00 * self a21 * self a33)
		- (self a01 * self a23 * self a30)
		- (self a03 * self a20 * self a31)! !

! Matrix methodsFor: 'inverse' !
b22

	^(self a00 * self a11 * self a33)
		+ (self a01* self a13 * self a30)
		+ (self a03 * self a10 * self a31)
		- (self a00 * self a13 * self a31)
		- (self a01 * self a10 * self a33)
		- (self a03 * self a11 * self a30)! !

! Matrix methodsFor: 'inverse' !
b23

	^(self a00 * self a13 * self a21)
		+ (self a01* self a10 * self a23)
		+ (self a03 * self a11 * self a20)
		- (self a00 * self a11 * self a23)
		- (self a01 * self a13 * self a20)
		- (self a03 * self a10 * self a21)! !

! Matrix methodsFor: 'inverse' !
b30

	^(self a10 * self a22 * self a31)
		+ (self a11* self a20 * self a32)
		+ (self a12 * self a21 * self a30)
		- (self a10 * self a21 * self a32)
		- (self a11 * self a22 * self a30)
		- (self a12 * self a20 * self a31)! !

! Matrix methodsFor: 'inverse' !
b31

	^(self a00 * self a21 * self a32)
		+ (self a01* self a22 * self a30)
		+ (self a02 * self a20 * self a31)
		- (self a00 * self a22 * self a31)
		- (self a01 * self a20 * self a32)
		- (self a02 * self a21 * self a30)! !

! Matrix methodsFor: 'inverse' !
b32

	^(self a00 * self a12 * self a31)
		+ (self a01* self a10 * self a32)
		+ (self a02 * self a11 * self a30)
		- (self a00 * self a11 * self a32)
		- (self a01 * self a12 * self a30)
		- (self a02 * self a10 * self a31)! !

! Matrix methodsFor: 'inverse' !
b33

	^(self a00 * self a11 * self a22)
		+ (self a01* self a12 * self a20)
		+ (self a02 * self a10 * self a21)
		- (self a00 * self a12 * self a21)
		- (self a01 * self a10 * self a22)
		- (self a02 * self a11 * self a20)! !

! Matrix methodsFor: 'inverse' !
determinant4D

	^
	self a00 * self a11 * self a22 * self a33
	+ (self a00 * self a12 * self a23 * self a31)
	+ (self a00 * self a13 * self a21 * self a32)
	+ (self a01 * self a10 * self a23 * self a32)

	+ (self a01 * self a12 * self a20 * self a33)
	+ (self a01 * self a13 * self a22 * self a30)
	+ (self a02 * self a10 * self a21 * self a33)
	+ (self a02 * self a11 * self a23 * self a30)

	+ (self a02 * self a13 * self a20 * self a31)
	+ (self a03 * self a10 * self a22 * self a31)
	+ (self a03 * self a11 * self a20 * self a32)
	+ (self a03 * self a12 * self a21 * self a30)

	- (self a00 * self a11 * self a23 * self a32)
	- (self a00 * self a12 * self a21 * self a33)
	- (self a00 * self a13 * self a22 * self a31)
	- (self a01 * self a10 * self a22 * self a33)

	- (self a01 * self a12 * self a23 * self a30)
	- (self a01 * self a13 * self a20 * self a32)
	- (self a02 * self a10 * self a23 * self a31)
	- (self a02 * self a11 * self a20 * self a33)

	- (self a02 * self a13 * self a21 * self a30)
	- (self a03 * self a10 * self a21 * self a32)
	- (self a03 * self a11 * self a22 * self a30)
	- (self a03 * self a12 * self a20 * self a31)! !

! Matrix methodsFor: 'inverse' !
inverse

	|  inverse |

	(self rows = 2 and: [self columns = 2]) ifTrue: [^self inverse2D].
	(self rows = 3 and: [self columns = 3]) ifTrue: [^self inverse3D].
	(self rows = 4 and: [self columns = 4]) ifTrue: [^self inverse4D].

	! !

! Matrix methodsFor: 'inverse' !
inverse2D

	| determinantDemoninator |
	determinantDemoninator := (self atRow: 1 column: 1) * (self atRow: 2 column: 2) - ((self atRow: 1 column: 2) * (self atRow: 2 column: 1)).
	determinantDemoninator = 0.0 ifTrue: [^self error: 'No inverse'].
	^self class fromArray: (
		(Array new: 2)
			at: 1 put: ((Array new: 2)
				at: 1 put: (self atRow: 2 column: 2) / determinantDemoninator;
				at: 2 put: (self atRow: 1 column: 2) negated / determinantDemoninator;
				yourself);
			at: 2 put: ((Array new: 2)
				at: 1 put: (self atRow: 2 column: 1) negated / determinantDemoninator;
				at: 2 put: (self atRow: 1 column: 1) / determinantDemoninator;
				yourself);
			yourself)

	! !

! Matrix methodsFor: 'inverse' !
inverse4D

	| det |
	det := self determinant4D.
	^self class fromArray: (Array
		with: (Array with: self b00 /det with: self b01 / det with: self b02 / det with: self b03 / det)
		with: (Array with: self b10 /det with: self b11 / det with: self b12 / det with: self b13 / det)
		with: (Array with: self b20 /det with: self b21 / det with: self b22 / det with: self b23 / det)
		with: (Array with: self b30 /det with: self b31 / det with: self b32 / det with: self b33 / det)
		)! !

! Matrix methodsFor: 'printing' !
javascriptString

	| stream |
	stream := WriteStream on: (String new: 1000).

	stream nextPut: $[.

	self elements do: [:each |
		stream print: each;
			nextPutAll: ', '].

	stream nextPut: $].
	^stream contents
 ! !

! Matrix methodsFor: 'printing' !
makeIdentity

	1 to: self rows do: [:rowNumber |
		1 to: self columns do: [:columnNumber |
			self atRow: rowNumber column: columnNumber put: (rowNumber = columnNumber ifTrue: [1.0] ifFalse: [0.0])] ]
! !

! Matrix methodsFor: 'printing' !
printOn: aStream

	aStream nextPut: $[; cr.

	1 to: self rows do: [:rowNumber |
		1 to: self columns do: [:columnNumber |
			aStream print: (self atRow: rowNumber column: columnNumber); space].
		aStream cr].

	aStream nextPut: $]! !

! Matrix class methodsFor: 'instance creation' !
columnVectorFromArray: anArray

	| matrix |

	matrix := self rows: anArray size columns: 1.
	1 to: anArray size do: [:index |
		matrix atRow: index column: 1 put: (anArray at: index)].
	^matrix

! !

! Matrix class methodsFor: 'instance creation' !
from3x3Array: anArray

	^self new from3x3Array: anArray! !

! Matrix class methodsFor: 'instance creation' !
from4x4Array: anArray

	^self new from4x4Array: anArray! !

! Matrix class methodsFor: 'instance creation' !
fromArray: anArray

	^self new fromArray: anArray! !

! Matrix class methodsFor: 'instance creation' !
identityRows: rowsInteger columns: columnsInteger

	^self new
		rows: rowsInteger columns: columnsInteger;
		makeIdentity;
		yourself
! !

! Matrix class methodsFor: 'instance creation' !
rows: rowsInteger columns: columnsInteger

	^self new
		rows: rowsInteger
		columns: columnsInteger
! !

! Matrix class methodsFor: 'instance creation' !
twoDFromPoint: aPoint

	^(self rows: 3 columns: 1)
		atRow: 1 column: 1 put: aPoint x;
		atRow: 2 column: 1 put: aPoint y;
		atRow: 3 column: 1 put: 1.0;
		yourself
! !

! MessageNotUnderstood methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream cr.
	aStream nextPutAll: self message! !

! MessageNotUnderstood class methodsFor: 'signalling' !
defaultErrorString

	^'Message not understood'! !

! Metaclass methodsFor: 'accessing' !
classDictionaries

	^self thisClass classDictionaries! !

! Metaclass methodsFor: 'accessing' !
kit

	^self thisClass kit! !

! Metaclass methodsFor: 'accessing' !
name

	^thisClass name , ' class'! !

! Metaclass methodsFor: 'accessing' !
printOn: aStream

	^aStream nextPutAll: self name! !

! Metaclass methodsFor: 'accessing' !
thisClass

	^thisClass! !

! Metaclass methodsFor: 'accessing' !
thisClass: aClass 

	thisClass := aClass! !

! Number methodsFor: 'accessing' !
coerceTo: aNumber

	^aNumber! !

! Number methodsFor: 'accessing' !
kind

	^#Number ! !

! Number methodsFor: 'arithmetic' !
* aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) * (aNumber coerceTo: self)].
	^self primitiveTimes: aNumber ! !

! Number methodsFor: 'arithmetic' !
+ aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) primitivePlus: (aNumber coerceTo: self)].
	^self primitivePlus: aNumber ! !

! Number methodsFor: 'arithmetic' !
- aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) - (aNumber coerceTo: self)].
	^self primitiveMinus: aNumber ! !

! Number methodsFor: 'arithmetic' !
/ aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) / (aNumber coerceTo: self)].
	^self primitiveDivide: aNumber ! !

! Number methodsFor: 'arithmetic' !
// aNumber

	| quotient |
	quotient := self asInteger quo: aNumber asInteger.
	quotient < 0 ifTrue: [^quotient - 1].
	^quotient  ! !

! Number methodsFor: 'arithmetic' !
abs

	self negative ifTrue: [^self negated].
	^self! !

! Number methodsFor: 'arithmetic' !
arccos

	^self asFloat arccos! !

! Number methodsFor: 'arithmetic' !
arcsin

	^self asFloat arcsin! !

! Number methodsFor: 'arithmetic' !
cos

	^self asFloat cos! !

! Number methodsFor: 'arithmetic' !
cosh

	^(self exp + self negated exp) / 2.0! !

! Number methodsFor: 'arithmetic' !
cot

	^self tan reciprocal! !

! Number methodsFor: 'arithmetic' !
coth

	^self tanh reciprocal! !

! Number methodsFor: 'arithmetic' !
csc

	^self sin reciprocal! !

! Number methodsFor: 'arithmetic' !
csch

	^self sinh reciprocal! !

! Number methodsFor: 'arithmetic' !
exp

	^self asFloat exp! !

! Number methodsFor: 'arithmetic' !
ln

	^self asFloat ln! !

! Number methodsFor: 'arithmetic' !
log

	^self ln / 10.0 ln! !

! Number methodsFor: 'arithmetic' !
quo: aNumber

	^(self coerceTo: aNumber) primitiveQuo: (aNumber coerceTo: self)! !

! Number methodsFor: 'arithmetic' !
raisedTo: aNumber

	^(self ln * aNumber) exp! !

! Number methodsFor: 'arithmetic' !
raisedToInteger: aNumber

	| power factors number |

	aNumber < 0 ifTrue: [
		^self raisedToNegativeInteger: aNumber].


	factors := OrderedCollection new: 10.

	number := aNumber.
	[number = 0] whileFalse: [
		factors add: (number rem: 2).
		number := number quo: 2].

	power := self class unity.
	
	factors reverseDo: [:each |
		power := power squared.
		each == 1 ifTrue: [power := power * self]].

	^power! !

! Number methodsFor: 'arithmetic' !
raisedToNegativeInteger: aNumber

	| power factors number |

	power := self class unity.
	
	factors := OrderedCollection new: 10.

	number := aNumber negated.

	[number = 0] whileFalse: [
		factors add: (number rem: 2).
		number := number quo: 2].

	power := self class unity.
	
	factors reverseDo: [:each |
		power := power squared.
		each == 1 ifTrue: [power := power // self]].

	^power! !

! Number methodsFor: 'arithmetic' !
reciprocal

	^self class unity / self! !

! Number methodsFor: 'arithmetic' !
rem: aNumber

	^(self coerceTo: aNumber) primitiveRem: (aNumber coerceTo: self)! !

! Number methodsFor: 'arithmetic' !
sec

	^self cos reciprocal! !

! Number methodsFor: 'arithmetic' !
sech

	^self cosh reciprocal! !

! Number methodsFor: 'arithmetic' !
sin

	^self asFloat sin! !

! Number methodsFor: 'arithmetic' !
sinh

	^(self exp - self negated exp) / 2.0! !

! Number methodsFor: 'arithmetic' !
sqrt

	^self asFloat sqrt! !

! Number methodsFor: 'arithmetic' !
squared
	"Answer the receiver multiplied by itself."

	^self * self! !

! Number methodsFor: 'arithmetic' !
tan

	^self asFloat tan! !

! Number methodsFor: 'arithmetic' !
tanh

	^(self exp - self negated exp) / (self exp + self negated exp)! !

! Number methodsFor: 'comparing' !
< aNumber

	^(self coerceTo: aNumber) primitiveLessThan: (aNumber coerceTo: self)! !

! Number methodsFor: 'comparing' !
<= aNumber

	^(self coerceTo: aNumber) primitiveLessThanOrEqualTo:  (aNumber coerceTo: self)! !

! Number methodsFor: 'comparing' !
= aNumber

	aNumber isNumber ifFalse: [^false].
	^(self coerceTo: aNumber) primitiveEqualTo: (aNumber coerceTo: self)! !

! Number methodsFor: 'comparing' !
> aNumber

	^(self coerceTo: aNumber) primitiveGreaterThan: (aNumber coerceTo: self)! !

! Number methodsFor: 'comparing' !
>= aNumber

	^(self coerceTo: aNumber) primitiveGreaterThanOrEqualTo:  (aNumber coerceTo: self)! !

! Number methodsFor: 'comparing' !
hash

	^self abs! !

! Number methodsFor: 'comparing' !
~= aNumber

	aNumber isNumber ifFalse: [^true].
	^(self coerceTo: aNumber) primitiveNotEqualTo: (aNumber coerceTo: self)! !

! Number methodsFor: 'converting' !
@ aNumber 

	^Point x: self y: aNumber! !

! Number methodsFor: 'converting' !
degreesToRadians

	^self * Float pi / 180.0! !

! Number methodsFor: 'converting' !
negated

	^self class zero - self! !

! Number methodsFor: 'converting' !
negative

	^self < self class zero! !

! Number methodsFor: 'converting' !
positive

	^self >= self class zero! !

! Number methodsFor: 'converting' !
radiansToDegrees

	^self * 180.0 / Float pi! !

! Number methodsFor: 'converting' !
sign

	self < self class zero ifTrue: [^-1].
	self > self class zero ifTrue: [^1].
	^0! !

! Number methodsFor: 'enumerating' !
to: stop by: step do: aBlock

	| current |

	current := self.
	step negative
		ifTrue: [[current >= stop] whileTrue: [
			aBlock value: current.
			current := current + step]]
		ifFalse: [[current <= stop] whileTrue: [
			aBlock value: current.
			current := current + step.]]! !

! Number methodsFor: 'enumerating' !
to: stop do: aBlock

	self to: stop by: 1 do: aBlock! !

! Number methodsFor: 'printing' !
jsonOn: aStream

	self printOn: aStream! !

! Number methodsFor: 'testing' !
isNumber

	^true! !

! Number methodsFor: 'testing' !
isZero
	^self = 0! !

! Number class methodsFor: 'reading' !
readFrom: aStream

	| sign mantissa decimalPosition position finished exponent mantissaDigits |

	sign := 1.
	aStream atEnd ifTrue: [^0.0].

	aStream peek = $- ifTrue: [
		sign := -1.
		aStream next].

	aStream peek = $+ ifTrue: [
		aStream next].

	mantissa := 0.
	mantissaDigits := 0.
	decimalPosition := nil.
	position := 0.
	finished := false.

	[aStream atEnd not and: [finished not]] whileTrue: [
		| character |
		finished := true.
		character := aStream next.
		character isDigit ifTrue: [mantissa := mantissa * 10 + character digitValue. finished := false. mantissaDigits := mantissaDigits + 1].
		character = $. ifTrue: [decimalPosition := position. finished := false].
		character = $e ifTrue: [exponent := Integer readFrom: aStream].
		position := position + 1.
		].

	decimalPosition isNil ifTrue: [decimalPosition := mantissaDigits].
	exponent isNil ifTrue: [exponent := 0].

	^(mantissa * sign) asFloat * (10 raisedToInteger: exponent + decimalPosition - mantissaDigits)! !

! Fraction methodsFor: 'accessing' !
denominator

	^denominator! !

! Fraction methodsFor: 'accessing' !
denominator: anInteger

	denominator := anInteger asInteger! !

! Fraction methodsFor: 'accessing' !
numerator

	^numerator! !

! Fraction methodsFor: 'accessing' !
numerator: anInteger

	numerator := anInteger asInteger! !

! Fraction methodsFor: 'arithmetic' !
primitiveDivide: aNumber

	^self class numerator: self numerator * aNumber denominator denominator: self denominator * aNumber numerator ! !

! Fraction methodsFor: 'arithmetic' !
primitiveMinus: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.

	^self class numerator: ((lcm quo: self denominator) * self numerator) - ((lcm quo: aNumber denominator) * aNumber numerator) denominator: lcm ! !

! Fraction methodsFor: 'arithmetic' !
primitivePlus: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.

	^self class numerator: ((lcm quo: self denominator) * self numerator) + ((lcm quo: aNumber denominator) * aNumber numerator) denominator: lcm ! !

! Fraction methodsFor: 'arithmetic' !
primitiveTimes: aNumber

	^self class numerator: self numerator * aNumber numerator denominator: self denominator * aNumber denominator ! !

! Fraction methodsFor: 'coercing' !
coerceFloat: aFloat

	^aFloat ! !

! Fraction methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction ! !

! Fraction methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger asFraction ! !

! Fraction methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger asFraction ! !

! Fraction methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceFraction: self ! !

! Fraction methodsFor: 'coercing' !
kind

	^#Fraction ! !

! Fraction methodsFor: 'comparing' !
primitiveEqualTo: aNumber

	^self numerator = aNumber numerator and: [self denominator = aNumber denominator]! !

! Fraction methodsFor: 'comparing' !
primitiveGreaterThan: aNumber

	| lcm |
	aNumber isFloat ifTrue: [^self asFloat > aNumber asFloat].

	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) > ((lcm quo: aNumber denominator) * aNumber numerator)! !

! Fraction methodsFor: 'comparing' !
primitiveGreaterThanOrEqualTo: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) >= ((lcm quo: aNumber denominator) * aNumber numerator)! !

! Fraction methodsFor: 'comparing' !
primitiveLessThan: aNumber

	| lcm |
	aNumber isFloat ifTrue: [^self asFloat < aNumber asFloat].

	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) < ((lcm quo: aNumber denominator) * aNumber numerator)! !

! Fraction methodsFor: 'comparing' !
primitiveLessThanOrEqualTo: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) <= ((lcm quo: aNumber denominator) * aNumber numerator)! !

! Fraction methodsFor: 'comparing' !
primitiveNotEqualTo: aNumber

	^self numerator ~= aNumber numerator or: [self denominator ~= aNumber denominator]! !

! Fraction methodsFor: 'converting' !
asFloat

	^self numerator asFloat / self denominator asFloat! !

! Fraction methodsFor: 'converting' !
asInteger

	^self numerator quo: self denominator! !

! Fraction methodsFor: 'printing' !
hex

	^(WriteStream on: (String new: 10))
		nextPutAll: self numerator hex;
		nextPutAll: ' / ';
		nextPutAll: self denominator hex;
		contents! !

! Fraction methodsFor: 'printing' !
printOn: aStream

	aStream
		print: self numerator;
		nextPutAll: ' / ';
		print: self denominator! !

! Fraction methodsFor: 'utility' !
reduce

	| gcd |
	gcd := self numerator gcd: self denominator.
	gcd = 1 ifTrue: [^self].
	self numerator: (self numerator quo: gcd).
	self denominator: (self denominator quo: gcd).
	self denominator < 0 ifTrue: [
		self denominator: self denominator negated.
		self numerator: self numerator negated].

	self denominator = 1 ifTrue: [^numerator].
	^self
! !

! Fraction class methodsFor: 'instance creation' !
numerator: numerator denominator: denominator

	^self new
		numerator: numerator;
		denominator: denominator;
		reduce
! !

! Fraction class methodsFor: 'instance creation' !
unity

	^1! !

! Fraction class methodsFor: 'instance creation' !
zero

	^0! !

! Integer methodsFor: 'accessing' !
denominator

	^1
! !

! Integer methodsFor: 'accessing' !
even

	^(self bitAnd: 1) = 0! !

! Integer methodsFor: 'accessing' !
numerator

	^self
! !

! Integer methodsFor: 'accessing' !
odd

	^(self bitAnd: 1) = 1! !

! Integer methodsFor: 'accessing' !
truncated

	^self! !

! Integer methodsFor: 'arithmetic' !
/ aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) / (aNumber coerceTo: self)].
	^self asFraction / aNumber asFraction! !

! Integer methodsFor: 'arithmetic' !
gcd: aNumber

	| a b t |
	a := self.
	b := aNumber.

	[b = 0] whileFalse: [
		t := b.
		b := a mod: b.	
		a := t].

	^a! !

! Integer methodsFor: 'arithmetic' !
lcm: aNumber

	^(self * aNumber) abs // (self gcd: aNumber)! !

! Integer methodsFor: 'computing' !
factorial

	| factorial |

	self <= 0 ifTrue: [^0].

	factorial := 1.
	2 to: self do: [:i | factorial := factorial * i].
	^factorial
! !

! Integer methodsFor: 'computing' !
intSqrt

	| guess lastGuess |

	guess := 1.
	(self printString size // 2) timesRepeat: [guess := guess * 10].
	lastGuess := 0.
	[guess := (guess + (self // guess)) // 2.
	guess = lastGuess] whileFalse: [
		lastGuess := guess].
	^guess

 ! !

! Integer methodsFor: 'converting' !
asFraction

	^Fraction new
		numerator: self;
		denominator: 1;
		yourself! !

! Integer methodsFor: 'converting' !
asInteger
	^self! !

! Integer methodsFor: 'enumerating' !
timesRepeat: aBlock

	1 to: self do: [:i | aBlock value].
	^nil! !

! Integer methodsFor: 'printing' !
hex

	^self printStringRadix: 16! !

! Integer methodsFor: 'printing' !
printHexOn: aStream padZeros: aNumber

	self printOn: aStream paddedWith: $0 to: aNumber base: 16! !

! Integer methodsFor: 'printing' !
printOn: aStream 

	| string value numberOfDigits |

	value := self.
	numberOfDigits := 0.
	
	[value := (value quo: 10) abs.
	numberOfDigits := numberOfDigits + 1.
	value = 0] whileFalse.

	self = 0 ifTrue: [^aStream nextPut: $0].
	string := String new: numberOfDigits.

	value := self.
	self < 0 ifTrue: [aStream nextPut: $-].
	numberOfDigits to: 1 by: -1 do: [:digitNumber |
		string at: digitNumber put: (Character digitValue: (value rem: 10) abs).
		value := (value quo: 10) abs].
	aStream nextPutAll: string ! !

! Integer methodsFor: 'printing' !
printOn: aStream paddedWith: aCharacter to: aNumber base: base

	| string value absValue numberOfDigits |
	value := absValue := self abs.
	numberOfDigits := 0.
	
	self = 0 ifTrue: [
		aNumber - 1 timesRepeat: [aStream nextPut: aCharacter].
		^aStream nextPut: $0].

	[value = 0] whileFalse: [
		value := value quo: base.
		numberOfDigits := numberOfDigits + 1].

	aNumber - numberOfDigits timesRepeat: [aStream nextPut: aCharacter].

	self = 0 ifTrue: [^self].
	
	string := String new: numberOfDigits.
	value := absValue.
	self < 0 ifTrue: [aStream nextPut: $-].
	numberOfDigits to: 1 by: -1 do: [:digitNumber |
		string at: digitNumber put: (Character digitValue: (value rem: base)).
		value := value quo: base].
	aStream nextPutAll: string ! !

! Integer methodsFor: 'printing' !
printStringRadix: aNumber

	| stream |

	stream := WriteStream on: String new.
	self printOn: stream paddedWith: Character space to: 0 base: aNumber.
	^stream contents! !

! Integer methodsFor: 'testing' !
isInteger

	^true! !

! Integer class methodsFor: 'instance creation' !
readFrom: aStream

	| result |
	result := 0.

	[aStream atEnd] whileFalse: [
		| character |
		(aStream peek between: $0 and: $9) ifFalse: [^result].
		character := aStream next.
		result := result * 10 + (character asInteger - $0 asInteger).
		].

	^result! !

! Integer class methodsFor: 'instance creation' !
readHexFrom: aStream

	| result |
	result := 0.

	[aStream atEnd] whileFalse: [
		| character digit |
		character := aStream peek asLowercase.
		digit := nil.
		(character between: $0 and: $9) ifTrue: [digit := character asInteger - $0 asInteger].
		(character between: $a and: $f) ifTrue: [digit := character asInteger - $a asInteger + 10].
		digit isNil ifTrue: [^result].
		aStream next.
		
		result := result * 16 + digit].

	^result! !

! Integer class methodsFor: 'instance creation' !
unity
	^1! !

! Integer class methodsFor: 'instance creation' !
zero
	^0! !

! LargeInteger methodsFor: 'accessing' !
bytes

	^bytes
! !

! LargeInteger methodsFor: 'accessing' !
bytes: aByteArray

	bytes := aByteArray
! !

! LargeInteger methodsFor: 'accessing' !
componentSize

	^componentSize! !

! LargeInteger methodsFor: 'accessing' !
componentSize: aNumber

	componentSize := aNumber! !

! LargeInteger methodsFor: 'arithmetic' !
divideWithRemainderBy: divisor

	<primitive: 33>
	self primitiveFailed! !

! LargeInteger methodsFor: 'arithmetic' !
mod: aNumber

	^self rem: aNumber! !

! LargeInteger methodsFor: 'arithmetic' !
primitiveDivide: aNumber

	<primitive: 30>
	self primitiveFailed
 ! !

! LargeInteger methodsFor: 'arithmetic' !
primitiveMinus: aLargeInteger

	<primitive: 22>
	self primitiveFailed  ! !

! LargeInteger methodsFor: 'arithmetic' !
primitivePlus: aLargeInteger

	<primitive: 21>
	self primitiveFailed  ! !

! LargeInteger methodsFor: 'arithmetic' !
primitiveQuo: aNumber

	^(self divideWithRemainderBy: aNumber) first ! !

! LargeInteger methodsFor: 'arithmetic' !
primitiveRem: aNumber

	^(self divideWithRemainderBy: aNumber asLargeInteger) last ! !

! LargeInteger methodsFor: 'arithmetic' !
primitiveTimes: aLargeInteger

	<primitive: 29>
	self primitiveFailed
 ! !

! LargeInteger methodsFor: 'coercing' !
coerceFloat: aFloat
	^aFloat ! !

! LargeInteger methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction ! !

! LargeInteger methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger ! !

! LargeInteger methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger asLargeInteger ! !

! LargeInteger methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceLargeInteger: self ! !

! LargeInteger methodsFor: 'coercing' !
kind

	^#LargeInteger ! !

! LargeInteger methodsFor: 'comparing' !
basicEqualTo: aNumber

	<primitive: 27>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
basicGreaterThan: aNumber

	<primitive: 24>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
basicGreaterThanOrEqual: aNumber

	<primitive: 26>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
basicLessThan: aNumber

	<primitive: 23>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
basicLessThanOrEqual: aNumber

	<primitive: 25>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
basicNotEqualTo: aNumber

	<primitive: 28>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
hash

	^self integerAt: 1! !

! LargeInteger methodsFor: 'comparing' !
primitiveEqualTo: aNumber

	^self basicEqualTo: aNumber! !

! LargeInteger methodsFor: 'comparing' !
primitiveGreaterThan: aNumber

	<primitive: 24>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
primitiveGreaterThanOrEqualTo: aNumber

	^self basicGreaterThanOrEqual: aNumber! !

! LargeInteger methodsFor: 'comparing' !
primitiveLessThan: aNumber

	<primitive: 23>
	self primitiveFailed! !

! LargeInteger methodsFor: 'comparing' !
primitiveLessThanOrEqualTo: aNumber

	^self basicLessThanOrEqual: aNumber! !

! LargeInteger methodsFor: 'comparing' !
primitiveNotEqualTo: aNumber

	^self basicNotEqualTo: aNumber! !

! LargeInteger methodsFor: 'converting' !
asFloat

	<primitive: 35>
	self primitiveFailed
! !

! LargeInteger methodsFor: 'converting' !
asLargeInteger

	^self
! !

! LargeInteger methodsFor: 'initialize-release' !
initialize

	super initialize.
	bytes := ByteArray new: 8 withAll: 0.
	componentSize := 1! !

! LargeInteger methodsFor: 'printing' !
printOn: aStream 

	| stream value numberOfDigits ten zero |

	value := self abs.
	
	self = 0 ifTrue: [^aStream nextPut: $0].

	stream := WriteStream on: (String new: 1000).

	value := self.

	self < 0 ifTrue: [aStream nextPut: $-].
	ten := 10 asLargeInteger.
	zero := 0 asLargeInteger.

	[zero = value asLargeInteger] whileFalse: [
		| quotientAndRemainder |
		quotientAndRemainder := value divideWithRemainderBy: ten.
		stream nextPut: (Character digitValue: quotientAndRemainder last).
		value := quotientAndRemainder first].

	aStream nextPutAll: stream contents reverse ! !

! LargeInteger methodsFor: 'testing' !
isLargeInteger

	^true! !

! LargeInteger methodsFor: 'utility' !
hex

	| stream |
	stream := WriteStream on: (String new: 1000).
	self printHexOn: stream.
	^stream contents
! !

! LargeInteger methodsFor: 'utility' !
integerAt: aNumber

	| integer |
	aNumber > 1 ifTrue: [^0].

	^self rem: 16r10000000! !

! LargeInteger methodsFor: 'utility' !
printHexOn: aStream

	self positive
		ifTrue: [aStream nextPutAll: '+']
		ifFalse: [aStream nextPutAll: '-'].

	aStream nextPut: $[.
	1 to: self bytes size do: [:index |
		aStream nextPutAll: (self bytes at: index) hex.
		aStream space].
	aStream nextPut: $]! !

! LargeInteger class methodsFor: 'instance creation' !
new

	^super new initialize! !

! LargeNegativeInteger methodsFor: 'testing' !
negative

	^true! !

! LargeNegativeInteger methodsFor: 'testing' !
positive

	^false! !

! LargeNegativeInteger methodsFor: 'utility' !
sign

	^-1! !

! LargePositiveInteger methodsFor: 'testing' !
negative

	^false! !

! LargePositiveInteger methodsFor: 'testing' !
positive

	^true! !

! LargePositiveInteger methodsFor: 'utility' !
sign

	^1
! !

! LimitedPrecisionReal methodsFor: 'arithmetic' !
fractionalValue

	^self - self asInteger! !

! LimitedPrecisionReal methodsFor: 'converting' !
asInteger

	self subclassResponsibility! !

! LimitedPrecisionReal methodsFor: 'converting' !
positive

	^self >= self class zero! !

! LimitedPrecisionReal methodsFor: 'printing' !
printOn: aStream 

	| fractionalPart roundedValue adjustment |
		
	self abs < 1.0e-14 ifTrue: [
		^aStream nextPutAll: '0.0'].

	self negative
		ifTrue: 
			[aStream nextPut: $-.
			^self abs printOn: aStream].

	adjustment := 5 * (0.1 raisedToInteger: self decimalDigitsOfPrecision - (self ln / 10.0 ln) truncated).
	roundedValue := self + adjustment.
	(roundedValue > 10.0e9) | (roundedValue < (1.0 / 10.0e9)) ifTrue: [^roundedValue printScientificNotationOn: aStream].

	roundedValue asInteger printOn: aStream.
	aStream nextPut: $..
	fractionalPart := roundedValue fractionalValue.
	adjustment := adjustment * 10.
	[
		fractionalPart := fractionalPart * 10.
		fractionalPart asInteger printOn: aStream.
		fractionalPart := fractionalPart fractionalValue.
		adjustment := adjustment * 10.
		fractionalPart > adjustment] whileTrue: [].

	^self! !

! LimitedPrecisionReal methodsFor: 'printing' !
printScientificNotationOn: aStream
	| mantissa exponent |

	exponent := (self abs ln / 10 ln) truncated.
	exponent negative ifTrue: [exponent := exponent - 1].

	self / (10 asFloat raisedToInteger: exponent) printOn: aStream.
	aStream nextPut: $e.
	exponent printOn: aStream.
! !

! LimitedPrecisionReal methodsFor: 'testing' !
isReal

	^true! !

! LimitedPrecisionReal class methodsFor: 'instance creation' !
new

	^self zero copy.! !

! LimitedPrecisionReal class methodsFor: 'instance creation' !
zero

	^self subclassResponsibility! !

! Float methodsFor: 'accessing' !
basicAt: aNumber

	^self ! !

! Float methodsFor: 'accessing' !
basicSize

	^0 ! !

! Float methodsFor: 'accessing' !
kind

	^#Float ! !

! Float methodsFor: 'arithmetic' !
arcTan2: angle

	<primitive: 56>
	self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
arccos

	<primitive: 59>
	^self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
arcsin

	<primitive: 58>
	^self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
arctan

	^self arcTan: 1.0! !

! Float methodsFor: 'arithmetic' !
asFloat

	^self! !

! Float methodsFor: 'arithmetic' !
cos

	<primitive: 54>
	self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
decimalDigitsOfPrecision
	^15! !

! Float methodsFor: 'arithmetic' !
exp

	<primitive: 65>
	^self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
fractionPart

	^self - self asInteger asFloat! !

! Float methodsFor: 'arithmetic' !
ln

	<primitive: 57>
	^self! !

! Float methodsFor: 'arithmetic' !
log

	<primitive: 57>
	self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
mod: aNumber

	self < 0.0 ifTrue: [^aNumber - (self abs mod: aNumber)].
	^(self / aNumber) fractionPart * aNumber! !

! Float methodsFor: 'arithmetic' !
primitiveDivide: aNumber 

	<primitive: 50>
	^self primitiveFailed ! !

! Float methodsFor: 'arithmetic' !
primitiveGreaterThan: aNumber 

	<primitive: 44>
	self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
primitiveGreaterThanOrEqualTo: aNumber 

	^(self < aNumber) not! !

! Float methodsFor: 'arithmetic' !
primitiveLessThan: aNumber 

	<primitive: 43>
	^self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
primitiveLessThanOrEqualTo: aNumber 

	^(self > aNumber) not! !

! Float methodsFor: 'arithmetic' !
primitiveMinus: aNumber 

	<primitive: 42>
	^self primitiveFailed ! !

! Float methodsFor: 'arithmetic' !
primitivePlus: aNumber 

	<primitive: 41>
	^self primitiveFailed ! !

! Float methodsFor: 'arithmetic' !
primitiveTimes: aNumber 

	<primitive: 49>
	^self primitiveFailed ! !

! Float methodsFor: 'arithmetic' !
raisedToNegativeInteger: aNumber

	| power factors number |

	power := self class unity.
	
	factors := OrderedCollection new: 10.

	number := aNumber negated.

	[number = 0] whileFalse: [
		factors add: (number rem: 2).
		number := number quo: 2].

	power := self class unity.
	
	factors reverseDo: [:each |
		power := power squared.
		each == 1 ifTrue: [power := power / self]].

	^power! !

! Float methodsFor: 'arithmetic' !
round
	| remainder decimal add|
	remainder := self truncated.
	decimal := self - remainder asFloat.
	decimal >= 0.5 ifTrue: [add := 1] ifFalse: [add := 0].
	
	^ remainder + add.! !

! Float methodsFor: 'arithmetic' !
roundUp
	self = self truncated asFloat ifTrue: [^self truncated]
	ifFalse: [^self truncated + 1]! !

! Float methodsFor: 'arithmetic' !
sin

	<primitive: 53>
	self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
sqrt

	<primitive: 52>
	self primitiveFailed! !

! Float methodsFor: 'arithmetic' !
tan

	<primitive: 55>
	self primitiveFailed! !

! Float methodsFor: 'coercing' !
coerceFloat: aFloat

	^aFloat ! !

! Float methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction asFloat  ! !

! Float methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger asFloat ! !

! Float methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger asFloat ! !

! Float methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceFloat: self ! !

! Float methodsFor: 'comparing' !
asInteger

	^self truncated! !

! Float methodsFor: 'comparing' !
primitiveEqualTo: aNumber 

	<primitive: 45>
	^false! !

! Float methodsFor: 'comparing' !
primitiveNotEqualTo: aNumber 

	^(self primitiveEqualTo: aNumber) not! !

! Float methodsFor: 'comparing' !
truncated

	<primitive: 51>
	self primitiveFailed! !

! Float methodsFor: 'testing' !
isFloat

	^true! !

! Float class methodsFor: 'instance creation' !
e

	^2.7182818284590452353602874713527! !

! Float class methodsFor: 'instance creation' !
new

	^self error: 'Can''t create Floats with new'! !

! Float class methodsFor: 'instance creation' !
pi

	^3.1415926535897932384626433832795! !

! Float class methodsFor: 'instance creation' !
unity

	^1.0! !

! Float class methodsFor: 'instance creation' !
zero

	^0.0! !

! OSHandle methodsFor: 'accessing' !
contents

	^self! !

! Point methodsFor: 'accessing' !
x

	^x! !

! Point methodsFor: 'accessing' !
x: aNumber 

	x := aNumber! !

! Point methodsFor: 'accessing' !
y

	^y! !

! Point methodsFor: 'accessing' !
y: aNumber 

	y := aNumber! !

! Point methodsFor: 'arithmetic' !
* aPointOrNumber

	aPointOrNumber class = Point
		ifTrue: [^Point x: self x * aPointOrNumber x y: self y * aPointOrNumber y].
	^Point x: self x * aPointOrNumber y: self y * aPointOrNumber! !

! Point methodsFor: 'arithmetic' !
+ aPoint

	^Point x: self x + aPoint x y: self y + aPoint y! !

! Point methodsFor: 'arithmetic' !
- aPoint

	^Point x: self x - aPoint x y: self y - aPoint y! !

! Point methodsFor: 'arithmetic' !
/ aPointOrNumber

	aPointOrNumber class = Point
		ifTrue: [^Point x: self x / aPointOrNumber x y: self y / aPointOrNumber y].
	^Point x: self x / aPointOrNumber y: self y / aPointOrNumber! !

! Point methodsFor: 'arithmetic' !
abs

	^self class x: x abs y: y abs! !

! Point methodsFor: 'arithmetic' !
dotProduct: aPoint 

	^self x * aPoint x + (self y * aPoint y)! !

! Point methodsFor: 'arithmetic' !
max: aPoint

	^Point x: (self x max: aPoint x) y: (self y max: aPoint y)! !

! Point methodsFor: 'arithmetic' !
min: aPoint

	^Point x: (self x min: aPoint x) y: (self y min: aPoint y)! !

! Point methodsFor: 'arithmetic' !
negated

	^Point x: self x negated y: self y negated! !

! Point methodsFor: 'arithmetic' !
r

	^(self x squared + self y squared) sqrt! !

! Point methodsFor: 'arithmetic' !
theta

	^self y asFloat arcTan2: self x asFloat! !

! Point methodsFor: 'arithmetic' !
transposed

	^Point x: self y y: self x! !

! Point methodsFor: 'comparing' !
= aPoint

	self class = aPoint class ifFalse: [^false].
	^x = aPoint x and: [y = aPoint y]! !

! Point methodsFor: 'comparing' !
hash

	^(x hash * 99859 + y hash) hash! !

! Point methodsFor: 'converting' !
corner: aPoint 

	^Rectangle origin: self corner: aPoint! !

! Point methodsFor: 'converting' !
extent: aPoint 

	^Rectangle origin: self extent: aPoint! !

! Point methodsFor: 'copying' !
copy

	^self class x: x y: y! !

! Point methodsFor: 'printing' !
printOn: aStream 

	self x printOn: aStream.
	aStream nextPutAll: ' @ '.
	self y printOn: aStream! !

! Point class methodsFor: 'instance creation' !
x: x y: y 

	^(self new)
		x: x;
		y: y;
		yourself! !

! Random methodsFor: 'accessing' !
seed

	^seed! !

! Random methodsFor: 'accessing' !
seed: aNumber

	seed := aNumber! !

! Random methodsFor: 'generating' !
next

	^self nextSeed asFloat / 120050.0! !

! Random methodsFor: 'generating' !
nextSeed

	^seed := seed * 2311 + 25367 \\ 120050! !

! Random methodsFor: 'initialize-release' !
initialize

	seed := Time millisecondClockValue.! !

! Random class methodsFor: 'instance creation' !
new

	^super new initialize! !

! Random class methodsFor: 'instance creation' !
seed: aNumber

	^self new
		seed: aNumber;
		yourself! !

! SHA1 methodsFor: 'accessing' !
hash: aString

	| byteStream length h0 h1 h2 h3 h4 words a b c d e f k hashArray length64 |

	h0 := 16r67452301.
	h1 := 16rEFCDAB89.
	h2 := 16r98BADCFE.
	h3 := 16r10325476.
	h4 := 16rC3D2E1F0.

	length := aString size * 8.

	byteStream := WriteStream on: (ByteArray new: 80).
	aString do: [:character | byteStream nextPut: character asInteger].
	byteStream nextPut: 16r80.

	[byteStream position * 8 \\ 512 = 448] whileFalse: [
		byteStream nextPut: 0].

	length64 := ByteArray new: 8.
	
	8 to: 1 by: -1 do: [:index |
		length64 at: index put: length \\ 256.
		length := length // 256].
	
	length64 do: [:each | byteStream nextPut: each].
	
	byteStream := byteStream contents readStream.
	[byteStream atEnd] whileFalse: [
		words := Array new: 80.
		
		1 to: 16 do: [:wordIndex |
			| word |
			word := byteStream next * 256 + byteStream next * 256 + byteStream next * 256 + byteStream next.
			words at: wordIndex put: word].
		
		17 to: 80 do: [:index |
			words at: index put: (
				((((words at: index - 3) bitXor:
				(words at: index - 8)) bitXor: (words at: index - 14))
					bitXor: (words at: index - 16)) leftRotate32: 1)].

		a := h0.
		b := h1.
		c := h2.
		d := h3.
		e := h4.

		1 to: 80 do: [:index |
			| temp |
			(index between: 1 and: 20) ifTrue: [
				f := (b bitAnd: c) bitOr: ((b bitXor: 4294967295) bitAnd: d).
				k := 16r5A827999].
			(index between: 21 and: 40) ifTrue: [
				f := (b bitXor: c) bitXor: d.
				k := 16r6ED9EBA1].
			(index between: 41 and: 60) ifTrue: [
				f := ((b bitAnd: c) bitOr: (b bitAnd: d)) bitOr: (c bitAnd: d).
				k := 16r8F1BBCDC].
			(index between: 61 and: 80) ifTrue: [
				f := (b bitXor: c) bitXor: d.
				k := 16rCA62C1D6].
			
			temp := ((a leftRotate32: 5) + f + e + k + (words at: index)) \\ 4294967296.
			e := d.
			d := c.
			c := b leftRotate32: 30.
			b := a.
			a := temp].

		h0 := (h0 + a) \\ 4294967296.
		h1 := (h1 + b) \\ 4294967296.
		h2 := (h2 + c) \\ 4294967296.
		h3 := (h3 + d) \\ 4294967296.
		h4 := (h4 + e) \\ 4294967296].

	hashArray := ByteArray new: 20.
	self
		write32: h0 into: hashArray startingAt: 1;
		write32: h1 into: hashArray startingAt: 5;
		write32: h2 into: hashArray startingAt: 9;
		write32: h3 into: hashArray startingAt: 13;
		write32: h4 into: hashArray startingAt: 17.

	^hashArray! !

! SHA1 methodsFor: 'accessing' !
write32: anInteger into: anArray startingAt: startingIndex

	| index number |
	
	index := startingIndex.
	number := anInteger.

	4 timesRepeat: [
		anArray at: index put: number // 16777216.
		number := number \\ 16777216 * 256.
		index := index + 1]! !

! SequenceableCollection methodsFor: 'accessing' !
at: aNumber ifAbsent: aBlock

	(aNumber between: 1 and: self size) ifFalse: [^aBlock value].
	^self at: aNumber! !

! SequenceableCollection methodsFor: 'accessing' !
first

	self isEmpty ifTrue: [^nil].
	^self at: 1! !

! SequenceableCollection methodsFor: 'accessing' !
firstIndexOf: anElement startingAt: startIndex

	startIndex to: self size do: [:index | (self at: index) = anElement ifTrue: [^index]].		
	^nil! !

! SequenceableCollection methodsFor: 'accessing' !
indexOf: anElement

	1 to: self size do: [:index | (self at: index) = anElement ifTrue: [^index]].	
	^0! !

! SequenceableCollection methodsFor: 'accessing' !
last

	self isEmpty ifTrue: [^nil].
	^self at: self size! !

! SequenceableCollection methodsFor: 'accessing' !
lastIndexOf: anElement

	self size to: 1 by: -1 do: [:index | (self at: index) = anElement ifTrue: [^index]].	
	^0! !

! SequenceableCollection methodsFor: 'accessing' !
reverse

	| result nextIndex |

	result := self class new: self size.
	nextIndex := 1.

	self size to: 1 by: -1 do: [:index |
		result at: nextIndex put: (self at: index).
		nextIndex := nextIndex + 1].

	^result! !

! SequenceableCollection methodsFor: 'comparing' !
= anObject 

	self class == anObject class ifFalse: [^false].
	self size = anObject size ifFalse: [^false].
	self with: anObject do: [:object1 :object2 |
		object1 = object2 ifFalse: [^false]].
	^true! !

! SequenceableCollection methodsFor: 'comparing' !
hash

	| hash |
	hash := 0.

	self do: [:each |
		hash := ((hash * 104729 + each hash) integerAt: 1) \\ 1099511627776  ].

	^hash! !

! SequenceableCollection methodsFor: 'converting' !
readStream

	^ReadStream on: self! !

! SequenceableCollection methodsFor: 'converting' !
readWriteStream

	^ReadWriteStream on: self! !

! SequenceableCollection methodsFor: 'converting' !
writeStream

	^WriteStream on: self! !

! SequenceableCollection methodsFor: 'copying' !
copy
	^self copyFrom: 1 to: self size.! !

! SequenceableCollection methodsFor: 'copying' !
copyFrom: startIndex to: endIndex 

	| result |

	endIndex < startIndex ifTrue: [^self class new: 0].

	result := self class new: endIndex - startIndex + 1.
	startIndex to: endIndex do: [:index |
		result at: index - startIndex + 1 put: (self at: index)].

	^result ! !

! SequenceableCollection methodsFor: 'copying' !
copyReplaceAll: collection1 with: collection2

	| inStream outStream |

	inStream := self readStream.
	outStream := WriteStream on: (self class new: collection2 size).

	[inStream atEnd] whileFalse: [
		| contents |
		contents := inStream throughAll: collection1.
		(contents endsWith: collection1)
			ifTrue: [
				outStream nextPutAll: (contents copyFrom: 1 to: (contents size - collection1 size)).
				outStream nextPutAll: collection2]
			ifFalse: [outStream nextPutAll: contents]].

	^outStream contents! !

! SequenceableCollection methodsFor: 'copying' !
copyReplacing: object1 with: object2

	| newString |
	newString := self class new: self size.
	1 to: newString size do: [:index |
		| currentObject |
		currentObject := self at: index.
		newString at: index put: (
			currentObject = object1
				ifTrue: [object2]
				ifFalse: [currentObject])].
	^newString! !

! SequenceableCollection methodsFor: 'copying' !
copyWith: anObject

	| copy |
	copy := self class new: self size + 1.
	1 to: self size do: [:index |
		copy at: index put: (self at: index)].
	copy at: self size + 1 put: anObject.
	^copy! !

! SequenceableCollection methodsFor: 'copying' !
copyWithout: anObject

	| copy occurrences newIndex |
	
	occurrences := self occurrencesOf: anObject.
	copy := self class new: self size - occurrences.
	newIndex := 1.

	1 to: self size do: [:index |
		| object |
		object := self at: index.
		object = anObject ifFalse: [
			copy at: newIndex put: object.
			newIndex := newIndex + 1]].
	^copy! !

! SequenceableCollection methodsFor: 'copying' !
printItWith: aDictionary

	| result |

	self disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'richTextSelectedString')) printString].

	self code: (self code copyFrom: 1 to: (aDictionary at: 'richTextSelectionEnd')) ,
		result, ' ',
		(self code copyFrom: (aDictionary at: 'richTextSelectionEnd') + 1 to: self code size).
	self updateCodePane! !

! SequenceableCollection methodsFor: 'enumerating' !
collect: aBlock 

	| result |
	result := self species new: self size.
	1 to: self size do: [:each | result at: each put: (aBlock value: (self at: each))].
	^result! !

! SequenceableCollection methodsFor: 'enumerating' !
do: aBlock 

	1 to: self size do: [:index |
		aBlock value: (self at: index)]! !

! SequenceableCollection methodsFor: 'enumerating' !
do: aBlock separatedBy: aBlock2

	| hasStarted |

	hasStarted := false.
	self do: [:each |
		hasStarted ifTrue: [aBlock2 value].
		hasStarted := true.
		aBlock value: each]! !

! SequenceableCollection methodsFor: 'enumerating' !
findFirst: aBlock

	| index |

	index := 1.
	self do: [:each | (aBlock value: each) ifTrue: [^index].
		index := index + 1].
	^0! !

! SequenceableCollection methodsFor: 'enumerating' !
findLast: aBlock

	| index |

	index := self size.
	self reverseDo: [:each | (aBlock value: each) ifTrue: [^index].
		index := index - 1].
	^0! !

! SequenceableCollection methodsFor: 'enumerating' !
keysAndValuesDo: aBlock 

	1 to: self size do: [:index |
		aBlock value: index value: (self at: index)]! !

! SequenceableCollection methodsFor: 'enumerating' !
reverseDo: aBlock 

	self size to: 1 by: -1 do: [:index |
		aBlock value: (self at: index)]! !

! SequenceableCollection methodsFor: 'enumerating' !
select: aBlock 

	| result resultIndex |
	result := self species new: self size.

	resultIndex := 0.

	1 to: self size do: [:index |
		| value |
		value := self at: index.
		(aBlock value: value)
			ifTrue: [
				resultIndex := resultIndex + 1.
				result at: resultIndex put: value]
			ifFalse: [nil]].

	^result copyFrom: 1 to: resultIndex! !

! SequenceableCollection methodsFor: 'enumerating' !
splitOn: anObject

	| result startSplitIndex |
	result := OrderedCollection new.
	startSplitIndex := 1.
	
	self keysAndValuesDo: [:key :each |
		each = anObject ifTrue: [
			result add: (self copyFrom: startSplitIndex to: key - 1).
			startSplitIndex := key + 1.
			]
		].
	
	result add: (self copyFrom: startSplitIndex to: self size).
	^result! !

! SequenceableCollection methodsFor: 'enumerating' !
with: aCollection do: aBlock 

	aCollection size = self size ifFalse: [self error: 'Sizes don''t match'].
	1 to: aCollection size do: [:index |
		aBlock
			value: (self at: index)
			value: (aCollection at: index)]! !

! SequenceableCollection methodsFor: 'json' !
jsonOn: aStream

	aStream nextPut: $[.
	self do: [:each | each jsonOn: aStream]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $].! !

! SequenceableCollection methodsFor: 'manipulation' !
indexOfSubCollection: aSubcollection startingAt: anIndex

	| lastStartingPoint currentIndex indexFound |
	
	lastStartingPoint := anIndex.
	currentIndex := anIndex.
	indexFound := false.
	
	[lastStartingPoint <= (self size - aSubcollection size)] whileTrue:[
		(self at: lastStartingPoint) =( aSubcollection at: 1) ifTrue: [
			currentIndex := lastStartingPoint + 1.
			indexFound := true.
			[(currentIndex - lastStartingPoint + 1 <= aSubcollection size) & (indexFound = false) not] whileTrue:[
				(self at: currentIndex) =  (aSubcollection at: currentIndex - lastStartingPoint + 1) ifFalse: [indexFound := false].
				currentIndex := currentIndex + 1.
			].
		].
		indexFound = true ifTrue: [^lastStartingPoint] ifFalse: [lastStartingPoint := lastStartingPoint + 1].
	].

	^0! !

! SequenceableCollection methodsFor: 'operating' !
, aCollection 

	| result mySize |
	mySize := self size.
	result := self class new: mySize + aCollection size.

	1 to: mySize do: [:index |
		result at: index put: (self at: index)].

	1 to: aCollection size do: [:index |
		result at: index + mySize put: (aCollection at: index)].

	^result! !

! SequenceableCollection methodsFor: 'private' !
species

	^OrderedCollection! !

! SequenceableCollection methodsFor: 'sorting' !
sorted

	^self sortedBy: [:a :b | a < b]
! !

! SequenceableCollection methodsFor: 'sorting' !
sortedBy: aBlock
	^(Sorter new sortBlock: aBlock) sort: self! !

! SequenceableCollection methodsFor: 'testing' !
endsWith: aCollection

	aCollection size = 0 ifTrue: [^false].
	self size < aCollection size ifTrue: [^false].

	aCollection keysAndValuesDo: [:index :value |
		(self at: self size - aCollection size + index) = value
			ifFalse: [^false].
		].

	^true! !

! SequenceableCollection class methodsFor: 'instance creation' !
from: aCollection

	| result |
	result := self new: aCollection size.
	1 to: aCollection size do: [:i | result at: i put: (aCollection at: i)].
	^result! !

! SequenceableCollection class methodsFor: 'instance creation' !
new: size withAll: anObject 

	| newCollection |

	newCollection := self new: size.
	1 to: size do: [:index |
		newCollection at: index put: anObject].

	^newCollection! !

! SequenceableCollection class methodsFor: 'instance creation' !
with: anObject 

	^(self new: 1)
		at: 1 put: anObject;
		yourself! !

! SequenceableCollection class methodsFor: 'instance creation' !
with: object1 with: object2 

	^(self new: 2)
		at: 1 put: object1;
		at: 2 put: object2;
		yourself! !

! SequenceableCollection class methodsFor: 'instance creation' !
with: object1 with: object2 with: object3 

	^(self new: 3)
		at: 1 put: object1;
		at: 2 put: object2;
		at: 3 put: object3;
		yourself! !

! SequenceableCollection class methodsFor: 'instance creation' !
with: object1 with: object2 with: object3 with: object4 

	^(self new: 4)
		at: 1 put: object1;
		at: 2 put: object2;
		at: 3 put: object3;
		at: 4 put: object4;
		yourself! !

! ArrayedCollection class methodsFor: 'instance creation' !
withAll: aCollection

	| newCollection index |
	newCollection := self new: aCollection size.
	index := 0.
	aCollection do: [:element | newCollection at: (index := index + 1) put: element].
	^newCollection! !

! Array methodsFor: 'printing' !
printCollectionStartOn: aStream
	aStream nextPutAll: '#('! !

! Array methodsFor: 'private' !
species

	^Array! !

! Array methodsFor: 'testing' !
isArray

	^true! !

! ByteArray methodsFor: 'converting' !
asByteArray

	^self! !

! ByteArray methodsFor: 'converting' !
asString

	^ByteString withAll: self! !

! ByteArray methodsFor: 'printing' !
printCollectionEndOn: aStream
	aStream nextPut: $]! !

! ByteArray methodsFor: 'printing' !
printCollectionStartOn: aStream
	aStream nextPutAll: '#['! !

! ByteArray methodsFor: 'printing' !
printStringHex

	| stream |

	stream := WriteStream on: String new.
	stream nextPutAll: '#['.
	self do: [:each | stream nextPutAll: (each printStringRadix: 16)]
		separatedBy: [stream space].
	stream nextPut: $].
	^stream contents! !

! ByteArray class methodsFor: 'instance creation' !
newFromImageSpace: aNumber

	<primitive: 120>
	self primitiveFailed! !

! OrderedCollection methodsFor: 'accessing' !
at: aNumber 

	(aNumber between: 1 and: self size)
		ifFalse: [^self error: 'Index out of bounds'].
	^values at: aNumber + firstIndex - 1! !

! OrderedCollection methodsFor: 'accessing' !
at: index put: anObject 

	(index = (self size + 1)) ifTrue: [self add: anObject. ^anObject].

	(index between: 1 and: self size)
		ifFalse: [^self error: 'Index out of bounds'].

	values at: index + firstIndex - 1 put: anObject.
	^anObject! !

! OrderedCollection methodsFor: 'accessing' !
initializeSize: aNumber 

	firstIndex := 1.
	lastIndex := 0.
	values := Array new: aNumber! !

! OrderedCollection methodsFor: 'accessing' !
last
	^ self at: self size.! !

! OrderedCollection methodsFor: 'accessing' !
privateValues

	^values ! !

! OrderedCollection methodsFor: 'accessing' !
size

	^lastIndex - firstIndex + 1! !

! OrderedCollection methodsFor: 'adding and removing' !
add: anObject 

	(lastIndex - values size) > 1 ifTrue: [
		self error: 'OrderedCollection broken: ', values class printString.
		].

	(lastIndex := lastIndex + 1) > values size ifTrue: [self grow].
	^values at: lastIndex put: anObject.! !

! OrderedCollection methodsFor: 'adding and removing' !
add: anObject beforeIndex: index

	| insertIndex |
	(lastIndex := lastIndex + 1) > values size ifTrue: [self grow].
	insertIndex := firstIndex - 1 + index.

	lastIndex to: insertIndex + 1 by: -1 do: [:i |
		values at: i put: (values at: i - 1)].

	^values at: insertIndex put: anObject.! !

! OrderedCollection methodsFor: 'adding and removing' !
addAll: aCollection 

	aCollection do: [:each | self add: each].
	^aCollection! !

! OrderedCollection methodsFor: 'adding and removing' !
addFirst: anObject 

	(lastIndex - values size) > 1 ifTrue: [
		self error: 'OrderedCollection broken: ', values class printString.
		].

	(firstIndex := firstIndex - 1) <= 0 ifTrue: [self growFirst].
	^values at: firstIndex put: anObject.! !

! OrderedCollection methodsFor: 'adding and removing' !
grow

	| newArray |
	newArray := Array new: (values size * 2 max: 5).

	1 to: values size do: [:index |
		newArray at: index put: (values at: index)].

	values := newArray! !

! OrderedCollection methodsFor: 'adding and removing' !
growFirst

	| newArray growSize |

	growSize := self growFirstSize.
	newArray := Array new: self size + growSize.
	firstIndex := firstIndex + growSize.
	lastIndex := lastIndex + growSize.

	firstIndex + 1 to: lastIndex do: [:index |
		newArray at: index put: (values at: index - growSize)].

	values := newArray! !

! OrderedCollection methodsFor: 'adding and removing' !
growFirstSize

	^10! !

! OrderedCollection methodsFor: 'adding and removing' !
remove: object
	self size to: 1 by: -1 do: [:index | (self at: index) = object ifTrue: [self removeIndex: index]].! !

! OrderedCollection methodsFor: 'adding and removing' !
removeAllSuchThat: aBlock 

	| copy sourceIndex |
	sourceIndex := 1.
	copy := self copy.
	1 to: self size do: [:index |
		(aBlock value: (copy at: index))
			ifTrue: [self removeIndex: sourceIndex]
			ifFalse: [sourceIndex := sourceIndex + 1].
		].
	^self! !

! OrderedCollection methodsFor: 'adding and removing' !
removeFirst

	^self removeIndex: 1! !

! OrderedCollection methodsFor: 'adding and removing' !
removeIndex: removeIndex

	| index |
	index := firstIndex - 1 + removeIndex.
	[index < lastIndex]
		whileTrue: 
			[values at: index put: (values at: index+ 1).
			index := index+ 1].
	values at: lastIndex put: nil.
	lastIndex := lastIndex - 1! !

! OrderedCollection methodsFor: 'adding and removing' !
removeLast

	| element |
	lastIndex >= firstIndex ifFalse: [^nil].
	element := values at: lastIndex.
	values at: lastIndex put: nil.
	lastIndex := lastIndex - 1.
	^element! !

! OrderedCollection methodsFor: 'converting' !
asArray
	| array |
	array := Array new: (self size).
	
	1 to: self size do: [:index | array at: index put: (self at: index)].
	
	^array! !

! OrderedCollection methodsFor: 'copying' !
copy

	| copy |
	copy := self class new: self size.
	self do: [:each | copy add: each].
	^copy! !

! OrderedCollection methodsFor: 'inspecting' !
inspectorFieldAt: anInteger

	^self at: anInteger! !

! OrderedCollection methodsFor: 'inspecting' !
inspectorFields

	| indexedFields |

	indexedFields := OrderedCollection new.
	1 to: (self size min: 500) do: [:each | indexedFields add: each].
	^indexedFields ! !

! OrderedCollection methodsFor: 'operating' !
, aCollection 

	| result mySize |
	mySize := self size.
	result := self class new: mySize + aCollection size.

	self do: [:element |
		result add: element].

	aCollection do: [:element |
		result add: element].

	^result! !

! OrderedCollection class methodsFor: 'instance creation' !
new

	^self new: 10! !

! OrderedCollection class methodsFor: 'instance creation' !
new: size 

	^(self basicNew) initializeSize: size; yourself! !

! OrderedCollection class methodsFor: 'instance creation' !
with: anObject 

	^(self new: 1)
		add: anObject;
		yourself! !

! OrderedCollection class methodsFor: 'instance creation' !
with: anObject with: object2

	^(self new: 10)
		add: anObject;
		add: object2;
		yourself! !

! OrderedCollection class methodsFor: 'instance creation' !
with: anObject with: object2 with: object3

	^(self new: 10)
		add: anObject;
		add: object2;
		add: object3;
		yourself! !

! OrderedCollection class methodsFor: 'instance creation' !
with: anObject with: object2 with: object3 with: object4

	^(self new: 10)
		add: anObject;
		add: object2;
		add: object3;
		add: object4;
		yourself! !

! Set methodsFor: 'accessing' !
basicValues
	^values! !

! Set methodsFor: 'accessing' !
includes: anObject 

	| probe initialProbe |
	self isEmpty ifTrue: [^false].
	initialProbe := probe := anObject hash \\ values size + 1.
	[(values at: probe) isNil]
		whileFalse: 
			[(values at: probe)
				= anObject ifTrue: [^true].
			(probe := probe + 1) > values size ifTrue: [probe := 1].
			probe = initialProbe ifTrue: [self error: 'No nils left in set']].
	^false ! !

! Set methodsFor: 'accessing' !
size

	^numberOfElements! !

! Set methodsFor: 'adding and removing' !
add: anObject 

	| probe initialProbe |
	numberOfElements * 100 // values size > 70 ifTrue: [self grow].
	initialProbe := probe := anObject hash \\ values size + 1.
	[(values at: probe) isNil]
		whileFalse: 
			[(values at: probe)
				= anObject ifTrue: [^anObject].
			(probe := probe + 1) > values size ifTrue: [probe := 1].
			probe = initialProbe ifTrue: [self error: 'No nils left in set']].
	values at: probe put: anObject.
	numberOfElements := numberOfElements + 1.
	^anObject! !

! Set methodsFor: 'adding and removing' !
addAll: aCollection 

	aCollection do: [:each | self add: each].
	^aCollection! !

! Set methodsFor: 'adding and removing' !
grow

	| newSet |
	
	newSet := self class new: (self size * 2 max: 10).

	self do: [:each | each isNil
		ifTrue: [nil]
		ifFalse: [newSet add: each]].

	values := newSet basicValues! !

! Set methodsFor: 'enumerating' !
do: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each]]! !

! Set methodsFor: 'initialize-release' !
initialize: size 

	values := Array new: size.
	numberOfElements := 0! !

! Set methodsFor: 'private' !
species

	^Set! !

! Set methodsFor: 'removing' !
remove: anObject 

	^self remove: anObject ifAbsent: [self error: 'Object not found in set']! !

! Set methodsFor: 'removing' !
remove: anObject ifAbsent: aBlock

	| probe initialProbe valuesToReHash rehashProbe |
	initialProbe := probe := anObject hash \\ values size + 1.

	[(values at: probe) = anObject]
		whileFalse: 
			[(values at: probe) isNil ifTrue: [
				aBlock value.
				^nil].
			(probe := probe + 1) > values size ifTrue: [probe := 1].
			probe = initialProbe ifTrue: [self error: 'No nils left in set'. ^nil]].

	values at: probe put: nil.
	numberOfElements := numberOfElements - 1.

	valuesToReHash := OrderedCollection new.
	(rehashProbe := probe + 1) > values size ifTrue: [rehashProbe := 1].
	
	[(values at: rehashProbe) isNil]
		whileFalse: 
			[valuesToReHash add: (values at: rehashProbe).
			values at: rehashProbe put: nil.
			numberOfElements := numberOfElements - 1.
			(rehashProbe := rehashProbe + 1) > values size ifTrue: [rehashProbe := 1].
			rehashProbe = initialProbe ifTrue: [self error: 'No nils left in set'. ^nil]].

	self addAll: valuesToReHash.

	^anObject! !

! Set methodsFor: 'repairing' !
recomputeTally
	| tally |
	tally := 0.
	self do: [:each | tally := tally + 1].
	numberOfElements := tally! !

! Set class methodsFor: 'instance creation' !
new

	^super new initialize: 10! !

! Set class methodsFor: 'instance creation' !
new: size 

	^super new initialize: (size max: 10)! !

! SmallInteger methodsFor: 'accessing' !
basicAt: aNumber

	^self ! !

! SmallInteger methodsFor: 'arithmetic' !
<< aNumber

	^self bitShift: aNumber! !

! SmallInteger methodsFor: 'arithmetic' !
>> aNumber

	^self bitShift: aNumber negated! !

! SmallInteger methodsFor: 'arithmetic' !
\\ aNumber 

	| remainder |
	remainder := self rem: aNumber.
	remainder < 0 ifTrue: [^remainder + aNumber].
	^remainder
  ! !

! SmallInteger methodsFor: 'arithmetic' !
asFloat

	<primitive: 13>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
bitAnd: aNumber

	<primitive: 90>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
bitInvert

	<primitive: 93>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
bitOr: aNumber

	<primitive: 91>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
bitShift: aNumber

	<primitive: 14>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
bitXOr: aNumber

	<primitive: 92>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
bitXor: aNumber

	<primitive: 92>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
divideWithRemainderBy: aNumber

	^self asLargeInteger divideWithRemainderBy: aNumber ! !

! SmallInteger methodsFor: 'arithmetic' !
leftRotate32: aNumber

	| temp lowerBits upperBits result masks |

	masks := #(2147483647 1073741823 536870911 268435455 134217727 67108863 33554431 16777215 8388607 4194303 2097151 1048575 524287 262143 131071 65535 32767 16383 8191 4095 2047 1023 511 255 127 63 31 15 7 3 1).

	temp := self \\ 4294967296.
	lowerBits := temp bitShift: aNumber - 32.
	upperBits := temp bitAnd: (masks at: aNumber).
	result := ((upperBits bitShift: aNumber) + lowerBits).
	^result! !

! SmallInteger methodsFor: 'arithmetic' !
mod: aNumber 

	^self rem: aNumber! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveDivide: aNumber 

	<primitive: 10>
	self primitiveFailed ! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveGreaterThan: aNumber 

	<primitive: 4>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveGreaterThanOrEqualTo: aNumber 

	<primitive: 6>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveLessThan: aNumber 

	<primitive: 3>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveLessThanOrEqualTo: aNumber

	<primitive: 5>
	^self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveMinus: aNumber 

	<primitive: 2>
	self primitiveFailed! !

! SmallInteger methodsFor: 'arithmetic' !
primitivePlus: aNumber 

	<primitive: 1>
	self primitiveFailed ! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveQuo: aNumber 

	<primitive: 12>
	self primitiveFailed ! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveRem: aNumber 

	<primitive: 11>
	self primitiveFailed ! !

! SmallInteger methodsFor: 'arithmetic' !
primitiveTimes: aNumber 

	<primitive: 9>
	self primitiveFailed ! !

! SmallInteger methodsFor: 'basicSize' !
basicSize
	^0 ! !

! SmallInteger methodsFor: 'coercing' !
coerceFloat: aFloat

	^aFloat ! !

! SmallInteger methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction ! !

! SmallInteger methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger! !

! SmallInteger methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger ! !

! SmallInteger methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceSmallInteger: self ! !

! SmallInteger methodsFor: 'coercing' !
kind

	^#SmallInteger ! !

! SmallInteger methodsFor: 'comparing' !
primitiveEqualTo: anObject 

	<primitive: 7>
	^false! !

! SmallInteger methodsFor: 'comparing' !
primitiveNotEqualTo: t1 

	<primitive: 8>
	^true! !

! SmallInteger methodsFor: 'large integer support' !
asLargeInteger

	<primitive: 20>
	self primitiveFailed
 ! !

! SmallInteger methodsFor: 'large integer support' !
integerAt: aNumber

	aNumber = 1 ifTrue: [^self abs].
	^0
! !

! SmallInteger methodsFor: 'large integer support' !
reduce

	^self! !

! SmallInteger class methodsFor: 'values' !
maxVal
	^1152921504606846975! !

! SmallInteger class methodsFor: 'values' !
minVal
	^-1152921504606846976! !

! Socket methodsFor: 'accessing' !
handle

	^handle! !

! Socket methodsFor: 'accessing' !
handle: anObject

	handle := anObject.! !

! Socket methodsFor: 'accessing' !
handleBlock

	^handleBlock
! !

! Socket methodsFor: 'accessing' !
handleBlock: aBlock

	handleBlock := aBlock
! !

! Socket methodsFor: 'accessing' !
stream

	^SocketStream on: self! !

! Socket methodsFor: 'actions' !
FIONBIO

	^16r8004667e ! !

! Socket methodsFor: 'actions' !
accept

	| newHandle |

	newHandle := self basicAccept.
	newHandle isInteger ifTrue: [^newHandle].

	^self class new
		handle: newHandle;
		yourself ! !

! Socket methodsFor: 'actions' !
basicAccept

	<primitive: 202>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
bind

	<primitive: 203>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
close

	self handle isNil ifTrue: [^self].
	self primClose.
	self handle: nil.! !

! Socket methodsFor: 'actions' !
connect

	<primitive: 204>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
family: family address: address port: port

	<primitive: 201>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
getPeerName

	<primitive: 205>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
getSockName

	<primitive: 206>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
getSockOptLevel: level optionName: optionName value: value length: length

	<primitive: 207>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
ioctl: cmd data: data

	<primitive: 221>
	self primitiveFailed ! !

! Socket methodsFor: 'actions' !
listen: backlog

	<primitive: 208>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
makeNonBlocking

	self ioctl: self FIONBIO data: 1 ! !

! Socket methodsFor: 'actions' !
primClose

	<primitive: 218>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
read: buffer length: length

	<primitive: 209>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
shutdown: how

	<primitive: 216>
	self primitiveFailed! !

! Socket methodsFor: 'actions' !
write: buffer length: length

	<primitive: 212>
	self primitiveFailed! !

! Socket methodsFor: 'testing' !
isActive

	^handle notNil! !

! Socket class methodsFor: 'constants' !
af_appletalk

	^16! !

! Socket class methodsFor: 'constants' !
af_bth

	^32! !

! Socket class methodsFor: 'constants' !
af_inet

	^2! !

! Socket class methodsFor: 'constants' !
af_inet6

	^23! !

! Socket class methodsFor: 'constants' !
af_ipx

	^6! !

! Socket class methodsFor: 'constants' !
af_irda

	^26! !

! Socket class methodsFor: 'constants' !
af_netbios

	^17! !

! Socket class methodsFor: 'constants' !
af_unspec

	^0! !

! Socket class methodsFor: 'constants' !
ipproto_icmp

	^1! !

! Socket class methodsFor: 'constants' !
ipproto_icpmv6

	^58! !

! Socket class methodsFor: 'constants' !
ipproto_igmp

	^2! !

! Socket class methodsFor: 'constants' !
ipproto_rfcomm

	^3! !

! Socket class methodsFor: 'constants' !
ipproto_rm

	^113! !

! Socket class methodsFor: 'constants' !
ipproto_tcp

	^6! !

! Socket class methodsFor: 'constants' !
ipproto_udp

	^17! !

! Socket class methodsFor: 'constants' !
sock_dgram

	^2! !

! Socket class methodsFor: 'constants' !
sock_raw

	^3! !

! Socket class methodsFor: 'constants' !
sock_rdm

	^4! !

! Socket class methodsFor: 'constants' !
sock_seqpacket

	^5! !

! Socket class methodsFor: 'constants' !
sock_stream

	^1! !

! Socket class methodsFor: 'instance creation' !
basicNewInDomain: domain type: type protocol: protocol

	<primitive: 200>! !

! Socket class methodsFor: 'instance creation' !
newInDomain: domain type: type protocol: protocol

	^self new
		handle: (self basicNewInDomain: domain type: type protocol: protocol);
		yourself! !

! Socket class methodsFor: 'instance creation' !
newTCPConnection

	^self
		newInDomain: self af_inet
		type: self sock_stream
		protocol: 0 ! !

! Socket class methodsFor: 'primitives' !
poll: handles events: events revents: revents timeout: timeout

	<primitive: 219>
	self primitiveFail
! !

! SocketDispatcher methodsFor: 'accessing' !
events

	^events! !

! SocketDispatcher methodsFor: 'accessing' !
events: anArray

	events := anArray! !

! SocketDispatcher methodsFor: 'accessing' !
handlers

	^handlers! !

! SocketDispatcher methodsFor: 'accessing' !
handlers: anArray

	handlers := anArray! !

! SocketDispatcher methodsFor: 'accessing' !
revents

	^revents! !

! SocketDispatcher methodsFor: 'accessing' !
revents: anArray

	revents := anArray! !

! SocketDispatcher methodsFor: 'accessing' !
running

	^running! !

! SocketDispatcher methodsFor: 'accessing' !
running: aBoolean

	running := aBoolean! !

! SocketDispatcher methodsFor: 'accessing' !
socketHandles

	^socketHandles! !

! SocketDispatcher methodsFor: 'accessing' !
socketHandles: anArray

	socketHandles := anArray! !

! SocketDispatcher methodsFor: 'accessing' !
timeoutHandler

	^timeoutHandler! !

! SocketDispatcher methodsFor: 'accessing' !
timeoutHandler: aHandler

	timeoutHandler := aHandler! !

! SocketDispatcher methodsFor: 'accessing' !
timeoutInterval

	^timeoutInterval! !

! SocketDispatcher methodsFor: 'accessing' !
timeoutInterval: aNumber

	timeoutInterval := aNumber! !

! SocketDispatcher methodsFor: 'handlers' !
addHandler: aSocketHandler

	aSocketHandler dispatcher: self.
	self handlers add: aSocketHandler.
	aSocketHandler startup
 ! !

! SocketDispatcher methodsFor: 'handlers' !
removeHandler: aSocketHandler

	(self handlers includes: aSocketHandler) ifFalse: [^self].

	aSocketHandler shutdown.
	self handlers remove: aSocketHandler! !

! SocketDispatcher methodsFor: 'handlers' !
shutdown

	self handlers copy do: [:each | self removeHandler: each].
	running := false.
 ! !

! SocketDispatcher methodsFor: 'initializing' !
initialize

	super initialize.
	self
		handlers: OrderedCollection new;
		running: true;
		timeoutInterval: 5000;
		yourself ! !

! SocketDispatcher methodsFor: 'polling' !
POLLHUP

	^16! !

! SocketDispatcher methodsFor: 'polling' !
POLLIN

	^1 ! !

! SocketDispatcher methodsFor: 'polling' !
poll

	self setupPollStructures.

	^Socket
		poll: self socketHandles asArray
		events: self events asArray
		revents: self revents asArray
		timeout: self timeoutInterval
 ! !

! SocketDispatcher methodsFor: 'polling' !
setupPollStructures

	self
		socketHandles: (self handlers collect: [:each | each socket handle]) asArray;
		events: (Array new: self socketHandles size withAll: self POLLIN);
		revents: (Array new: self socketHandles size withAll: 0) ! !

! SocketDispatcher methodsFor: 'polling' !
startPollLoop

	[self running] whileTrue: [
		| result |
		result := self poll.
		result = 0
			ifTrue: [self timeoutHandler isNil ifFalse: [self timeoutHandler handle]]
			ifFalse: [
				result < 0 ifTrue: [^self error: 'poll loop error: ', result printString].
				self revents keysAndValuesDo: [:index :value |
					(value bitAnd: self POLLHUP) = self POLLHUP ifTrue: [(self handlers at: index) socket close. (self handlers at: index) closeIfNeeded].
					(value bitAnd: self POLLIN) = self POLLIN ifTrue: [(self handlers at: index) handle] ] ] ]
  ! !

! SocketHandler methodsFor: 'accessing' !
dispatcher

	^dispatcher ! !

! SocketHandler methodsFor: 'accessing' !
dispatcher: aDispatcher

	dispatcher := aDispatcher ! !

! SocketHandler methodsFor: 'accessing' !
socket

	^socket! !

! SocketHandler methodsFor: 'accessing' !
socket: aSocket

	socket := aSocket! !

! SocketHandler methodsFor: 'handling' !
closeIfNeeded

	(self socket isActive not and: [self dispatcher notNil])
		ifTrue: [self dispatcher removeHandler: self]! !

! SocketHandler methodsFor: 'handling' !
handle

	self subclassResponsibility! !

! SocketHandler methodsFor: 'handling' !
shutdown
 
	self socket isNil ifFalse: [self socket close]
! !

! SocketHandler methodsFor: 'handling' !
startup
 ! !

! SocketHandler methodsFor: 'initializing' !
initialize

	 ! !

! SocketHandler class methodsFor: 'instance creation' !
new

	^super new initialize; yourself ! !

! SocketHandler class methodsFor: 'instance creation' !
startupOn: aSocket


	^self new
		socket: aSocket;
		yourself! !

! SocketAcceptHandler methodsFor: 'accessing' !
clientHandler

	^clientHandler! !

! SocketAcceptHandler methodsFor: 'accessing' !
clientHandler: aHandler

	clientHandler := aHandler! !

! SocketAcceptHandler methodsFor: 'accessing' !
portNumber

	^portNumber! !

! SocketAcceptHandler methodsFor: 'accessing' !
portNumber: aNumber

	portNumber := aNumber! !

! SocketAcceptHandler methodsFor: 'handling' !
handle

	| result |

	result := self socket accept.
	result isInteger ifTrue: [
		self log: 'Socket accept error: ', result printString.
		^self].

	self dispatcher
		addHandler: (self clientHandler startupOn: result)


  ! !

! SocketAcceptHandler methodsFor: 'handling' !
shutdown

	self socket close ! !

! SocketAcceptHandler methodsFor: 'handling' !
startup

	self socket: (Socket newTCPConnection	
		family: Socket af_inet address: 0 port: self portNumber;
		bind;
		listen: 10;
		makeNonBlocking;
		yourself).
! !

! SocketLauncher methodsFor: 'accessing' !
commandHandlerClass

	^commandHandlerClass! !

! SocketLauncher methodsFor: 'accessing' !
commandHandlerClass: aClass

	commandHandlerClass := aClass! !

! SocketLauncher methodsFor: 'accessing' !
screenHandlerClass

	^screenHandlerClass! !

! SocketLauncher methodsFor: 'accessing' !
screenHandlerClass: aClass

	screenHandlerClass := aClass! !

! SocketLauncher methodsFor: 'accessing' !
startupReceiver

	^startupReceiver! !

! SocketLauncher methodsFor: 'accessing' !
startupReceiver: anObject

	startupReceiver := anObject! !

! SocketLauncher methodsFor: 'accessing' !
startupSelector

	^startupSelector! !

! SocketLauncher methodsFor: 'accessing' !
startupSelector: aSymbol

	startupSelector := aSymbol! !

! SocketLauncher methodsFor: 'startup' !
startupOn: aSocket

	^self screenHandlerClass new
		socket: aSocket;
		commandHandler: self commandHandlerClass new;
		startupReceiver: self startupReceiver;
		startupSelector: self startupSelector;
		yourself
		! !

! SocketTimeoutHandler methodsFor: 'accessing' !
timeoutBlock

	^timeoutBlock! !

! SocketTimeoutHandler methodsFor: 'accessing' !
timeoutBlock: aBlock

	timeoutBlock := aBlock! !

! SocketTimeoutHandler methodsFor: 'handling' !
handle

	self timeoutBlock value! !

! SocketUIScreenHandler methodsFor: 'accessing' !
commandHandler

	^commandHandler ! !

! SocketUIScreenHandler methodsFor: 'accessing' !
commandHandler: aCommandHandler

	commandHandler := aCommandHandler ! !

! SocketUIScreenHandler methodsFor: 'accessing' !
socketState

	^socketState! !

! SocketUIScreenHandler methodsFor: 'accessing' !
socketState: aSymbol

	socketState := aSymbol! !

! SocketUIScreenHandler methodsFor: 'accessing' !
startupReceiver

	^startupReceiver! !

! SocketUIScreenHandler methodsFor: 'accessing' !
startupReceiver: anObject

	startupReceiver := anObject! !

! SocketUIScreenHandler methodsFor: 'accessing' !
startupSelector

	^startupSelector! !

! SocketUIScreenHandler methodsFor: 'accessing' !
startupSelector: aSymbol

	startupSelector := aSymbol! !

! SocketUIScreenHandler methodsFor: 'accessing' !
uiScreen

	^uiScreen! !

! SocketUIScreenHandler methodsFor: 'accessing' !
uiScreen: aUIScreen

	uiScreen := aUIScreen! !

! SocketUIScreenHandler methodsFor: 'accessing' !
webSocket

	^webSocket! !

! SocketUIScreenHandler methodsFor: 'accessing' !
webSocket: aWebSocket

	webSocket := aWebSocket! !

! SocketUIScreenHandler methodsFor: 'handling' !
handle

	self withMyUIScreenDo: [
		| message |
		self socketState = #connecting ifTrue: [^self handleWebSocketConnection].
		message := self webSocket readContentMessage.
		message isNil
			ifTrue: [self socket close]
			ifFalse: [self processMessage: message]].

	self closeIfNeeded
 ! !

! SocketUIScreenHandler methodsFor: 'handling' !
handleWebSocketConnection

	self webSocket processConnectionMessage.
	self socketState: #connected.

	(self startupReceiver notNil and: [self startupSelector notNil]) ifTrue: [
		self withMyUIScreenDo: [self startupReceiver perform: self startupSelector]].

	self closeIfNeeded
! !

! SocketUIScreenHandler methodsFor: 'handling' !
processMessage: aMessage

	Error
		try: [
			self commandHandler processMessage: aMessage onWebSocket: self webSocket]
		catch: [:ex |
			Debugger openOn: thisContext message: ex message.
			ex return: true]
		finally: nil.
! !

! SocketUIScreenHandler methodsFor: 'handling' !
startup

	webSocket := WebSocket new.

	uiScreen := UIScreen new
		webSocket: webSocket;
		yourself.

	webSocket
		socket: self socket;
		startupConnection;
		yourself.
! !

! SocketUIScreenHandler methodsFor: 'handling' !
withMyUIScreenDo: aBlock

	| oldScreen |
	oldScreen := Smalltalk at: #CurrentScreen.
	Smalltalk at: #CurrentScreen put: self uiScreen.
	aBlock ensure: [Smalltalk at: #CurrentScreen put: oldScreen]
 ! !

! SocketUIScreenHandler methodsFor: 'initializing' !
initialize

	super initialize.
	self socketState: #connecting

! !

! Sorter methodsFor: 'accessing' !
partition: aCollection from: start to: end

	| pivotValue i j |

	pivotValue := aCollection at: end.
	(sortBlock value: pivotValue value: pivotValue) ifTrue: [^self partitionInclusive: aCollection from: start to: end].

	i := start.
	j := end.

	[
		"Find the index i of the first element that's out of order.  If none, then i = j."
		[
		i < j and: [sortBlock value: (aCollection at: i) value: pivotValue]] whileTrue: [i := i + 1].
	
		i = j ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifTrue: [^j + 1 min: end].
			^j].
	
		"Find the index j of the last element that's out of order.  If none, then j = i."
		[j > i and: [sortBlock value: pivotValue value: (aCollection at: j)]] whileTrue: [j := j - 1].
		j = i ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifTrue: [^j + 1 min: end].
			^j].

		self swap: aCollection from: i to: j.

			i := i + 1
	] whileTrue: []! !

! Sorter methodsFor: 'accessing' !
sort: aCollection
	^self sort: aCollection from: 1 to: aCollection size! !

! Sorter methodsFor: 'accessing' !
sort: aCollection from: start to: end

	| centerIndex partitionsToSort |

	start >= end ifTrue: [^aCollection].

	partitionsToSort := OrderedCollection new
		add: (Array with: start with: end);
		yourself.

	[partitionsToSort isEmpty] whileFalse: [
		| partition partitionStart partitionEnd |
		
		partition := partitionsToSort removeLast.
		partitionStart := partition first.
		partitionEnd := partition last.
		partition := nil.
		
		centerIndex := self partition: aCollection from: partitionStart to: partitionEnd.
		"centerIndex is the index of the first element where the block evaluates to true"
		
		centerIndex - 1 > partitionStart ifTrue: [
			partitionsToSort add: (Array with: partitionStart with: centerIndex - 1)].
		centerIndex < partitionEnd ifTrue: [
			partitionsToSort add: (Array with: centerIndex with: partitionEnd)]].
	
	partitionsToSort := nil.
	^aCollection
! !

! Sorter methodsFor: 'accessing' !
sortBlock
	^sortBlock! !

! Sorter methodsFor: 'accessing' !
sortBlock: aBlock
	sortBlock := aBlock! !

! Sorter methodsFor: 'sorting' !
partitionInclusive: aCollection from: start to: end

	| pivotValue i j |

	pivotValue := aCollection at: end.

	i := start.
	j := end.

	[
		"Find the index i of the first element that's out of order.  If none, then i = j."
		[
		i < j and: [(sortBlock value: pivotValue value: (aCollection at: i)) not]] whileTrue: [i := i + 1].	
		i = j ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifFalse: [^j + 1 min: end].
			^j].
	
		"Find the index j of the last element that's out of order.  If none, then j = i."
		[j > i and: [(sortBlock value: (aCollection at: j) value: pivotValue) not]] whileTrue: [j := j - 1].
		j = i ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifFalse: [^j + 1 min: end].
			^j].

		self swap: aCollection from: i to: j.

			i := i + 1
	] whileTrue: []! !

! Sorter methodsFor: 'sorting' !
swap: aCollection from: i to: j

	| temp |
	temp :=  aCollection at: i.
	aCollection at: i put: (aCollection at: j).
	aCollection at: j put: temp! !

! Stream methodsFor: 'accessing' !
readLimit

	^readLimit! !

! Stream methodsFor: 'accessing' !
readLimit: aNumber 

	readLimit := aNumber! !

! Stream methodsFor: 'positioning' !
position

	^position! !

! Stream methodsFor: 'positioning' !
position: aNumber 

	position := aNumber! !

! Stream methodsFor: 'positioning' !
skip: aNumber 

	((position := position + aNumber) < 0 or: [position > self readLimit])
		ifTrue: [self error: 'Position out of bounds']! !

! InternalStream methodsFor: 'accessing' !
collection

	^collection! !

! InternalStream methodsFor: 'accessing' !
collection: aCollection 

	readLimit := (collection := aCollection) size! !

! InternalStream methodsFor: 'initialize-release' !
initialize

	self reset! !

! InternalStream methodsFor: 'initialize-release' !
reset

	position := 0! !

! InternalStream class methodsFor: 'instance creation' !
new

	^super new initialize! !

! InternalStream class methodsFor: 'instance creation' !
on: aCollection 

	^self new
		collection: aCollection;
		yourself! !

! ReadStream methodsFor: 'accessing' !
atEnd

	^position >= self readLimit! !

! ReadStream methodsFor: 'accessing' !
next

	position >= self readLimit ifTrue: [self error: 'Read past end of stream'].
	position := position + 1.
	^collection at: position! !

! ReadStream methodsFor: 'accessing' !
next: aNumber

	| stream |
	
	stream := WriteStream on: self collection class new.
	aNumber timesRepeat: [
		| next |
		next := self next.
		next isNil ifTrue: [^nil].
		stream nextPut: next].

	^stream contents! !

! ReadStream methodsFor: 'accessing' !
nextAvailable: aNumber

	| stream |
	
	stream := WriteStream on: self collection class new.
	aNumber timesRepeat: [
		self atEnd ifFalse: [stream nextPut: self next]].

	^stream contents! !

! ReadStream methodsFor: 'accessing' !
peek

	| item |

	self atEnd ifTrue: [^nil].
	item := self next.
	self skip: -1.
	^item! !

! ReadStream methodsFor: 'accessing' !
previous

	| item |

	position = 0 ifTrue: [^nil].
	self skip: -1.
	item := self next.
	^item  ! !

! ReadStream methodsFor: 'accessing' !
throughAll: aCollection

	| contents |

	contents := OrderedCollection new.

	[self atEnd] whileFalse: [
		contents add: self next.
		(contents endsWith: aCollection) ifTrue: [
			^collection class withAll: contents]].

	^contents! !

! ReadStream methodsFor: 'accessing' !
upTo: anObject

	| stream |

	stream := WriteStream on: (collection class new: collection size).

	[self atEnd not and: [self peek ~= anObject]]
		whileTrue: [stream nextPut: self next].

	self atEnd ifFalse: [self next].

	^stream contents! !

! ReadStream methodsFor: 'accessing' !
upToAll: aCollection

	| found |

	found := self throughAll: aCollection.
	^found copyFrom: 1 to: (found size - aCollection size)! !

! ReadStream methodsFor: 'accessing' !
upToEnd

	| outStream |

	outStream := WriteStream on: (String new: 10).
	[self atEnd] whileFalse: [
		outStream nextPut: self next].

	^outStream contents! !

! ReadStream methodsFor: 'fileIn/Out' !
fileIn

	^FileinReader fileIn: self! !

! ReadStream methodsFor: 'writing' !
contents

	^collection copyFrom: 1 to: position! !

! ReadWriteStream methodsFor: 'writing' !
contents

	^collection copyFrom: 1 to: position! !

! ReadWriteStream methodsFor: 'writing' !
cr

	self nextPut: Character cr! !

! ReadWriteStream methodsFor: 'writing' !
grow

	| newCollection |
	newCollection := collection class new: (collection size * 2 max: 10).
	1 to: collection size do: [:index |
		newCollection at: index put: (collection at: index)].

	collection := newCollection! !

! ReadWriteStream methodsFor: 'writing' !
nextPut: anObject 

	position >= collection size ifTrue: [self grow].
	position := position + 1.
	collection at: position put: anObject.
	readLimit := position! !

! ReadWriteStream methodsFor: 'writing' !
nextPutAll: aCollection 

	aCollection do: [:character | self nextPut: character]! !

! ReadWriteStream methodsFor: 'writing' !
print: aStream 

	aStream printOn: self! !

! ReadWriteStream methodsFor: 'writing' !
print: anObject limit: aNumber

	anObject printOn: self limit: aNumber! !

! ReadWriteStream methodsFor: 'writing' !
space

	self nextPut: Character space! !

! ReadWriteStream methodsFor: 'writing' !
tab

	self nextPut: Character tab! !

! FileStream methodsFor: 'accessing' !
atEnd

	<primitive: 1509>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
basicNext

	self lineEndConvention notNil ifTrue: [^self lineEndConvention nextFor: self].
	^self primNext! !

! FileStream methodsFor: 'accessing' !
basicNext: aNumber

	self lineEndConvention notNil ifTrue: [^self lineEndConvention next: aNumber for: self].
	^self primNext: aNumber! !

! FileStream methodsFor: 'accessing' !
basicUpToEnd

	self lineEndConvention notNil ifTrue: [^self lineEndConvention upToEndFor: self].
	^self primUpToEnd! !

! FileStream methodsFor: 'accessing' !
binary

	self isBinary: true! !

! FileStream methodsFor: 'accessing' !
close

	<primitive: 1502>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
flush

	<primitive: 1510>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
handle

	^handle! !

! FileStream methodsFor: 'accessing' !
handle: anObject

	handle := anObject! !

! FileStream methodsFor: 'accessing' !
isBinary

	^isBinary! !

! FileStream methodsFor: 'accessing' !
isBinary: anObject

	anObject
		ifTrue: [self lineEndConvention: nil]
		ifFalse: [self lineEndConvention: LineEndConventionCRLF new].
	isBinary := anObject! !

! FileStream methodsFor: 'accessing' !
lineEndConvention
	^lineEndConvention! !

! FileStream methodsFor: 'accessing' !
lineEndConvention: aLineEndConvention
	lineEndConvention := aLineEndConvention! !

! FileStream methodsFor: 'accessing' !
next

	| result |
	
	result := self basicNext.
	^self isBinary
		ifTrue: [result]
		ifFalse: [Character value: result]! !

! FileStream methodsFor: 'accessing' !
next: aNumber

	| result |

	result := self basicNext: aNumber.
	^self isBinary ifTrue: [result asByteArray] ifFalse: [result asString]! !

! FileStream methodsFor: 'accessing' !
nextPut: anInteger

	self lineEndConvention notNil ifTrue: [^self lineEndConvention nextPut: anInteger for: self].
	^self primNextPut: anInteger! !

! FileStream methodsFor: 'accessing' !
nextPutAll: aCollection

	self lineEndConvention notNil ifTrue: [^self lineEndConvention nextPutAll: aCollection for: self].
	^self primNextPutAll: aCollection! !

! FileStream methodsFor: 'accessing' !
open: aString

	self lineEndConvention: LineEndConventionCRLF new.
	^self primOpen: aString! !

! FileStream methodsFor: 'accessing' !
open: aString mode: aNullTerminatedString

	self lineEndConvention: LineEndConventionCRLF new.
	^self primOpen: aString mode: aNullTerminatedString! !

! FileStream methodsFor: 'accessing' !
position

	<primitive: 1511>
	^self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
position: aNumber

	<primitive: 1512>
	^self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primNext

	<primitive: 1503>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primNext: aNumber

	<primitive: 1504>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primNextPut: anInteger

	<primitive: 1505>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primNextPutAll: aCollection

	<primitive: 1506>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primOpen: aString

	<primitive: 1500>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primOpen: aString mode: aNullTerminatedString

	<primitive: 1501>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primSkip: aNumber

	<primitive: 1507>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
primUpToEnd

	<primitive: 1508>
	self primitiveFailed! !

! FileStream methodsFor: 'accessing' !
skip: aNumber

	self lineEndConvention notNil ifTrue: [^self lineEndConvention skip: aNumber for: self].
	^self primSkip: aNumber! !

! FileStream methodsFor: 'accessing' !
upToEnd

	| result |

	result := self basicUpToEnd.
	^self isBinary ifTrue: [result asByteArray] ifFalse: [result asString]! !

! FileStream methodsFor: 'initialize-release' !
initialize

	super initialize.
	isBinary := false! !

! FileStream class methodsFor: 'constants' !
append

	^'ab'! !

! FileStream class methodsFor: 'constants' !
appendableRead

	^'ab+'! !

! FileStream class methodsFor: 'constants' !
overwrite

	^'wb+'! !

! FileStream class methodsFor: 'constants' !
pathDelimiterString

	^'/'! !

! FileStream class methodsFor: 'constants' !
read

	^'rb'! !

! FileStream class methodsFor: 'constants' !
writableRead

	^'rb+'! !

! FileStream class methodsFor: 'constants' !
write

	^'wb'! !

! SocketStream methodsFor: 'accessing' !
atEnd

	^false! !

! SocketStream methodsFor: 'accessing' !
bufferSize

	^1024! !

! SocketStream methodsFor: 'accessing' !
next

	internalStream atEnd ifTrue: [
		self read].
	internalStream atEnd ifTrue: [^nil].
	^internalStream next! !

! SocketStream methodsFor: 'accessing' !
peek

	internalStream atEnd ifTrue: [
		self read].
	^internalStream peek! !

! SocketStream methodsFor: 'accessing' !
read

	| byteArray length |

	byteArray := ByteArray new: self bufferSize.
	length := socket read: byteArray length: self bufferSize.
	internalStream collection: (byteArray copyFrom: 1 to: length).
	internalStream reset! !

! SocketStream methodsFor: 'accessing' !
socket

	^socket! !

! SocketStream methodsFor: 'accessing' !
socket: anObject

	socket := anObject! !

! SocketStream methodsFor: 'initialize-release' !
initialize

	super initialize.
	internalStream := ReadWriteStream on: ByteArray new.
	collection := ByteArray new! !

! SocketStream methodsFor: 'testing' !
isActive

	^self socket isActive ! !

! SocketStream methodsFor: 'writing' !
commit

	| byteArray |

	byteArray := internalStream contents.
	socket write: byteArray length: byteArray size.
	self reset! !

! SocketStream methodsFor: 'writing' !
nextPut: anObject

	internalStream nextPut: anObject! !

! SocketStream methodsFor: 'writing' !
reset

	internalStream := ReadWriteStream on: ByteArray new! !

! SocketStream class methodsFor: 'instance creation' !
on: aSocket

	^self new
		socket: aSocket;
		yourself! !

! String methodsFor: 'converting' !
asFilename

	^Filename named: self! !

! String methodsFor: 'converting' !
asLowercase

	| newString |
	newString := self class new: self size.
	1 to: self size do: [:index |
		newString at: index put: (self at: index) asLowercase].
	^newString! !

! String methodsFor: 'converting' !
asSimtalkString

	^self! !

! String methodsFor: 'converting' !
asSymbol

	^ByteSymbol intern: self! !

! String methodsFor: 'converting' !
asUppercase

	| newString |
	newString := self class new: self size.
	1 to: self size do: [:index |
		newString at: index put: (self at: index) asUppercase].
	^newString! !

! String methodsFor: 'converting' !
convertLineEndingsTo2: aSymbol

	| inStream outStream |

	inStream := self readStream.
	outStream := WriteStream on: (String new: self size).

	[inStream atEnd] whileFalse: [
		| character |
		character := inStream next.
		character = Character cr ifTrue: [(inStream atEnd not and: [inStream peek = Character lf]) ifTrue: [inStream next]].
		character = Character lf ifTrue: [(inStream atEnd not and: [inStream peek = Character cr]) ifTrue: [inStream next]].
		(character = Character cr |  (character = Character lf))
			ifTrue: [
				aSymbol = #cr ifTrue: [outStream nextPut: Character cr].
				aSymbol = #lf ifTrue: [outStream nextPut: Character lf].
				aSymbol = #crlf ifTrue: [outStream nextPut: Character cr; nextPut: Character lf]]
			ifFalse: [outStream nextPut: character]
		].

	^outStream contents! !

! String methodsFor: 'converting' !
convertLineEndingsTo: aSymbol

	| inStream outStream |

	inStream := self readStream.
	outStream := WriteStream on: (String new: self size).

	[inStream atEnd] whileFalse: [
		| character |
		character := inStream next.
		character = Character cr ifTrue: [(inStream atEnd not and: [inStream peek = Character lf]) ifTrue: [inStream next]].
		character = Character lf ifTrue: [(inStream atEnd not and: [inStream peek = Character cr]) ifTrue: [inStream next]].
		(character = Character cr |  (character = Character lf))
			ifTrue: [
				aSymbol = #cr ifTrue: [outStream nextPut: Character cr].
				aSymbol = #lf ifTrue: [outStream nextPut: Character lf].
				aSymbol = #crlf ifTrue: [outStream nextPut: Character cr; nextPut: Character lf]]
			ifFalse: [outStream nextPut: character]
		].

	^outStream contents! !

! String methodsFor: 'converting' !
crToCRLF

	| in out |
	in := self readStream.
	out := WriteStream on: (String new: self size).

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		out nextPut: character.
		character = Character cr
			ifTrue: [out nextPut: Character lf]
		].

	^out contents
! !

! String methodsFor: 'converting' !
crToLF

	| in out |
	in := self readStream.
	out := WriteStream on: (String new: self size).

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		character = Character cr
			ifTrue: [out nextPut: Character lf]
			ifFalse: [out nextPut: character]
		].

	^out contents
 ! !

! String methodsFor: 'converting' !
extractUTF8CharacterFrom: aStream

	| value |
	value := aStream next asInteger.
	(value bitAnd: 16r80) = 0 ifTrue: [^value].
	(value bitAnd: 16rE0) = 16rC0
		ifTrue: [^((value bitAnd: 16r1F) bitShift: 6) + (aStream next asInteger bitAnd: 16r3F)].
	(value bitAnd: 16rF0) = 16rE0
		ifTrue: [^((value bitAnd: 16r0F) bitShift: 12)
				+ ((aStream next asInteger bitAnd: 16r3F) bitShift: 6)
				+ (aStream next asInteger bitAnd: 16r3F)].
	(value bitAnd: 16rF8) = 16rF0
		ifTrue: [^(value bitAnd: 16r07) << 18
				+ ((aStream next asInteger bitAnd: 16r3F) bitShift: 12)
				+ ((aStream next asInteger bitAnd: 16r3F) bitShift: 6)
				+ (aStream next asInteger bitAnd: 16r3F)].

	self error: 'Invalid UTF-8 String'! !

! String methodsFor: 'converting' !
lfToCR

	| in out |
	in := self readStream.
	out := WriteStream on: (String new: self size).

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		character = Character lf
			ifTrue: [out nextPut: Character cr]
			ifFalse: [out nextPut: character]
		].

	^out contents
 ! !

! String methodsFor: 'converting' !
trimSeparators

	| firstNonSeparator lastNonSeparator |

	firstNonSeparator := self findFirst: [:each | each isSeparator not].
	firstNonSeparator = 0 ifTrue: [^''].

	lastNonSeparator := self findLast: [:each | each isSeparator not].
	lastNonSeparator < firstNonSeparator ifTrue: [^''].
	
	^self copyFrom: firstNonSeparator to: lastNonSeparator! !

! String methodsFor: 'converting' !
utf8Decode

	| decodedString stream |
	decodedString := OrderedCollection new.
	stream := self readStream.
	[stream atEnd] whileFalse: [
		decodedString add: (self extractUTF8CharacterFrom: stream).
		].

	^decodedString asArray! !

! String methodsFor: 'json' !
jsonOn: aStream

	aStream nextPut: $".
	aStream nextPutAll: ((self copyReplaceAll: '\' with: '\\') copyReplaceAll: '"' with: '\"').
	aStream nextPut: $".! !

! String methodsFor: 'manipulation' !
asByteArray

	| byteArray |
	byteArray := ByteArray new: self size.
	1 to: self size do: [:i |
		byteArray at: i put: (self at: i) asInteger].
	^byteArray! !

! String methodsFor: 'manipulation' !
asString

	^self! !

! String methodsFor: 'manipulation' !
capitalized

	^self asString copy at: 1 put: (self at: 1) asUppercase! !

! String methodsFor: 'manipulation' !
subStringFrom: i to: j

	| subString |
	i < 0 ifTrue: [^self].
	j > self size ifTrue: [^self].
	subString := self class new: (j - i) + 1.
	i to: j do: [:index |
		subString at: (index - i + 1) put: (self at: index).
	].

	^subString! !

! String methodsFor: 'manipulation' !
withCRs

	^self copyReplacing: $\ with: Character cr! !

! String methodsFor: 'printing' !
printOn: aStream 

	self printPrefixOn: aStream.

	self do: [:t2 | 
		t2 = $' ifTrue: [aStream nextPut: $'].
		aStream nextPut: t2].

	self printSuffixOn: aStream! !

! String methodsFor: 'printing' !
printPrefixOn: aStream 

	aStream nextPut: $'! !

! String methodsFor: 'printing' !
printSuffixOn: aStream 

	aStream nextPut: $'! !

! String methodsFor: 'printing' !
storeOn: aStream 

	^self printOn: aStream! !

! String methodsFor: 'testing' !
< aString

	^(self compareString: aString) = -1! !

! String methodsFor: 'testing' !
<= aString

	^(self compareString: aString) <= 0! !

! String methodsFor: 'testing' !
> aString

	^(self compareString: aString) = 1! !

! String methodsFor: 'testing' !
>= aString

	^(self compareString: aString) >= 0! !

! String methodsFor: 'testing' !
compareString: aString

	| index selfSize aStringSize|

	index := 1.
	selfSize := self size.
	aStringSize := aString size.

	[(index <= selfSize) and: [index <= aStringSize]] whileTrue: [
		| character1 character2 |
		character1 := self at: index.
		character2 := aString at: index.
		character1 < character2 ifTrue: [^-1].
		character1 > character2 ifTrue: [^1].
		index := index + 1].

	index <= selfSize ifTrue: [^1].
	index <= aStringSize ifTrue: [^-1].
	^0! !

! String methodsFor: 'testing' !
isString

	^true! !

! String methodsFor: 'utilities' !
match: aString ignoreCase: aBoolean

	! !

! String methodsFor: 'utilities' !
matches: aString

	^(StringMatcher pattern: self) match: aString! !

! String methodsFor: 'utilities' !
splitBy: aCharacter

	| tokens stream |

	tokens := OrderedCollection new.
	stream := self readStream.
	[stream atEnd] whileFalse: [
		tokens add: (stream upTo: aCharacter)].

	^tokens! !

! String methodsFor: 'utilities' !
tokensBasedOn: aCharacter

	^self splitBy: aCharacter! !

! String class methodsFor: 'instance creation' !
implementationClass

	^ByteString! !

! String class methodsFor: 'instance creation' !
new: anInteger

	^self implementationClass basicNew: anInteger! !

! ByteString methodsFor: 'accessing' !
at: index 

	<primitive: 63>
	self primitiveFailed! !

! ByteString methodsFor: 'accessing' !
at: index put: value 

	<primitive: 64>
	self primitiveFailed! !

! ByteString methodsFor: 'accessing' !
basicAt: index 

	<primitive: 63>
	self primitiveFailed! !

! ByteString methodsFor: 'accessing' !
basicAt: index put: value 

	<primitive: 64>
	self primitiveFailed! !

! ByteString methodsFor: 'converting' !
asInt

	| integer multiplier |
	multiplier := 10 raisedToInteger: self size - 1.
	integer := 0.
	1 to: self size do: [:index | 
			integer := integer + ((self at: index) asInteger - 48 * multiplier).
			multiplier := multiplier // 10].


^integer! !

! ByteString methodsFor: 'converting' !
asTwoByteString

	| newString |
	newString := TwoByteString new: self size.
	1 to: self size do: [:index |
		newString at: index put: (self at: index)].
	^newString ! !

! ByteString methodsFor: 'printing' !
printStringHex

	| stream |

	stream := WriteStream on: String new.
	stream nextPutAll: '#['.
	self do: [:each |
		stream nextPutAll: (each asInteger printStringRadix: 16);
			space].
	stream nextPut: $].
	^stream contents! !

! StringMatcher methodsFor: 'accessing' !
index

	^index! !

! StringMatcher methodsFor: 'accessing' !
index: aNumber

	index := aNumber! !

! StringMatcher methodsFor: 'accessing' !
parent

	^parent! !

! StringMatcher methodsFor: 'accessing' !
parent: aStringMatcher

	parent := aStringMatcher! !

! StringMatcher methodsFor: 'accessing' !
pattern

	^pattern! !

! StringMatcher methodsFor: 'accessing' !
pattern: aString

	pattern := aString! !

! StringMatcher methodsFor: 'accessing' !
submatchers

	^submatchers! !

! StringMatcher methodsFor: 'adding and removing' !
addSubmatcher: aStringMatcher

	self submatchers add: aStringMatcher.
	aStringMatcher parent: self
! !

! StringMatcher methodsFor: 'adding and removing' !
removeSubmatcher: aStringMatcher

	self submatchers remove: aStringMatcher
! !

! StringMatcher methodsFor: 'initializing' !
initialize

	submatchers := OrderedCollection new.
	index := 1
! !

! StringMatcher methodsFor: 'matching' !
advance

	^self index: self index + 1
! !

! StringMatcher methodsFor: 'matching' !
fail

	self parent removeSubmatcher: self! !

! StringMatcher methodsFor: 'matching' !
match: aString

	self setupSubmatchers.
	aString do: [:character |
		submatchers isEmpty ifTrue: [^false].
		submatchers copy do: [:submatcher |
			submatcher matchCharacter: character]].

	^submatchers anySatisfy: [:each | each isFinished]

! !

! StringMatcher methodsFor: 'matching' !
matchCharacter: aCharacter

	| nextPatternCharacter |
	self index > self pattern size ifTrue: [self fail. ^self].
	nextPatternCharacter := self peekPattern.
	nextPatternCharacter = $? ifTrue: [^self advance].
	nextPatternCharacter = $* ifTrue: [
		| newSubmatcher |
		newSubmatcher := self class new
			pattern: self pattern;
			index: self index + 1;
			yourself.

		self parent addSubmatcher: newSubmatcher.
		newSubmatcher matchCharacter: aCharacter.

		^self].
	nextPatternCharacter = aCharacter
		ifTrue: [self advance]
		ifFalse: [self fail]

! !

! StringMatcher methodsFor: 'matching' !
peekPattern

	^self pattern at: self index
! !

! StringMatcher methodsFor: 'matching' !
setupSubmatchers

	self addSubmatcher: (self class new
		pattern: self pattern;
		yourself)

! !

! StringMatcher methodsFor: 'testing' !
isFinished

	^(self index > pattern size) or: [
		self index = pattern size and: [self peekPattern = $*]]! !

! StringMatcher class methodsFor: 'instance creation' !
new

	^super new initialize; yourself! !

! StringMatcher class methodsFor: 'instance creation' !
pattern: aString

	^self new
		pattern: aString;
		yourself
! !

! Symbol methodsFor: 'accessing' !
numArgs

	(self allSatisfy: [:eachCharacter | eachCharacter isNonBinarySelectorCharacter]) ifFalse: [^1].
	^self occurrencesOf: $:! !

! Symbol methodsFor: 'comparing' !
= anObject

	^self == anObject! !

! Symbol methodsFor: 'comparing' !
hash

	^self identityHash! !

! Symbol methodsFor: 'converting' !
asSimTalkSymbol

	^self! !

! Symbol methodsFor: 'converting' !
asSymbol

	^self! !

! Symbol methodsFor: 'converting' !
eventKey

	^self! !

! Symbol methodsFor: 'instance creation' !
isSymbol

	^true! !

! Symbol methodsFor: 'operating' !
, aCollection 

	^self asString , aCollection! !

! Symbol methodsFor: 'printing' !
printOn: aStream 

	(self allSatisfy: [:each | each isAlphaNumeric | (each = $_)])
		ifTrue: [aStream nextPut: $#; nextPutAll: self. ^self].
	super printOn: aStream! !

! Symbol methodsFor: 'printing' !
printPrefixOn: aStream 

	aStream nextPutAll: '#'''! !

! Symbol class methodsFor: 'instance creation' !
implementationClass

	^ByteSymbol! !

! ByteSymbol methodsFor: 'accessing' !
at: index 

	<primitive: 63>
	self primitiveFailed! !

! ByteSymbol methodsFor: 'converting' !
asString

	^ByteString from: self! !

! ByteSymbol class methodsFor: 'instance creation' !
intern: aString

	^self symbolTable at: aString  asString asSimtalkString ifAbsentPut: [
		self from: aString]! !

! ByteSymbol class methodsFor: 'symbol table' !
garbageCollectSymbolTable

	| symbols count |
	symbols := self symbolTable asArray.
	count := 0.

	symbols do: [:each |
		| references |
		self log: each.
		references := each allOwners size.
		self log: each , ' -> ', references printString.
		references = 4 ifTrue: [
			self symbolTable removeKey: each asString].
		count := count + 1.
		count = 20 ifTrue: [
			BeagleSystem globalGarbageCollect.
			count := 0] ]! !

! ByteSymbol class methodsFor: 'symbol table' !
symbolTable

	<primitive: 551>
	self primitiveFailed! !

! Time methodsFor: 'FormattedStrings' !
showHourlyCountdown
		| minutePadder secondPadder |
		self minutes < 10 ifTrue: [minutePadder := '0'] ifFalse: [minutePadder := ''].
		(self totalSeconds \\ 60) < 10 ifTrue: [secondPadder := '0'] ifFalse: [secondPadder := ''].
		
		^minutePadder , self minutes , ':' , secondPadder , (self totalSeconds \\ 60) printString! !

! Time methodsFor: 'accessing' !
hours
	^self totalHours \\ 24! !

! Time methodsFor: 'accessing' !
milliseconds

	^milliseconds! !

! Time methodsFor: 'accessing' !
milliseconds: aNumber

	milliseconds := aNumber! !

! Time methodsFor: 'accessing' !
minutes
	^self totalMinutes \\ 60! !

! Time methodsFor: 'accessing' !
seconds
	^self totalSeconds \\ 60! !

! Time methodsFor: 'accessing' !
setMilliseconds: aNumber

	milliseconds := aNumber! !

! Time methodsFor: 'accessing' !
totalHours
	^self totalMinutes // 60! !

! Time methodsFor: 'accessing' !
totalMilliseconds

	^milliseconds! !

! Time methodsFor: 'accessing' !
totalMinutes
	^self totalSeconds // 60! !

! Time methodsFor: 'accessing' !
totalSeconds
	^self totalMilliseconds // 1000! !

! Time methodsFor: 'arithmetic' !
- aTime 

	^(self class new) setMilliseconds: self totalMilliseconds - aTime totalMilliseconds; yourself! !

! Time methodsFor: 'comparing' !
< value

	^self milliseconds < value milliseconds! !

! Time methodsFor: 'comparing' !
<= value

	^self milliseconds <= value milliseconds! !

! Time methodsFor: 'comparing' !
> value

	^self milliseconds > value milliseconds! !

! Time methodsFor: 'comparing' !
>= value

	^self milliseconds >= value milliseconds! !

! Time methodsFor: 'printing' !
printOn: aStream 

	| hours minutes seconds fractionalMilliseconds remainder |
	fractionalMilliseconds := milliseconds \\ 1000.
	seconds := (remainder := milliseconds // 1000) \\ 60.
	minutes := (remainder := remainder // 60) \\ 60.
	hours := remainder // 60.

	aStream print: hours; nextPut: $:.
	minutes < 10 ifTrue: [aStream nextPut: $0].

	aStream print: minutes; nextPut: $:.
	seconds < 10 ifTrue: [aStream nextPut: $0].

	aStream print: seconds; nextPut: $..
	fractionalMilliseconds < 100 ifTrue: [aStream nextPut: $0].
	fractionalMilliseconds < 10 ifTrue: [aStream nextPut: $0].
	aStream print: fractionalMilliseconds! !

! Time methodsFor: 'printing' !
writeBinaryOn: aStream

	aStream nextPutInt32: self milliseconds! !

! Time class methodsFor: 'instance creation' !
fromSeconds: aNumber

	^(self new) setMilliseconds: aNumber * 1000; yourself! !

! Time class methodsFor: 'instance creation' !
millisecondClockValue

	<primitive: 408>
	^self! !

! Time class methodsFor: 'instance creation' !
millisecondsToRun: aBlock

	| start end |
	start := self millisecondClockValue.
	aBlock value.
	end := self millisecondClockValue.
	^end - start
! !

! Time class methodsFor: 'instance creation' !
now

	^(self new) setMilliseconds: self millisecondClockValue; yourself! !

! Time class methodsFor: 'instance creation' !
readBinaryFrom: 	aStream

	^self new
		milliseconds: aStream nextInt32;
		yourself! !

! True methodsFor: 'accessing' !
& aBoolean 

	^aBoolean! !

! True methodsFor: 'accessing' !
and: aBlock 

	^aBlock value! !

! True methodsFor: 'accessing' !
ifFalse: aBlock 

	^nil! !

! True methodsFor: 'accessing' !
ifFalse: falseBlock ifTrue: trueBlock 

	^trueBlock value! !

! True methodsFor: 'accessing' !
ifTrue: aBlock 

	^aBlock value! !

! True methodsFor: 'accessing' !
ifTrue: trueBlock ifFalse: falseBlock 

	^trueBlock value! !

! True methodsFor: 'accessing' !
not

	^false! !

! True methodsFor: 'accessing' !
or: aBlock 

	^true! !

! True methodsFor: 'accessing' !
| aBoolean

	^true! !

! True methodsFor: 'printing' !
printOn: aStream 

	aStream nextPutAll: 'true'! !

! TwoByteString methodsFor: 'accessing' !
at: index

	^Character value: (self basicAt: index - 1 * 2 + 1) * 256 + (self basicAt: index - 1 * 2 + 2)! !

! TwoByteString methodsFor: 'accessing' !
at: index put: aCharacter

	self
		basicAt: index - 1 * 2 + 1 put: aCharacter asInteger // 256;
		basicAt: index - 1 * 2 + 2 put: aCharacter asInteger \\ 256 ! !

! TwoByteString methodsFor: 'accessing' !
size

	^self basicSize // 2 ! !

! TwoByteString methodsFor: 'converting' !
asTwoByteString

	^self
 ! !

! TwoByteString class methodsFor: 'instance creation' !
new: anInteger
 
	| newString |
	newString := self basicNew: anInteger * 2.
	1 to: newString basicSize do: [:i |
		newString basicAt: i put: 0].
	^newString! !

! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitSymbol;
		buildClass;
		newClass! !

! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classVariableNames: classVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitSymbol;
		buildClass;
		newClass! !

! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray

	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol! !

! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol! !

! UndefinedObject methodsFor: 'controlling' !
ifNil: aBlock 

	^aBlock value! !

! UndefinedObject methodsFor: 'controlling' !
ifNil: nilBlock ifNotNil: notNilBlock 

	^nilBlock value! !

! UndefinedObject methodsFor: 'controlling' !
ifNotNil: aBlock 

	^self! !

! UndefinedObject methodsFor: 'creating' !
modifyClass: existingClass
		flags: newFlags
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment! !

! UndefinedObject methodsFor: 'printing' !
printOn: aStream 

	aStream nextPutAll: 'nil'! !

! UndefinedObject methodsFor: 'testing' !
isNil

	^true! !

! UndefinedObject methodsFor: 'testing' !
notNil

	^false! !

! UninterpretedBytes methodsFor: 'accessing' !
bitSequenceFrom: i to: j
"Allows to reason about specific bits in an array of UninterpretedBytes. For example, the numeric value of only the first 3 bits."

	| total |
	total := 0.
	
	i to: j do: [:index | | byte mask |
		byte := self at: (index // 8) + 1.
		"System log: 'accessing byte: ' , byte printString , ' from byte index: ' , ((index // 8) + 1) printString , ' in search for the ' , index printString , 'th bit, using (' , index printString , ' / 8) + 1'."
		mask :=  1.
		byte := byte >> (7 - (index \\ 8)).
		byte := byte bitAnd: mask.
		total := total bitOr: (byte << (j - index))
		
	].

	^total! !

! UninterpretedBytes methodsFor: 'accessing' !
doubleAt: index put: aDouble 

	1 to: 8 do: [:i |
		self at: index + i put: (aDouble at: i)]! !

! UninterpretedBytes methodsFor: 'accessing' !
floatAt: index

	<primitive: 548>
	| myFloat |
	myFloat := Float new.
	1 to: 4 do: [:i |
		myFloat at: i put: (self at: index + i)].
	
	^myFloat! !

! UninterpretedBytes methodsFor: 'accessing' !
floatAt: index put: aFloat

	<primitive: 549>
	1 to: 4 do: [:i |
		self at: index + i put: (aFloat at: i)]! !

! UninterpretedBytes methodsFor: 'accessing' !
size

	^self basicSize! !

! UninterpretedBytes methodsFor: 'accessing' !
uint32At: offset 

	| total |
	total := 0.
	1 to: 4 do: [:index |
		total := total * 256 + (self at: offset + (5 - index))].

	^total! !

! UninterpretedBytes methodsFor: 'accessing' !
uint32At: index put: a32bitUnsignedInteger

	| remainder |
	remainder := a32bitUnsignedInteger.

	1 to: 4 do: [:i |
		self at: index + i put: (remainder \\ 256).
		remainder := remainder // 256].! !

! UninterpretedBytes methodsFor: 'accessing' !
uint64At: offset 

	| total |
	total := 0.
	1 to: 8 do: [:index |
		total := total * 256 + (self at: offset + (9 - index))].

	^total! !

! UninterpretedBytes methodsFor: 'accessing' !
uint64At: index put: a64bitUnsignedInteger
	| remainder |
	remainder := a64bitUnsignedInteger.
	1 to: 8 do: [:i |
		self at: index + i put: (remainder \\ 256). remainder := remainder // 256]! !

! UninterpretedBytes methodsFor: 'converting' !
asByteString
	| byteString |
	byteString := ByteString new: self size.
	
	1 to: self size do: [:index |
	byteString at: index put: (Character value: (self at: index)).
	].
	^byteString.! !

! UninterpretedBytes methodsFor: 'converting' !
asString

	^self asByteString! !

! UninterpretedBytes methodsFor: 'converting' !
floatArrayPrintString

	| stream |
	stream := WriteStream on: (ByteString new: 20).
	stream nextPut: ${.
	0 to: self size - 1 by: 4 do: [:i |
		(self floatAt: i) printOn: stream.
		stream space].
	stream nextPut: $}.
	^stream contents! !

! UninterpretedBytes methodsFor: 'converting' !
hexString
	| stream |
	stream := WriteStream on: (String new: 20).
	1 to: self size do: [:i |
		(self at: i) printHexOn: stream padZeros: 2].
	^stream contents! !

! UninterpretedBytes methodsFor: 'copying' !
copy

	<primitive: 550>
	self primitiveFailed! !

! UninterpretedBytes methodsFor: 'generating' !
randomize

	| randomness |
	randomness := Random new.
	
	1 to: self size do: [:index | self at: index put: randomness nextSeed \\ 256]! !

! Vector methodsFor: 'accessing' !
+ aVector

	^self class
		x: self x + aVector x
		y: self y + aVector y
		z: self z + aVector z
		w: self defaultW! !

! Vector methodsFor: 'accessing' !
- aVector

	^self class
		x: self x - aVector x
		y: self y - aVector y
		z: self z - aVector z
		w: self defaultW! !

! Vector methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber

	^elements at: rowNumber! !

! Vector methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber put: value

	elements at: rowNumber put: value! !

! Vector methodsFor: 'accessing' !
columns

	^1! !

! Vector methodsFor: 'accessing' !
defaultW

	^0.0! !

! Vector methodsFor: 'accessing' !
elements

	^elements! !

! Vector methodsFor: 'accessing' !
elements: anArray

	elements := anArray! !

! Vector methodsFor: 'accessing' !
printOn: aStream

	aStream nextPut: $<.

	elements do: [:each |
		each printOn: aStream.
		aStream space].

	aStream skip: -1.
	aStream nextPut: $>! !

! Vector methodsFor: 'accessing' !
rows

	^elements size! !

! Vector methodsFor: 'accessing' !
w

	^elements at: 4! !

! Vector methodsFor: 'accessing' !
w: value

	^elements at: 4 put: value! !

! Vector methodsFor: 'accessing' !
x

	^elements at: 1! !

! Vector methodsFor: 'accessing' !
x: value

	^elements at: 1 put: value! !

! Vector methodsFor: 'accessing' !
y

	^elements at: 2! !

! Vector methodsFor: 'accessing' !
y: value

	^elements at: 2 put: value! !

! Vector methodsFor: 'accessing' !
z

	^elements at: 3! !

! Vector methodsFor: 'accessing' !
z: value

	^elements at: 3 put: value! !

! Vector methodsFor: 'initializing' !
initialize

	elements := OrderedCollection with: 0.0 with: 0.0 with: 0.0 with: self defaultW! !

! Vector class methodsFor: 'instance creation' !
new

	^super new initialize; yourself! !

! Vector class methodsFor: 'instance creation' !
x: x y: y z: z w: w

	^self new
		x: x;
		y: y;
		z: z;
		w: w;
		yourself! !

! WebSocket methodsFor: 'accessing' !
close

	socket ifNotNil: [
		socket close.
		socket := nil].! !

! WebSocket methodsFor: 'accessing' !
isConnecting

	^isConnecting ! !

! WebSocket methodsFor: 'accessing' !
isConnecting: aBoolean

	isConnecting := aBoolean ! !

! WebSocket methodsFor: 'accessing' !
lengthFor: aString

	| length |

	length := aString size.
	length < 126 ifTrue: [^ByteArray with: length].
	length < 65536 ifTrue: [
		^(ByteArray new: 3)
			at: 1 put: 126;
			at: 2 put: (length // 16r100 \\ 16r100);
			at: 3 put: (length \\ 16r100);
			yourself].
	^(ByteArray new: 9)
		at: 1 put: 127;
		at: 2 put: (length // 16r100000000000000 \\ 16r100);
		at: 3 put: (length // 16r1000000000000 \\ 16r100);
		at: 4 put: (length // 16r10000000000 \\ 16r100);
		at: 5 put: (length // 16r100000000 \\ 16r100);
		at: 6 put: (length // 16r1000000 \\ 16r100);
		at: 7 put: (length // 16r10000 \\ 16r100);
		at: 8 put: (length // 16r100 \\ 16r100);
		at: 9 put: (length \\ 16r100);
		yourself! !

! WebSocket methodsFor: 'accessing' !
mask

	^(ByteArray new: 4)
		at: 1 put: (random next * 256) truncated;
		at: 2 put: (random next * 256) truncated;
		at: 3 put: (random next * 256) truncated;
		at: 4 put: (random next * 256) truncated;
		yourself! !

! WebSocket methodsFor: 'accessing' !
onMessageReceive: aSocket do: aBlock

	^aBlock value

! !

! WebSocket methodsFor: 'accessing' !
openOnPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processMessages.! !

! WebSocket methodsFor: 'accessing' !
processContentMessage: aMessage

	self raiseEvent: (MessageReceivedEvent new message: aMessage; yourself).
	^true! !

! WebSocket methodsFor: 'accessing' !
processMessage: aMessage

	(aMessage indexOfSubCollection: 'Connection: Upgrade' startingAt: 1) > 0 ifTrue: [
		^self processSocketConnectMessage: aMessage].! !

! WebSocket methodsFor: 'accessing' !
processMessages

	[self processWebSocketMessages]
		ensure: [self close]! !

! WebSocket methodsFor: 'accessing' !
processWebSocketMessages

	socket isActive ifFalse: [^self].
	
	self processSocketConnectMessage: self readConnectionMessage.

	[self readAndProcessMessages.
		socket isActive] whileTrue: [].

	BeagleSystem finish! !

! WebSocket methodsFor: 'accessing' !
random

	^random ! !

! WebSocket methodsFor: 'accessing' !
random: anObject

	random := anObject ! !

! WebSocket methodsFor: 'accessing' !
readContentMessage

	| header length mask payload payload2 |

	stream reset.
	header := stream next: 2.
	header isNil ifTrue: [
		^nil].

	length := (header at: 2) bitAnd: 16r7F.
	length = 126 ifTrue: [length := stream next * 256 + stream next]
		ifFalse: [length = 127 ifTrue: [length := stream next * 256 + stream next * 256 + stream next * 256 + stream next * 256 + stream next * 256 + stream next]].

	mask := #[0 0 0 0].
	((header at: 2) bitAnd: 128) = 128 ifTrue: [
		mask := stream next: 4].
	
	payload := stream next: length.
	payload2 := self xorPayload: payload copy withMask: mask.

	^payload2 asString! !

! WebSocket methodsFor: 'accessing' !
send: aString

	| payload |

	payload := aString asByteArray.
	
	stream
		reset;
		nextPut: 16r81;   "Final frame - text"
		nextPutAll: (self lengthFor: aString);
		nextPutAll: payload;
		commit! !

! WebSocket methodsFor: 'accessing' !
socket

	^socket! !

! WebSocket methodsFor: 'accessing' !
socket: anObject

	socket := anObject! !

! WebSocket methodsFor: 'accessing' !
stream

	^stream ! !

! WebSocket methodsFor: 'accessing' !
stream: anObject

	stream := anObject ! !

! WebSocket methodsFor: 'accessing' !
xorPayload: payload withMask: mask
	
	1 to: payload size do: [:index | payload at: index put: ((payload at: index) bitXor: (mask at: index - 1 \\ 4 + 1))].
	^payload! !

! WebSocket methodsFor: 'connecting' !
openClientFor: host onPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processClientMessages.! !

! WebSocket methodsFor: 'connecting' !
openClientOnPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processClientMessages.! !

! WebSocket methodsFor: 'connecting' !
openServerOnPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processServerMessages.! !

! WebSocket methodsFor: 'connecting' !
processClientMessages

	[self processWebSocketClientMessages]
		ensure: [self close]! !

! WebSocket methodsFor: 'connecting' !
processConnectionMessage

	self processSocketConnectMessage: self readConnectionMessage! !

! WebSocket methodsFor: 'connecting' !
processSocketClientConnectMessage: aMessage keyString: aString

	| key responseKey connectResponse |

	messageStream := aMessage readStream.
	messageStream throughAll: 'Sec-WebSocket-Accept:'.
	key := (messageStream upTo: Character cr) trimSeparators.
	responseKey := Base64Encoder new encodeStream: (SHA1 new hash: (aString, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11') asByteArray) readStream.
	responseKey = key ifFalse: [^self error: 'Unable to switch WebSocket protocol'].! !

! WebSocket methodsFor: 'connecting' !
processSocketConnectMessage: aMessage

	| key responseKey connectResponse |

	messageStream := aMessage readStream.
	messageStream throughAll: 'Sec-WebSocket-Key:'.
	key := (messageStream upTo: Character cr) trimSeparators.
	responseKey := Base64Encoder new encodeStream: (SHA1 new hash: (key, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11') asByteArray) readStream.

	connectResponse := 'HTTP/1.1 101 Switching Protocols\Upgrade: websocket\Connection: Upgrade\Sec-WebSocket-Accept: ', responseKey, '\\' copyReplaceAll: '\' with: (String with: Character cr with: Character lf).

	stream
		reset;
		nextPutAll: connectResponse asByteArray;
		commit! !

! WebSocket methodsFor: 'connecting' !
processWebSocketClientMessages

	|  keyString |

	socket isActive ifFalse: [^self].

	keyString := self sendClientConnectMessage.
	self processSocketClientConnectMessage: self readConnectionMessage keyString: keyString.
	[self readAndProcessMessages.
		socket isActive] whileTrue: [].

	BeagleSystem finish! !

! WebSocket methodsFor: 'connecting' !
readConnectionMessage

	| line result |

	messageStream := WriteStream on: (String new: 30).
	[line := (stream upTo: Character lf asInteger) asString trimSeparators.
		messageStream nextPutAll: line; cr.
		line isEmpty] whileFalse: [].
	result := messageStream contents.
	^result! !

! WebSocket methodsFor: 'processing' !
onMessageReceiveDo: aBlock

	aBlock value
! !

! WebSocket methodsFor: 'processing' !
processContentMessage

	Error
		try: [
			self processContentMessage: self readContentMessage.
			stream isActive ifFalse: [^self].
			true]
		catch: [:ex |
			Debugger openOn: thisContext message: ex message.
			self send: ex message.
			ex return: true]
		finally: nil.
 ! !

! WebSocket methodsFor: 'processing' !
processServerMessages

	[self processWebSocketServerMessages]
		ensure: [self close]! !

! WebSocket methodsFor: 'processing' !
processSocketServerConnectMessage: aMessage

	| key responseKey connectResponse |

	messageStream := aMessage readStream.
	messageStream throughAll: 'Sec-WebSocket-Key:'.
	key := (messageStream upTo: Character cr) trimSeparators.
	responseKey := Base64Encoder new encodeStream: (SHA1 new hash: (key, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11') asByteArray) readStream.

	connectResponse := 'HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: ', responseKey, '

' copyReplaceAll: (String with: Character cr) with: (String with: Character cr with: Character lf).

	stream
		nextPutAll: connectResponse asByteArray;
		commit! !

! WebSocket methodsFor: 'processing' !
processWebSocketServerMessages

	socket isActive ifFalse: [^self].
	
	self processSocketServerConnectMessage: self readConnectionMessage.
	[self readAndProcessMessages.
		socket isActive] whileTrue: [].

	BeagleSystem finish! !

! WebSocket methodsFor: 'processing' !
readAndProcessMessages

	[self processContentMessage] whileTrue: []  ! !

! WebSocket methodsFor: 'processing' !
sendClientConnectMessage

	| key keyString connectRequest |

	key := ByteArray new: 16.
	1 to: 16 do: [:i | key at: i put: (random next * 256) truncated].
	keyString := Base64Encoder new encodeStream: key readStream.

	connectRequest := 'GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: ', keyString, '
Sec-WebSocket-Version: 13

' copyReplaceAll: (String with: Character cr) with: (String with: Character cr with: Character lf).

	stream
		nextPutAll: connectRequest asByteArray;
		commit.

	^keyString! !

! WebSocket methodsFor: 'processing' !
startupConnection

	self
		stream: self socket stream;
		random: Random new.
! !

! WebSocket methodsFor: 'testing' !
isActive

	^self socket notNil and: [self socket isActive]! !

! WriteStream methodsFor: 'writing' !
at: index put: value

	self collection at: index put: value! !

! WriteStream methodsFor: 'writing' !
bufferArrayFor: aVariable data: aCollection as: aSymbol

	| javaScriptType |

	aVariable attributeType = #float ifTrue: [javaScriptType := 'Float32Array'].
	aVariable attributeType = #unsignedByte ifTrue: [javaScriptType := 'Uint8Array'].

	self
		nextPutAll: self gl;
		nextPutAll: '.bufferData(';
		nextPutAll: self gl;
		nextPutAll: '.ARRAY_BUFFER, new ';
		nextPutAll: javaScriptType;
		nextPutAll: '(['.

	aCollection do: [:each | self nextPutAll: each printString]
		separatedBy: [self nextPutAll: ','].

	self nextPutAll: ']), ';
		nextPutAll: self gl;
		nextPutAll: '.'.

	aSymbol = #staticDraw ifTrue: [self nextPutAll: 'STATIC_DRAW'].

	self nextPutAll: ');';
	cr

 ! !

! WriteStream methodsFor: 'writing' !
contents

	^collection copyFrom: 1 to: position! !

! WriteStream methodsFor: 'writing' !
cr

	self nextPut: Character cr! !

! WriteStream methodsFor: 'writing' !
grow

	| newCollection |

	newCollection := collection class new: ((collection size * 2) max: 10).
	1 to: collection size do: [:index |
		newCollection at: index put: (collection at: index)].

	collection := newCollection! !

! WriteStream methodsFor: 'writing' !
lf

	self nextPut: Character lf! !

! WriteStream methodsFor: 'writing' !
nextPut: anObject 

	position >= collection size ifTrue: [self grow].
	position := position + 1.
	collection at: position put: anObject.
	readLimit := position! !

! WriteStream methodsFor: 'writing' !
nextPutAll: aCollection 

	aCollection do: [:each | self nextPut: each]! !

! WriteStream methodsFor: 'writing' !
print: anObject 

	anObject printOn: self! !

! WriteStream methodsFor: 'writing' !
print: anObject limit: aNumber

	anObject printOn: self limit: aNumber! !

! WriteStream methodsFor: 'writing' !
space

	self nextPut: Character space! !

! WriteStream methodsFor: 'writing' !
tab

	self nextPut: Character tab! !

KitManager default currentKit allDefinedClasses: #(Array ArrayedCollection Association Base64Encoder BeagleSystem Behavior BlockClosure Boolean ByteArray ByteString ByteSymbol CachedValue Character Class ClassCreator ClassDescription Collection CompiledBlock CompiledCode CompiledMethod ComputedField DateTime Dictionary Doit Error EventBase Exception ExceptionBase ExceptionHandler ExceptionList False FileStream Filename Float Fraction HaltException IdentityDictionary Integer IntegerArray InternalStream JunkClass Kit KitManager LargeInteger LargeNegativeInteger LargePositiveInteger LimitedPrecisionReal LineEndConvention LineEndConventionCR LineEndConventionCRLF LineEndConventionLF Magnitude Matrix MemorySpace MessageNotUnderstood Metaclass MethodDictionary Number OSHandle Object OrderedCollection Point PrimitiveFailedError Random ReadStream ReadWriteStream SHA1 SequenceableCollection Set SmallInteger Socket SocketAcceptHandler SocketDispatcher SocketHandler SocketLauncher SocketStream SocketTimeoutHandler SocketUIScreenHandler Sorter Stream String StringMatcher Symbol Time True TwoByteString TwoByteSymbol UndefinedObject UninterpretedBytes Vector Warning WebSocket WriteStream) andMethods: #() !

KitManager default currentKit allDefinedMethodsFor: BeagleSystem methods: #() !

KitManager default currentKit allDefinedMethodsFor: BeagleSystem class methods: #(#allClasses #auditImage #badMetaclasses #becomeSystem #changesFile #changesFileName #checkClasses #checkClassesReferences #checkGlobals #checkKits #checkSystem #cleanupOrganizations #clearCurrent #clearSources #clearUndeclared #closeSourceFiles #current #fileinAllClasses #fileoutAllClasses #'findBytecodeSequence:inCompiledCode:into:' #'findBytecodeSequence:inMethod:into:' #'findBytecodeSequence:inMethodsOfClass:into:' #'findBytecodeSequence:inMethodsOfClassOrSubclasses:into:' #finish #fixBadMetaclasses #fixClassReferences #'fixClassReferencesIn:' #'getSource:' #'gettersOfInstanceVariable:inClass:' #'gettersOfInstanceVariable:inClass:into:' #globalGarbageCollect #imageName #'imageName:' #imageNameNoExtension #'implementersOf:' #isEmscripten #'log:' #'logObject:' #'matchesBytecodeInfo:with:' #methodsWithNoSources #new #openSourceFiles #'primSaveImage:' #'primitiveLog:' #reallocateObjectSpaces #'reallocateSpace:size:' #'referencesToAssociation:' #'referencesToClass:' #'referencesToInstanceVariable:inClass:' #'referencesToUndeclared:' #'runJavaScript:' #'runJavaScriptWithReturn:' #saveImage #'saveImage:' #'sendersOf:' #'settersOfInstanceVariable:inClass:' #'settersOfInstanceVariable:inClass:into:' #shutdown #sourceFileName #sourceFileNames #'sourceFileNames:' #sourceFiles #'sourceFiles:' #sourcesFile #sourcesFileName #spaceSize16 #specialSelectors #'specialSelectors:' #start #startAcceptSocket #webSocketPortNumber #'wellKnownAt:' #'wellKnownAt:put:' #wellKnownSize #writeAllFiles) !

KitManager default currentKit allDefinedMethodsFor: Behavior methods: #(#allInstVarNames #'allInstVarNamesInto:' #allInstances #allSubclasses #'allSubclassesInto:' #basicNew #'basicNew:' #'basicRemoveSubclass:' #'canUnderstand:' #'compiledMethodAt:' #'fileoutMethodNamed:on:' #'fileoutMethodsOn:' #'fileoutMethodsOn:forKit:' #flags #'flags:' #globalDictionaries #'inheritsFrom:' #initialize #instSize #'instVarNameForIndex:' #instVarNames #'instVarNames:' #methodDictionary #'methodDictionary:' #new #'new:' #'removeSelector:' #selectors #subclasses #'subclasses:' #superclass #'superclass:' #withAllSubclasses #'withAllSubclassesInto:' #withAllSuperclasses #'withAllSuperclassesInto:') !

KitManager default currentKit allDefinedMethodsFor: Behavior class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: BlockClosure methods: #(#allNestedLiterals #bytecodes #cache #copiedValues #'copiedValues:' #'cull:' #'cull:cull:' #'cull:cull:cull:' #'ensure:' #isBlock #isBlockClosure #method #'method:' #methodContext #'methodContext:' #numberOfArguments #'on:do:' #value #'value:' #'value:value:' #whileFalse #'whileFalse:' #whileTrue #'whileTrue:') !

KitManager default currentKit allDefinedMethodsFor: BlockClosure class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Boolean methods: #() !

KitManager default currentKit allDefinedMethodsFor: Boolean class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Character methods: #(#'<' #'<=' #'=' #'>' #'>=' #asInteger #asLowercase #asString #asUppercase #digitValue #hash #isAlphaNumeric #isAlphabetic #isDigit #isLowercase #isNonBinarySelectorCharacter #isSeparator #isUppercase #isVowel #'printOn:') !

KitManager default currentKit allDefinedMethodsFor: Character class methods: #(#backspace #cr #'digitValue:' #lf #space #tab #'value:' #vowels) !

KitManager default currentKit allDefinedMethodsFor: Class methods: #(#'byteSubclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'byteSubclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #classDictionaries #classInstVarNamesString #classTypeFlags #'classVarNames:' #environment #'environment:' #'fileoutBytesDefinitionOn:' #'fileoutDefinitionOn:' #'fileoutPlainClassDefinitionOn:' #fileoutSource #'fileoutSourceOn:' #'fileoutVariableDefinitionOn:' #globalDictionaries #instVarNamesString #isBytesClass #isVariableClass #kit #'kit:' #'migrateAllInstancesFrom:' #'migrateClassFrom:' #name #'name:' #'printOn:' #'removeSubclass:' #'subclassNamed:flags:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:flags:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #thisClass #'variableSubclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'variableSubclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:') !

KitManager default currentKit allDefinedMethodsFor: Class class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ClassCreator methods: #(#addClassToEnvironment #addClassToKit #buildClass #classInstanceVariableNames #'classInstanceVariableNames:' #classVariableNames #'classVariableNames:' #createClass #environment #'environment:' #flags #'flags:' #hasDefinitionChanged #instanceVariableNames #'instanceVariableNames:' #kitName #'kitName:' #linkToSuperclass #migrateInstances #modifyClass #modifySubclasses #name #'name:' #newClass #'newClass:' #oldClass #'oldClass:' #'removeClass:' #removeClassFromEnvironment #'removeClassFromEnvironment:' #superclass #'superclass:' #unlinkFromSuperclass) !

KitManager default currentKit allDefinedMethodsFor: ClassCreator class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ClassDescription methods: #(#basicCleanupOrganization #cleanupOrganization #'methodsInOrganization:' #'newOrganization:' #organization #'organization:' #'organizationAt:add:' #'organizationFor:' #'removeSelector:') !

KitManager default currentKit allDefinedMethodsFor: ClassDescription class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CompiledBlock methods: #(#isBlock #isCompiledBlock #outerMethod #'outerMethod:' #'printOn:' #rootMethod #value #'value:' #'value:value:') !

KitManager default currentKit allDefinedMethodsFor: CompiledBlock class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CompiledCode methods: #(#allNestedLiterals #bytecodes #'bytecodes:' #'callOffsetsIn:do:' #'findSendWithOffset:' #getSource #literals #localVariableNames #'localVariableNames:' #mclass #'mclass:' #methodOffsets #numberOfArguments #'numberOfArguments:' #numberOfLocals #'numberOfSendsIn:' #numberOfTemporaries #'numberOfTemporaries:' #sourceOffsets #'sourceOffsets:' #sourceOffsetsDictionary #'writeMethodOffsets:') !

KitManager default currentKit allDefinedMethodsFor: CompiledCode class methods: #() !

KitManager default currentKit allDefinedMethodsFor: CompiledMethod methods: #(#allMessages #definingKit #'fileoutOn:' #isPrimitive #kit #'kit:' #organization #'printOn:' #rootMethod #selector #'selector:') !

KitManager default currentKit allDefinedMethodsFor: CompiledMethod class methods: #() !

KitManager default currentKit allDefinedMethodsFor: DateTime methods: #(#'<' #'addMilliseconds:' #asMilliseconds #day #'day:' #'daysIn:forYear:' #'difference:' #hours #'initFromSystemFormat:' #'isLeap:' #milliseconds #minutes #minutesAndSecondsPrintString #month #'month:' #'printOn:' #seconds #time #'time:' #'writeBinaryOn:' #year #'year:') !

KitManager default currentKit allDefinedMethodsFor: DateTime class methods: #(#'fromSystemFormat:' #now #'readBinaryFrom:' #systemDate) !

KitManager default currentKit allDefinedMethodsFor: Doit methods: #() !

KitManager default currentKit allDefinedMethodsFor: Doit class methods: #(#doit) !

KitManager default currentKit allDefinedMethodsFor: Error methods: #() !

KitManager default currentKit allDefinedMethodsFor: Error class methods: #() !

KitManager default currentKit allDefinedMethodsFor: EventBase methods: #(#eventRegistry #initialize #'onEvent:do:' #'raiseEvent:') !

KitManager default currentKit allDefinedMethodsFor: EventBase class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: Exception methods: #(#action #'action:' #asString #message #'message:' #pass #'printOn:' #raiseSignal #result #'result:' #resume #retry #return #'return:') !

KitManager default currentKit allDefinedMethodsFor: Exception class methods: #(#',' #defaultErrorString #exceptionHandlers #'findSendWithOffset:' #'handlerFor:before:' #'handlesException:' #signal #'signal:' #'try:catch:' #'try:catch:finally:' #'try:finally:' #'unwindTo:') !

KitManager default currentKit allDefinedMethodsFor: False methods: #(#'&' #'and:' #'ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifTrue:ifFalse:' #not #'or:' #'printOn:' #'|') !

KitManager default currentKit allDefinedMethodsFor: False class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Filename methods: #(#'/' #'\' #appendStream #asCoreFilename #asFilename #asString #'construct:' #'copyTo:' #exists #fileIn #fileSize #path #'path:' #readStream #'renameTo:' #writeStream) !

KitManager default currentKit allDefinedMethodsFor: Filename class methods: #(#'fileExists:' #getInternalPath #internalPath #'named:' #pathDelimiterString #'rename:to:' #'sizeOfFile:' #'unpackAssetToInternalPath:') !

KitManager default currentKit allDefinedMethodsFor: Float methods: #(#'arcTan2:' #arccos #arcsin #arctan #asFloat #asInteger #'basicAt:' #basicSize #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #cos #decimalDigitsOfPrecision #exp #fractionPart #isFloat #kind #ln #log #'mod:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveTimes:' #'raisedToNegativeInteger:' #round #roundUp #sin #sqrt #tan #truncated) !

KitManager default currentKit allDefinedMethodsFor: Float class methods: #(#e #new #pi #unity #zero) !

KitManager default currentKit allDefinedMethodsFor: Fraction methods: #(#asFloat #asInteger #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #denominator #'denominator:' #hex #kind #numerator #'numerator:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveTimes:' #'printOn:' #reduce) !

KitManager default currentKit allDefinedMethodsFor: Fraction class methods: #(#'numerator:denominator:' #unity #zero) !

KitManager default currentKit allDefinedMethodsFor: HaltException methods: #(#raiseSignal2) !

KitManager default currentKit allDefinedMethodsFor: HaltException class methods: #(#'signal:') !

KitManager default currentKit allDefinedMethodsFor: Integer methods: #(#'/' #asFraction #asInteger #denominator #even #factorial #'gcd:' #hex #intSqrt #isInteger #'lcm:' #numerator #odd #'printHexOn:padZeros:' #'printOn:' #'printOn:paddedWith:to:base:' #'printStringRadix:' #'timesRepeat:' #truncated) !

KitManager default currentKit allDefinedMethodsFor: Integer class methods: #(#'readFrom:' #'readHexFrom:' #unity #zero) !

KitManager default currentKit allDefinedMethodsFor: Kit methods: #(#'addClass:' #'addMethod:' #'addRequiredKit:' #'allDefinedClasses:andMethods:' #'allDefinedMethodsFor:methods:' #cantUnloadReason #definedClasses #'definedClasses:' #'definesClass:' #'ensureLoaded:' #extendedClasses #extendedMethods #'extendedMethods:' #'extendsMethodNamed:inClass:' #fileout #'fileoutDefinedClassesOn:' #'fileoutDefinedMethodsOn:' #'fileoutExtendedMethodsOn:' #'fileoutInventoryOn:' #'fileoutOn:' #'includedClasses:' #initialize #name #'name:' #'partialSortDefinedClassesDo:' #'printOn:' #'removeClass:' #'removeMethod:' #'removeRequiredKit:' #requiredKitNames #'requiredKitNames:' #sortDefinedClasses #subKits #'subKits:' #unload #versionName #'versionName:' #'writeLoadRequiredKitsOn:') !

KitManager default currentKit allDefinedMethodsFor: Kit class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: KitManager methods: #(#'addKit:' #'addKitNamed:' #'allDefinedClasses:andMethods:' #'allDefinedMethodsFor:methods:' #classesNotInKit #currentKit #'currentKit:' #'currentKitNamed:' #fileinAllKits #fileoutAllKits #finishFileinKit #'hasKitNamed:' #initialize #'kitForClass:' #'kitForClass:ifNone:' #'kitNamed:' #'kitNamedIfAbsentAdd:' #kits #kitsInLoadOrder #'removeKit:' #writeAllKits) !

KitManager default currentKit allDefinedMethodsFor: KitManager class methods: #(#clearDefault #current #default #new) !

KitManager default currentKit allDefinedMethodsFor: LargeInteger methods: #(#asFloat #asLargeInteger #'basicEqualTo:' #'basicGreaterThan:' #'basicGreaterThanOrEqual:' #'basicLessThan:' #'basicLessThanOrEqual:' #'basicNotEqualTo:' #bytes #'bytes:' #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #componentSize #'componentSize:' #'divideWithRemainderBy:' #hash #hex #initialize #'integerAt:' #isLargeInteger #kind #'mod:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveQuo:' #'primitiveRem:' #'primitiveTimes:' #'printHexOn:' #'printOn:') !

KitManager default currentKit allDefinedMethodsFor: LargeInteger class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: LargeNegativeInteger methods: #(#negative #positive #sign) !

KitManager default currentKit allDefinedMethodsFor: LargeNegativeInteger class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LargePositiveInteger methods: #(#negative #positive #sign) !

KitManager default currentKit allDefinedMethodsFor: LargePositiveInteger class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LimitedPrecisionReal methods: #(#asInteger #fractionalValue #isReal #positive #'printOn:' #'printScientificNotationOn:') !

KitManager default currentKit allDefinedMethodsFor: LimitedPrecisionReal class methods: #(#new #zero) !

KitManager default currentKit allDefinedMethodsFor: Magnitude methods: #(#'<' #'<=' #'>' #'>=' #'between:and:' #'max:' #'min:') !

KitManager default currentKit allDefinedMethodsFor: Magnitude class methods: #() !

KitManager default currentKit allDefinedMethodsFor: MemorySpace methods: #() !

KitManager default currentKit allDefinedMethodsFor: MemorySpace class methods: #() !

KitManager default currentKit allDefinedMethodsFor: MessageNotUnderstood methods: #(#'printOn:') !

KitManager default currentKit allDefinedMethodsFor: MessageNotUnderstood class methods: #(#defaultErrorString) !

KitManager default currentKit allDefinedMethodsFor: Metaclass methods: #(#classDictionaries #kit #name #'printOn:' #thisClass #'thisClass:') !

KitManager default currentKit allDefinedMethodsFor: Metaclass class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Number methods: #(#'*' #'+' #'-' #'/' #'//' #'<' #'<=' #'=' #'>' #'>=' #'@' #abs #arccos #arcsin #'coerceTo:' #cos #cosh #cot #coth #csc #csch #degreesToRadians #exp #hash #isNumber #isZero #'jsonOn:' #kind #ln #log #negated #negative #positive #'quo:' #radiansToDegrees #'raisedTo:' #'raisedToInteger:' #'raisedToNegativeInteger:' #reciprocal #'rem:' #sec #sech #sign #sin #sinh #sqrt #squared #tan #tanh #'to:by:do:' #'to:do:' #'~=') !

KitManager default currentKit allDefinedMethodsFor: Number class methods: #(#'readFrom:') !

KitManager default currentKit allDefinedMethodsFor: OSHandle methods: #(#contents) !

KitManager default currentKit allDefinedMethodsFor: OSHandle class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Point methods: #(#'*' #'+' #'-' #'/' #'=' #abs #copy #'corner:' #'dotProduct:' #'extent:' #hash #'max:' #'min:' #negated #'printOn:' #r #theta #transposed #x #'x:' #y #'y:') !

KitManager default currentKit allDefinedMethodsFor: Point class methods: #(#'x:y:') !

KitManager default currentKit allDefinedMethodsFor: PrimitiveFailedError methods: #() !

KitManager default currentKit allDefinedMethodsFor: PrimitiveFailedError class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SHA1 methods: #(#'hash:' #'write32:into:startingAt:') !

KitManager default currentKit allDefinedMethodsFor: SHA1 class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SmallInteger methods: #(#'<<' #'>>' #'\\' #asFloat #asLargeInteger #'basicAt:' #basicSize #'bitAnd:' #bitInvert #'bitOr:' #'bitShift:' #'bitXOr:' #'bitXor:' #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #'divideWithRemainderBy:' #'integerAt:' #kind #'leftRotate32:' #'mod:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveQuo:' #'primitiveRem:' #'primitiveTimes:' #reduce) !

KitManager default currentKit allDefinedMethodsFor: SmallInteger class methods: #(#maxVal #minVal) !

KitManager default currentKit allDefinedMethodsFor: Socket methods: #(#FIONBIO #accept #basicAccept #bind #close #connect #'family:address:port:' #getPeerName #getSockName #'getSockOptLevel:optionName:value:length:' #handle #'handle:' #handleBlock #'handleBlock:' #'ioctl:data:' #isActive #'listen:' #makeNonBlocking #primClose #'read:length:' #'shutdown:' #stream #'write:length:') !

KitManager default currentKit allDefinedMethodsFor: Socket class methods: #(#af_appletalk #af_bth #af_inet #af_inet6 #af_ipx #af_irda #af_netbios #af_unspec #'basicNewInDomain:type:protocol:' #ipproto_icmp #ipproto_icpmv6 #ipproto_igmp #ipproto_rfcomm #ipproto_rm #ipproto_tcp #ipproto_udp #'newInDomain:type:protocol:' #newTCPConnection #'poll:events:revents:timeout:' #sock_dgram #sock_raw #sock_rdm #sock_seqpacket #sock_stream) !

KitManager default currentKit allDefinedMethodsFor: SocketAcceptHandler methods: #(#clientHandler #'clientHandler:' #handle #portNumber #'portNumber:' #shutdown #startup) !

KitManager default currentKit allDefinedMethodsFor: SocketAcceptHandler class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SocketDispatcher methods: #(#POLLHUP #POLLIN #'addHandler:' #events #'events:' #handlers #'handlers:' #initialize #poll #'removeHandler:' #revents #'revents:' #running #'running:' #setupPollStructures #shutdown #socketHandles #'socketHandles:' #startPollLoop #timeoutHandler #'timeoutHandler:' #timeoutInterval #'timeoutInterval:') !

KitManager default currentKit allDefinedMethodsFor: SocketDispatcher class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SocketHandler methods: #(#closeIfNeeded #dispatcher #'dispatcher:' #handle #initialize #shutdown #socket #'socket:' #startup) !

KitManager default currentKit allDefinedMethodsFor: SocketHandler class methods: #(#new #'startupOn:') !

KitManager default currentKit allDefinedMethodsFor: SocketLauncher methods: #(#commandHandlerClass #'commandHandlerClass:' #screenHandlerClass #'screenHandlerClass:' #'startupOn:' #startupReceiver #'startupReceiver:' #startupSelector #'startupSelector:') !

KitManager default currentKit allDefinedMethodsFor: SocketLauncher class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SocketTimeoutHandler methods: #(#handle #timeoutBlock #'timeoutBlock:') !

KitManager default currentKit allDefinedMethodsFor: SocketTimeoutHandler class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SocketUIScreenHandler methods: #(#commandHandler #'commandHandler:' #handle #handleWebSocketConnection #initialize #'processMessage:' #socketState #'socketState:' #startup #startupReceiver #'startupReceiver:' #startupSelector #'startupSelector:' #uiScreen #'uiScreen:' #webSocket #'webSocket:' #'withMyUIScreenDo:') !

KitManager default currentKit allDefinedMethodsFor: SocketUIScreenHandler class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Time methods: #(#'-' #'<' #'<=' #'>' #'>=' #hours #milliseconds #'milliseconds:' #minutes #'printOn:' #seconds #'setMilliseconds:' #showHourlyCountdown #totalHours #totalMilliseconds #totalMinutes #totalSeconds #'writeBinaryOn:') !

KitManager default currentKit allDefinedMethodsFor: Time class methods: #(#'fromSeconds:' #millisecondClockValue #'millisecondsToRun:' #now #'readBinaryFrom:') !

KitManager default currentKit allDefinedMethodsFor: True methods: #(#'&' #'and:' #'ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifTrue:ifFalse:' #not #'or:' #'printOn:' #'|') !

KitManager default currentKit allDefinedMethodsFor: True class methods: #() !

KitManager default currentKit allDefinedMethodsFor: UndefinedObject methods: #(#'ifNil:' #'ifNil:ifNotNil:' #'ifNotNil:' #isNil #'modifyClass:flags:instVarNames:classVarNames:classInstVarNames:environment:' #notNil #'printOn:' #'subclassNamed:flags:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:flags:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:') !

KitManager default currentKit allDefinedMethodsFor: UndefinedObject class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Warning methods: #() !

KitManager default currentKit allDefinedMethodsFor: Warning class methods: #() !

KitManager default currentKit allDefinedMethodsFor: WebSocket methods: #(#close #isActive #isConnecting #'isConnecting:' #'lengthFor:' #mask #'onMessageReceive:do:' #'onMessageReceiveDo:' #'openClientFor:onPort:' #'openClientOnPort:' #'openOnPort:' #'openServerOnPort:' #processClientMessages #processConnectionMessage #processContentMessage #'processContentMessage:' #'processMessage:' #processMessages #processServerMessages #'processSocketClientConnectMessage:keyString:' #'processSocketConnectMessage:' #'processSocketServerConnectMessage:' #processWebSocketClientMessages #processWebSocketMessages #processWebSocketServerMessages #random #'random:' #readAndProcessMessages #readConnectionMessage #readContentMessage #'send:' #sendClientConnectMessage #socket #'socket:' #startupConnection #stream #'stream:' #'xorPayload:withMask:') !

KitManager default currentKit allDefinedMethodsFor: WebSocket class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Object methods: #(#'->' #'=' #'==' #allOwners #asString #'at:' #'at:put:' #'basicAt:' #'basicAt:put:' #'basicPrintOn:' #basicPrintString #basicSize #'become:' #class #copy #displayString #'error:' #halt #hash #identityHash #'ifNil:' #'ifNil:ifNotNil:' #'ifNotNil:' #initialize #'instVarAt:' #'instVarAt:put:' #isArray #isBlock #isBlockClosure #isCollection #isCompiledBlock #isDictionary #isFloat #isIndexed #isInteger #'isKindOf:' #isLargeInteger #'isMemberOf:' #isNil #isNumber #isReal #isString #isSymbol #isUI #isVMMigrationNew #'log:' #markNewVersion #markVMMigrationNew #'migrateFrom:instVarMapping:' #notNil #'perform:' #'perform:with:' #'perform:with:with:' #'perform:with:with:with:' #'perform:withArguments:' #postCopy #primitiveFailed #primitiveHalt #'printOn:' #printString #'remote_instVarAt:' #'remote_instVarAt:put:' #'setClass:' #shallowCopy #'shallowCopyTo:' #size #'storeOn:' #storeString #walkback #yourself #'~=' #'~~') !

KitManager default currentKit allDefinedMethodsFor: Object class methods: #(#'log:' #systemDictionary) !

KitManager default currentKit allDefinedMethodsFor: Base64Encoder methods: #(#base64Characters #'base64ToInteger:' #decodeBlock #'decodeStream:' #'encode1:' #'encode2:with:' #'encode3:with:with:' #'encodeStream:' #encodeTriple #'integerToBase64:') !

KitManager default currentKit allDefinedMethodsFor: Base64Encoder class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ExceptionBase methods: #(#catchBlock #'catchBlock:' #finallyBlock #'finallyBlock:' #unwind) !

KitManager default currentKit allDefinedMethodsFor: ExceptionBase class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ExceptionHandler methods: #(#catchBlock #'catchBlock:' #exceptionClass #'exceptionClass:' #finallyBlock #'finallyBlock:' #'handlesException:' #unwind) !

KitManager default currentKit allDefinedMethodsFor: ExceptionHandler class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ExceptionList methods: #(#',' #'addException:' #exceptionHandlers #exceptions #'exceptions:' #'handlesException:' #initialize #'try:catch:' #'try:catch:finally:' #'try:finally:') !

KitManager default currentKit allDefinedMethodsFor: ExceptionList class methods: #(#new) !

KitManager default currentKit allDefinedMethodsFor: ComputedField methods: #(#action #'action:' #asString #isComputedField #name #'name:' #'printOn:' #'valueFor:') !

KitManager default currentKit allDefinedMethodsFor: ComputedField class methods: #(#'name:action:') !

KitManager default currentKit allDefinedMethodsFor: Array methods: #(#isArray #'printCollectionStartOn:' #species) !

KitManager default currentKit allDefinedMethodsFor: Array class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ArrayedCollection methods: #() !

KitManager default currentKit allDefinedMethodsFor: ArrayedCollection class methods: #(#'withAll:') !

KitManager default currentKit allDefinedMethodsFor: Association methods: #(#'=' #hash #key #'key:' #'printOn:' #value #'value:') !

KitManager default currentKit allDefinedMethodsFor: Association class methods: #(#'key:value:') !

KitManager default currentKit allDefinedMethodsFor: ByteArray methods: #(#asByteArray #asString #'printCollectionEndOn:' #'printCollectionStartOn:' #printStringHex) !

KitManager default currentKit allDefinedMethodsFor: ByteArray class methods: #(#'newFromImageSpace:') !

KitManager default currentKit allDefinedMethodsFor: ByteString methods: #(#asInt #asTwoByteString #'at:' #'at:put:' #'basicAt:' #'basicAt:put:' #printStringHex) !

KitManager default currentKit allDefinedMethodsFor: ByteString class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ByteSymbol methods: #(#asString #'at:') !

KitManager default currentKit allDefinedMethodsFor: ByteSymbol class methods: #(#garbageCollectSymbolTable #'intern:' #symbolTable) !

KitManager default currentKit allDefinedMethodsFor: Collection methods: #(#'allSatisfy:' #'anySatisfy:' #asArray #asByteArray #asOrderedCollection #asSet #'collect:' #'detect:' #'detect:ifNone:' #'do:' #'do:separatedBy:' #'includes:' #'inject:into:' #isCollection #isEmpty #notEmpty #'occurrencesOf:' #'printCollectionEndOn:' #'printCollectionStartOn:' #'printOn:' #'printOn:limit:' #'reject:' #'remove:' #'removeAll:' #'select:' #size #species #'storeOn:') !

KitManager default currentKit allDefinedMethodsFor: Collection class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LineEndConventionCRLF methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:') !

KitManager default currentKit allDefinedMethodsFor: LineEndConventionCRLF class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Dictionary methods: #(#'addAssociation:' #'associationAt:' #'associationAt:ifAbsent:' #associations #'associationsDo:' #'at:' #'at:ifAbsent:' #'at:ifAbsentPut:' #'at:put:' #basicValues #'bindingFor:' #copy #copyWithAssociations #'do:' #'doesKey:match:' #'findIndex:' #growIfNeeded #'includesKey:' #'initialProbeFor:' #'initialize:' #isDictionary #keys #'keysAndValuesDo:' #'keysDo:' #'privateRemoveKey:' #rehash #'removeKey:' #'removeKey:ifAbsent:' #size #values) !

KitManager default currentKit allDefinedMethodsFor: Dictionary class methods: #(#new #'new:' #rehashAllDictionaries) !

KitManager default currentKit allDefinedMethodsFor: FileStream methods: #(#atEnd #basicNext #'basicNext:' #basicUpToEnd #binary #close #flush #handle #'handle:' #initialize #isBinary #'isBinary:' #lineEndConvention #'lineEndConvention:' #next #'next:' #'nextPut:' #'nextPutAll:' #'open:' #'open:mode:' #position #'position:' #primNext #'primNext:' #'primNextPut:' #'primNextPutAll:' #'primOpen:' #'primOpen:mode:' #'primSkip:' #primUpToEnd #'skip:' #upToEnd) !

KitManager default currentKit allDefinedMethodsFor: FileStream class methods: #(#append #appendableRead #overwrite #pathDelimiterString #read #writableRead #write) !

KitManager default currentKit allDefinedMethodsFor: IdentityDictionary methods: #(#'doesKey:match:' #'initialProbeFor:') !

KitManager default currentKit allDefinedMethodsFor: IdentityDictionary class methods: #() !

KitManager default currentKit allDefinedMethodsFor: IntegerArray methods: #() !

KitManager default currentKit allDefinedMethodsFor: IntegerArray class methods: #() !

KitManager default currentKit allDefinedMethodsFor: InternalStream methods: #(#collection #'collection:' #initialize #reset) !

KitManager default currentKit allDefinedMethodsFor: InternalStream class methods: #(#new #'on:') !

KitManager default currentKit allDefinedMethodsFor: LineEndConvention methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:') !

KitManager default currentKit allDefinedMethodsFor: LineEndConvention class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LineEndConventionCR methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:') !

KitManager default currentKit allDefinedMethodsFor: LineEndConventionCR class methods: #() !

KitManager default currentKit allDefinedMethodsFor: LineEndConventionLF methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:') !

KitManager default currentKit allDefinedMethodsFor: LineEndConventionLF class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Matrix methods: #(#'*' #'+' #'-' #a00 #a01 #a02 #a03 #a10 #a11 #a12 #a13 #a20 #a21 #a22 #a23 #a30 #a31 #a32 #a33 #as2DPoint #'atRow:column:' #'atRow:column:put:' #b00 #b01 #b02 #b03 #b10 #b11 #b12 #b13 #b20 #b21 #b22 #b23 #b30 #b31 #b32 #b33 #columns #determinant4D #elements #'from3x3Array:' #'from4x4Array:' #'fromArray:' #inverse #inverse2D #inverse4D #javascriptString #makeIdentity #'printOn:' #rows #'rows:columns:' #w #x #y #z) !

KitManager default currentKit allDefinedMethodsFor: Matrix class methods: #(#'columnVectorFromArray:' #'from3x3Array:' #'from4x4Array:' #'fromArray:' #'identityRows:columns:' #'rows:columns:' #'twoDFromPoint:') !

KitManager default currentKit allDefinedMethodsFor: MethodDictionary methods: #() !

KitManager default currentKit allDefinedMethodsFor: MethodDictionary class methods: #() !

KitManager default currentKit allDefinedMethodsFor: OrderedCollection methods: #(#',' #'add:' #'add:beforeIndex:' #'addAll:' #'addFirst:' #asArray #'at:' #'at:put:' #copy #grow #growFirst #growFirstSize #'initializeSize:' #'inspectorFieldAt:' #inspectorFields #last #privateValues #'remove:' #'removeAllSuchThat:' #removeFirst #'removeIndex:' #removeLast #size) !

KitManager default currentKit allDefinedMethodsFor: OrderedCollection class methods: #(#new #'new:' #'with:' #'with:with:' #'with:with:with:' #'with:with:with:with:') !

KitManager default currentKit allDefinedMethodsFor: Random methods: #(#initialize #next #nextSeed #seed #'seed:') !

KitManager default currentKit allDefinedMethodsFor: Random class methods: #(#new #'seed:') !

KitManager default currentKit allDefinedMethodsFor: ReadStream methods: #(#atEnd #contents #fileIn #next #'next:' #'nextAvailable:' #peek #previous #'throughAll:' #'upTo:' #'upToAll:' #upToEnd) !

KitManager default currentKit allDefinedMethodsFor: ReadStream class methods: #() !

KitManager default currentKit allDefinedMethodsFor: ReadWriteStream methods: #(#contents #cr #grow #'nextPut:' #'nextPutAll:' #'print:' #'print:limit:' #space #tab) !

KitManager default currentKit allDefinedMethodsFor: ReadWriteStream class methods: #() !

KitManager default currentKit allDefinedMethodsFor: SequenceableCollection methods: #(#',' #'=' #'at:ifAbsent:' #'collect:' #copy #'copyFrom:to:' #'copyReplaceAll:with:' #'copyReplacing:with:' #'copyWith:' #'copyWithout:' #'do:' #'do:separatedBy:' #'endsWith:' #'findFirst:' #'findLast:' #first #'firstIndexOf:startingAt:' #hash #'indexOf:' #'indexOfSubCollection:startingAt:' #'jsonOn:' #'keysAndValuesDo:' #last #'lastIndexOf:' #'printItWith:' #readStream #readWriteStream #reverse #'reverseDo:' #'select:' #sorted #'sortedBy:' #species #'splitOn:' #'with:do:' #writeStream) !

KitManager default currentKit allDefinedMethodsFor: SequenceableCollection class methods: #(#'from:' #'new:withAll:' #'with:' #'with:with:' #'with:with:with:' #'with:with:with:with:') !

KitManager default currentKit allDefinedMethodsFor: Set methods: #(#'add:' #'addAll:' #basicValues #'do:' #grow #'includes:' #'initialize:' #recomputeTally #'remove:' #'remove:ifAbsent:' #size #species) !

KitManager default currentKit allDefinedMethodsFor: Set class methods: #(#new #'new:') !

KitManager default currentKit allDefinedMethodsFor: SocketStream methods: #(#atEnd #bufferSize #commit #initialize #isActive #next #'nextPut:' #peek #read #reset #socket #'socket:') !

KitManager default currentKit allDefinedMethodsFor: SocketStream class methods: #(#'on:') !

KitManager default currentKit allDefinedMethodsFor: Sorter methods: #(#'partition:from:to:' #'partitionInclusive:from:to:' #'sort:' #'sort:from:to:' #sortBlock #'sortBlock:' #'swap:from:to:') !

KitManager default currentKit allDefinedMethodsFor: Sorter class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Stream methods: #(#position #'position:' #readLimit #'readLimit:' #'skip:') !

KitManager default currentKit allDefinedMethodsFor: Stream class methods: #() !

KitManager default currentKit allDefinedMethodsFor: String methods: #(#'<' #'<=' #'>' #'>=' #asByteArray #asFilename #asLowercase #asSimtalkString #asString #asSymbol #asUppercase #capitalized #'compareString:' #'convertLineEndingsTo2:' #'convertLineEndingsTo:' #crToCRLF #crToLF #'extractUTF8CharacterFrom:' #isString #'jsonOn:' #lfToCR #'match:ignoreCase:' #'matches:' #'printOn:' #'printPrefixOn:' #'printSuffixOn:' #'splitBy:' #'storeOn:' #'subStringFrom:to:' #'tokensBasedOn:' #trimSeparators #utf8Decode #withCRs) !

KitManager default currentKit allDefinedMethodsFor: String class methods: #(#implementationClass #'new:') !

KitManager default currentKit allDefinedMethodsFor: StringMatcher methods: #(#'addSubmatcher:' #advance #fail #index #'index:' #initialize #isFinished #'match:' #'matchCharacter:' #parent #'parent:' #pattern #'pattern:' #peekPattern #'removeSubmatcher:' #setupSubmatchers #submatchers) !

KitManager default currentKit allDefinedMethodsFor: StringMatcher class methods: #(#new #'pattern:') !

KitManager default currentKit allDefinedMethodsFor: Symbol methods: #(#',' #'=' #asSimTalkSymbol #asSymbol #eventKey #hash #isSymbol #numArgs #'printOn:' #'printPrefixOn:') !

KitManager default currentKit allDefinedMethodsFor: Symbol class methods: #(#implementationClass) !

KitManager default currentKit allDefinedMethodsFor: TwoByteString methods: #(#asTwoByteString #'at:' #'at:put:' #size) !

KitManager default currentKit allDefinedMethodsFor: TwoByteString class methods: #(#'new:') !

KitManager default currentKit allDefinedMethodsFor: TwoByteSymbol methods: #() !

KitManager default currentKit allDefinedMethodsFor: TwoByteSymbol class methods: #() !

KitManager default currentKit allDefinedMethodsFor: UninterpretedBytes methods: #(#asByteString #asString #'bitSequenceFrom:to:' #copy #'doubleAt:put:' #floatArrayPrintString #'floatAt:' #'floatAt:put:' #hexString #randomize #size #'uint32At:' #'uint32At:put:' #'uint64At:' #'uint64At:put:') !

KitManager default currentKit allDefinedMethodsFor: UninterpretedBytes class methods: #() !

KitManager default currentKit allDefinedMethodsFor: Vector methods: #(#'+' #'-' #'atRow:column:' #'atRow:column:put:' #columns #defaultW #elements #'elements:' #initialize #'printOn:' #rows #w #'w:' #x #'x:' #y #'y:' #z #'z:') !

KitManager default currentKit allDefinedMethodsFor: Vector class methods: #(#new #'x:y:z:w:') !

KitManager default currentKit allDefinedMethodsFor: WriteStream methods: #(#'at:put:' #'bufferArrayFor:data:as:' #contents #cr #grow #lf #'nextPut:' #'nextPutAll:' #'print:' #'print:limit:' #space #tab) !

KitManager default currentKit allDefinedMethodsFor: WriteStream class methods: #() !

KitManager default currentKit allDefinedMethodsFor: JunkClass methods: #(#ifFalseIfTrueTest #ifFalseReturnTest #ifFalseTest #ifTrueIfFalseTest #initialize #junkMethod #junkMethod10 #junkMethod2 #junkMethod3 #junkMethod4 #junkMethod5 #junkMethod6 #junkMethod7 #junkMethod8 #'method2:' #nonLocalReturn #nonLocalReturnA #'nonLocalReturnB:' #nonLocalReturnC) !

KitManager default currentKit allDefinedMethodsFor: JunkClass class methods: #(#classVar1Variable) !

KitManager default currentKit allDefinedMethodsFor: CachedValue methods: #(#block #'block:' #resetValue #value #'value:') !

KitManager default currentKit allDefinedMethodsFor: CachedValue class methods: #(#'block:') !

KitManager default finishFileinKit !
