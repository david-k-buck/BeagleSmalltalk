! Doit class methodsFor: 'doit' !
doit ^[KitManager current fileinAllKits] value ! !
! Doit class methodsFor: 'doit' !
doit ^[('kits' asFilename construct: 'Core.kit') fileIn] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKitNamed: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit ensureLoaded: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[nil subclassNamed: #Object
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Association
	instVarNames: 'key value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Base64Encoder
	instVarNames: 'inputStream outputStream isFinished'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #BeagleSystem
	instVarNames: ''
	classInstVarNames: 'current imageName sourceFiles sourceFileNames specialSelectors'
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Behavior
	instVarNames: 'superclass methodDictionary flags subclasses instVarNames'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #BlockClosure
	instVarNames: 'method methodContext copiedValues'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Boolean
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #CachedValue
	instVarNames: 'value block'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ClassCreator
	instVarNames: 'name oldClass newClass superclass instanceVariableNames classVariableNames classInstanceVariableNames flags environment kitName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior subclassNamed: #ClassDescription
	instVarNames: 'organization'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription subclassNamed: #Class
	instVarNames: 'name kit environment'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Collection
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object variableSubclassNamed: #CompiledCode
	instVarNames: 'bytecodes numberOfArguments numberOfTemporaries localVariableNames stackNeeded polymorphicInlineCache sourceOffsets mclass'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode variableSubclassNamed: #CompiledBlock
	instVarNames: 'outerMethod dummy'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode variableSubclassNamed: #CompiledMethod
	instVarNames: 'selector kit'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ComputedField
	instVarNames: 'name action'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection variableSubclassNamed: #Dictionary
	instVarNames: 'values tally'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Doit
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #EventBase
	instVarNames: 'eventRegistry'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Exception
	instVarNames: 'message action result'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception subclassNamed: #Error
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ExceptionBase
	instVarNames: 'catchBlock finallyBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ExceptionHandler
	instVarNames: 'catchBlock finallyBlock exceptionClass'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ExceptionList
	instVarNames: 'exceptions'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Boolean subclassNamed: #False
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Filename
	instVarNames: 'path'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Error subclassNamed: #HaltException
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary variableSubclassNamed: #IdentityDictionary
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object variableSubclassNamed: #JunkClass
	instVarNames: 'instVar1 instVar2'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Kit
	instVarNames: 'name requiredKitNames definedClasses extendedMethods subKits versionName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #KitManager
	instVarNames: 'kits currentKit'
	classInstVarNames: 'default'
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #LineEndConvention
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention subclassNamed: #LineEndConventionCR
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention subclassNamed: #LineEndConventionCRLF
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention subclassNamed: #LineEndConventionLF
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Magnitude
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude subclassNamed: #Character
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude subclassNamed: #DateTime
	instVarNames: 'day month year time'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Matrix
	instVarNames: 'elements rows columns'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object byteSubclassNamed: #MemorySpace
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Error subclassNamed: #MessageNotUnderstood
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription subclassNamed: #Metaclass
	instVarNames: 'thisClass'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[IdentityDictionary variableSubclassNamed: #MethodDictionary
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude subclassNamed: #Number
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Number subclassNamed: #Fraction
	instVarNames: 'numerator denominator'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Number subclassNamed: #Integer
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer subclassNamed: #LargeInteger
	instVarNames: 'bytes componentSize'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger subclassNamed: #LargeNegativeInteger
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger subclassNamed: #LargePositiveInteger
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Number byteSubclassNamed: #LimitedPrecisionReal
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal byteSubclassNamed: #Float
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object byteSubclassNamed: #OSHandle
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Point
	instVarNames: 'x y'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Error subclassNamed: #PrimitiveFailedError
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Random
	instVarNames: 'seed'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #SHA1
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection subclassNamed: #SequenceableCollection
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection subclassNamed: #ArrayedCollection
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ArrayedCollection variableSubclassNamed: #Array
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ArrayedCollection subclassNamed: #IntegerArray
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[IntegerArray byteSubclassNamed: #ByteArray
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection subclassNamed: #OrderedCollection
	instVarNames: 'firstIndex lastIndex values'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection subclassNamed: #Set
	instVarNames: 'values numberOfElements'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer subclassNamed: #SmallInteger
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Socket
	instVarNames: 'handle readStream writeStream handleBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase subclassNamed: #SocketDispatcher
	instVarNames: 'socketHandles events revents handlers timeoutHandler timeoutInterval running'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #SocketHandler
	instVarNames: 'socket dispatcher'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler subclassNamed: #SocketAcceptHandler
	instVarNames: 'portNumber clientHandler'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #SocketLauncher
	instVarNames: 'screenHandlerClass commandHandlerClass startupReceiver startupSelector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler subclassNamed: #SocketTimeoutHandler
	instVarNames: 'timeoutBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler subclassNamed: #SocketUIScreenHandler
	instVarNames: 'webSocket socketState uiScreen commandHandler startupReceiver startupSelector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Sorter
	instVarNames: 'sortBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Stream
	instVarNames: 'position readLimit'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Stream subclassNamed: #InternalStream
	instVarNames: 'collection'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream subclassNamed: #ReadStream
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream subclassNamed: #ReadWriteStream
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream subclassNamed: #FileStream
	instVarNames: 'handle isBinary lineEndConvention'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream subclassNamed: #SocketStream
	instVarNames: 'socket internalStream'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ArrayedCollection subclassNamed: #String
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[String byteSubclassNamed: #ByteString
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #StringMatcher
	instVarNames: 'submatchers pattern parent index'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[String subclassNamed: #Symbol
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol byteSubclassNamed: #ByteSymbol
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude subclassNamed: #Time
	instVarNames: 'milliseconds'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Boolean subclassNamed: #True
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[String byteSubclassNamed: #TwoByteString
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol byteSubclassNamed: #TwoByteSymbol
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #UndefinedObject
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection byteSubclassNamed: #UninterpretedBytes
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Vector
	instVarNames: 'elements'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception subclassNamed: #Warning
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase subclassNamed: #WebSocket
	instVarNames: 'socket stream messageStream random isConnecting'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream subclassNamed: #WriteStream
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Core'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
at: index 

	<primitive: 60>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
at: index put: anObject 

	<primitive: 61>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
basicAt: index 

	<primitive: 60>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
basicAt: index put: anObject 

	<primitive: 61>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
basicSize

	<primitive: 62>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
become: anObject

	<primitive: 555>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
size

	^self class instSize ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'accessing'] value ! !
! Object methodsFor: 'accessing' !
yourself

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'class membership'] value ! !
! Object methodsFor: 'class membership' !
class

	<primitive: 111>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'class membership'] value ! !
! Object methodsFor: 'class membership' !
isKindOf: aClass

	self class == aClass ifTrue: [^true].
	^self class inheritsFrom: aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'class membership'] value ! !
! Object methodsFor: 'class membership' !
isMemberOf: aClass

	^self class == aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'comparing'] value ! !
! Object methodsFor: 'comparing' !
= anObject 

	^self == anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'comparing'] value ! !
! Object methodsFor: 'comparing' !
hash

	^self identityHash ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'comparing'] value ! !
! Object methodsFor: 'comparing' !
identityHash

	<primitive: 75>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'comparing'] value ! !
! Object methodsFor: 'comparing' !
~= t1 

	^(self = t1) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'controlling'] value ! !
! Object methodsFor: 'controlling' !
ifNil: aBlock 

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'controlling'] value ! !
! Object methodsFor: 'controlling' !
ifNil: nilBlock ifNotNil: notNilBlock 

	^notNilBlock cull: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'controlling'] value ! !
! Object methodsFor: 'controlling' !
ifNotNil: aBlock 

	^aBlock cull: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'converting'] value ! !
! Object methodsFor: 'converting' !
-> anObject 

	^Association key: self value: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'copying'] value ! !
! Object methodsFor: 'copying' !
copy

	^self shallowCopy postCopy; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'copying'] value ! !
! Object methodsFor: 'copying' !
postCopy

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'copying'] value ! !
! Object methodsFor: 'copying' !
shallowCopy

	| copy |
	copy := self class basicNew: self basicSize.
	self shallowCopyTo: copy.
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'copying'] value ! !
! Object methodsFor: 'copying' !
shallowCopyTo: copy

	1 to: self class instSize do: [:index |
		copy instVarAt: index put: (self instVarAt: index)].
	
	1 to: self basicSize do: [:index |
		copy basicAt: index put: (self basicAt: index)].
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'displaying'] value ! !
! Object methodsFor: 'displaying' !
displayString

	^self printString ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'error handling'] value ! !
! Object methodsFor: 'error handling' !
error: aString 

	Error signal: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'error handling'] value ! !
! Object methodsFor: 'error handling' !
primitiveFailed

	self walkback.
	PrimitiveFailedError signal ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'initialize-release'] value ! !
! Object methodsFor: 'initialize-release' !
initialize
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'logging'] value ! !
! Object methodsFor: 'logging' !
log: aString

	BeagleSystem log: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'migrating'] value ! !
! Object methodsFor: 'migrating' !
migrateFrom: anObject instVarMapping: anArray
	"Migrate instance variables from anObject to self.
	The instVarMapping is an array that matches the new instance size.  The elements are integers or blocks or nil.
	Integers represent the index of the instance variable of the old object to copy over.
	nil represents no mapping = leave the new instance variable nil.
	Providing a block runs the block on the old object to compute the value to write into the instance variable of the new object."

	1 to: anArray size do: [:instVarNumber |
		| oldIndex value |
		oldIndex := anArray at: instVarNumber.
		oldIndex notNil ifTrue: [
			value := oldIndex isInteger
				ifTrue: [anObject instVarAt: oldIndex]
				ifFalse: [oldIndex cull: anObject].
			self instVarAt: instVarNumber put: value]].
	
	1 to: (anObject basicSize min: self basicSize) do: [:indexedInstVarNumber |
		self basicAt: indexedInstVarNumber put: (anObject basicAt: indexedInstVarNumber)] ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'navigating'] value ! !
! Object methodsFor: 'navigating' !
allOwners

	| owners |

	owners := OrderedCollection new.

	Class allSubclasses do: [:eachMetaclass |
		eachMetaclass allInstances do: [:metaclass |
			metaclass thisClass allInstances do: [:inst |
				(inst ~~ owners and: [inst ~~ owners privateValues]) ifTrue: [
					1 to: inst basicSize do: [:indexedVarNum | (inst basicAt: indexedVarNum) == self ifTrue: [owners add: inst]].
					1 to: inst class allInstVarNames size do: [:namedVarNum | (inst instVarAt: namedVarNum) == self ifTrue: [owners add: inst]]].
			]
		]
	].

	^owners  ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
asString

	^self printString ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
basicPrintOn: aStream 

	self class name first isVowel
		ifTrue: [aStream nextPutAll: 'an ']
		ifFalse: [aStream nextPutAll: 'a '].

	aStream nextPutAll: self class name ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
basicPrintString

	| stream |
	stream := WriteStream on: (ByteString new: 30).
	self basicPrintOn: stream.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
printOn: aStream 

	self class name first isVowel
		ifTrue: [aStream nextPutAll: 'an']
		ifFalse: [aStream nextPutAll: 'a'].

	aStream nextPutAll: self class name ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
printString

	| stream |
	stream := WriteStream on: (ByteString new: 30).
	self printOn: stream.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
storeOn: aStream 

	^self printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'printing'] value ! !
! Object methodsFor: 'printing' !
storeString

	| stream |
	stream := WriteStream on: (ByteString new: 30).
	self storeOn: stream.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'private'] value ! !
! Object methodsFor: 'private' !
markNewVersion

	<primitive: 701>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'private'] value ! !
! Object methodsFor: 'private' !
setClass: newClass

	<primitive: 702>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
halt

	HaltException signal: 'Halt'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
instVarAt: index 

	<primitive: 420>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
instVarAt: index put: anObject 

	<primitive: 421>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
isVMMigrationNew
	<primitive: 703>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
markVMMigrationNew
	<primitive: 701>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
perform: aSelector

	^self perform: aSelector withArguments: #() ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
perform: aSelector with: anArgument

	^self perform: aSelector withArguments: (Array with: anArgument) ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
perform: aSelector with: anArgument with: arg2

	^self perform: aSelector withArguments: (Array with: anArgument with: arg2) ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
perform: aSelector with: anArgument with: arg2 with: arg3

	^self perform: aSelector withArguments: (Array with: anArgument with: arg2 with: arg3) ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
perform: aSelector withArguments: anArray

	<primitive: 552>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
primitiveHalt

	<primitive: 407>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
remote_instVarAt: index 

	<primitive: 420>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
remote_instVarAt: index put: anObject 

	<primitive: 421>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'system primitives'] value ! !
! Object methodsFor: 'system primitives' !
walkback

	<primitive: 557>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
== anObject

	<primitive: 110>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isArray

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isBlock

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isBlockClosure

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isCollection

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isCompiledBlock

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isDictionary

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isFloat

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isIndexed

	^(self class flags bitAnd: 2) ~= 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isInteger

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isLargeInteger

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isNil

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isNumber

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isReal

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isString

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isSymbol

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
isUI

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
notNil

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'testing'] value ! !
! Object methodsFor: 'testing' !
~~ anObject

	^(self == anObject) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Object class methodsFor: 'logging'] value ! !
! Object class methodsFor: 'logging' !
log: aString

	BeagleSystem log: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Object class methodsFor: 'migrating'] value ! !
! Object class methodsFor: 'migrating' !
systemDictionary

	<primitive: 553>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'accessing'] value ! !
! Association methodsFor: 'accessing' !
key

	^key ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'accessing'] value ! !
! Association methodsFor: 'accessing' !
key: anObject 

	key := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'accessing'] value ! !
! Association methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'accessing'] value ! !
! Association methodsFor: 'accessing' !
value: anObject 

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'printing'] value ! !
! Association methodsFor: 'printing' !
printOn: aStream

	self key printOn: aStream.
	aStream nextPutAll: '->'.
	self value printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'testing'] value ! !
! Association methodsFor: 'testing' !
= anAssociation

	self class == anAssociation class ifFalse: [^false].
	self key == anAssociation key ifFalse: [^false].
	self value == anAssociation value ifFalse: [^false].
	^true
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Association methodsFor: 'testing'] value ! !
! Association methodsFor: 'testing' !
hash

	^(self key identityHash + self value identityHash) abs

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Association class methodsFor: 'instance creation'] value ! !
! Association class methodsFor: 'instance creation' !
key: key value: value 

	^self new
		key: key;
		value: value;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
base64Characters

	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
base64ToInteger: aCharacter

	(aCharacter between: $A and: $Z) ifTrue: [^aCharacter asInteger - $A asInteger].
	(aCharacter between: $a and: $z) ifTrue: [^aCharacter asInteger - $a asInteger + 26].
	(aCharacter between: $0 and: $9) ifTrue: [^aCharacter asInteger - $0 asInteger + 52].
	aCharacter = $+ ifTrue: [^62].
	aCharacter = $/ ifTrue: [^63].

	self error: 'Base64 error' ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
decodeBlock

	| bits byteNumber |

	bits := 0.
	byteNumber := 0.

	[inputStream atEnd] whileFalse: [
		| character decodedBits |
		character := inputStream next.
		character = $= ifTrue: [^self].
		decodedBits := self base64ToInteger: character.
		bits := bits * 64 + decodedBits.
		byteNumber = 1 ifTrue: [
			outputStream nextPut: bits // 16.
			bits := bits \\ 16].
		byteNumber = 2 ifTrue: [
			outputStream nextPut: bits // 4.
			bits := bits \\ 4].
		byteNumber = 3 ifTrue: [
			outputStream nextPut: bits.
			bits := 0].
		byteNumber := (byteNumber + 1) \\ 4.
		]. ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
decodeStream: aStream

	isFinished := false.
	inputStream := aStream.
	outputStream := WriteStream on: (ByteArray new: 10).

	self decodeBlock.

	^outputStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
encode1: aCharacter

	| integer result |
	integer := aCharacter asInteger * 16.

	result := Array new: 4.
	result
		at: 3 put: $=;
		at: 4 put: $=.

	2 to: 1 by: -1 do: [:index |
		result at: index put: (self integerToBase64: integer \\ 64).
		integer := integer // 64].

	result do: [:eachCharacter |
		outputStream nextPut: eachCharacter].

	isFinished := true. ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
encode2: character1 with: character2

	| integer result |
	integer := character1 asInteger * 256 + character2 asInteger * 4.

	result := Array new: 4.
	result at: 4 put: $=.

	3 to: 1 by: -1 do: [:index |
		result at: index put: (self integerToBase64: integer \\ 64).
		integer := integer // 64].

	result do: [:eachCharacter |
		outputStream nextPut: eachCharacter].

	isFinished := true ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
encode3: character1 with: character2 with: character3

	| integer result |
	integer := character1 asInteger * 256 + character2 asInteger * 256 + character3 asInteger.

	result := Array new: 4.

	4 to: 1 by: -1 do: [:index |
		result at: index put: (self integerToBase64: integer \\ 64).
		integer := integer // 64].

	result do: [:eachCharacter |
		outputStream nextPut: eachCharacter] ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
encodeStream: aStream

	isFinished := false.
	inputStream := aStream.
	outputStream := WriteStream on: (String new: 10).

	[inputStream atEnd] whileFalse: [
		self encodeTriple].

	isFinished ifFalse: [outputStream nextPut: $=].
	^outputStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
encodeTriple

	| character1 character2 character3 |

	character1 := inputStream next.

	character2 := inputStream atEnd
		ifTrue: [nil]
		ifFalse: [inputStream next].

	character3 := inputStream atEnd
		ifTrue: [nil]
		ifFalse: [inputStream next].

	character3 isNil ifFalse: [^self encode3: character1 with: character2 with: character3].
	character2 isNil ifFalse: [^self encode2: character1 with: character2].
	self encode1: character1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Base64Encoder methodsFor: 'accessing'] value ! !
! Base64Encoder methodsFor: 'accessing' !
integerToBase64: integer

	^self base64Characters at: integer + 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'accessing'] value ! !
! BeagleSystem class methodsFor: 'accessing' !
imageName

	^imageName ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'accessing'] value ! !
! BeagleSystem class methodsFor: 'accessing' !
imageName: aString

	imageName := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'accessing'] value ! !
! BeagleSystem class methodsFor: 'accessing' !
imageNameNoExtension

	^self imageName copyFrom: 1 to: (self imageName lastIndexOf: $.) - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'accessing'] value ! !
! BeagleSystem class methodsFor: 'accessing' !
specialSelectors

	^specialSelectors ifNil: [specialSelectors := #(#'+' 1 #'-' 1 #'*' 1 #not 0 #'==' 1 #'~~' 1 #'=' 1 #'~=' 1 #isNil 0 #notNil 0 #'>' 1 #'<' 1 #'>=' 1 #'<=' 1 #'evaluate:' 1 #printString 0 #'raiseSignal' 0 #'perform:withArguments:' 2 #halt 0 #'debugIt:' 1 #'evaluateJsonString:' 1)] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'accessing'] value ! !
! BeagleSystem class methodsFor: 'accessing' !
specialSelectors: anArray

	specialSelectors := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
checkClasses

	| allMetaclasses badMetaclasses |

	badMetaclasses := OrderedCollection new.

	BeagleSystem globalGarbageCollect.
	allMetaclasses := Metaclass allInstances.
	allMetaclasses do: [:metaclass |
		| class |
		(metaclass superclass subclasses includes: metaclass) ifFalse: [
			badMetaclasses add: metaclass.
			self log: 'Metaclass not in superclasses'' subclass list: ', metaclass printString].

		metaclass thisClass superclass isNil ifFalse: [
			(metaclass thisClass superclass subclasses includes: metaclass thisClass) ifFalse: [
				badMetaclasses add: metaclass.
				self log: 'Class not in superclasses'' subclass list: ', metaclass thisClass printString]].

		(class := Smalltalk at: metaclass thisClass name ifAbsent: [nil]) == metaclass thisClass ifFalse: [
			badMetaclasses add: metaclass.
			class isNil
				ifTrue: [self log: 'Class not in globals: ' , metaclass thisClass name]
				ifFalse: [self log: 'Class not the same as global: ', metaclass thisClass name]]].

	self allClasses do: [:eachClass |
		(Smalltalk at: eachClass name ifAbsent: [nil]) == eachClass ifFalse: [
			badMetaclasses add: eachClass.
			self log: 'Subclass not in globals: ', eachClass printString]].

	^badMetaclasses


		 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
checkClassesReferences

	BeagleSystem allClasses do: [:eachClass |
		eachClass selectors do: [:selector |
			(eachClass compiledMethodAt: selector) allNestedLiterals do: [:literal |
				(literal isMemberOf: Association) ifTrue: [
					(Smalltalk associationAt: literal key) == literal ifFalse: [
						self log: 'Class reference doesn''t use the same association: ', literal key, ' in ', eachClass printString, '>>', selector]]]].

		eachClass class selectors do: [:selector |
			(eachClass class compiledMethodAt: selector) allNestedLiterals do: [:literal |
				(literal isMemberOf: Association) ifTrue: [
					(Smalltalk associationAt: literal key) == literal ifFalse: [
						self log: 'Class reference doesn''t use the same association: ', literal key, ' in ', eachClass printString, '>>', selector]]]]].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
checkGlobals

	| correct incorrect |
	correct := 0.
	incorrect := 0.
	Object withAllSubclasses do: [:class |
		class selectors do: [:selector |
			(class compiledMethodAt: selector) allNestedLiterals do: [:literal |
				(literal isMemberOf: Association) ifTrue: [
					literal == (Smalltalk associationAt: literal key)
						ifTrue: [correct := correct + 1]
						ifFalse: [incorrect := incorrect + 1.
							self log: class printString, ' > ', selector, ' === ', literal key]]]]].

	^Array with: correct with: incorrect ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
checkKits

	KitManager current kits do: [:eachKit |
		eachKit definedClasses do: [:eachClass |
			eachClass == (Smalltalk at: eachClass name ifAbsent: [nil]) ifFalse: [
				self log: 'Bad class ', eachClass name, ' in Kit: ', eachKit name]]] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
checkSystem

	| badGlobals |

	self log: 'Start check system'.
	badGlobals := self checkGlobals.
	badGlobals last = 0 ifFalse: [
		self error: 'Bad globals: ', badGlobals last].

	self checkClasses.
	self checkClassesReferences.
	self checkKits.

	self log: 'Finished check system'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
fixClassReferences

	BeagleSystem allClasses do: [:eachClass |
		eachClass selectors do: [:selector |
			self fixClassReferencesIn: (eachClass compiledMethodAt: selector)].

		eachClass class selectors do: [:selector |
			self fixClassReferencesIn: (eachClass class compiledMethodAt: selector)]].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'checking'] value ! !
! BeagleSystem class methodsFor: 'checking' !
fixClassReferencesIn: aCompiledCode

	aCompiledCode literals keysAndValuesDo: [:number :literal |
		literal isCompiledBlock ifTrue: [self fixClassReferencesIn: literal].
		literal isBlockClosure ifTrue: [self fixClassReferencesIn: literal method].
		(literal isMemberOf: Association) ifTrue: [
			| global |
			global := Smalltalk associationAt: literal key.
			global isNil ifFalse: [
				literal == global ifFalse: [
					aCompiledCode at: number put: global]]]
		]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'garbage collecting'] value ! !
! BeagleSystem class methodsFor: 'garbage collecting' !
auditImage

	<primitive: 300>
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'garbage collecting'] value ! !
! BeagleSystem class methodsFor: 'garbage collecting' !
globalGarbageCollect

	<primitive: 559>
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'garbage collecting'] value ! !
! BeagleSystem class methodsFor: 'garbage collecting' !
reallocateObjectSpaces

	<primitive: 301>
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'image saving'] value ! !
! BeagleSystem class methodsFor: 'image saving' !
primSaveImage: aString

	<primitive: 558>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'image saving'] value ! !
! BeagleSystem class methodsFor: 'image saving' !
saveImage

	^self saveImage: self imageNameNoExtension ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'image saving'] value ! !
! BeagleSystem class methodsFor: 'image saving' !
saveImage: aString

	self sourceFiles: nil.
	WebSession current closeAllWindows.

	self primSaveImage: aString.

	self log: 'Saved image as: ', aString printString.
	self changesFileName = (aString, '.cha') ifTrue: [^self].

	self changesFileName asFilename copyTo: aString, '.cha'.
	self sourceFileNames at: 2 put: aString, '.cha'.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'instance creation'] value ! !
! BeagleSystem class methodsFor: 'instance creation' !
clearCurrent

	current := nil ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'instance creation'] value ! !
! BeagleSystem class methodsFor: 'instance creation' !
current

	^current ifNil: [
		current := self basicNew.
		current initialize.
		current] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'instance creation'] value ! !
! BeagleSystem class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'logging'] value ! !
! BeagleSystem class methodsFor: 'logging' !
log: aString

	self primitiveLog: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'logging'] value ! !
! BeagleSystem class methodsFor: 'logging' !
logObject: anObject

	| string |
	string := anObject printString.
	(string asSimtalkString splitOn: Character cr) do: [:line |
		self log: line] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
allClasses

	^((Class withAllSubclasses copyWithout: Class) collect: [:each | each thisClass]) asArray sortedBy: [:a :b | a name < b name] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
clearUndeclared

	Undeclared keys do: [:each | Undeclared removeKey: each] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
fileinAllClasses

	'stSource\allFiles.st' asFilename fileIn  ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
fileoutAllClasses

	self allClasses do: [:each | each fileoutSource].
	self writeAllFiles ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inCompiledCode: aCompiledCode into: aCollection

	| stream |

	stream := DecompileStream on: aCompiledCode.
	[stream atEnd] whileFalse: [
		| bytecodeInfo |
		bytecodeInfo := stream next.
		(self matchesBytecodeInfo: bytecodeInfo with: bytecodeSequence) ifTrue: [
			| rootMethod |
			rootMethod := aCompiledCode rootMethod.
			aCollection add: (Array with: rootMethod mclass with: (rootMethod mclass organizationFor: rootMethod selector) with: rootMethod selector with: rootMethod kit)] ]
   ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inMethod: aMethod into: aCollection

	self findBytecodeSequence: bytecodeSequence inCompiledCode: aMethod into: aCollection.

	aMethod allNestedLiterals do: [:eachLiteral |
		eachLiteral isBlock ifTrue: [
			self findBytecodeSequence: bytecodeSequence inCompiledCode: eachLiteral into: aCollection]]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection

	aBehavior methodDictionary do: [:eachMethod |
		self findBytecodeSequence: bytecodeSequence inMethod: eachMethod into: aCollection] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
findBytecodeSequence: bytecodeSequence inMethodsOfClassOrSubclasses: aBehavior into: aCollection

	aBehavior withAllSubclasses do: [:eachClass |
		self findBytecodeSequence: bytecodeSequence inMethodsOfClass: eachClass into: aCollection].

	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
gettersOfInstanceVariable: aString inClass: aBehavior

	| methods |

	methods := OrderedCollection new.
	self gettersOfInstanceVariable:  aString inClass: aBehavior into: methods.
	^methods   ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
gettersOfInstanceVariable: aString inClass: aBehavior into: aCollection

	| bytecodeSequence methods variableNumber |

	(aBehavior allInstVarNames includes: aString) ifFalse: [
		self error: 'Instance variable ', aString, ' not found in class ', aBehavior printString].

	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		pushInstVarReference: (InstanceVariable new variableName: aString);
		yourself) bytecodeStream contents.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	variableNumber := aBehavior allInstVarNames indexOf: aString.
	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		pushSelfInstanceVariableReference: (Array with: 0 with: variableNumber);
		yourself) bytecodeStream contents asArray at: 2 put: nil; yourself.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
implementersOf: aSymbol
	| result |
	result := OrderedCollection new.
	Object withAllSubclasses do: [:eachClass |
		(eachClass methodDictionary includesKey: aSymbol) ifTrue: [
			result add: (Array with: eachClass with: (eachClass organizationFor: aSymbol) with: aSymbol with: (eachClass compiledMethodAt: aSymbol) kit)]].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
matchesBytecodeInfo: bytecodeInfo with: bytecodeSequence

	| bytecodeArgs |

	(bytecodeInfo at: 2) = bytecodeSequence first ifFalse: [^false].

	bytecodeArgs := bytecodeInfo last.

	bytecodeArgs size = (bytecodeSequence size - 1) ifFalse: [^false].
	1 to: bytecodeArgs size do: [:index |
		(bytecodeSequence at: index + 1) isNil ifFalse: [
			(bytecodeArgs at: index) = (bytecodeSequence at: index + 1) ifFalse: [^false].
			] ].

	^true

  ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
referencesToAssociation: anAssociation

	| result |
	result := OrderedCollection new.

	Object withAllSubclasses do: [:eachClass |
		eachClass methodDictionary keysAndValuesDo: [:selector :method |
			(method allNestedLiterals includes: anAssociation) ifTrue: [
				result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
referencesToClass: aClass
	| result association |
	result := Set new.
	association := aClass environment associationAt: aClass name.

	Object withAllSubclasses do: [:eachClass |
		eachClass methodDictionary keysAndValuesDo: [:selector :method |
			(method allNestedLiterals includes: association) ifTrue: [
				result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]].
	^result asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
referencesToInstanceVariable: aString inClass: aBehavior

	| methods |

	methods := Set new.
	self
		gettersOfInstanceVariable:  aString inClass: aBehavior into: methods;
		settersOfInstanceVariable:  aString inClass: aBehavior into: methods.
	^methods  asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
referencesToUndeclared: aSymbol
	| result association |
	result := OrderedCollection new.
	association := Undeclared associationAt: aSymbol.

	Object withAllSubclasses do: [:eachClass |
		eachClass methodDictionary keysAndValuesDo: [:selector :method |
			(method allNestedLiterals includes: association) ifTrue: [
				result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
sendersOf: aSymbol
	| result |
	result := Set new.
	Object withAllSubclasses do: [:eachClass |
		eachClass = Doit class ifFalse: [
			eachClass methodDictionary keysAndValuesDo: [:selector :method |
				(method allNestedLiterals includes: aSymbol) ifTrue: [
					result add: (Array with: eachClass with: (eachClass organizationFor: selector) with: selector with: method kit)]]]].
	^result asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
settersOfInstanceVariable: aString inClass: aBehavior

	| methods |

	methods := OrderedCollection new.
	self settersOfInstanceVariable:  aString inClass: aBehavior into: methods.
	^methods   ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
settersOfInstanceVariable: aString inClass: aBehavior into: aCollection

	| bytecodeSequence methods variableNumber |

	(aBehavior allInstVarNames includes: aString) ifFalse: [
		self error: 'Instance variable ', aString, ' not found in class ', aBehavior printString].

	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		storeInstanceVariableAssignment: (InstanceVariable new variableName: aString);
		yourself) bytecodeStream contents.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	variableNumber := aBehavior allInstVarNames indexOf: aString.
	bytecodeSequence := (CodeGenerator new
		targetClass: aBehavior;
		storeSelfInstvarAssignment: (Array with: 0 with: variableNumber);
		yourself) bytecodeStream contents asArray at: 2 put: nil; yourself.

	self findBytecodeSequence: bytecodeSequence inMethodsOfClass: aBehavior into: aCollection.

	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
writeAllFiles

	| stream |

	stream := 'stSource\allFiles.st' asFilename writeStream.
	self allClasses do: [:class |
		stream
			nextPutAll: '''stSource\';
			nextPutAll: class name;
			nextPutAll: '.st'' asFilename fileIn!';
			cr].

	stream close
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'primitive'] value ! !
! BeagleSystem class methodsFor: 'primitive' !
primitiveLog: aString

	<primitive: 406>
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
changesFile

	^(self sourceFiles at: 2) ifNil: [
		| file |
		file := self changesFileName asFilename appendStream.
		self sourceFiles at: 2 put: file.
		file] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
changesFileName

	^self sourceFileNames at: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
clearSources

	self allClasses do: [:class |
		class selectors do: [:selector |
			(class compiledMethodAt: selector) sourceOffsets: nil].
		class class selectors do: [:selector |
			(class class compiledMethodAt: selector) sourceOffsets: nil]].
		
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
closeSourceFiles

	self sourceFiles keysAndValuesDo: [:key :value |
		value notNil ifTrue: [
			value close.
			self sourceFiles at: key put: nil]] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
getSource: anArray
	| stream theClass |
	stream := WriteStream on: (String new: 1000).
	theClass := Smalltalk at: anArray first.
	anArray size = 3 ifTrue: [theClass := theClass class].
	theClass fileoutMethodNamed: anArray last on: stream.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
methodsWithNoSources

	| methods |

	methods := OrderedCollection new.
	self allClasses do: [:class |
		class selectors do: [:selector |
			(class compiledMethodAt: selector) sourceOffsets isNil ifTrue: [methods add: (Array with: class with: selector)]].
		class class selectors do: [:selector |
			(class class compiledMethodAt: selector) sourceOffsets isNil ifTrue: [methods add: (Array with: class class with: selector)]]].
	
	^methods
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
openSourceFiles

	self sourceFileNames keysAndValuesDo: [:key :value |
		value notNil ifTrue: [
			self sourceFiles at: key put: ((Filename named: value) appendStream)]] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourceFileName

	^self sourceFiles at: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourceFileNames

	^sourceFileNames ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourceFileNames: anArray

	sourceFileNames := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourceFiles

	^sourceFiles ifNil: [sourceFiles := Array new: 16] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourceFiles: anArray

	sourceFiles := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourcesFile

	^(self sourceFiles at: 1) ifNil: [
		| file |
		file := self changesFileName asFilename readStream.
		self sourceFiles at: 1 put: file.
		file] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'sources'] value ! !
! BeagleSystem class methodsFor: 'sources' !
sourcesFileName

	^self sourceFileNames at: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'startup'] value ! !
! BeagleSystem class methodsFor: 'startup' !
finish

	<primitive: 409> ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'startup'] value ! !
! BeagleSystem class methodsFor: 'startup' !
shutdown

	self log: 'Shutdown'.
	CurrentSocketDispatcher shutdown
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'startup'] value ! !
! BeagleSystem class methodsFor: 'startup' !
start

	Exception exceptionHandlers removeAllSuchThat: [:each | true].
	self startAcceptSocket
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'startup'] value ! !
! BeagleSystem class methodsFor: 'startup' !
startAcceptSocket

	Smalltalk at: #CurrentSocketDispatcher put: SocketDispatcher new.
	(Smalltalk at: #CurrentSocketDispatcher)
		addHandler: (SocketAcceptHandler new
			portNumber: 5000;
			clientHandler: (SocketLauncher new
				screenHandlerClass: SocketUIScreenHandler;
				commandHandlerClass: DevelopmentCommandHandler;
				yourself);
			yourself);
		timeoutHandler: (SocketTimeoutHandler new
			timeoutBlock: [];
			yourself);
		startPollLoop.

 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
badMetaclasses

	^self allClasses select: [:eachClass |
		(eachClass environment at: eachClass name) ~~ eachClass] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
becomeSystem

	<primitive: 302>
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
cleanupOrganizations

	self allClasses do: [:eachClass |
		eachClass cleanupOrganization] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
fixBadMetaclasses

	^self badMetaclasses do: [:eachClass |
		eachClass class superclass subclasses: (eachClass class superclass subclasses copyWithout: eachClass class)] ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
reallocateSpace: spaceNumber size: size

	<primitive: 303> ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
runJavaScript: aString

	(Smalltalk at: #CurrentScreen) webSocket send: '`', aString ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
runJavaScriptWithReturn: aString

	| result |
	(Smalltalk at: #CurrentScreen) webSocket send: '`connection.send(', aString, ');'.
	[result := (Smalltalk at: #CurrentScreen) webSocket readContentMessage.
		result isNil] whileTrue: [].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
spaceSize16

	<primitive: 304> ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
webSocketPortNumber

	<primitive: 220>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
wellKnownAt: index

	<primitive: 610> ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
wellKnownAt: index put: value

	<primitive: 611> ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'system'] value ! !
! BeagleSystem class methodsFor: 'system' !
wellKnownSize

	<primitive: 612> ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'testing'] value ! !
! BeagleSystem class methodsFor: 'testing' !
isEmscripten

	<primitive: 600>
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
allInstVarNames

	| collection |

	collection := OrderedCollection new.
	^self allInstVarNamesInto: collection ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
allInstVarNamesInto: aCollection

	self superclass isNil ifFalse: [self superclass allInstVarNamesInto: aCollection].
	aCollection addAll: self instVarNames.
	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
allInstances

	<primitive: 556>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
allSubclasses

	^self allSubclassesInto: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
allSubclassesInto: aCollection 

	subclasses isNil ifFalse: [subclasses do: [:subclass | subclass withAllSubclassesInto: aCollection]].
	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
basicNew

	<primitive: 70>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
basicNew: size 

	<primitive: 71>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
compiledMethodAt: selector

	^self methodDictionary at: selector ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
flags

	^flags ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
flags: aNumber 

	flags := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
globalDictionaries

	^Array with: Object systemDictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
instSize

	superclass isNil ifTrue: [^instVarNames size].
	^superclass instSize + instVarNames size ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
instVarNameForIndex: aNumber 

	aNumber > self instSize ifTrue: [^nil].
	superclass isNil ifTrue: [^instVarNames at: aNumber].
	^(superclass instVarNameForIndex: aNumber)
		ifNil: [instVarNames at: aNumber - superclass instSize] ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
instVarNames

	^instVarNames ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
instVarNames: anArray 

	instVarNames := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
methodDictionary

	^methodDictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
methodDictionary: aDictionary 

	methodDictionary := aDictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
new

	<primitive: 70>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
new: size 

	<primitive: 71>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
selectors

	^self methodDictionary keys ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
subclasses

	^subclasses ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
subclasses: anObject

	subclasses := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
superclass

	^superclass ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
superclass: aClass 

	superclass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
withAllSubclasses

	^self withAllSubclassesInto: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
withAllSubclassesInto: aCollection 

	aCollection add: self.
	subclasses isNil ifFalse: [subclasses do: [:subclass | subclass withAllSubclassesInto: aCollection]].
	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
withAllSuperclasses

	^self withAllSuperclassesInto: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'accessing'] value ! !
! Behavior methodsFor: 'accessing' !
withAllSuperclassesInto: aCollection 

	aCollection add: self.
	superclass isNil ifFalse: [superclass withAllSuperclassesInto: aCollection].
	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'fileIn/Out'] value ! !
! Behavior methodsFor: 'fileIn/Out' !
fileoutMethodNamed: aMethodName on: aStream

	self organization keysAndValuesDo: [:organizationName :methodNames |
		methodNames do: [:eachMethodName |
			eachMethodName = aMethodName ifTrue: [
				aStream nextPutAll: '! ';
					nextPutAll: self printString;
					nextPutAll: ' methodsFor: ';
					nextPutAll: organizationName printString;
					nextPutAll: ' !';
					cr.
				(self compiledMethodAt: eachMethodName) fileoutOn: aStream.
				aStream
					nextPutAll: '! !';
					cr; cr]]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'fileIn/Out'] value ! !
! Behavior methodsFor: 'fileIn/Out' !
fileoutMethodsOn: aStream

	(self organization keys asArray sortedBy: [:a :b | a < b]) do: [:organizationName |
		| methodNames |
		methodNames := (self organization at: organizationName) asArray sortedBy: [:a :b | a < b].
		methodNames do: [:eachMethodName |
		
			aStream nextPutAll: '! ';
				nextPutAll: self printString;
				nextPutAll: ' methodsFor: ';
				nextPutAll: organizationName printString;
				nextPutAll: ' !';
				cr.
			(self compiledMethodAt: eachMethodName) fileoutOn: aStream.
			aStream
				nextPutAll: '! !';
				cr; cr]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'fileIn/Out'] value ! !
! Behavior methodsFor: 'fileIn/Out' !
fileoutMethodsOn: aStream forKit: aKit

	(self organization keys asArray sortedBy: [:a :b | a < b]) do: [:organizationName |
		| methodNames |
		methodNames := (self organization at: organizationName) asArray sortedBy: [:a :b | a < b].
		methodNames do: [:eachMethodName |
			| method |
			method := self compiledMethodAt: eachMethodName.
			method definingKit == aKit ifTrue: [
				aStream nextPutAll: '! ';
					nextPutAll: self printString;
					nextPutAll: ' methodsFor: ';
					nextPutAll: organizationName printString;
					nextPutAll: ' !';
					cr.
				method fileoutOn: aStream.
				aStream
					nextPutAll: '! !';
					cr; cr] ] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'initialize-release'] value ! !
! Behavior methodsFor: 'initialize-release' !
initialize

	subclasses := #() ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'removing'] value ! !
! Behavior methodsFor: 'removing' !
basicRemoveSubclass: aClass

	^self subclasses: (self subclasses copyWithout: aClass) ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'removing'] value ! !
! Behavior methodsFor: 'removing' !
removeSelector: aSymbol

	| method |
	method := self compiledMethodAt: aSymbol.
	method kit isNil ifFalse: [
		method kit removeMethod: method].

	self methodDictionary removeKey: aSymbol.
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'testing'] value ! !
! Behavior methodsFor: 'testing' !
canUnderstand: aSymbol 

	(methodDictionary includesKey: aSymbol) ifTrue: [^true].
	superclass isNil ifTrue: [^false].
	^superclass canUnderstand: aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior methodsFor: 'testing'] value ! !
! Behavior methodsFor: 'testing' !
inheritsFrom: aClass

	self == aClass ifTrue: [^true].
	self superclass isNil ifTrue: [^false].
	^self superclass inheritsFrom: aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Behavior class methodsFor: 'instance creation'] value ! !
! Behavior class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
allNestedLiterals

	^self method allNestedLiterals ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
bytecodes

	^self method bytecodes ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
cache

	| oldBlock cachedValue |
	oldBlock := self.
	cachedValue := CachedValue new.
	oldBlock become: cachedValue.
	oldBlock block: cachedValue; resetValue.
	^oldBlock
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
copiedValues

	^copiedValues ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
copiedValues: anArray

	copiedValues := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
method

	^method ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
method: anObject

	method := anObject.
	copiedValues := Array new ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
methodContext

	^methodContext ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
methodContext: anObject

	methodContext:= anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'accessing'] value ! !
! BlockClosure methodsFor: 'accessing' !
numberOfArguments

	^self method numberOfArguments ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
cull: anObject

	self numberOfArguments = 1 ifTrue: [
		^self value: anObject].
	self numberOfArguments = 0 ifTrue: [
		^self value].
	self error: 'Improper number of arguments' ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
cull: anObject cull: object2

	self numberOfArguments = 2 ifTrue: [
		^self value: anObject value: object2].
	self numberOfArguments = 1 ifTrue: [
		^self value: anObject].
	self numberOfArguments = 0 ifTrue: [
		^self value].
	self error: 'Improper number of arguments' ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
cull: anObject cull: object2 cull: object3

	self numberOfArguments = 3 ifTrue: [
		^self value: anObject value: object2 value: object3].
	self numberOfArguments = 2 ifTrue: [
		^self value: anObject value: object2].
	self numberOfArguments = 1 ifTrue: [
		^self value: anObject].
	self numberOfArguments = 0 ifTrue: [
		^self value].
	self error: 'Improper number of arguments' ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
ensure: aBlock

	^Exception
		try: [self value]
		finally: [aBlock value]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
on: anExceptionClass do: handlerBlock

	^anExceptionClass
		try: self
		catch: handlerBlock
		finally: []
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
value

	<primitive: 501>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
value: object 

	<primitive: 502>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
value: object1 value: object2 

	<primitive: 503>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
whileFalse

	[self value] whileFalse: [nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
whileFalse: aBlock

	self value
		ifFalse:
			[aBlock value.
			[self value] whileFalse: [aBlock value]] ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
whileTrue

	[self value] whileTrue: [nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'evaluating'] value ! !
! BlockClosure methodsFor: 'evaluating' !
whileTrue: aBlock

	self value
		ifTrue:
			[aBlock value.
			[self value] whileTrue: [aBlock value]] ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'testing'] value ! !
! BlockClosure methodsFor: 'testing' !
isBlock

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockClosure methodsFor: 'testing'] value ! !
! BlockClosure methodsFor: 'testing' !
isBlockClosure

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[CachedValue methodsFor: 'accessing'] value ! !
! CachedValue methodsFor: 'accessing' !
block

	^block ! !
! Doit class methodsFor: 'doit' !
doit ^[CachedValue methodsFor: 'accessing'] value ! !
! CachedValue methodsFor: 'accessing' !
block: anObject

	block := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CachedValue methodsFor: 'accessing'] value ! !
! CachedValue methodsFor: 'accessing' !
resetValue

	self value: self block value ! !
! Doit class methodsFor: 'doit' !
doit ^[CachedValue methodsFor: 'accessing'] value ! !
! CachedValue methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[CachedValue methodsFor: 'accessing'] value ! !
! CachedValue methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CachedValue class methodsFor: 'instance creation'] value ! !
! CachedValue class methodsFor: 'instance creation' !
block: aBlock

	^self new
		block: aBlock;
		resetValue;
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
classInstanceVariableNames

	| names |
	classInstanceVariableNames isString ifTrue: [
		^((classInstanceVariableNames splitBy: Character space) select: [:each | each notEmpty]) asArray].

	names := OrderedCollection new.
	classInstanceVariableNames do: [:name |
		names addAll: ((name splitBy: Character space) select: [:each | each notEmpty])].
	^names asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
classInstanceVariableNames: anArray

	classInstanceVariableNames := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
classVariableNames

	^classVariableNames ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
classVariableNames: anArray

	classVariableNames := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
environment

	^environment ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
environment: anObject

	environment := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
flags

	^flags ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
flags: anInteger

	flags := anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
instanceVariableNames

	| names |
	instanceVariableNames isString ifTrue: [
		^((instanceVariableNames splitBy: Character space) select: [:each | each notEmpty]) asArray].

	names := OrderedCollection new.
	instanceVariableNames do: [:name |
		names addAll: ((name splitBy: Character space) select: [:each | each notEmpty])].
	^names asArray
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
instanceVariableNames: anArray

	instanceVariableNames := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
kitName

	^kitName ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
kitName: aSymbol

	kitName := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
name: aClass

	name := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
newClass

	^newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
newClass: aClass

	newClass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
oldClass

	^oldClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
oldClass: aClass

	oldClass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
superclass

	^superclass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'accessing'] value ! !
! ClassCreator methodsFor: 'accessing' !
superclass: aClass

	superclass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
addClassToEnvironment

	self newClass environment: self environment.
	self environment at: self name put: self newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
addClassToKit

	| kit |

	self kitName isNil ifTrue: [^self].
	kit := KitManager current kitNamed: self kitName.
	kit isNil ifTrue: [^self].

	(KitManager current kitForClass: self newClass) ifNotNil: [:oldKit | oldKit removeClass: self newClass].
	kit addClass: self newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
buildClass

	self oldClass: (self environment at: self name ifAbsent: [nil]).
	self oldClass ifNotNil: [^self modifyClass].

	self createClass.
	self
		linkToSuperclass;
		addClassToEnvironment;
		addClassToKit ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
createClass

	| oldMetaclass newMetaclass swapTemp |

	newMetaclass := Metaclass new
		flags: ((superclass class allInstVarNames size + self classInstanceVariableNames size) bitShift: 16);
		superclass: superclass class;
		instVarNames: self classInstanceVariableNames;
		methodDictionary: (oldClass ifNil: [MethodDictionary new] ifNotNil: [oldClass class methodDictionary copy]);
		subclasses: #();
		organization: (oldClass ifNil: [Dictionary new] ifNotNil: [oldClass class organization copy]);
		yourself.

	oldClass notNil ifTrue: [
		oldMetaclass := oldClass class.
		oldMetaclass become: newMetaclass.
		swapTemp := oldMetaclass.
		oldMetaclass := newMetaclass.
		newMetaclass := swapTemp.
	
		oldClass setClass: oldMetaclass].

	newClass := ((newMetaclass new)
		name: self name;
		flags: ((superclass allInstVarNames size + self instanceVariableNames size) bitShift: 16) + self flags;
		methodDictionary: (oldClass ifNil: [MethodDictionary new] ifNotNil: [oldClass methodDictionary copy]);
		instVarNames: self instanceVariableNames;
		"classVarNames: self classVariableNames;"
		organization: (oldClass ifNil: [Dictionary new] ifNotNil: [oldClass organization copy]);
		superclass: superclass;
		subclasses: #();
		environment: self environment;
		yourself).

	oldClass notNil ifTrue: [
		oldClass become: newClass.
		swapTemp := oldClass.
		oldClass := newClass.
		newClass := swapTemp.
		oldClass subclasses ifNotNil: [:subclasses |
			subclasses do: [:eachSubclass |
				eachSubclass class superclass: oldMetaclass.
				eachSubclass superclass: oldClass]]].

	newMetaclass thisClass: newClass.

	^self newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
linkToSuperclass

	self superclass isNil ifTrue: [
		"If we don't have a superclass, our metaclasses superclass is Class"
		Class subclasses: (Class subclasses copyWith: self newClass class).
		^self].

	self superclass class subclasses: ((self superclass class subclasses ifNil: [#()]) copyWith: self newClass class).
	self superclass subclasses: ((self superclass subclasses ifNil: [#()]) copyWith: self newClass) ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
migrateInstances
	| newInstVarNames oldInstVarNames mapping |
	
	newInstVarNames := newClass allInstVarNames.
	oldInstVarNames := oldClass allInstVarNames.

	mapping := Array new: newInstVarNames size.
	1 to: newInstVarNames size do: [:newInstVarNumber |
		| index |
		index := oldInstVarNames indexOf: (newInstVarNames at: newInstVarNumber).
		index ~= 0 ifTrue: [
			mapping at: newInstVarNumber put: index]].

	newClass allInstances do: [:oldInstance |
		| newInstance |
		oldInstance setClass: oldClass.
		newInstance := newClass basicNew: oldInstance basicSize.
		newInstance migrateFrom: oldInstance instVarMapping: mapping.
		oldInstance become: newInstance] ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
modifyClass

	self hasDefinitionChanged ifFalse: [^self oldClass].

	self
		createClass;
		unlinkFromSuperclass;
		linkToSuperclass;
		addClassToEnvironment;
		addClassToKit;
		migrateInstances;
		recompileClass;
		modifySubclasses ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
modifySubclasses

	oldClass subclasses do: [:eachSubclass |
		self class new
			name: eachSubclass name;
			flags: (oldClass flags bitAnd: 16r3);
			oldClass: eachSubclass;
			superclass: self newClass;
			instanceVariableNames: eachSubclass instVarNames;
			classInstanceVariableNames: eachSubclass class instVarNames;
			"classVariableNames: oldClass classVarNames;"
			environment: oldClass environment;
			modifyClass]  ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
removeClassFromEnvironment

	self removeClassFromEnvironment: self oldClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
removeClassFromEnvironment: aClass

	aClass environment removeKey: aClass name.
	(KitManager current kitForClass: aClass ifNone: [nil]) ifNotNil: [:kit |
		kit removeClass: aClass].

	aClass methodDictionary do: [:method |
		method kit notNil ifTrue: [method kit removeMethod: method]].

	aClass class methodDictionary do: [:method |
		method kit notNil ifTrue: [method kit removeMethod: method]]. ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
unlinkFromSuperclass

	oldClass superclass isNil ifTrue: [
		"If the old class has a nil superclass, we still have to unlink the metaclass from Object"
		Class subclasses: (Class subclasses copyWithout: self newClass class).
		^self].

	oldClass superclass class subclasses ifNotNil: [:collection |
		oldClass superclass class subclasses: (collection copyWithout: self newClass class)].

	oldClass superclass subclasses ifNotNil: [:collection |
		oldClass superclass subclasses: (collection copyWithout: self newClass)] ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'removing'] value ! !
! ClassCreator methodsFor: 'removing' !
removeClass: aClass

	aClass withAllSubclasses do: [:each |
		self removeClassFromEnvironment: each].
	aClass superclass removeSubclass: aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'testing'] value ! !
! ClassCreator methodsFor: 'testing' !
hasDefinitionChanged

	self superclass == self oldClass superclass ifFalse: [^true].
	self instanceVariableNames = self oldClass instVarNames ifFalse: [^true].
	self classInstanceVariableNames = self oldClass class instVarNames ifFalse: [^true].
	self flags = (self oldClass flags bitAnd: 16rF) ifFalse: [^true].
	^false
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'accessing'] value ! !
! ClassDescription methodsFor: 'accessing' !
newOrganization: aString


	^self organization at: aString ifAbsentPut: [Set new] ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'accessing'] value ! !
! ClassDescription methodsFor: 'accessing' !
organization

	^organization ifNil: [organization := Dictionary new] ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'accessing'] value ! !
! ClassDescription methodsFor: 'accessing' !
organization: aDictionary

	^organization := aDictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'accessing'] value ! !
! ClassDescription methodsFor: 'accessing' !
organizationAt: aString add: aSymbol

	(self organizationFor: aSymbol) ifNotNil: [:organizationName |
		(self organization at: organizationName) remove: aSymbol].

	(self newOrganization: aString) add: aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'accessing'] value ! !
! ClassDescription methodsFor: 'accessing' !
organizationFor: aSymbol

	self organization keysAndValuesDo: [:key :value |
		(value includes: aSymbol) ifTrue: [^key]].

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'organization'] value ! !
! ClassDescription methodsFor: 'organization' !
basicCleanupOrganization

	| selectors badOrganizations |

	badOrganizations := OrderedCollection new.

	self organization keysAndValuesDo: [:key :set |
		key isSymbol ifTrue: [
			set do: [:selector | self organizationAt: key asString add: selector].
			badOrganizations add: key]].

	badOrganizations do: [:each | self organization removeKey: each].

	selectors := self selectors.
	self organization keysAndValuesDo: [:key :collection |
		collection copy do: [:eachSelector |
			(selectors includes: eachSelector)
				ifTrue: [selectors remove: eachSelector]
				ifFalse: [
					collection remove: eachSelector]]].

	selectors isEmpty ifFalse: [
		(self organization at: 'uncategorized' ifAbsentPut: [Set new]) addAll: selectors].
	
	self organization copy keysAndValuesDo: [:key :value |
		value isEmpty ifTrue: [self organization removeKey: key]]
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'organization'] value ! !
! ClassDescription methodsFor: 'organization' !
cleanupOrganization

	self basicCleanupOrganization.
	self class basicCleanupOrganization ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'organization'] value ! !
! ClassDescription methodsFor: 'organization' !
methodsInOrganization: aString

	^(organization at: aString ifAbsent: [^#()]) collect: [:eachSelector | self compiledMethodAt: eachSelector] ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'removing'] value ! !
! ClassDescription methodsFor: 'removing' !
removeSelector: aSymbol

	| oldProtocol |
	oldProtocol := self organizationFor: aSymbol.
	super removeSelector: aSymbol.
	(self organization at: oldProtocol ifAbsent: [^self])
		remove: aSymbol ifAbsent: [] ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
classDictionaries

	^#() ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
classTypeFlags

	^self flags bitAnd: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
classVarNames: aCollection

	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
environment

	^environment ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
environment: anObject

	environment := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
globalDictionaries

	^super globalDictionaries , self classDictionaries ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
isBytesClass

	^(self classTypeFlags bitAnd: 1) = 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
isVariableClass

	^(self classTypeFlags bitAnd: 2) = 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
kit

	^kit ifNil: [kit := KitManager current kitForClass: self] ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
kit: aKit

	kit := aKit ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
name: anObject

	name := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'accessing'] value ! !
! Class methodsFor: 'accessing' !
thisClass

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
byteSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 3
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
byteSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 3
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitString

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitString;
		buildClass;
		newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitString

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classVariableNames: classVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitString;
		buildClass;
		newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
variableSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: kitSymbol

	^self subclassNamed: aSymbol
		flags: 2
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: kitSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'creating'] value ! !
! Class methodsFor: 'creating' !
variableSubclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: kitSymbol

	^self subclassNamed: aSymbol
		flags: 2
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: kitSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
classInstVarNamesString

	| stream |
	stream := WriteStream on: (String new: 100).
	self class instVarNames
		do: [:name | stream nextPutAll: name]
		separatedBy: [stream space].
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
fileoutBytesDefinitionOn: aStream

	| kit |

	kit := KitManager current kitForClass: self.
	kit isNil ifTrue: [kit := KitManager current kitNamed: 'Core'].
 
	self superclass printOn: aStream.
	aStream
		nextPutAll: ' byteSubclassNamed: ';
		print: self name;
		cr; tab; nextPutAll: 'instVarNames: '; print: self instVarNamesString;
		cr; tab; nextPutAll: 'classInstVarNames: '; print: self classInstVarNamesString;
		cr; tab; nextPutAll: 'environment: Object systemDictionary';
		cr; tab; nextPutAll: 'kitName: '''; nextPutAll: kit name; nextPutAll: ''' !' ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
fileoutDefinitionOn: aStream

	self isBytesClass ifTrue: [^self fileoutBytesDefinitionOn: aStream].
	self isVariableClass ifTrue: [^self fileoutVariableDefinitionOn: aStream].
	self fileoutPlainClassDefinitionOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
fileoutPlainClassDefinitionOn: aStream

	| kit |

	kit := KitManager current kitForClass: self.
	kit isNil ifTrue: [kit := KitManager current kitNamed: 'Core'].
 
	self superclass printOn: aStream.
	aStream
		nextPutAll: ' subclassNamed: ';
		print: self name;
		cr; tab; nextPutAll: 'instVarNames: '; print: self instVarNamesString;
		cr; tab; nextPutAll: 'classInstVarNames: '; print: self classInstVarNamesString;
		cr; tab; nextPutAll: 'environment: Object systemDictionary';
		cr; tab; nextPutAll: 'kitName: '''; nextPutAll: kit name; nextPutAll: ''' !' ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
fileoutSource

	| stream |

	self log: 'fileout: ', self name.

	stream := ('stSource' asFilename construct: self name asString, '.st') writeStream.
	self fileoutSourceOn: stream.
	stream close ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
fileoutSourceOn: aStream

	self fileoutDefinitionOn: aStream.
	aStream cr; cr.
	self fileoutMethodsOn: aStream.
	self class fileoutMethodsOn: aStream.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
fileoutVariableDefinitionOn: aStream
	| kit |

	kit := KitManager current kitForClass: self.
	kit isNil ifTrue: [kit := KitManager current kitNamed: 'Core'].
 
	self superclass printOn: aStream.
	aStream
		nextPutAll: ' variableSubclassNamed: ';
		print: self name;
		cr; tab; nextPutAll: 'instVarNames: '; print: self instVarNamesString;
		cr; tab; nextPutAll: 'classInstVarNames: '; print: self classInstVarNamesString;
		cr; tab; nextPutAll: 'environment: Object systemDictionary';
		cr; tab; nextPutAll: 'kitName: '''; nextPutAll: kit name; nextPutAll: ''' !' ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'fileIn/Out'] value ! !
! Class methodsFor: 'fileIn/Out' !
instVarNamesString

	| stream |
	stream := WriteStream on: (String new: 100).
	self instVarNames
		do: [:name | stream nextPutAll: name]
		separatedBy: [stream space].
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'migrating'] value ! !
! Class methodsFor: 'migrating' !
migrateAllInstancesFrom: oldClass
	
	| newInstVarNames oldInstVarNames mapping |
	
	newInstVarNames := self allInstVarNames.
	oldInstVarNames := oldClass allInstVarNames.

	mapping := Array new: newInstVarNames size.
	1 to: newInstVarNames size do: [:newInstVarNumber |
		| index |
		index := oldInstVarNames indexOf: (newInstVarNames at: newInstVarNumber).
		index ~= 0 ifTrue: [
			mapping at: newInstVarNumber put: index]].

	oldClass allInstances do: [:oldInstance |
		| newInstance |
		newInstance := self basicNew: oldInstance basicSize.
		newInstance migrateFrom: oldInstance instVarMapping: mapping.
		oldInstance become: newInstance].
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'migrating'] value ! !
! Class methodsFor: 'migrating' !
migrateClassFrom: oldClass

	| newInstVarNames oldInstVarNames mapping |
	
	newInstVarNames := self class allInstVarNames.
	oldInstVarNames := oldClass class allInstVarNames.

	oldInstVarNames = newInstVarNames ifTrue: [^self].
	
	mapping := Array new: newInstVarNames size.
	1 to: newInstVarNames size do: [:newInstVarNumber |
		| index |
		index := oldInstVarNames indexOf: (newInstVarNames at: newInstVarNumber).
		index ~= 0 ifTrue: [
			mapping at: newInstVarNumber put: index]].

	self migrateFrom: oldClass instVarMapping: mapping ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'printing'] value ! !
! Class methodsFor: 'printing' !
printOn: aStream

	^aStream nextPutAll: self name ! !
! Doit class methodsFor: 'doit' !
doit ^[Class methodsFor: 'removing'] value ! !
! Class methodsFor: 'removing' !
removeSubclass: aClass

	self class basicRemoveSubclass: aClass class.
	self basicRemoveSubclass: aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'accessing'] value ! !
! Collection methodsFor: 'accessing' !
includes: anObject 

	self do: [:each | 
		each = anObject ifTrue: [^true]].
	
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'accessing'] value ! !
! Collection methodsFor: 'accessing' !
size

	^self basicSize ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'converting'] value ! !
! Collection methodsFor: 'converting' !
asArray
	| array index |

	(self isMemberOf: Array) ifTrue: [^self].
	
	array := Array new: self size.
	index := 1.
	self do: [:each |
		array at: index put: each.
		index := index + 1].
	^array
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'converting'] value ! !
! Collection methodsFor: 'converting' !
asByteArray
	| array index |

	(self isMemberOf: ByteArray) ifTrue: [^self].
	
	array := ByteArray new: self size.
	index := 1.
	self do: [:each |
		array at: index put: each.
		index := index + 1].
	^array
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'converting'] value ! !
! Collection methodsFor: 'converting' !
asOrderedCollection
	| orderedCollection |

	(self isMemberOf: OrderedCollection) ifTrue: [^self].
	
	orderedCollection := OrderedCollection new: self size.
	self do: [:each |
		orderedCollection add: each].
	^orderedCollection
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'converting'] value ! !
! Collection methodsFor: 'converting' !
asSet
	| set |

	(self isMemberOf: Set) ifTrue: [^self].
	
	set := Set new: self size.
	self do: [:each |
		set add: each].
	^set
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
allSatisfy: aBlock 

	self do: [:each | (aBlock value: each) = true
			ifFalse: [^false]].
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
anySatisfy: aBlock 

	self do: [:each | 
		(aBlock value: each) = true ifTrue: [^true].
		nil].
	
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
collect: aBlock 

	| result |
	result := self species new: self size.
	self do: [:each | result add: (aBlock value: each)].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
detect: aBlock

	^self detect: aBlock ifNone: [self halt] ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
detect: aBlock ifNone: noneBlock

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^noneBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
do: aBlock 

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
do: aBlock separatedBy: aBlock2

	| hasStarted |

	hasStarted := false.
	self do: [:each |
		hasStarted ifTrue: [aBlock2 value].
		hasStarted := true.
		aBlock value: each] ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
inject: anObject into: aBlock

	| result |
	result := anObject.
	self do: [:each | result := aBlock value: result value: each].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
occurrencesOf: anObject

	| occurrences |

	occurrences := 0.
	self do: [:each | each = anObject ifTrue: [occurrences := occurrences + 1]].
	^occurrences ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
reject: aBlock 

	^self select: [:each | (aBlock value: each) not] ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'enumerating'] value ! !
! Collection methodsFor: 'enumerating' !
select: aBlock 

	| result |
	result := self species new: self size.
	self do: [:each | (aBlock value: each)
			ifTrue: [result add: each]
			ifFalse: [nil]].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'printing'] value ! !
! Collection methodsFor: 'printing' !
printCollectionEndOn: aStream
	aStream nextPut: $) ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'printing'] value ! !
! Collection methodsFor: 'printing' !
printCollectionStartOn: aStream
	aStream
		nextPutAll: self class name;
		nextPutAll: ' (' ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'printing'] value ! !
! Collection methodsFor: 'printing' !
printOn: aStream

	| count |
	count := 0.

	self printCollectionStartOn: aStream.
	self
		do: [:each |
			each printOn: aStream.
			count := count + 1.
			count > 100 ifTrue: [
				aStream nextPutAll: '...'.
				self printCollectionEndOn: aStream.
				^self]]
		separatedBy: [aStream space].

	self printCollectionEndOn: aStream
	  ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'printing'] value ! !
! Collection methodsFor: 'printing' !
printOn: aStream limit: aNumber

	| count |
	count := 0.
	self printCollectionStartOn: aStream.
	self
		do: [:each |
			each printOn: aStream.
			count := count + 1.
			count > aNumber ifTrue: [
				aStream nextPutAll: '...'.
				self printCollectionEndOn: aStream.
				^self]]
		separatedBy: [aStream space].

	self printCollectionEndOn: aStream
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'printing'] value ! !
! Collection methodsFor: 'printing' !
storeOn: aStream

	self printCollectionStartOn: aStream.
	self
		do: [:each | each printOn: aStream]
		separatedBy: [aStream space].

	self printCollectionEndOn: aStream
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'private'] value ! !
! Collection methodsFor: 'private' !
species

	^self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'removing'] value ! !
! Collection methodsFor: 'removing' !
remove: anObject

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'removing'] value ! !
! Collection methodsFor: 'removing' !
removeAll: aCollection

	aCollection do: [:each | self remove: each] ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'testing'] value ! !
! Collection methodsFor: 'testing' !
isCollection

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'testing'] value ! !
! Collection methodsFor: 'testing' !
isEmpty

	^self size = 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Collection methodsFor: 'testing'] value ! !
! Collection methodsFor: 'testing' !
notEmpty

	^self isEmpty not ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
allNestedLiterals

	| literals |

	literals := OrderedCollection new: self basicSize.
	1 to: self basicSize do: [:index |
		literals add: (self at: index).
		(self at: index) isBlock ifTrue: [
			literals addAll: (self at: index) allNestedLiterals]].

	^literals asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
bytecodes

	^bytecodes ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
bytecodes: anObject

	bytecodes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
callOffsetsIn: anObject do: aBlock

	| decompileStream line matchNext offset|

	matchNext := false.

	decompileStream := anObject decompileNoBytes readStream.
	[decompileStream atEnd] whileFalse: [
		line := decompileStream upTo: Character cr.
		matchNext ifTrue: [
			offset := line trimSeparators readStream upTo: $:.
			aBlock value: (Integer readHexFrom: offset readStream).
			matchNext := false].
		('*call*' match: line) ifTrue: [matchNext := true]
		] ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
getSource

	| stream |

	stream := (BeagleSystem sourceFileNames at: (self sourceOffsets at: 1)) asFilename readStream.
	^[stream position: (self sourceOffsets at: 2).
		stream next: (self sourceOffsets at: 3) - (self sourceOffsets at: 2)]
		ensure: [stream close]  ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
literals

	| literals |

	literals := Array new: self basicSize.
	1 to: self basicSize do: [:index |
		literals at: index put: (self at: index)].

	^literals ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
localVariableNames

	^localVariableNames ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
localVariableNames: anObject

	localVariableNames := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
mclass

	^mclass ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
mclass: anObject

	mclass := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
methodOffsets

	^self sourceOffsets copyFrom: 2 to: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
numberOfArguments

	^numberOfArguments ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
numberOfArguments: anObject

	numberOfArguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
numberOfLocals

	^self numberOfArguments + self numberOfTemporaries ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
numberOfSendsIn: anObject

	| numberOfSends |
	numberOfSends := 0.
	self callOffsetsIn: anObject do: [:offset |
		numberOfSends := numberOfSends + 1].

	^numberOfSends ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
numberOfTemporaries

	^numberOfTemporaries ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
numberOfTemporaries: anObject

	numberOfTemporaries := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
sourceOffsets

	^sourceOffsets ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
sourceOffsets: anObject

	sourceOffsets := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
sourceOffsetsDictionary

	| dictionary |
	dictionary := Dictionary new.
	4 to: self sourceOffsets size by: 3 do: [:index |
		dictionary
			at: (self sourceOffsets at: index)
			put: (Array
					with: (self sourceOffsets at: index + 1)
					with: (self sourceOffsets at: index + 2))].
	^dictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
writeMethodOffsets: anArray

	anArray isNil ifTrue: [^self].

	self sourceOffsets
		at: 1 put: 2;
		at: 2 put: (anArray at: 1);
		at: 3 put: (anArray at: 2).

	self literals do: [:eachLiteral |
		eachLiteral isCompiledBlock ifTrue: [
			eachLiteral writeMethodOffsets: anArray].
		eachLiteral isBlockClosure ifTrue: [
			eachLiteral method writeMethodOffsets: anArray].
		] ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'navigating'] value ! !
! CompiledCode methodsFor: 'navigating' !
findSendWithOffset: aNumber

	4 to: self sourceOffsets size by: 3 do: [:offset |
		| bytecodeOffset sourceStart sourceEnd |
		bytecodeOffset := self sourceOffsets at: offset.
		sourceStart := self sourceOffsets at: offset + 1.
		sourceEnd := self sourceOffsets at: offset + 2.

		(aNumber between: sourceStart and: sourceEnd) ifTrue: [
			| stream |
			stream := self decompile readStream.
			[stream atEnd] whileFalse: [
				| line lineStream |
				line := stream upTo: Character cr.
				lineStream := line readStream.
				(lineStream upTo: $:) trimSeparators = bytecodeOffset hex ifTrue: [
					lineStream upToAll: 'literal '.
					^self at: (Integer readFrom: lineStream) + 1]
				]
			]
		].

	self literals do: [:literal |
		literal isBlockClosure ifTrue: [
			| selector |
			selector := literal method findSendWithOffset: aNumber.
			selector isNil ifFalse: [^selector]].
		literal isCompiledBlock ifTrue: [
			| selector |
			selector := literal findSendWithOffset: aNumber.
			selector isNil ifFalse: [^selector]].
	].

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'accessing'] value ! !
! CompiledBlock methodsFor: 'accessing' !
outerMethod

	^outerMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'accessing'] value ! !
! CompiledBlock methodsFor: 'accessing' !
outerMethod: anObject

	outerMethod := anObject.
	1 to: self basicSize do: [:index |
		| literal |
		literal := self basicAt: index.
		literal isCompiledBlock ifTrue: [literal outerMethod: anObject].
		literal isBlockClosure ifTrue: [literal method outerMethod: anObject] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'accessing'] value ! !
! CompiledBlock methodsFor: 'accessing' !
rootMethod

	^self outerMethod rootMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'printing'] value ! !
! CompiledBlock methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: '[] in ';
		print: self outerMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'running'] value ! !
! CompiledBlock methodsFor: 'running' !
value

	<primitive: 501>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'running'] value ! !
! CompiledBlock methodsFor: 'running' !
value: anObject

	<primitive: 502>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'running'] value ! !
! CompiledBlock methodsFor: 'running' !
value: anObject value: anotherObject

	<primitive: 503>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'testing'] value ! !
! CompiledBlock methodsFor: 'testing' !
isBlock

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledBlock methodsFor: 'testing'] value ! !
! CompiledBlock methodsFor: 'testing' !
isCompiledBlock

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
allMessages

	| selectors |
	selectors := Set new.
	self allNestedLiterals do: [:literal |
		literal isSymbol ifTrue: [
			selectors add: literal]].

	^selectors asOrderedCollection sorted addFirst: self selector; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
definingKit

	^self kit ifNil: [KitManager current kitForClass: self mclass thisClass] ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
kit

	^kit ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
kit: aKit

	kit := aKit ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
organization

	^self mclass organizationFor: self selector ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
rootMethod

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'accessing'] value ! !
! CompiledMethod methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'fileout'] value ! !
! CompiledMethod methodsFor: 'fileout' !
fileoutOn: aStream

	aStream nextPutAll: self getSource ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'printing'] value ! !
! CompiledMethod methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: self mclass name;
		nextPutAll: ' >> ';
		nextPutAll: self selector ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledMethod methodsFor: 'testing'] value ! !
! CompiledMethod methodsFor: 'testing' !
isPrimitive

	^self bytecodes first = 16rDB ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'accessing'] value ! !
! ComputedField methodsFor: 'accessing' !
action

	^action ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'accessing'] value ! !
! ComputedField methodsFor: 'accessing' !
action: anObject

	action := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'accessing'] value ! !
! ComputedField methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'accessing'] value ! !
! ComputedField methodsFor: 'accessing' !
name: anObject

	name := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'converting'] value ! !
! ComputedField methodsFor: 'converting' !
asString

	^'- ', self name ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'evaluating'] value ! !
! ComputedField methodsFor: 'evaluating' !
valueFor: anObject

	^self action value: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'printing'] value ! !
! ComputedField methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: self name;
		nextPutAll: ' ==> ';
		print: self action ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField methodsFor: 'testing'] value ! !
! ComputedField methodsFor: 'testing' !
isComputedField

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[ComputedField class methodsFor: 'instance creation'] value ! !
! ComputedField class methodsFor: 'instance creation' !
name: aString action: aValueModel

	^self new
		name: aString;
		action: aValueModel;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
addAssociation: anAssociation 

	| foundValue index |
	index := self findIndex: anAssociation key.
	(foundValue := values at: index) notNil ifTrue: [
		foundValue value: anAssociation value.
		^anAssociation value].
	tally := tally + 1.
	values at: index put: anAssociation.
	self growIfNeeded.
	^anAssociation value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
associationAt: aKey

	| index |
	
	index := self findIndex: aKey.
	index = 0 ifTrue: [^nil].
	^values at: index ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
associationAt: aKey ifAbsent: aBlock

	| index |
	
	index := self findIndex: aKey.
	index = 0 ifTrue: [^aBlock value].
	^values at: index ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
associations

	| collection |
	collection := OrderedCollection new: self size.
	self associationsDo: [:assoc | collection add: assoc].
	^collection
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
at: anObject 

	| association index |
	index := self findIndex: anObject.
	(association := values at: index) isNil ifTrue: [^self error: 'Key [' , anObject printString, '] not found'].
	^association value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
at: key ifAbsent: aBlock 

	| association index |
	index := self findIndex: key.
	(association := values at: index) isNil ifTrue: [^aBlock value].
	^association value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
at: key ifAbsentPut: aBlock 

	| association index |
	index := self findIndex: key.
	(association := values at: index) isNil ifTrue: [^self at: key put: aBlock value].
	^association value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
at: key put: value 

	| association index |
	index := self findIndex: key.
	index = 0 ifTrue: [
		self growIfNeeded.
		index := self findIndex: key].
	(association := values at: index) notNil
		ifTrue: 
			[association value: value.
			^value].
	tally := tally + 1.
	values at: index put: (Association key: key value: value).
	self growIfNeeded.
	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
basicValues
	^values ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
bindingFor: aKey

	^self associationAt: aKey ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
doesKey: key match: anObject

	^key = anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
findIndex: anObject 

	| probe association initialProbe |

	initialProbe := probe := self initialProbeFor: anObject.
	initialProbe = 0 ifTrue: [^0].

	[(association := values at: probe) isNil ifTrue: [^probe].
	(self doesKey: association key match: anObject) ifTrue: [^probe].
	(probe := probe + 1) > values size ifTrue: [probe := 1].
	probe = initialProbe ifTrue: [^self error: self class printString , ' is completely full'].
	true] whileTrue.
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
growIfNeeded

	| oldValues newDictionary |
	(values size > 0 and: [
		tally * 100 // values size <= 70]) ifTrue: [^self].

	oldValues := values.
	newDictionary := self class new: (values size max: 5) * 2.

	oldValues do: [:each | each isNil
			ifFalse: [newDictionary addAssociation: each]].
	
	values := newDictionary basicValues ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
includesKey: anObject 
	| index |
	index := self findIndex: anObject.
	index = 0 ifTrue: [^false].
	^(values at: index) notNil ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
initialProbeFor: anObject 
	values isEmpty ifTrue: [^0].
	^anObject hash \\ values size + 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
keys

	| set |
	set := Set new: values size.
	values do: [:each | each notNil
			ifTrue: [set add: each key]].
	^set ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
rehash

	| newDictionary |

	newDictionary := self class new: values size.
	self associationsDo: [:each |
		newDictionary addAssociation: each].

	self become: newDictionary
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
size

	^tally ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'accessing'] value ! !
! Dictionary methodsFor: 'accessing' !
values

	| result |
	result := OrderedCollection new: self size.
	values do: [:each | each notNil
			ifTrue: [result add: each value]].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'copying'] value ! !
! Dictionary methodsFor: 'copying' !
copy

	| copy |
	copy := self class new: values size.
	self keysAndValuesDo: [:key :value |
		copy at: key put: value].
	
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'copying'] value ! !
! Dictionary methodsFor: 'copying' !
copyWithAssociations

	| copy |
	copy := self class new: values size.
	self associationsDo: [:assoc |
		copy addAssociation: assoc].
	
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'enumerating'] value ! !
! Dictionary methodsFor: 'enumerating' !
associationsDo: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each]
			ifFalse: [nil]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'enumerating'] value ! !
! Dictionary methodsFor: 'enumerating' !
do: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each value]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'enumerating'] value ! !
! Dictionary methodsFor: 'enumerating' !
keysAndValuesDo: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each key value: each value]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'enumerating'] value ! !
! Dictionary methodsFor: 'enumerating' !
keysDo: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each key]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'initialize-release'] value ! !
! Dictionary methodsFor: 'initialize-release' !
initialize: size 

	tally := 0.
	values := Array new: (size max: 10) ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'removing'] value ! !
! Dictionary methodsFor: 'removing' !
privateRemoveKey: anObject 

	| probe initialProbe valuesToReHash rehashProbe oldObject |

	oldObject := self at: anObject.
	initialProbe := self initialProbeFor: anObject.
	probe := self findIndex: anObject.
	values at: probe put: nil.
	tally := tally - 1.

	"A poor man's rehash."
	self become: self copyWithAssociations.

	"valuesToReHash := OrderedCollection new.

	rehashProbe := initialProbe + 1.
	rehashProbe > values size ifTrue: [rehashProbe := 1].

	[(values at: rehashProbe) isNil] whileFalse: [
		valuesToReHash add: (values at: rehashProbe).
		values at: rehashProbe put: nil.
		tally := tally - 1.
		(rehashProbe := rehashProbe + 1) > values size ifTrue: [rehashProbe := 1].
		rehashProbe = initialProbe ifTrue: [self error: 'No nils left in set'. ^nil]].

	valuesToReHash do: [:eachAssociation | self addAssociation: eachAssociation]."

	^oldObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'removing'] value ! !
! Dictionary methodsFor: 'removing' !
removeKey: anObject

	| newDictionary oldObject |

	newDictionary := self copyWithAssociations.
	oldObject := newDictionary privateRemoveKey: anObject.
	values := newDictionary basicValues.
	tally := newDictionary size.
	^oldObject
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'removing'] value ! !
! Dictionary methodsFor: 'removing' !
removeKey: anObject ifAbsent: aBlock

	(self includesKey: anObject) ifFalse: [^aBlock value].
	^self removeKey: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'testing'] value ! !
! Dictionary methodsFor: 'testing' !
isDictionary

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary class methodsFor: 'instance creation'] value ! !
! Dictionary class methodsFor: 'instance creation' !
new

	^self new: 20 ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary class methodsFor: 'instance creation'] value ! !
! Dictionary class methodsFor: 'instance creation' !
new: size 

	^self basicNew initialize: size ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary class methodsFor: 'instance creation'] value ! !
! Dictionary class methodsFor: 'instance creation' !
rehashAllDictionaries

	(self withAllSubclasses) do: [:class |
		class allInstances do: [:instance | instance rehash].
		].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Doit class methodsFor: 'uncategorized'] value ! !
! Doit class methodsFor: 'uncategorized' !
doit ^[KitManager current fileoutAllKits] value ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase methodsFor: 'accessing'] value ! !
! EventBase methodsFor: 'accessing' !
eventRegistry
	^eventRegistry ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase methodsFor: 'initializing'] value ! !
! EventBase methodsFor: 'initializing' !
initialize

	eventRegistry := Dictionary new ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase methodsFor: 'initializing'] value ! !
! EventBase methodsFor: 'initializing' !
onEvent: anEventKey do: aBlock

	(eventRegistry at: anEventKey ifAbsentPut: [OrderedCollection new])
		add: aBlock  ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase methodsFor: 'raising'] value ! !
! EventBase methodsFor: 'raising' !
raiseEvent: anEvent

	(eventRegistry at: anEvent eventKey ifAbsent: [^false])
		do: [:eachBlock | eachBlock cull: anEvent].
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase class methodsFor: 'instance creation'] value ! !
! EventBase class methodsFor: 'instance creation' !
new
	^super new initialize; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
action

	^action ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
action: anObject

	action := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
asString

	^self message ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
message

	^message ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
message: anObject

	message := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
result

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'accessing'] value ! !
! Exception methodsFor: 'accessing' !
result: anObject

	result := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'handling'] value ! !
! Exception methodsFor: 'handling' !
pass

	action := #pass ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'handling'] value ! !
! Exception methodsFor: 'handling' !
raiseSignal

	| handler |

	handler := self class handlerFor: self before: nil.

	[handler notNil and: [
		handler catchBlock cull: self.
		self action = #resume ifTrue: [^self].
		self action = #pass]] whileTrue: [
		handler := self class handlerFor: self before: handler] ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'handling'] value ! !
! Exception methodsFor: 'handling' !
resume

	action := #resume ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'handling'] value ! !
! Exception methodsFor: 'handling' !
retry

	action := #retry ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'handling'] value ! !
! Exception methodsFor: 'handling' !
return

	result := self.
	action := #return ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'handling'] value ! !
! Exception methodsFor: 'handling' !
return: anObject

	result := anObject.
	action := #return ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception methodsFor: 'printing'] value ! !
! Exception methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' - ';
		nextPutAll: self message ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'accessing'] value ! !
! Exception class methodsFor: 'accessing' !
try: tryBlock catch: catchBlock

	^self try: tryBlock catch: catchBlock finally: nil ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'accessing'] value ! !
! Exception class methodsFor: 'accessing' !
try: tryBlock catch: catchBlock finally: finallyBlock

	| wrappedCatchBlock result handler |

	handler := ExceptionHandler new
		exceptionClass: (catchBlock ifNil: [nil] ifNotNil: [self]);
		finallyBlock: finallyBlock;
		yourself.

	wrappedCatchBlock := catchBlock ifNil: [nil] ifNotNil: [[:ex |
		catchBlock cull: ex.
		ex action = #return ifTrue: [
			handler unwind.
			^ex result].
		ex action = #retry ifTrue: [
			result := tryBlock value] ] ].
	
	handler catchBlock: wrappedCatchBlock.

	self exceptionHandlers add: handler.

	result := tryBlock value.
	handler unwind.

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'accessing'] value ! !
! Exception class methodsFor: 'accessing' !
try: tryBlock finally: finallyBlock

	^self try: tryBlock catch: nil finally: finallyBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'instance creation'] value ! !
! Exception class methodsFor: 'instance creation' !
, anException

	^ExceptionList new
		addException: self;
		addException: anException;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'instance creation'] value ! !
! Exception class methodsFor: 'instance creation' !
exceptionHandlers

	<primitive: 554>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'instance creation'] value ! !
! Exception class methodsFor: 'instance creation' !
handlerFor: anException before: aHandler

	| startingHandlerIndex |

	startingHandlerIndex := aHandler isNil
		ifTrue: [self exceptionHandlers size]
		ifFalse: [self exceptionHandlers indexOf: aHandler].

	startingHandlerIndex to: 1 by: -1 do: [:index |
		| handler |
		handler := self exceptionHandlers at: index.
		(handler exceptionClass notNil and: [handler exceptionClass handlesException: anException]) ifTrue: [^handler]].

	^nil. ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'signalling'] value ! !
! Exception class methodsFor: 'signalling' !
defaultErrorString

	^'Unhandled Exception' ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'signalling'] value ! !
! Exception class methodsFor: 'signalling' !
findSendWithOffset: aNumber

	4 to: self sourceOffsets size by: 3 do: [:offset |
		| bytecodeOffset sourceStart sourceEnd |
		bytecodeOffset := self sourceOffsets at: offset.
		sourceStart := self sourceOffsets at: offset + 1.
		sourceEnd := self sourceOffsets at: offset + 2.

		(aNumber between: sourceStart and: sourceEnd) ifTrue: [
			| stream |
			stream := self decompile readStream.
			[stream atEnd] whileFalse: [
				| line |
				line := stream upTo: Character cr.
				(line readStream upTo: $:) trimSeparators = bytecodeOffset hex ifTrue: [
					self log: line]
				]
			]
		].

	^#gotIt
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'signalling'] value ! !
! Exception class methodsFor: 'signalling' !
handlesException: anException

	^anException isKindOf: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'signalling'] value ! !
! Exception class methodsFor: 'signalling' !
signal

	self signal: self defaultErrorString ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'signalling'] value ! !
! Exception class methodsFor: 'signalling' !
signal: aString

	self new
		message: aString;
		raiseSignal ! !
! Doit class methodsFor: 'doit' !
doit ^[Exception class methodsFor: 'signalling'] value ! !
! Exception class methodsFor: 'signalling' !
unwindTo: aHandler

	| index |

	index := self exceptionHandlers indexOf: aHandler.
	index = 0 ifTrue: [^self].
	self exceptionHandlers size to: index by: -1 do: [:eachIndex |
		(self exceptionHandlers at: eachIndex) finallyBlock ifNotNil: [:block |
				block value].
		self exceptionHandlers removeLast] ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionBase methodsFor: 'accessing'] value ! !
! ExceptionBase methodsFor: 'accessing' !
catchBlock

	^catchBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionBase methodsFor: 'accessing'] value ! !
! ExceptionBase methodsFor: 'accessing' !
catchBlock: anObject

	catchBlock := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionBase methodsFor: 'accessing'] value ! !
! ExceptionBase methodsFor: 'accessing' !
finallyBlock

	^finallyBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionBase methodsFor: 'accessing'] value ! !
! ExceptionBase methodsFor: 'accessing' !
finallyBlock: anObject

	finallyBlock := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionBase methodsFor: 'handling'] value ! !
! ExceptionBase methodsFor: 'handling' !
unwind

	Exception unwindTo: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'accessing'] value ! !
! ExceptionHandler methodsFor: 'accessing' !
catchBlock

	^catchBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'accessing'] value ! !
! ExceptionHandler methodsFor: 'accessing' !
catchBlock: anObject

	catchBlock := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'accessing'] value ! !
! ExceptionHandler methodsFor: 'accessing' !
exceptionClass

	^exceptionClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'accessing'] value ! !
! ExceptionHandler methodsFor: 'accessing' !
exceptionClass: anObject

	exceptionClass := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'accessing'] value ! !
! ExceptionHandler methodsFor: 'accessing' !
finallyBlock

	^finallyBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'accessing'] value ! !
! ExceptionHandler methodsFor: 'accessing' !
finallyBlock: anObject

	finallyBlock := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'handling'] value ! !
! ExceptionHandler methodsFor: 'handling' !
handlesException: anException

	^self exceptionClass notNil and: [anException isKindOf: self exceptionClass] ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionHandler methodsFor: 'handling'] value ! !
! ExceptionHandler methodsFor: 'handling' !
unwind

	Exception unwindTo: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'accessing'] value ! !
! ExceptionList methodsFor: 'accessing' !
exceptions

	^exceptions ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'accessing'] value ! !
! ExceptionList methodsFor: 'accessing' !
exceptions: anObject

	exceptions := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'adding'] value ! !
! ExceptionList methodsFor: 'adding' !
, anException

	self addException: anException
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'adding'] value ! !
! ExceptionList methodsFor: 'adding' !
addException: anException

	exceptions add: anException
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'handling'] value ! !
! ExceptionList methodsFor: 'handling' !
exceptionHandlers

	^Exception exceptionHandlers ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'handling'] value ! !
! ExceptionList methodsFor: 'handling' !
handlesException: anException

	^self exceptions anySatisfy: [:each | each handlesException: anException] ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'handling'] value ! !
! ExceptionList methodsFor: 'handling' !
try: tryBlock catch: catchBlock

	^Exception try: tryBlock catch: catchBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'handling'] value ! !
! ExceptionList methodsFor: 'handling' !
try: tryBlock catch: catchBlock finally: finallyBlock

	^Exception try: tryBlock catch: catchBlock finally: finallyBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'handling'] value ! !
! ExceptionList methodsFor: 'handling' !
try: tryBlock finally: finallyBlock

	^Exception try: tryBlock finally: finallyBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList methodsFor: 'initializing'] value ! !
! ExceptionList methodsFor: 'initializing' !
initialize

	exceptions := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[ExceptionList class methodsFor: 'instance creation'] value ! !
! ExceptionList class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
& aBoolean 

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
and: aBlock 

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
ifFalse: aBlock 

	^aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
ifFalse: falseBlock ifTrue: trueBlock 

	^falseBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
ifTrue: aBlock 

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
ifTrue: trueBlock ifFalse: falseBlock 

	^falseBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
not

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
or: aBlock 

	^aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'accessing'] value ! !
! False methodsFor: 'accessing' !
| aBoolean 

	^aBoolean ! !
! Doit class methodsFor: 'doit' !
doit ^[False methodsFor: 'printing'] value ! !
! False methodsFor: 'printing' !
printOn: aStream 

	aStream nextPutAll: 'false' ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'accessing'] value ! !
! Filename methodsFor: 'accessing' !
appendStream

	^(FileStream new open: self path mode: FileStream append) ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'accessing'] value ! !
! Filename methodsFor: 'accessing' !
asFilename

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'accessing'] value ! !
! Filename methodsFor: 'accessing' !
path

	^path ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'accessing'] value ! !
! Filename methodsFor: 'accessing' !
path: anObject

	path := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'accessing'] value ! !
! Filename methodsFor: 'accessing' !
readStream

	^(FileStream new open: self path mode: FileStream read) ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'accessing'] value ! !
! Filename methodsFor: 'accessing' !
writeStream

	^(FileStream new open: self path mode: FileStream write) ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'fileIn/Out'] value ! !
! Filename methodsFor: 'fileIn/Out' !
fileIn

	| file |

	BeagleSystem log: 'Filing in ', self path.
	file := self readStream.
	file fileIn.
	file close ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
/ aString

	^self construct: aString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
\ aString

	^self construct: aString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
asCoreFilename

	^path asVWString asFilename ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
asString

	^path ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
construct: aString

	^self class named: self path, self class pathDelimiterString, aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
copyTo: destinationPathString

	| file1 file2 |

	file1 := self readStream.
	file2 := destinationPathString asFilename writeStream.
	[file1 atEnd] whileFalse: [
		file2 nextPut: file1 next].
	file1 close.
	file2 close ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
fileSize

	^self class sizeOfFile: path ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'operations'] value ! !
! Filename methodsFor: 'operations' !
renameTo: destinationPathString

	^self class rename: path to: destinationPathString ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename methodsFor: 'testing'] value ! !
! Filename methodsFor: 'testing' !
exists

	^self class fileExists: path ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'instance creation'] value ! !
! Filename class methodsFor: 'instance creation' !
getInternalPath

	<primitive: 800>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'instance creation'] value ! !
! Filename class methodsFor: 'instance creation' !
internalPath

	^self named: (self getInternalPathX) ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'instance creation'] value ! !
! Filename class methodsFor: 'instance creation' !
named: aString

	^self new
		path: aString;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'operations'] value ! !
! Filename class methodsFor: 'operations' !
fileExists: aString

	<primitive: 1403>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'operations'] value ! !
! Filename class methodsFor: 'operations' !
pathDelimiterString

	<primitive: 1513>
	^'/' ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'operations'] value ! !
! Filename class methodsFor: 'operations' !
rename: originPathString to: destinationPathString

	<primitive: 1405>
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'operations'] value ! !
! Filename class methodsFor: 'operations' !
sizeOfFile: aZeroTerminatedString
	
	<primitive: 1404>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Filename class methodsFor: 'operations'] value ! !
! Filename class methodsFor: 'operations' !
unpackAssetToInternalPath: aString

	<primitive: 801>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[HaltException methodsFor: 'signaling'] value ! !
! HaltException methodsFor: 'signaling' !
raiseSignal2

	self raiseSignal
 ! !
! Doit class methodsFor: 'doit' !
doit ^[HaltException class methodsFor: 'signalling'] value ! !
! HaltException class methodsFor: 'signalling' !
signal: aString

	self new
		message: aString;
		raiseSignal2 ! !
! Doit class methodsFor: 'doit' !
doit ^[IdentityDictionary methodsFor: 'accessing'] value ! !
! IdentityDictionary methodsFor: 'accessing' !
doesKey: key match: anObject

	^key == anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[IdentityDictionary methodsFor: 'accessing'] value ! !
! IdentityDictionary methodsFor: 'accessing' !
initialProbeFor: anObject 
	values isEmpty ifTrue: [^0].
	^anObject identityHash \\ values size + 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
ifFalseIfTrueTest

	| result |

	self isNil
		ifFalse: [result := 5]
		ifTrue: [result := 6].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
ifFalseReturnTest

	| result |

	self isNil
		ifFalse: [^result := 5].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
ifFalseTest

	| result |

	self isNil
		ifFalse: [result := 5].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
ifTrueIfFalseTest

	| result |

	self isNil
		ifTrue: [
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
	result := 5 * 43 * 21 * 98 * 97 * 35 * 46.
]
		ifFalse: [result := 6].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
initialize

	instVar1 := 5.
	instVar2 := 7

 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod

	| factorial hash |

	factorial := 1.
	hash := super hash.

	1 to: 5 do: [:x |	factorial := factorial * x].

	^factorial * 5
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod10

	^[CompileError new raiseSignal.  3 + 4]
		on: CompileError
		do: [:ex | ex resume].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod2

	self initialize.
	^[instVar1 := 6] value. ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod3

	^(3 + 4) ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod4

	self halt.
	^super isKindOf: Object ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod5

	"Junk"

	self halt.
	^self perform: #junkMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod6

	| y |

	"Junk xxxx"

	y := 0.
	instVar1 := 3.

	^[:x | x ifNotNil: [self halt. instVar1 * x + y]] value: 5  ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod7

	| a |
	a := 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
junkMethod8

	self
		basicAt: 3 - 1 * 2 + 1;
		basicAt: 3 - 1 * 2 + 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
method2: aNumber

	^aNumber cos + instVar1 + instVar2 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
nonLocalReturn

	self ifNotNil: [:object | ^self].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
nonLocalReturnA

	self nonLocalReturnB: [^self]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
nonLocalReturnB: aBlock

	self halt.
	aBlock value

 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass methodsFor: 'junk'] value ! !
! JunkClass methodsFor: 'junk' !
nonLocalReturnC

	self nonLocalReturnA.
	^5
 ! !
! Doit class methodsFor: 'doit' !
doit ^[JunkClass class methodsFor: 'junk'] value ! !
! JunkClass class methodsFor: 'junk' !
classVar1Variable

	^[nil] cache ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
definedClasses
	^definedClasses ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
definedClasses: aCollection
	definedClasses := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
extendedClasses

	^(self extendedMethods collect: [:each | each first thisClass]) asSet ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
extendedMethods
	^extendedMethods ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
extendedMethods: aCollection
	extendedMethods := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
name
	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
name: aCollection
	name := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
requiredKitNames
	^requiredKitNames ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
requiredKitNames: aCollection
	requiredKitNames := aCollection asOrderedCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
subKits
	^subKits ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
subKits: aCollection
	subKits := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
versionName
	^versionName ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'accessing'] value ! !
! Kit methodsFor: 'accessing' !
versionName: aString

	versionName := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
addClass: aClass
	(self definesClass: aClass) ifTrue: [^self].
	self definedClasses add: aClass.
	aClass kit: self.

	aClass methodDictionary do: [:method |
		method kit == self ifTrue: [self removeMethod: method]].


	aClass class methodDictionary do: [:method |
		method kit == self ifTrue: [self removeMethod: method]]. ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
addMethod: aMethod
	self extendedMethods add: (Array with: aMethod mclass with: aMethod selector).
	aMethod kit: (aMethod mclass kit == self
		ifTrue: [nil]
		ifFalse: [self]) ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
addRequiredKit: aKit
	self requiredKitNames add: aKit name ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
includedClasses: aCollection

	| classesToRemove |

	classesToRemove := self definedClasses copy.
	aCollection do: [:each | classesToRemove removeAllSuchThat: [:eachClass | eachClass name = each] ].

	classesToRemove copy reverseDo: [:eachClass |
		self removeClass: eachClass.
		ClassCreator new removeClass: eachClass]

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
partialSortDefinedClassesDo: aBlock

	| sortedClasses superclasses classesToProcess |

	sortedClasses := self definedClasses copy sortedBy: [:a :b | a name < b name].

	superclasses := Dictionary new.
	sortedClasses do: [:eachClass |
		superclasses at: eachClass put: ((eachClass withAllSuperclasses) remove: eachClass; yourself)].

	classesToProcess := Set new addAll: self definedClasses; yourself.

	[sortedClasses notEmpty] whileTrue: [
		| class |
		class := sortedClasses detect: [:eachClass | ((superclasses at: eachClass) anySatisfy: [:each | classesToProcess includes: each]) not] ifNone: [nil].
		class isNil ifTrue: [^self].
		aBlock value: class.
		classesToProcess remove: class.
self log: class name.
		sortedClasses remove: class]   ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
removeClass: aClass

	self definedClasses remove: aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
removeMethod: aMethod
	self extendedMethods remove: (Array with: aMethod mclass with: aMethod selector).
	aMethod kit: nil ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
removeRequiredKit: aKit
	self requiredKitNames remove: aKit name ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'adding and removing'] value ! !
! Kit methodsFor: 'adding and removing' !
sortDefinedClasses

	self definedClasses: (self definedClasses sortedBy: [:a :b | a name < b name]) ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
allDefinedClasses: classArray andMethods: methodArray ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
allDefinedMethodsFor: aClass methods: aCollection

	| methodsToDelete |

	methodsToDelete := OrderedCollection new.

	aClass methodDictionary keysAndValuesDo: [:selector :method |
		((aCollection includes: selector) not and: [method kit isNil]) ifTrue: [methodsToDelete add: selector] ].

	methodsToDelete do: [:eachSelector |
		aClass removeSelector: eachSelector]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
ensureLoaded: aCollection

	self requiredKitNames: aCollection asOrderedCollection.

	aCollection do: [:each |
		(KitManager current hasKitNamed: each) ifFalse: [
			('kits' asFilename construct: (each , '.kit')) fileIn ] ].

	KitManager default currentKit: self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
fileout

	| folder stream |
	
	folder := 'kits' asFilename.
	stream := (folder construct: self name, '.kit') writeStream.
	[self fileoutOn: stream] ensure: [stream close]
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
fileoutDefinedClassesOn: aStream

	self partialSortDefinedClassesDo: [:eachClass |
		eachClass fileoutDefinitionOn: aStream.
		aStream cr; cr].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
fileoutDefinedMethodsOn: aStream

	self partialSortDefinedClassesDo: [:eachClass |
		eachClass fileoutMethodsOn: aStream forKit: self.
		eachClass class fileoutMethodsOn: aStream forKit: self].
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
fileoutExtendedMethodsOn: aStream

	(self extendedMethods asArray sortedBy: [:array1:array2 |
			array1 first name < array2 first name or: [
				(array1 first = array2 first) and: [array1 last < array2 last]]]) do: [:eachMethod |
		eachMethod first fileoutMethodNamed: eachMethod last on: aStream.
		aStream nextPutAll: 'KitManager default currentKit addMethod: (';
			nextPutAll: eachMethod first name;
			nextPutAll: ' compiledMethodAt: #';
			nextPutAll: eachMethod last;
			nextPutAll: ') !';
			cr; cr].
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
fileoutInventoryOn: aStream

	aStream
		nextPutAll: 'KitManager default currentKit allDefinedClasses: ';
		print: (self definedClasses asArray sortedBy: [:class1 :class2 | class1 name < class2 name]) limit: 1000000000;
		nextPutAll: ' andMethods: ';
		print: (self extendedMethods asArray sortedBy: [:array1 :array2 |
			array1 first name < array2 first name or: [
				(array1 first = array2 first) and: [array1 last < array2 last]]]) limit: 100000000;
		nextPutAll: ' !';
		cr; cr.

	self definedClasses do: [:eachClass |
		aStream nextPutAll: 'KitManager default currentKit allDefinedMethodsFor: ';
			nextPutAll: eachClass name;
			nextPutAll: ' methods: ';
			print: (eachClass selectors asArray sorted select: [:eachMethod | (eachClass compiledMethodAt: eachMethod) kit isNil]) limit: 100000000;
			nextPutAll: ' !';
			cr; cr.

		aStream nextPutAll: 'KitManager default currentKit allDefinedMethodsFor: ';
			nextPutAll: eachClass name;
			nextPutAll: ' class methods: ';
			print: (eachClass class selectors asArray sorted select: [:eachMethod | (eachClass class compiledMethodAt: eachMethod) kit isNil]) limit: 100000000;
			nextPutAll: ' !';
			cr; cr.
		].

	  ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
fileoutOn: aStream

	aStream nextPutAll: 'KitManager default currentKitNamed: ', self name printString, ' !'; cr; cr.
	
	self
		writeLoadRequiredKitsOn: aStream;
		fileoutDefinedClassesOn: aStream;
		fileoutDefinedMethodsOn: aStream;
		fileoutExtendedMethodsOn: aStream;
		fileoutInventoryOn: aStream.

	aStream nextPutAll: 'KitManager default finishFileinKit !'; cr

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'fileout'] value ! !
! Kit methodsFor: 'fileout' !
writeLoadRequiredKitsOn: aStream

	aStream
		nextPutAll: 'KitManager default currentKit ensureLoaded: ', self requiredKitNames asArray printString, ' !'; cr; cr.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'initialize-release'] value ! !
! Kit methodsFor: 'initialize-release' !
initialize

	definedClasses := OrderedCollection new.
	extendedMethods := Set new.
	requiredKitNames := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'loading and unloading'] value ! !
! Kit methodsFor: 'loading and unloading' !
unload

	 | classes |

	self extendedMethods copy do: [:methodClassAndSelector |
		methodClassAndSelector first removeSelector: methodClassAndSelector last].

	classes := OrderedCollection new.
	self partialSortDefinedClassesDo: [:class | classes add: class].

	classes reverseDo: [:class | ClassCreator new removeClass: class].

	KitManager current removeKit: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'printing'] value ! !
! Kit methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' (';
		print: self name;
		nextPut: $) ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'testing'] value ! !
! Kit methodsFor: 'testing' !
cantUnloadReason

	| requiringKits |
	requiringKits := KitManager current kits asArray select: [:each | each requiredKitNames includes: self name].
	requiringKits notEmpty ifTrue: [^'There are kits that require this one: ', (requiringKits asArray collect: [:each | each name]) printString].

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'testing'] value ! !
! Kit methodsFor: 'testing' !
definesClass: aClass
	aClass isNil ifTrue: [^false].
	^self definedClasses includes: aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit methodsFor: 'testing'] value ! !
! Kit methodsFor: 'testing' !
extendsMethodNamed: methodName inClass: aClass
	^self extendedMethods includes: (Array with: aClass name with: methodName) ! !
! Doit class methodsFor: 'doit' !
doit ^[Kit class methodsFor: 'instance creation'] value ! !
! Kit class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
classesNotInKit
	^((Class withAllSubclasses copyWithout: Class) collect: [:each | each thisClass]) select: [:each |
		(self kitForClass: each) name = 'Other']
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
currentKit
	^currentKit ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
currentKit: aKit
	currentKit := aKit ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
currentKitNamed: aString
	self currentKit: (self kits detect: [:each | each name = aString] ifNone: [self addKitNamed: aString]) ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
kitForClass: aClass

	^self kitForClass: aClass ifNone: [self kitNamedIfAbsentAdd: 'Other']
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
kitForClass: aClass ifNone: aBlock

	^self kits
		detect: [:kit | kit definesClass: aClass]
		ifNone: aBlock
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
kitNamed: aString

	^self kits detect: [:kit | kit name = aString] ifNone: [nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
kitNamedIfAbsentAdd: aString

	^(self kitNamed: aString) ifNil: [
		self addKitNamed: aString]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
kits
	^kits
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'accessing'] value ! !
! KitManager methodsFor: 'accessing' !
kitsInLoadOrder

	| processedKits kitsToProcess orderedKits |

	processedKits := Set new.
	kitsToProcess := self kits values sortedBy: [:a :b | a name < b name].
	orderedKits := OrderedCollection new.

	[kitsToProcess isEmpty] whileFalse: [
		| kit |
		kit := kitsToProcess detect: [:each | 
				each requiredKitNames isEmpty or: [each requiredKitNames allSatisfy: [:eachKitName | processedKits includes: eachKitName] ] ]
			ifNone: [self error: 'Circular kit list'].
		orderedKits add: kit.
		processedKits add: kit name.
		kitsToProcess remove: kit].

	^orderedKits


	
  ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'adding and removing'] value ! !
! KitManager methodsFor: 'adding and removing' !
addKit: aKit

	self kits at: aKit name put: aKit ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'adding and removing'] value ! !
! KitManager methodsFor: 'adding and removing' !
addKitNamed: aString

	| kit |

	self addKit: (kit := Kit new name: aString; yourself).
	^kit ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'adding and removing'] value ! !
! KitManager methodsFor: 'adding and removing' !
removeKit: aKit

	self kits removeKey: aKit name ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'file in and out'] value ! !
! KitManager methodsFor: 'file in and out' !
allDefinedClasses: classes andMethods: methods

	self definedClasses copy do: [:class |
		(classes includes: class name) ifFalse: [
			ClassCreator new removeClass: class]].

	self extendedMethods copy do: [:methodDescriptor |
		methodDescriptor first  methodDictionary removeKey: methodDescriptor last]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'file in and out'] value ! !
! KitManager methodsFor: 'file in and out' !
allDefinedMethodsFor: classes methods: methods
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'file in and out'] value ! !
! KitManager methodsFor: 'file in and out' !
fileinAllKits

	BeagleSystem changesFileName asFilename exists ifFalse: [
		BeagleSystem changesFileName asFilename writeStream; close].

	('kits' asFilename construct: 'allKits.st') fileIn ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'file in and out'] value ! !
! KitManager methodsFor: 'file in and out' !
fileoutAllKits

	self kits do: [:each |
		self log: 'Fileout kit: ', each name.
		each fileout].
	self writeAllKits ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'file in and out'] value ! !
! KitManager methodsFor: 'file in and out' !
finishFileinKit
	self currentKit: nil ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'file in and out'] value ! !
! KitManager methodsFor: 'file in and out' !
writeAllKits

	| stream |

	stream := ('kits' asFilename construct: 'allKits.st') writeStream.
	[self kitsInLoadOrder do: [:kit |
		stream
			nextPutAll: '(''kits'' asFilename construct: ''', kit name, '.kit'') fileIn !'; cr] ]
		ensure: [stream close]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'initialize-release'] value ! !
! KitManager methodsFor: 'initialize-release' !
initialize

	kits := Dictionary new ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager methodsFor: 'testing'] value ! !
! KitManager methodsFor: 'testing' !
hasKitNamed: aString

	^kits includesKey: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager class methodsFor: 'accessing'] value ! !
! KitManager class methodsFor: 'accessing' !
clearDefault
	^default := nil ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager class methodsFor: 'accessing'] value ! !
! KitManager class methodsFor: 'accessing' !
default
	^default ifNil: [default := self new] ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager class methodsFor: 'instance creation'] value ! !
! KitManager class methodsFor: 'instance creation' !
current
	^self default ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager class methodsFor: 'instance creation'] value ! !
! KitManager class methodsFor: 'instance creation' !
new
	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention methodsFor: 'reading'] value ! !
! LineEndConvention methodsFor: 'reading' !
next: aNumber for: aFileStream
	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention methodsFor: 'reading'] value ! !
! LineEndConvention methodsFor: 'reading' !
nextFor: aFileStream
	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention methodsFor: 'reading'] value ! !
! LineEndConvention methodsFor: 'reading' !
skip: aNumber for: aFileStream
	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention methodsFor: 'reading'] value ! !
! LineEndConvention methodsFor: 'reading' !
upToEndFor: aFileStream
	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention methodsFor: 'writing'] value ! !
! LineEndConvention methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConvention methodsFor: 'writing'] value ! !
! LineEndConvention methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCR methodsFor: 'reading'] value ! !
! LineEndConventionCR methodsFor: 'reading' !
next: aNumber for: aFileStream
	^aFileStream primNext: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCR methodsFor: 'reading'] value ! !
! LineEndConventionCR methodsFor: 'reading' !
nextFor: aFileStream
	^aFileStream primNext ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCR methodsFor: 'reading'] value ! !
! LineEndConventionCR methodsFor: 'reading' !
skip: aNumber for: aFileStream
	^aFileStream primSkip: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCR methodsFor: 'reading'] value ! !
! LineEndConventionCR methodsFor: 'reading' !
upToEndFor: aFileStream
	^aFileStream primUpToEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCR methodsFor: 'writing'] value ! !
! LineEndConventionCR methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	^aFileStream primNextPut: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCR methodsFor: 'writing'] value ! !
! LineEndConventionCR methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	^aFileStream primNextPutAll: aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCRLF methodsFor: 'reading'] value ! !
! LineEndConventionCRLF methodsFor: 'reading' !
next: aNumber for: aFileStream
	| bytes |
	bytes := aFileStream primNext: aNumber.
	bytes last = 13 ifTrue: [
		| lf |
		lf := aFileStream primNext.
		lf = 10 ifFalse: [aFileStream primSkip: -1]].
		
	^bytes copyReplaceAll: #(13 10) with: #(13) ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCRLF methodsFor: 'reading'] value ! !
! LineEndConventionCRLF methodsFor: 'reading' !
nextFor: aFileStream
	| character |
	character := aFileStream primNext.
	character = 13 ifTrue: [
		| lf |
		lf := aFileStream primNext.
		lf = 10 ifFalse: [aFileStream primSkip: -1]].
	^character ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCRLF methodsFor: 'reading'] value ! !
! LineEndConventionCRLF methodsFor: 'reading' !
skip: aNumber for: aFileStream
	aFileStream primSkip: aNumber.
	aFileStream primNext asInteger = 10
		ifTrue: [aFileStream primSkip: -2]
		ifFalse: [aFileStream primSkip: -1] ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCRLF methodsFor: 'reading'] value ! !
! LineEndConventionCRLF methodsFor: 'reading' !
upToEndFor: aFileStream
	^aFileStream primUpToEnd copyReplaceAll: #(13 10) with: #(13) ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCRLF methodsFor: 'writing'] value ! !
! LineEndConventionCRLF methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	anInteger asInteger = 13 ifTrue: [
		^aFileStream
			primNextPut: 13;
			primNextPut: 10].
	^aFileStream primNextPut: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionCRLF methodsFor: 'writing'] value ! !
! LineEndConventionCRLF methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	^aFileStream primNextPutAll: (aCollection asByteArray copyReplaceAll: #(13) with: #(13 10)) ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionLF methodsFor: 'reading'] value ! !
! LineEndConventionLF methodsFor: 'reading' !
next: aNumber for: aFileStream
	| bytes |
	bytes := aFileStream primNext: aNumber.
	^bytes copyReplacing: 10 with: 13 ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionLF methodsFor: 'reading'] value ! !
! LineEndConventionLF methodsFor: 'reading' !
nextFor: aFileStream
	| character |
	character := aFileStream primNext.
	character = 10
		ifTrue: [^13]
		ifFalse: [^character] ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionLF methodsFor: 'reading'] value ! !
! LineEndConventionLF methodsFor: 'reading' !
skip: aNumber for: aFileStream
	^aFileStream primSkip: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionLF methodsFor: 'reading'] value ! !
! LineEndConventionLF methodsFor: 'reading' !
upToEndFor: aFileStream
	^aFileStream primUpToEnd copyReplacing: 10 with: 13 ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionLF methodsFor: 'writing'] value ! !
! LineEndConventionLF methodsFor: 'writing' !
nextPut: anInteger for: aFileStream
	anInteger = 13 ifTrue: [^aFileStream nextPut: 10].
	^aFileStream primNextPut: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[LineEndConventionLF methodsFor: 'writing'] value ! !
! LineEndConventionLF methodsFor: 'writing' !
nextPutAll: aCollection for: aFileStream
	^aFileStream primNextPutAll: (aCollection copyReplacing: 13 with: 10) ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
< value1

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
<= value1

	^self < value1 or: [self = value1] ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
> value1

	^(self <= value1) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
>= value1

	^(self < value1) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
between: value1 and: value2 

	self < value1 ifTrue: [^false].
	^self <= value2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
max: aMagnitude 

	self > aMagnitude ifTrue: [^self].
	^aMagnitude ! !
! Doit class methodsFor: 'doit' !
doit ^[Magnitude methodsFor: 'comparing'] value ! !
! Magnitude methodsFor: 'comparing' !
min: aMagnitude 

	self < aMagnitude ifTrue: [^self].
	^aMagnitude ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'accessing'] value ! !
! Character methodsFor: 'accessing' !
asInteger

	<primitive: 410>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'accessing'] value ! !
! Character methodsFor: 'accessing' !
isVowel

	^self class vowels includes: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
< aCharacter

	^self asInteger < aCharacter asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
<= aCharacter

	^self asInteger <= aCharacter asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
= aCharacter

	self class = aCharacter class ifFalse: [^false].
	^self asInteger = aCharacter asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
> aCharacter

	^self asInteger > aCharacter asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
>= aCharacter

	^self asInteger >= aCharacter asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
digitValue

	(self asLowercase between: $a and: $z) ifTrue: [
		^self asLowercase asInteger - $a asInteger + 10].

	(self asLowercase between: $0 and: $9) ifTrue: [
		^self asInteger - $0 asInteger].

	^-1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'comparing'] value ! !
! Character methodsFor: 'comparing' !
hash

	^self asInteger hash ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'converting'] value ! !
! Character methodsFor: 'converting' !
asLowercase

	self isUppercase ifFalse: [^self].
	^Character value: self asInteger + 16r20 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'converting'] value ! !
! Character methodsFor: 'converting' !
asString

	^String with: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'converting'] value ! !
! Character methodsFor: 'converting' !
asUppercase

	self isLowercase ifFalse: [^self].
	^Character value: self asInteger - 16r20 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'printing'] value ! !
! Character methodsFor: 'printing' !
printOn: aStream 

	(self asInteger between: 32 and: 127)
		ifTrue: [aStream nextPut: $$; nextPut: self]
		ifFalse: [aStream nextPutAll: '$<'; nextPutAll: self asInteger hex; nextPut: $>]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isAlphaNumeric

	self isAlphabetic ifTrue: [^true].
	^self isDigit ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isAlphabetic

	self isUppercase ifTrue: [^true].
	self isLowercase ifTrue: [^true].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isDigit

	(self between: $0 and: $9) ifTrue: [^true].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isLowercase

	^self between: $a and: $z ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isNonBinarySelectorCharacter

	self isAlphaNumeric ifTrue: [^true].
	self = $_ ifTrue: [^true].
	self = $: ifTrue: [^true].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isSeparator

	self = Character space ifTrue: [^true].
	self = Character cr ifTrue: [^true].
	self = Character lf ifTrue: [^true].
	self = Character tab ifTrue: [^true].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Character methodsFor: 'testing'] value ! !
! Character methodsFor: 'testing' !
isUppercase

	^self between: $A and: $Z ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'constants'] value ! !
! Character class methodsFor: 'constants' !
backspace

	^Character value: 8 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'constants'] value ! !
! Character class methodsFor: 'constants' !
cr

	^Character value: 13 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'constants'] value ! !
! Character class methodsFor: 'constants' !
lf

	^Character value: 10 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'constants'] value ! !
! Character class methodsFor: 'constants' !
space

	^Character value: 32 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'constants'] value ! !
! Character class methodsFor: 'constants' !
tab

	^Character value: 9 ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'instance creation'] value ! !
! Character class methodsFor: 'instance creation' !
digitValue: aNumber 

	^self value:
		(aNumber < 10
			ifTrue: [48 + aNumber]
			ifFalse: [55 + aNumber]) ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'instance creation'] value ! !
! Character class methodsFor: 'instance creation' !
value: aNumber 

	<primitive: 411>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Character class methodsFor: 'instance creation'] value ! !
! Character class methodsFor: 'instance creation' !
vowels

	^'aAeEiIoOuU' ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
asMilliseconds

	| yearIndex absDays seconds |
	yearIndex := self year - 1901.
	absDays := yearIndex * 365 + (yearIndex // 4) + ((yearIndex + 300) // 400)
				- (yearIndex // 100) + self day
				- 1 + (self firstDayOf: self month).	"elapsed years"	"ordinary leap years"	"leap centuries, first one is 2000, i.e. yearIndex = 99"	"non-leap centuries"
	seconds := (self hours * 60 + self minutes) * 60
				+ self seconds.
	"do it this way to minimize large arithmetic"
	^(absDays * 86400 + seconds) * 1000 + self milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
day

	^day ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
day: anObject

	day := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
hours

	^self time hours ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
milliseconds

	^self time milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
minutes

	^self time minutes ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
month

	^month ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
month: anObject

	month := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
seconds

	^self time seconds ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
time

	^time ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
time: aTime

	time := aTime ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
year

	^year ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'accessing'] value ! !
! DateTime methodsFor: 'accessing' !
year: anObject

	year := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'comparing'] value ! !
! DateTime methodsFor: 'comparing' !
< aDateTime

	self year < aDateTime year ifTrue: [^true].
	self year > aDateTime year ifTrue: [^false].
	self month < aDateTime month ifTrue: [^true].
	self month > aDateTime month ifTrue: [^false].
	self day < aDateTime day  ifTrue: [^true].
	self day  > aDateTime day  ifTrue: [^false].
	self time < aDateTime time  ifTrue: [^true].
	self time  > aDateTime time  ifTrue: [^false].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'comparison'] value ! !
! DateTime methodsFor: 'comparison' !
addMilliseconds: aNumber

	| total daysInMonth |
	total := time milliseconds + aNumber.
	time milliseconds: total \\ 86400000. "1000* 3600 * 24 "
	total := total // 86400000.
	day := day + total.
	[day > (daysInMonth := self daysIn: self month forYear: self year)] whileTrue: [
		day := day - daysInMonth.
		month := month + 1.
		month > 12 ifTrue: [month := 1. year := year + 1]]. ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'comparison'] value ! !
! DateTime methodsFor: 'comparison' !
difference: aHexlinkDate
	| difference carryOver |
	difference := DateTime new.
	
	carryOver := 0.
	self time milliseconds >= aHexlinkDate time milliseconds ifTrue: [difference time: (Time new setMilliseconds: self time milliseconds - aHexlinkDate time milliseconds)]
		 ifFalse: [difference time: (Time new setMilliseconds: (1000 * 60 * 60 * 24) - (aHexlinkDate time milliseconds - self time milliseconds)). carryOver := 1].

	self day >= aHexlinkDate day ifTrue: [difference day: self day - aHexlinkDate day - carryOver. carryOver := 0.]
						ifFalse: [
							| lastMonth yearCheck |
							self month = 1 ifTrue: [lastMonth := 12. yearCheck := self year - 1.] ifFalse: [lastMonth := self month - 1. yearCheck := self year].
							difference day: (self daysIn: lastMonth forYear: yearCheck) - (aHexlinkDate day - self day) - carryOver.
							carryOver := 1.
						].

	self month >= aHexlinkDate month ifTrue: [difference month: self month - aHexlinkDate month - carryOver. carryOver := 0.]
							ifFalse: [difference month: 12 - (aHexlinkDate month - self month) - carryOver. carryOver := 1.].

	difference year: self year - aHexlinkDate year - carryOver.
	
	^difference ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'initialize-release'] value ! !
! DateTime methodsFor: 'initialize-release' !
initFromSystemFormat: aNumber

	time := Time new setMilliseconds: aNumber \\ 100000000.
	year := aNumber // 100000000 \\ 10000.
	month := aNumber // 1000000000000 \\ 100.
	day := aNumber // 100000000000000 \\ 100. ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'internal'] value ! !
! DateTime methodsFor: 'internal' !
daysIn: monthNumeric forYear: yearNumeric

	(monthNumeric = 1) |  (monthNumeric = 3) | (monthNumeric = 5) | (monthNumeric = 7) | (monthNumeric = 8) | (monthNumeric = 10) | (monthNumeric = 12)
		ifTrue: [^31].
	(monthNumeric = 4) |  (monthNumeric = 6) | (monthNumeric = 9) | (monthNumeric = 11)
		ifTrue: [^30].
	(monthNumeric = 2) ifTrue: [
			(self isLeap: yearNumeric) ifTrue: [^29] ifFalse: [^28].
	].
		
		^31 ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'internal'] value ! !
! DateTime methodsFor: 'internal' !
isLeap: yearNumeric
	| condition1 condition2 |
	
	condition2 := true.
	
	(yearNumeric \\ 4 = 0) ifTrue: [condition1 := true] ifFalse: [condition1 := false] .
	
	(yearNumeric \\ 100 = 0) & (yearNumeric \\ 400 = 0) ifTrue: [condition2 := false].
	
	condition1 & condition2 ifTrue: [^true] ifFalse: [^false] ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'printing'] value ! !
! DateTime methodsFor: 'printing' !
minutesAndSecondsPrintString

	^time minutes printString, ':', (time seconds < 10 ifTrue: ['0', time seconds printString] ifFalse: [time seconds printString]) ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'printing'] value ! !
! DateTime methodsFor: 'printing' !
printOn: aStream

	self year printOn: aStream.
	aStream nextPut: $/.
	self month < 10 ifTrue: [aStream nextPut: $0].
	self month printOn: aStream.
	aStream nextPut: $/.
	self day < 10 ifTrue: [aStream nextPut: $0].
	self day printOn: aStream.
	aStream nextPut: Character space.
	self time printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime methodsFor: 'printing'] value ! !
! DateTime methodsFor: 'printing' !
writeBinaryOn: aStream

	aStream
		nextPutInt16: self year;
		nextPut: self month;
		nextPut: self day;
		write: self time ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime class methodsFor: 'instance creation'] value ! !
! DateTime class methodsFor: 'instance creation' !
fromSystemFormat: aNumber
	"Takes in a date in the form of an integer. The integer value represents the digits of the date in the format DDMMYYYYZZZZZZZZ, where Z is milliseconds from midnight"
	^super new initFromSystemFormat: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime class methodsFor: 'primitives'] value ! !
! DateTime class methodsFor: 'primitives' !
now

	^self fromSystemFormat: self systemDate ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime class methodsFor: 'primitives'] value ! !
! DateTime class methodsFor: 'primitives' !
readBinaryFrom: 	aStream

	^self new
		year: aStream nextInt16;
		month: aStream next;
		day: aStream next;
		time: (Time readBinaryFrom: aStream);
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[DateTime class methodsFor: 'primitives'] value ! !
! DateTime class methodsFor: 'primitives' !
systemDate

	<primitive: 700>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
as2DPoint

	^(self atRow: 1 column: 1) @ (self atRow: 2 column: 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber

	^elements at: (rowNumber - 1) * columns + columnNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber put: value

	elements at: (rowNumber - 1) * columns + columnNumber put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
columns

	^columns ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
elements

	^elements ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
rows

	^rows ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
w

	^self atRow: 4 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
x

	^self atRow: 1 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
y

	^self atRow: 2 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'accessing'] value ! !
! Matrix methodsFor: 'accessing' !
z

	^self atRow: 3 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'arithmetic'] value ! !
! Matrix methodsFor: 'arithmetic' !
* aMatrix

	| newMatrix |

	self columns = aMatrix rows ifFalse: [^self error: 'Matrices are the wrong sizes to multiply.'].

	newMatrix := Matrix rows: self rows columns: aMatrix columns.
	1 to: self rows do: [:rowNumber |
		1 to: aMatrix columns do: [:columnNumber |
			| total |
			total := 0.0.
			1 to: self columns do: [:i |
				total := total + ((self atRow: rowNumber column: i) * (aMatrix atRow: i column: columnNumber))].
			newMatrix atRow: rowNumber column: columnNumber put: total]].

	^newMatrix
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'arithmetic'] value ! !
! Matrix methodsFor: 'arithmetic' !
+ aMatrix

	| newMatrix |

	(self rows = aMatrix rows and: [self columns = aMatrix columns])
		ifFalse: [^self error: 'Matrices are the wrong sizes to add.'].

	newMatrix := Matrix rows: self rows columns: self columns.
	1 to: self rows do: [:rowNumber |
		1 to: aMatrix columns do: [:columnNumber |
			newMatrix atRow: rowNumber column: columnNumber put: (self atRow: rowNumber column: columnNumber) + (aMatrix atRow: rowNumber column: columnNumber)]].

	^newMatrix
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'arithmetic'] value ! !
! Matrix methodsFor: 'arithmetic' !
- aMatrix

	| newMatrix |

	(self rows = aMatrix rows and: [self columns = aMatrix columns])
		ifFalse: [^self error: 'Matrices are the wrong sizes to subtract.'].

	newMatrix := Matrix rows: self rows columns: self columns.
	1 to: self rows do: [:rowNumber |
		1 to: aMatrix columns do: [:columnNumber |
			newMatrix atRow: rowNumber column: columnNumber put: (self atRow: rowNumber column: columnNumber) - (aMatrix atRow: rowNumber column: columnNumber)]].

	^newMatrix
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'initializing'] value ! !
! Matrix methodsFor: 'initializing' !
from3x3Array: anArray

	self rows: 3 columns: 3.

	1 to: 3 do: [:rowNumber |
		1 to: 3 do: [:columnNumber |
			self atRow: rowNumber column: columnNumber put: (anArray at: (rowNumber - 1) * 3 + columnNumber)]].

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'initializing'] value ! !
! Matrix methodsFor: 'initializing' !
from4x4Array: anArray

	self rows: 4 columns: 4.

	1 to: 4 do: [:rowNumber |
		1 to: 4 do: [:columnNumber |
			self atRow: rowNumber column: columnNumber put: (anArray at: (rowNumber - 1) * 4 + columnNumber)]].

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'initializing'] value ! !
! Matrix methodsFor: 'initializing' !
fromArray: anArray

	self rows: anArray size columns: (anArray first size).

	anArray keysAndValuesDo: [:rowNumber :subarray |
		subarray keysAndValuesDo: [:columnNumber :value |
			self atRow: rowNumber column: columnNumber put: value]].

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'initializing'] value ! !
! Matrix methodsFor: 'initializing' !
rows: rowsInteger columns: columnsInteger

	rows := rowsInteger.
	columns := columnsInteger.
	elements := Array new: rows * columns.
	1 to: rows * columns do: [:i | elements at: i put: 0.0] ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a00

	^self atRow: 1 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a01

	^self atRow: 1 column: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a02

	^self atRow: 1 column: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a03

	^self atRow: 1 column: 4 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a10

	^self atRow: 2 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a11

	^self atRow: 2 column: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a12

	^self atRow: 2 column: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a13

	^self atRow: 2 column: 4 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a20

	^self atRow: 3 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a21

	^self atRow: 3 column: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a22

	^self atRow: 3 column: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a23

	^self atRow: 3 column: 4 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a30

	^self atRow: 4 column: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a31

	^self atRow: 4 column: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a32

	^self atRow: 4 column: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
a33

	^self atRow: 4 column: 4 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b00

	^(self a11 * self a22 * self a33)
		+ (self a12 * self a23 * self a31)
		+ (self a13 * self a21 * self a32)
		- (self a11 * self a23 * self a32)
		- (self a12 * self a21 * self a33)
		- (self a13 * self a22 * self a31) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b01

	^(self a01 * self a23 * self a32)
		+ (self a02 * self a21 * self a33)
		+ (self a03 * self a22 * self a31)
		- (self a01 * self a22 * self a33)
		- (self a02 * self a23 * self a31)
		- (self a03 * self a21 * self a32) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b02

	^(self a01 * self a12 * self a33)
		+ (self a02 * self a13 * self a31)
		+ (self a03 * self a11 * self a32)
		- (self a01 * self a13 * self a32)
		- (self a02 * self a11 * self a33)
		- (self a03 * self a12 * self a31) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b03

	^(self a01 * self a13 * self a22)
		+ (self a02 * self a11 * self a23)
		+ (self a03 * self a12 * self a21)
		- (self a01 * self a12 * self a23)
		- (self a02 * self a13 * self a21)
		- (self a03 * self a11 * self a22) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b10

	^(self a10 * self a23 * self a32)
		+ (self a12 * self a20 * self a33)
		+ (self a13 * self a22 * self a30)
		- (self a10 * self a22 * self a33)
		- (self a12 * self a23 * self a30)
		- (self a13 * self a20 * self a32) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b11

	^(self a00 * self a22 * self a33)
		+ (self a02 * self a23 * self a30)
		+ (self a03 * self a20 * self a32)
		- (self a00 * self a23 * self a32)
		- (self a02 * self a20 * self a33)
		- (self a03 * self a22 * self a30) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b12

	^(self a00 * self a13 * self a32)
		+ (self a02 * self a10 * self a33)
		+ (self a03 * self a12 * self a30)
		- (self a00 * self a12 * self a33)
		- (self a02 * self a13 * self a30)
		- (self a03 * self a10 * self a32) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b13

	^(self a00 * self a12 * self a23)
		+ (self a02 * self a13 * self a20)
		+ (self a03 * self a10 * self a22)
		- (self a00 * self a13 * self a22)
		- (self a02 * self a10 * self a23)
		- (self a03 * self a12 * self a20) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b20

	^(self a10 * self a21 * self a33)
		+ (self a11* self a23 * self a30)
		+ (self a13 * self a20 * self a31)
		- (self a10 * self a23 * self a31)
		- (self a11 * self a20 * self a33)
		- (self a13 * self a21 * self a30) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b21

	^(self a00 * self a23 * self a31)
		+ (self a01* self a20 * self a33)
		+ (self a03 * self a21 * self a30)
		- (self a00 * self a21 * self a33)
		- (self a01 * self a23 * self a30)
		- (self a03 * self a20 * self a31) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b22

	^(self a00 * self a11 * self a33)
		+ (self a01* self a13 * self a30)
		+ (self a03 * self a10 * self a31)
		- (self a00 * self a13 * self a31)
		- (self a01 * self a10 * self a33)
		- (self a03 * self a11 * self a30) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b23

	^(self a00 * self a13 * self a21)
		+ (self a01* self a10 * self a23)
		+ (self a03 * self a11 * self a20)
		- (self a00 * self a11 * self a23)
		- (self a01 * self a13 * self a20)
		- (self a03 * self a10 * self a21) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b30

	^(self a10 * self a22 * self a31)
		+ (self a11* self a20 * self a32)
		+ (self a12 * self a21 * self a30)
		- (self a10 * self a21 * self a32)
		- (self a11 * self a22 * self a30)
		- (self a12 * self a20 * self a31) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b31

	^(self a00 * self a21 * self a32)
		+ (self a01* self a22 * self a30)
		+ (self a02 * self a20 * self a31)
		- (self a00 * self a22 * self a31)
		- (self a01 * self a20 * self a32)
		- (self a02 * self a21 * self a30) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b32

	^(self a00 * self a12 * self a31)
		+ (self a01* self a10 * self a32)
		+ (self a02 * self a11 * self a30)
		- (self a00 * self a11 * self a32)
		- (self a01 * self a12 * self a30)
		- (self a02 * self a10 * self a31) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
b33

	^(self a00 * self a11 * self a22)
		+ (self a01* self a12 * self a20)
		+ (self a02 * self a10 * self a21)
		- (self a00 * self a12 * self a21)
		- (self a01 * self a10 * self a22)
		- (self a02 * self a11 * self a20) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
determinant4D

	^
	self a00 * self a11 * self a22 * self a33
	+ (self a00 * self a12 * self a23 * self a31)
	+ (self a00 * self a13 * self a21 * self a32)
	+ (self a01 * self a10 * self a23 * self a32)

	+ (self a01 * self a12 * self a20 * self a33)
	+ (self a01 * self a13 * self a22 * self a30)
	+ (self a02 * self a10 * self a21 * self a33)
	+ (self a02 * self a11 * self a23 * self a30)

	+ (self a02 * self a13 * self a20 * self a31)
	+ (self a03 * self a10 * self a22 * self a31)
	+ (self a03 * self a11 * self a20 * self a32)
	+ (self a03 * self a12 * self a21 * self a30)

	- (self a00 * self a11 * self a23 * self a32)
	- (self a00 * self a12 * self a21 * self a33)
	- (self a00 * self a13 * self a22 * self a31)
	- (self a01 * self a10 * self a22 * self a33)

	- (self a01 * self a12 * self a23 * self a30)
	- (self a01 * self a13 * self a20 * self a32)
	- (self a02 * self a10 * self a23 * self a31)
	- (self a02 * self a11 * self a20 * self a33)

	- (self a02 * self a13 * self a21 * self a30)
	- (self a03 * self a10 * self a21 * self a32)
	- (self a03 * self a11 * self a22 * self a30)
	- (self a03 * self a12 * self a20 * self a31) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
inverse

	|  inverse |

	(self rows = 2 and: [self columns = 2]) ifTrue: [^self inverse2D].
	(self rows = 3 and: [self columns = 3]) ifTrue: [^self inverse3D].
	(self rows = 4 and: [self columns = 4]) ifTrue: [^self inverse4D].

	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
inverse2D

	| determinantDemoninator |
	determinantDemoninator := (self atRow: 1 column: 1) * (self atRow: 2 column: 2) - ((self atRow: 1 column: 2) * (self atRow: 2 column: 1)).
	determinantDemoninator = 0.0 ifTrue: [^self error: 'No inverse'].
	^self class fromArray: (
		(Array new: 2)
			at: 1 put: ((Array new: 2)
				at: 1 put: (self atRow: 2 column: 2) / determinantDemoninator;
				at: 2 put: (self atRow: 1 column: 2) negated / determinantDemoninator;
				yourself);
			at: 2 put: ((Array new: 2)
				at: 1 put: (self atRow: 2 column: 1) negated / determinantDemoninator;
				at: 2 put: (self atRow: 1 column: 1) / determinantDemoninator;
				yourself);
			yourself)

	 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'inverse'] value ! !
! Matrix methodsFor: 'inverse' !
inverse4D

	| det |
	det := self determinant4D.
	^self class fromArray: (Array
		with: (Array with: self b00 /det with: self b01 / det with: self b02 / det with: self b03 / det)
		with: (Array with: self b10 /det with: self b11 / det with: self b12 / det with: self b13 / det)
		with: (Array with: self b20 /det with: self b21 / det with: self b22 / det with: self b23 / det)
		with: (Array with: self b30 /det with: self b31 / det with: self b32 / det with: self b33 / det)
		) ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'printing'] value ! !
! Matrix methodsFor: 'printing' !
javascriptString

	| stream |
	stream := WriteStream on: (String new: 1000).

	stream nextPut: $[.

	self elements do: [:each |
		stream print: each;
			nextPutAll: ', '].

	stream nextPut: $].
	^stream contents
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'printing'] value ! !
! Matrix methodsFor: 'printing' !
makeIdentity

	1 to: self rows do: [:rowNumber |
		1 to: self columns do: [:columnNumber |
			self atRow: rowNumber column: columnNumber put: (rowNumber = columnNumber ifTrue: [1.0] ifFalse: [0.0])] ]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix methodsFor: 'printing'] value ! !
! Matrix methodsFor: 'printing' !
printOn: aStream

	aStream nextPut: $[; cr.

	1 to: self rows do: [:rowNumber |
		1 to: self columns do: [:columnNumber |
			aStream print: (self atRow: rowNumber column: columnNumber); space].
		aStream cr].

	aStream nextPut: $] ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
columnVectorFromArray: anArray

	| matrix |

	matrix := self rows: anArray size columns: 1.
	1 to: anArray size do: [:index |
		matrix atRow: index column: 1 put: (anArray at: index)].
	^matrix

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
from3x3Array: anArray

	^self new from3x3Array: anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
from4x4Array: anArray

	^self new from4x4Array: anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
fromArray: anArray

	^self new fromArray: anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
identityRows: rowsInteger columns: columnsInteger

	^self new
		rows: rowsInteger columns: columnsInteger;
		makeIdentity;
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
rows: rowsInteger columns: columnsInteger

	^self new
		rows: rowsInteger
		columns: columnsInteger
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Matrix class methodsFor: 'instance creation'] value ! !
! Matrix class methodsFor: 'instance creation' !
twoDFromPoint: aPoint

	^(self rows: 3 columns: 1)
		atRow: 1 column: 1 put: aPoint x;
		atRow: 2 column: 1 put: aPoint y;
		atRow: 3 column: 1 put: 1.0;
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageNotUnderstood methodsFor: 'printing'] value ! !
! MessageNotUnderstood methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream cr.
	aStream nextPutAll: self message ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageNotUnderstood class methodsFor: 'signalling'] value ! !
! MessageNotUnderstood class methodsFor: 'signalling' !
defaultErrorString

	^'Message not understood' ! !
! Doit class methodsFor: 'doit' !
doit ^[Metaclass methodsFor: 'accessing'] value ! !
! Metaclass methodsFor: 'accessing' !
classDictionaries

	^self thisClass classDictionaries ! !
! Doit class methodsFor: 'doit' !
doit ^[Metaclass methodsFor: 'accessing'] value ! !
! Metaclass methodsFor: 'accessing' !
kit

	^self thisClass kit ! !
! Doit class methodsFor: 'doit' !
doit ^[Metaclass methodsFor: 'accessing'] value ! !
! Metaclass methodsFor: 'accessing' !
name

	^thisClass name , ' class' ! !
! Doit class methodsFor: 'doit' !
doit ^[Metaclass methodsFor: 'accessing'] value ! !
! Metaclass methodsFor: 'accessing' !
printOn: aStream

	^aStream nextPutAll: self name ! !
! Doit class methodsFor: 'doit' !
doit ^[Metaclass methodsFor: 'accessing'] value ! !
! Metaclass methodsFor: 'accessing' !
thisClass

	^thisClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Metaclass methodsFor: 'accessing'] value ! !
! Metaclass methodsFor: 'accessing' !
thisClass: aClass 

	thisClass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'accessing'] value ! !
! Number methodsFor: 'accessing' !
coerceTo: aNumber

	^aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'accessing'] value ! !
! Number methodsFor: 'accessing' !
kind

	^#Number  ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
* aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) * (aNumber coerceTo: self)].
	^self primitiveTimes: aNumber  ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
+ aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) primitivePlus: (aNumber coerceTo: self)].
	^self primitivePlus: aNumber  ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
- aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) - (aNumber coerceTo: self)].
	^self primitiveMinus: aNumber  ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
/ aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) / (aNumber coerceTo: self)].
	^self primitiveDivide: aNumber  ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
// aNumber

	| quotient |
	quotient := self asInteger quo: aNumber asInteger.
	quotient < 0 ifTrue: [^quotient - 1].
	^quotient   ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
abs

	self negative ifTrue: [^self negated].
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
arccos

	^self asFloat arccos ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
arcsin

	^self asFloat arcsin ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
cos

	^self asFloat cos ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
cosh

	^(self exp + self negated exp) / 2.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
cot

	^self tan reciprocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
coth

	^self tanh reciprocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
csc

	^self sin reciprocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
csch

	^self sinh reciprocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
exp

	^self asFloat exp ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
ln

	^self asFloat ln ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
log

	^self ln / 10.0 ln ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
quo: aNumber

	^(self coerceTo: aNumber) primitiveQuo: (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
raisedTo: aNumber

	^(self ln * aNumber) exp ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
raisedToInteger: aNumber

	| power factors number |

	aNumber < 0 ifTrue: [
		^self raisedToNegativeInteger: aNumber].


	factors := OrderedCollection new: 10.

	number := aNumber.
	[number = 0] whileFalse: [
		factors add: (number rem: 2).
		number := number quo: 2].

	power := self class unity.
	
	factors reverseDo: [:each |
		power := power squared.
		each == 1 ifTrue: [power := power * self]].

	^power ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
raisedToNegativeInteger: aNumber

	| power factors number |

	power := self class unity.
	
	factors := OrderedCollection new: 10.

	number := aNumber negated.

	[number = 0] whileFalse: [
		factors add: (number rem: 2).
		number := number quo: 2].

	power := self class unity.
	
	factors reverseDo: [:each |
		power := power squared.
		each == 1 ifTrue: [power := power // self]].

	^power ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
reciprocal

	^self class unity / self ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
rem: aNumber

	^(self coerceTo: aNumber) primitiveRem: (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
sec

	^self cos reciprocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
sech

	^self cosh reciprocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
sin

	^self asFloat sin ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
sinh

	^(self exp - self negated exp) / 2.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
sqrt

	^self asFloat sqrt ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
squared
	"Answer the receiver multiplied by itself."

	^self * self ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
tan

	^self asFloat tan ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'arithmetic'] value ! !
! Number methodsFor: 'arithmetic' !
tanh

	^(self exp - self negated exp) / (self exp + self negated exp) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
< aNumber

	^(self coerceTo: aNumber) primitiveLessThan: (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
<= aNumber

	^(self coerceTo: aNumber) primitiveLessThanOrEqualTo:  (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
= aNumber

	aNumber isNumber ifFalse: [^false].
	^(self coerceTo: aNumber) primitiveEqualTo: (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
> aNumber

	^(self coerceTo: aNumber) primitiveGreaterThan: (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
>= aNumber

	^(self coerceTo: aNumber) primitiveGreaterThanOrEqualTo:  (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
hash

	^self abs ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'comparing'] value ! !
! Number methodsFor: 'comparing' !
~= aNumber

	aNumber isNumber ifFalse: [^true].
	^(self coerceTo: aNumber) primitiveNotEqualTo: (aNumber coerceTo: self) ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
@ aNumber 

	^Point x: self y: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
degreesToRadians

	^self * Float pi / 180.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
negated

	^self class zero - self ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
negative

	^self < self class zero ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
positive

	^self >= self class zero ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
radiansToDegrees

	^self * 180.0 / Float pi ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'converting'] value ! !
! Number methodsFor: 'converting' !
sign

	self < self class zero ifTrue: [^-1].
	self > self class zero ifTrue: [^1].
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'enumerating'] value ! !
! Number methodsFor: 'enumerating' !
to: stop by: step do: aBlock

	| current |

	current := self.
	step negative
		ifTrue: [[current >= stop] whileTrue: [
			aBlock value: current.
			current := current + step]]
		ifFalse: [[current <= stop] whileTrue: [
			aBlock value: current.
			current := current + step.]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'enumerating'] value ! !
! Number methodsFor: 'enumerating' !
to: stop do: aBlock

	self to: stop by: 1 do: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'printing'] value ! !
! Number methodsFor: 'printing' !
jsonOn: aStream

	self printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'testing'] value ! !
! Number methodsFor: 'testing' !
isNumber

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Number methodsFor: 'testing'] value ! !
! Number methodsFor: 'testing' !
isZero
	^self = 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Number class methodsFor: 'reading'] value ! !
! Number class methodsFor: 'reading' !
readFrom: aStream

	| sign mantissa decimalPosition position finished exponent mantissaDigits |

	sign := 1.
	aStream atEnd ifTrue: [^0.0].

	aStream peek = $- ifTrue: [
		sign := -1.
		aStream next].

	aStream peek = $+ ifTrue: [
		aStream next].

	mantissa := 0.
	mantissaDigits := 0.
	decimalPosition := nil.
	position := 0.
	finished := false.

	[aStream atEnd not and: [finished not]] whileTrue: [
		| character |
		finished := true.
		character := aStream next.
		character isDigit ifTrue: [mantissa := mantissa * 10 + character digitValue. finished := false. mantissaDigits := mantissaDigits + 1].
		character = $. ifTrue: [decimalPosition := position. finished := false].
		character = $e ifTrue: [exponent := Integer readFrom: aStream].
		position := position + 1.
		].

	decimalPosition isNil ifTrue: [decimalPosition := mantissaDigits].
	exponent isNil ifTrue: [exponent := 0].

	^(mantissa * sign) asFloat * (10 raisedToInteger: exponent + decimalPosition - mantissaDigits) ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'accessing'] value ! !
! Fraction methodsFor: 'accessing' !
denominator

	^denominator ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'accessing'] value ! !
! Fraction methodsFor: 'accessing' !
denominator: anInteger

	denominator := anInteger asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'accessing'] value ! !
! Fraction methodsFor: 'accessing' !
numerator

	^numerator ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'accessing'] value ! !
! Fraction methodsFor: 'accessing' !
numerator: anInteger

	numerator := anInteger asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'arithmetic'] value ! !
! Fraction methodsFor: 'arithmetic' !
primitiveDivide: aNumber

	^self class numerator: self numerator * aNumber denominator denominator: self denominator * aNumber numerator  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'arithmetic'] value ! !
! Fraction methodsFor: 'arithmetic' !
primitiveMinus: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.

	^self class numerator: ((lcm quo: self denominator) * self numerator) - ((lcm quo: aNumber denominator) * aNumber numerator) denominator: lcm  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'arithmetic'] value ! !
! Fraction methodsFor: 'arithmetic' !
primitivePlus: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.

	^self class numerator: ((lcm quo: self denominator) * self numerator) + ((lcm quo: aNumber denominator) * aNumber numerator) denominator: lcm  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'arithmetic'] value ! !
! Fraction methodsFor: 'arithmetic' !
primitiveTimes: aNumber

	^self class numerator: self numerator * aNumber numerator denominator: self denominator * aNumber denominator  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'coercing'] value ! !
! Fraction methodsFor: 'coercing' !
coerceFloat: aFloat

	^aFloat  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'coercing'] value ! !
! Fraction methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'coercing'] value ! !
! Fraction methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger asFraction  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'coercing'] value ! !
! Fraction methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger asFraction  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'coercing'] value ! !
! Fraction methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceFraction: self  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'coercing'] value ! !
! Fraction methodsFor: 'coercing' !
kind

	^#Fraction  ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'comparing'] value ! !
! Fraction methodsFor: 'comparing' !
primitiveEqualTo: aNumber

	^self numerator = aNumber numerator and: [self denominator = aNumber denominator] ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'comparing'] value ! !
! Fraction methodsFor: 'comparing' !
primitiveGreaterThan: aNumber

	| lcm |
	aNumber isFloat ifTrue: [^self asFloat > aNumber asFloat].

	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) > ((lcm quo: aNumber denominator) * aNumber numerator) ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'comparing'] value ! !
! Fraction methodsFor: 'comparing' !
primitiveGreaterThanOrEqualTo: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) >= ((lcm quo: aNumber denominator) * aNumber numerator) ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'comparing'] value ! !
! Fraction methodsFor: 'comparing' !
primitiveLessThan: aNumber

	| lcm |
	aNumber isFloat ifTrue: [^self asFloat < aNumber asFloat].

	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) < ((lcm quo: aNumber denominator) * aNumber numerator) ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'comparing'] value ! !
! Fraction methodsFor: 'comparing' !
primitiveLessThanOrEqualTo: aNumber

	| lcm |
	lcm := self denominator lcm: aNumber denominator.
	^((lcm quo: self denominator) * self numerator) <= ((lcm quo: aNumber denominator) * aNumber numerator) ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'comparing'] value ! !
! Fraction methodsFor: 'comparing' !
primitiveNotEqualTo: aNumber

	^self numerator ~= aNumber numerator or: [self denominator ~= aNumber denominator] ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'converting'] value ! !
! Fraction methodsFor: 'converting' !
asFloat

	^self numerator asFloat / self denominator asFloat ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'converting'] value ! !
! Fraction methodsFor: 'converting' !
asInteger

	^self numerator quo: self denominator ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'printing'] value ! !
! Fraction methodsFor: 'printing' !
hex

	^(WriteStream on: (String new: 10))
		nextPutAll: self numerator hex;
		nextPutAll: ' / ';
		nextPutAll: self denominator hex;
		contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'printing'] value ! !
! Fraction methodsFor: 'printing' !
printOn: aStream

	aStream
		print: self numerator;
		nextPutAll: ' / ';
		print: self denominator ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction methodsFor: 'utility'] value ! !
! Fraction methodsFor: 'utility' !
reduce

	| gcd |
	gcd := self numerator gcd: self denominator.
	gcd = 1 ifTrue: [^self].
	self numerator: (self numerator quo: gcd).
	self denominator: (self denominator quo: gcd).
	self denominator < 0 ifTrue: [
		self denominator: self denominator negated.
		self numerator: self numerator negated].

	self denominator = 1 ifTrue: [^numerator].
	^self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction class methodsFor: 'instance creation'] value ! !
! Fraction class methodsFor: 'instance creation' !
numerator: numerator denominator: denominator

	^self new
		numerator: numerator;
		denominator: denominator;
		reduce
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction class methodsFor: 'instance creation'] value ! !
! Fraction class methodsFor: 'instance creation' !
unity

	^1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Fraction class methodsFor: 'instance creation'] value ! !
! Fraction class methodsFor: 'instance creation' !
zero

	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'accessing'] value ! !
! Integer methodsFor: 'accessing' !
denominator

	^1
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'accessing'] value ! !
! Integer methodsFor: 'accessing' !
even

	^(self bitAnd: 1) = 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'accessing'] value ! !
! Integer methodsFor: 'accessing' !
numerator

	^self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'accessing'] value ! !
! Integer methodsFor: 'accessing' !
odd

	^(self bitAnd: 1) = 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'accessing'] value ! !
! Integer methodsFor: 'accessing' !
truncated

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'arithmetic'] value ! !
! Integer methodsFor: 'arithmetic' !
/ aNumber

	self kind ~~ aNumber kind ifTrue: [^(self coerceTo: aNumber) / (aNumber coerceTo: self)].
	^self asFraction / aNumber asFraction ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'arithmetic'] value ! !
! Integer methodsFor: 'arithmetic' !
gcd: aNumber

	| a b t |
	a := self.
	b := aNumber.

	[b = 0] whileFalse: [
		t := b.
		b := a mod: b.	
		a := t].

	^a ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'arithmetic'] value ! !
! Integer methodsFor: 'arithmetic' !
lcm: aNumber

	^(self * aNumber) abs // (self gcd: aNumber) ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'computing'] value ! !
! Integer methodsFor: 'computing' !
factorial

	| factorial |

	self <= 0 ifTrue: [^0].

	factorial := 1.
	2 to: self do: [:i | factorial := factorial * i].
	^factorial
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'computing'] value ! !
! Integer methodsFor: 'computing' !
intSqrt

	| guess lastGuess |

	guess := 1.
	(self printString size // 2) timesRepeat: [guess := guess * 10].
	lastGuess := 0.
	[guess := (guess + (self // guess)) // 2.
	guess = lastGuess] whileFalse: [
		lastGuess := guess].
	^guess

  ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'converting'] value ! !
! Integer methodsFor: 'converting' !
asFraction

	^Fraction new
		numerator: self;
		denominator: 1;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'converting'] value ! !
! Integer methodsFor: 'converting' !
asInteger
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'enumerating'] value ! !
! Integer methodsFor: 'enumerating' !
timesRepeat: aBlock

	1 to: self do: [:i | aBlock value].
	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'printing'] value ! !
! Integer methodsFor: 'printing' !
hex

	^self printStringRadix: 16 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'printing'] value ! !
! Integer methodsFor: 'printing' !
printHexOn: aStream padZeros: aNumber

	self printOn: aStream paddedWith: $0 to: aNumber base: 16 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'printing'] value ! !
! Integer methodsFor: 'printing' !
printOn: aStream 

	| string value numberOfDigits |

	value := self.
	numberOfDigits := 0.
	
	[value := (value quo: 10) abs.
	numberOfDigits := numberOfDigits + 1.
	value = 0] whileFalse.

	self = 0 ifTrue: [^aStream nextPut: $0].
	string := String new: numberOfDigits.

	value := self.
	self < 0 ifTrue: [aStream nextPut: $-].
	numberOfDigits to: 1 by: -1 do: [:digitNumber |
		string at: digitNumber put: (Character digitValue: (value rem: 10) abs).
		value := (value quo: 10) abs].
	aStream nextPutAll: string  ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'printing'] value ! !
! Integer methodsFor: 'printing' !
printOn: aStream paddedWith: aCharacter to: aNumber base: base

	| string value absValue numberOfDigits |
	value := absValue := self abs.
	numberOfDigits := 0.
	
	self = 0 ifTrue: [
		aNumber - 1 timesRepeat: [aStream nextPut: aCharacter].
		^aStream nextPut: $0].

	[value = 0] whileFalse: [
		value := value quo: base.
		numberOfDigits := numberOfDigits + 1].

	aNumber - numberOfDigits timesRepeat: [aStream nextPut: aCharacter].

	self = 0 ifTrue: [^self].
	
	string := String new: numberOfDigits.
	value := absValue.
	self < 0 ifTrue: [aStream nextPut: $-].
	numberOfDigits to: 1 by: -1 do: [:digitNumber |
		string at: digitNumber put: (Character digitValue: (value rem: base)).
		value := value quo: base].
	aStream nextPutAll: string  ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'printing'] value ! !
! Integer methodsFor: 'printing' !
printStringRadix: aNumber

	| stream |

	stream := WriteStream on: String new.
	self printOn: stream paddedWith: Character space to: 0 base: aNumber.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer methodsFor: 'testing'] value ! !
! Integer methodsFor: 'testing' !
isInteger

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer class methodsFor: 'instance creation'] value ! !
! Integer class methodsFor: 'instance creation' !
readFrom: aStream

	| result |
	result := 0.

	[aStream atEnd] whileFalse: [
		| character |
		(aStream peek between: $0 and: $9) ifFalse: [^result].
		character := aStream next.
		result := result * 10 + (character asInteger - $0 asInteger).
		].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer class methodsFor: 'instance creation'] value ! !
! Integer class methodsFor: 'instance creation' !
readHexFrom: aStream

	| result |
	result := 0.

	[aStream atEnd] whileFalse: [
		| character digit |
		character := aStream peek asLowercase.
		digit := nil.
		(character between: $0 and: $9) ifTrue: [digit := character asInteger - $0 asInteger].
		(character between: $a and: $f) ifTrue: [digit := character asInteger - $a asInteger + 10].
		digit isNil ifTrue: [^result].
		aStream next.
		
		result := result * 16 + digit].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer class methodsFor: 'instance creation'] value ! !
! Integer class methodsFor: 'instance creation' !
unity
	^1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Integer class methodsFor: 'instance creation'] value ! !
! Integer class methodsFor: 'instance creation' !
zero
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'accessing'] value ! !
! LargeInteger methodsFor: 'accessing' !
bytes

	^bytes
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'accessing'] value ! !
! LargeInteger methodsFor: 'accessing' !
bytes: aByteArray

	bytes := aByteArray
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'accessing'] value ! !
! LargeInteger methodsFor: 'accessing' !
componentSize

	^componentSize ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'accessing'] value ! !
! LargeInteger methodsFor: 'accessing' !
componentSize: aNumber

	componentSize := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
divideWithRemainderBy: divisor

	<primitive: 33>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
mod: aNumber

	^self rem: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
primitiveDivide: aNumber

	<primitive: 30>
	self primitiveFailed
  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
primitiveMinus: aLargeInteger

	<primitive: 22>
	self primitiveFailed   ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
primitivePlus: aLargeInteger

	<primitive: 21>
	self primitiveFailed   ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
primitiveQuo: aNumber

	^(self divideWithRemainderBy: aNumber) first  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
primitiveRem: aNumber

	^(self divideWithRemainderBy: aNumber asLargeInteger) last  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'arithmetic'] value ! !
! LargeInteger methodsFor: 'arithmetic' !
primitiveTimes: aLargeInteger

	<primitive: 29>
	self primitiveFailed
  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'coercing'] value ! !
! LargeInteger methodsFor: 'coercing' !
coerceFloat: aFloat
	^aFloat  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'coercing'] value ! !
! LargeInteger methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'coercing'] value ! !
! LargeInteger methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'coercing'] value ! !
! LargeInteger methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger asLargeInteger  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'coercing'] value ! !
! LargeInteger methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceLargeInteger: self  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'coercing'] value ! !
! LargeInteger methodsFor: 'coercing' !
kind

	^#LargeInteger  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
basicEqualTo: aNumber

	<primitive: 27>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
basicGreaterThan: aNumber

	<primitive: 24>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
basicGreaterThanOrEqual: aNumber

	<primitive: 26>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
basicLessThan: aNumber

	<primitive: 23>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
basicLessThanOrEqual: aNumber

	<primitive: 25>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
basicNotEqualTo: aNumber

	<primitive: 28>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
hash

	^self integerAt: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
primitiveEqualTo: aNumber

	^self basicEqualTo: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
primitiveGreaterThan: aNumber

	<primitive: 24>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
primitiveGreaterThanOrEqualTo: aNumber

	^self basicGreaterThanOrEqual: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
primitiveLessThan: aNumber

	<primitive: 23>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
primitiveLessThanOrEqualTo: aNumber

	^self basicLessThanOrEqual: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'comparing'] value ! !
! LargeInteger methodsFor: 'comparing' !
primitiveNotEqualTo: aNumber

	^self basicNotEqualTo: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'converting'] value ! !
! LargeInteger methodsFor: 'converting' !
asFloat

	<primitive: 35>
	self primitiveFailed
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'converting'] value ! !
! LargeInteger methodsFor: 'converting' !
asLargeInteger

	^self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'initialize-release'] value ! !
! LargeInteger methodsFor: 'initialize-release' !
initialize

	super initialize.
	bytes := ByteArray new: 8 withAll: 0.
	componentSize := 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'printing'] value ! !
! LargeInteger methodsFor: 'printing' !
printOn: aStream 

	| stream value numberOfDigits ten zero |

	value := self abs.
	
	self = 0 ifTrue: [^aStream nextPut: $0].

	stream := WriteStream on: (String new: 1000).

	value := self.

	self < 0 ifTrue: [aStream nextPut: $-].
	ten := 10 asLargeInteger.
	zero := 0 asLargeInteger.

	[zero = value asLargeInteger] whileFalse: [
		| quotientAndRemainder |
		quotientAndRemainder := value divideWithRemainderBy: ten.
		stream nextPut: (Character digitValue: quotientAndRemainder last).
		value := quotientAndRemainder first].

	aStream nextPutAll: stream contents reverse  ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'testing'] value ! !
! LargeInteger methodsFor: 'testing' !
isLargeInteger

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'utility'] value ! !
! LargeInteger methodsFor: 'utility' !
hex

	| stream |
	stream := WriteStream on: (String new: 1000).
	self printHexOn: stream.
	^stream contents
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'utility'] value ! !
! LargeInteger methodsFor: 'utility' !
integerAt: aNumber

	| integer |
	aNumber > 1 ifTrue: [^0].

	^self rem: 16r10000000 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger methodsFor: 'utility'] value ! !
! LargeInteger methodsFor: 'utility' !
printHexOn: aStream

	self positive
		ifTrue: [aStream nextPutAll: '+']
		ifFalse: [aStream nextPutAll: '-'].

	aStream nextPut: $[.
	1 to: self bytes size do: [:index |
		aStream nextPutAll: (self bytes at: index) hex.
		aStream space].
	aStream nextPut: $] ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeInteger class methodsFor: 'instance creation'] value ! !
! LargeInteger class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeNegativeInteger methodsFor: 'testing'] value ! !
! LargeNegativeInteger methodsFor: 'testing' !
negative

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeNegativeInteger methodsFor: 'testing'] value ! !
! LargeNegativeInteger methodsFor: 'testing' !
positive

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeNegativeInteger methodsFor: 'utility'] value ! !
! LargeNegativeInteger methodsFor: 'utility' !
sign

	^-1 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargePositiveInteger methodsFor: 'testing'] value ! !
! LargePositiveInteger methodsFor: 'testing' !
negative

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[LargePositiveInteger methodsFor: 'testing'] value ! !
! LargePositiveInteger methodsFor: 'testing' !
positive

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LargePositiveInteger methodsFor: 'utility'] value ! !
! LargePositiveInteger methodsFor: 'utility' !
sign

	^1
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal methodsFor: 'arithmetic'] value ! !
! LimitedPrecisionReal methodsFor: 'arithmetic' !
fractionalValue

	^self - self asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal methodsFor: 'converting'] value ! !
! LimitedPrecisionReal methodsFor: 'converting' !
asInteger

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal methodsFor: 'converting'] value ! !
! LimitedPrecisionReal methodsFor: 'converting' !
positive

	^self >= self class zero ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal methodsFor: 'printing'] value ! !
! LimitedPrecisionReal methodsFor: 'printing' !
printOn: aStream 

	| fractionalPart roundedValue adjustment |
		
	self abs < 1.0e-14 ifTrue: [
		^aStream nextPutAll: '0.0'].

	self negative
		ifTrue: 
			[aStream nextPut: $-.
			^self abs printOn: aStream].

	adjustment := 5 * (0.1 raisedToInteger: self decimalDigitsOfPrecision - (self ln / 10.0 ln) truncated).
	roundedValue := self + adjustment.
	(roundedValue > 10.0e9) | (roundedValue < (1.0 / 10.0e9)) ifTrue: [^roundedValue printScientificNotationOn: aStream].

	roundedValue asInteger printOn: aStream.
	aStream nextPut: $..
	fractionalPart := roundedValue fractionalValue.
	adjustment := adjustment * 10.
	[
		fractionalPart := fractionalPart * 10.
		fractionalPart asInteger printOn: aStream.
		fractionalPart := fractionalPart fractionalValue.
		adjustment := adjustment * 10.
		fractionalPart > adjustment] whileTrue: [].

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal methodsFor: 'printing'] value ! !
! LimitedPrecisionReal methodsFor: 'printing' !
printScientificNotationOn: aStream
	| mantissa exponent |

	exponent := (self abs ln / 10 ln) truncated.
	exponent negative ifTrue: [exponent := exponent - 1].

	self / (10 asFloat raisedToInteger: exponent) printOn: aStream.
	aStream nextPut: $e.
	exponent printOn: aStream.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal methodsFor: 'testing'] value ! !
! LimitedPrecisionReal methodsFor: 'testing' !
isReal

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal class methodsFor: 'instance creation'] value ! !
! LimitedPrecisionReal class methodsFor: 'instance creation' !
new

	^self zero copy. ! !
! Doit class methodsFor: 'doit' !
doit ^[LimitedPrecisionReal class methodsFor: 'instance creation'] value ! !
! LimitedPrecisionReal class methodsFor: 'instance creation' !
zero

	^self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'accessing'] value ! !
! Float methodsFor: 'accessing' !
basicAt: aNumber

	^self  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'accessing'] value ! !
! Float methodsFor: 'accessing' !
basicSize

	^0  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'accessing'] value ! !
! Float methodsFor: 'accessing' !
kind

	^#Float  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
arcTan2: angle

	<primitive: 56>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
arccos

	<primitive: 59>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
arcsin

	<primitive: 58>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
arctan

	^self arcTan: 1.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
asFloat

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
cos

	<primitive: 54>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
decimalDigitsOfPrecision
	^15 ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
exp

	<primitive: 65>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
fractionPart

	^self - self asInteger asFloat ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
ln

	<primitive: 57>
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
log

	<primitive: 57>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
mod: aNumber

	self < 0.0 ifTrue: [^aNumber - (self abs mod: aNumber)].
	^(self / aNumber) fractionPart * aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveDivide: aNumber 

	<primitive: 50>
	^self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveGreaterThan: aNumber 

	<primitive: 44>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveGreaterThanOrEqualTo: aNumber 

	^(self < aNumber) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveLessThan: aNumber 

	<primitive: 43>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveLessThanOrEqualTo: aNumber 

	^(self > aNumber) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveMinus: aNumber 

	<primitive: 42>
	^self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitivePlus: aNumber 

	<primitive: 41>
	^self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
primitiveTimes: aNumber 

	<primitive: 49>
	^self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
raisedToNegativeInteger: aNumber

	| power factors number |

	power := self class unity.
	
	factors := OrderedCollection new: 10.

	number := aNumber negated.

	[number = 0] whileFalse: [
		factors add: (number rem: 2).
		number := number quo: 2].

	power := self class unity.
	
	factors reverseDo: [:each |
		power := power squared.
		each == 1 ifTrue: [power := power / self]].

	^power ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
round
	| remainder decimal add|
	remainder := self truncated.
	decimal := self - remainder asFloat.
	decimal >= 0.5 ifTrue: [add := 1] ifFalse: [add := 0].
	
	^ remainder + add. ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
roundUp
	self = self truncated asFloat ifTrue: [^self truncated]
	ifFalse: [^self truncated + 1] ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
sin

	<primitive: 53>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
sqrt

	<primitive: 52>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'arithmetic'] value ! !
! Float methodsFor: 'arithmetic' !
tan

	<primitive: 55>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'coercing'] value ! !
! Float methodsFor: 'coercing' !
coerceFloat: aFloat

	^aFloat  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'coercing'] value ! !
! Float methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction asFloat   ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'coercing'] value ! !
! Float methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger asFloat  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'coercing'] value ! !
! Float methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger asFloat  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'coercing'] value ! !
! Float methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceFloat: self  ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'comparing'] value ! !
! Float methodsFor: 'comparing' !
asInteger

	^self truncated ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'comparing'] value ! !
! Float methodsFor: 'comparing' !
primitiveEqualTo: aNumber 

	<primitive: 45>
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'comparing'] value ! !
! Float methodsFor: 'comparing' !
primitiveNotEqualTo: aNumber 

	^(self primitiveEqualTo: aNumber) not ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'comparing'] value ! !
! Float methodsFor: 'comparing' !
truncated

	<primitive: 51>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Float methodsFor: 'testing'] value ! !
! Float methodsFor: 'testing' !
isFloat

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Float class methodsFor: 'instance creation'] value ! !
! Float class methodsFor: 'instance creation' !
e

	^2.7182818284590452353602874713527 ! !
! Doit class methodsFor: 'doit' !
doit ^[Float class methodsFor: 'instance creation'] value ! !
! Float class methodsFor: 'instance creation' !
new

	^self error: 'Can''t create Floats with new' ! !
! Doit class methodsFor: 'doit' !
doit ^[Float class methodsFor: 'instance creation'] value ! !
! Float class methodsFor: 'instance creation' !
pi

	^3.1415926535897932384626433832795 ! !
! Doit class methodsFor: 'doit' !
doit ^[Float class methodsFor: 'instance creation'] value ! !
! Float class methodsFor: 'instance creation' !
unity

	^1.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Float class methodsFor: 'instance creation'] value ! !
! Float class methodsFor: 'instance creation' !
zero

	^0.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[OSHandle methodsFor: 'accessing'] value ! !
! OSHandle methodsFor: 'accessing' !
contents

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'accessing'] value ! !
! Point methodsFor: 'accessing' !
x

	^x ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'accessing'] value ! !
! Point methodsFor: 'accessing' !
x: aNumber 

	x := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'accessing'] value ! !
! Point methodsFor: 'accessing' !
y

	^y ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'accessing'] value ! !
! Point methodsFor: 'accessing' !
y: aNumber 

	y := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
* aPointOrNumber

	aPointOrNumber class = Point
		ifTrue: [^Point x: self x * aPointOrNumber x y: self y * aPointOrNumber y].
	^Point x: self x * aPointOrNumber y: self y * aPointOrNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
+ aPoint

	^Point x: self x + aPoint x y: self y + aPoint y ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
- aPoint

	^Point x: self x - aPoint x y: self y - aPoint y ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
/ aPointOrNumber

	aPointOrNumber class = Point
		ifTrue: [^Point x: self x / aPointOrNumber x y: self y / aPointOrNumber y].
	^Point x: self x / aPointOrNumber y: self y / aPointOrNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
abs

	^self class x: x abs y: y abs ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
dotProduct: aPoint 

	^self x * aPoint x + (self y * aPoint y) ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
max: aPoint

	^Point x: (self x max: aPoint x) y: (self y max: aPoint y) ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
min: aPoint

	^Point x: (self x min: aPoint x) y: (self y min: aPoint y) ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
negated

	^Point x: self x negated y: self y negated ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
r

	^(self x squared + self y squared) sqrt ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
theta

	^self y asFloat arcTan2: self x asFloat ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'arithmetic'] value ! !
! Point methodsFor: 'arithmetic' !
transposed

	^Point x: self y y: self x ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'comparing'] value ! !
! Point methodsFor: 'comparing' !
= aPoint

	self class = aPoint class ifFalse: [^false].
	^x = aPoint x and: [y = aPoint y] ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'comparing'] value ! !
! Point methodsFor: 'comparing' !
hash

	^(x hash * 99859 + y hash) hash ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'converting'] value ! !
! Point methodsFor: 'converting' !
corner: aPoint 

	^Rectangle origin: self corner: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'converting'] value ! !
! Point methodsFor: 'converting' !
extent: aPoint 

	^Rectangle origin: self extent: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'copying'] value ! !
! Point methodsFor: 'copying' !
copy

	^self class x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'printing'] value ! !
! Point methodsFor: 'printing' !
printOn: aStream 

	self x printOn: aStream.
	aStream nextPutAll: ' @ '.
	self y printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Point class methodsFor: 'instance creation'] value ! !
! Point class methodsFor: 'instance creation' !
x: x y: y 

	^(self new)
		x: x;
		y: y;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Random methodsFor: 'accessing'] value ! !
! Random methodsFor: 'accessing' !
seed

	^seed ! !
! Doit class methodsFor: 'doit' !
doit ^[Random methodsFor: 'accessing'] value ! !
! Random methodsFor: 'accessing' !
seed: aNumber

	seed := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Random methodsFor: 'generating'] value ! !
! Random methodsFor: 'generating' !
next

	^self nextSeed asFloat / 120050.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Random methodsFor: 'generating'] value ! !
! Random methodsFor: 'generating' !
nextSeed

	^seed := seed * 2311 + 25367 \\ 120050 ! !
! Doit class methodsFor: 'doit' !
doit ^[Random methodsFor: 'initialize-release'] value ! !
! Random methodsFor: 'initialize-release' !
initialize

	seed := Time millisecondClockValue. ! !
! Doit class methodsFor: 'doit' !
doit ^[Random class methodsFor: 'instance creation'] value ! !
! Random class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[Random class methodsFor: 'instance creation'] value ! !
! Random class methodsFor: 'instance creation' !
seed: aNumber

	^self new
		seed: aNumber;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SHA1 methodsFor: 'accessing'] value ! !
! SHA1 methodsFor: 'accessing' !
hash: aString

	| byteStream length h0 h1 h2 h3 h4 words a b c d e f k hashArray length64 |

	h0 := 16r67452301.
	h1 := 16rEFCDAB89.
	h2 := 16r98BADCFE.
	h3 := 16r10325476.
	h4 := 16rC3D2E1F0.

	length := aString size * 8.

	byteStream := WriteStream on: (ByteArray new: 80).
	aString do: [:character | byteStream nextPut: character asInteger].
	byteStream nextPut: 16r80.

	[byteStream position * 8 \\ 512 = 448] whileFalse: [
		byteStream nextPut: 0].

	length64 := ByteArray new: 8.
	
	8 to: 1 by: -1 do: [:index |
		length64 at: index put: length \\ 256.
		length := length // 256].
	
	length64 do: [:each | byteStream nextPut: each].
	
	byteStream := byteStream contents readStream.
	[byteStream atEnd] whileFalse: [
		words := Array new: 80.
		
		1 to: 16 do: [:wordIndex |
			| word |
			word := byteStream next * 256 + byteStream next * 256 + byteStream next * 256 + byteStream next.
			words at: wordIndex put: word].
		
		17 to: 80 do: [:index |
			words at: index put: (
				((((words at: index - 3) bitXor:
				(words at: index - 8)) bitXor: (words at: index - 14))
					bitXor: (words at: index - 16)) leftRotate32: 1)].

		a := h0.
		b := h1.
		c := h2.
		d := h3.
		e := h4.

		1 to: 80 do: [:index |
			| temp |
			(index between: 1 and: 20) ifTrue: [
				f := (b bitAnd: c) bitOr: ((b bitXor: 4294967295) bitAnd: d).
				k := 16r5A827999].
			(index between: 21 and: 40) ifTrue: [
				f := (b bitXor: c) bitXor: d.
				k := 16r6ED9EBA1].
			(index between: 41 and: 60) ifTrue: [
				f := ((b bitAnd: c) bitOr: (b bitAnd: d)) bitOr: (c bitAnd: d).
				k := 16r8F1BBCDC].
			(index between: 61 and: 80) ifTrue: [
				f := (b bitXor: c) bitXor: d.
				k := 16rCA62C1D6].
			
			temp := ((a leftRotate32: 5) + f + e + k + (words at: index)) \\ 4294967296.
			e := d.
			d := c.
			c := b leftRotate32: 30.
			b := a.
			a := temp].

		h0 := (h0 + a) \\ 4294967296.
		h1 := (h1 + b) \\ 4294967296.
		h2 := (h2 + c) \\ 4294967296.
		h3 := (h3 + d) \\ 4294967296.
		h4 := (h4 + e) \\ 4294967296].

	hashArray := ByteArray new: 20.
	self
		write32: h0 into: hashArray startingAt: 1;
		write32: h1 into: hashArray startingAt: 5;
		write32: h2 into: hashArray startingAt: 9;
		write32: h3 into: hashArray startingAt: 13;
		write32: h4 into: hashArray startingAt: 17.

	^hashArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SHA1 methodsFor: 'accessing'] value ! !
! SHA1 methodsFor: 'accessing' !
write32: anInteger into: anArray startingAt: startingIndex

	| index number |
	
	index := startingIndex.
	number := anInteger.

	4 timesRepeat: [
		anArray at: index put: number // 16777216.
		number := number \\ 16777216 * 256.
		index := index + 1] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
at: aNumber ifAbsent: aBlock

	(aNumber between: 1 and: self size) ifFalse: [^aBlock value].
	^self at: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
first

	self isEmpty ifTrue: [^nil].
	^self at: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
firstIndexOf: anElement startingAt: startIndex

	startIndex to: self size do: [:index | (self at: index) = anElement ifTrue: [^index]].		
	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
indexOf: anElement

	1 to: self size do: [:index | (self at: index) = anElement ifTrue: [^index]].	
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
last

	self isEmpty ifTrue: [^nil].
	^self at: self size ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
lastIndexOf: anElement

	self size to: 1 by: -1 do: [:index | (self at: index) = anElement ifTrue: [^index]].	
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'accessing'] value ! !
! SequenceableCollection methodsFor: 'accessing' !
reverse

	| result nextIndex |

	result := self class new: self size.
	nextIndex := 1.

	self size to: 1 by: -1 do: [:index |
		result at: nextIndex put: (self at: index).
		nextIndex := nextIndex + 1].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'comparing'] value ! !
! SequenceableCollection methodsFor: 'comparing' !
= anObject 

	self class == anObject class ifFalse: [^false].
	self size = anObject size ifFalse: [^false].
	self with: anObject do: [:object1 :object2 |
		object1 = object2 ifFalse: [^false]].
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'comparing'] value ! !
! SequenceableCollection methodsFor: 'comparing' !
hash

	| hash |
	hash := 0.

	self do: [:each |
		hash := ((hash * 104729 + each hash) integerAt: 1) \\ 1099511627776  ].

	^hash ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'converting'] value ! !
! SequenceableCollection methodsFor: 'converting' !
readStream

	^ReadStream on: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'converting'] value ! !
! SequenceableCollection methodsFor: 'converting' !
readWriteStream

	^ReadWriteStream on: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'converting'] value ! !
! SequenceableCollection methodsFor: 'converting' !
writeStream

	^WriteStream on: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
copy
	^self copyFrom: 1 to: self size. ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
copyFrom: startIndex to: endIndex 

	| result |

	endIndex < startIndex ifTrue: [^self class new: 0].

	result := self class new: endIndex - startIndex + 1.
	startIndex to: endIndex do: [:index |
		result at: index - startIndex + 1 put: (self at: index)].

	^result  ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
copyReplaceAll: collection1 with: collection2

	| inStream outStream |

	inStream := self readStream.
	outStream := WriteStream on: (self class new: collection2 size).

	[inStream atEnd] whileFalse: [
		| contents |
		contents := inStream throughAll: collection1.
		(contents endsWith: collection1)
			ifTrue: [
				outStream nextPutAll: (contents copyFrom: 1 to: (contents size - collection1 size)).
				outStream nextPutAll: collection2]
			ifFalse: [outStream nextPutAll: contents]].

	^outStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
copyReplacing: object1 with: object2

	| newString |
	newString := self class new: self size.
	1 to: newString size do: [:index |
		| currentObject |
		currentObject := self at: index.
		newString at: index put: (
			currentObject = object1
				ifTrue: [object2]
				ifFalse: [currentObject])].
	^newString ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
copyWith: anObject

	| copy |
	copy := self class new: self size + 1.
	1 to: self size do: [:index |
		copy at: index put: (self at: index)].
	copy at: self size + 1 put: anObject.
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
copyWithout: anObject

	| copy occurrences newIndex |
	
	occurrences := self occurrencesOf: anObject.
	copy := self class new: self size - occurrences.
	newIndex := 1.

	1 to: self size do: [:index |
		| object |
		object := self at: index.
		object = anObject ifFalse: [
			copy at: newIndex put: object.
			newIndex := newIndex + 1]].
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'copying'] value ! !
! SequenceableCollection methodsFor: 'copying' !
printItWith: aDictionary

	| result |

	self disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'richTextSelectedString')) printString].

	self code: (self code copyFrom: 1 to: (aDictionary at: 'richTextSelectionEnd')) ,
		result, ' ',
		(self code copyFrom: (aDictionary at: 'richTextSelectionEnd') + 1 to: self code size).
	self updateCodePane ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
collect: aBlock 

	| result |
	result := self species new: self size.
	1 to: self size do: [:each | result at: each put: (aBlock value: (self at: each))].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
do: aBlock 

	1 to: self size do: [:index |
		aBlock value: (self at: index)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
do: aBlock separatedBy: aBlock2

	| hasStarted |

	hasStarted := false.
	self do: [:each |
		hasStarted ifTrue: [aBlock2 value].
		hasStarted := true.
		aBlock value: each] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
findFirst: aBlock

	| index |

	index := 1.
	self do: [:each | (aBlock value: each) ifTrue: [^index].
		index := index + 1].
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
findLast: aBlock

	| index |

	index := self size.
	self reverseDo: [:each | (aBlock value: each) ifTrue: [^index].
		index := index - 1].
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
keysAndValuesDo: aBlock 

	1 to: self size do: [:index |
		aBlock value: index value: (self at: index)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
reverseDo: aBlock 

	self size to: 1 by: -1 do: [:index |
		aBlock value: (self at: index)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
select: aBlock 

	| result resultIndex |
	result := self species new: self size.

	resultIndex := 0.

	1 to: self size do: [:index |
		| value |
		value := self at: index.
		(aBlock value: value)
			ifTrue: [
				resultIndex := resultIndex + 1.
				result at: resultIndex put: value]
			ifFalse: [nil]].

	^result copyFrom: 1 to: resultIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
splitOn: anObject

	| result startSplitIndex |
	result := OrderedCollection new.
	startSplitIndex := 1.
	
	self keysAndValuesDo: [:key :each |
		each = anObject ifTrue: [
			result add: (self copyFrom: startSplitIndex to: key - 1).
			startSplitIndex := key + 1.
			]
		].
	
	result add: (self copyFrom: startSplitIndex to: self size).
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'enumerating'] value ! !
! SequenceableCollection methodsFor: 'enumerating' !
with: aCollection do: aBlock 

	aCollection size = self size ifFalse: [self error: 'Sizes don''t match'].
	1 to: aCollection size do: [:index |
		aBlock
			value: (self at: index)
			value: (aCollection at: index)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'json'] value ! !
! SequenceableCollection methodsFor: 'json' !
jsonOn: aStream

	aStream nextPut: $[.
	self do: [:each | each jsonOn: aStream]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $]. ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'manipulation'] value ! !
! SequenceableCollection methodsFor: 'manipulation' !
indexOfSubCollection: aSubcollection startingAt: anIndex

	| lastStartingPoint currentIndex indexFound |
	
	lastStartingPoint := anIndex.
	currentIndex := anIndex.
	indexFound := false.
	
	[lastStartingPoint <= (self size - aSubcollection size)] whileTrue:[
		(self at: lastStartingPoint) =( aSubcollection at: 1) ifTrue: [
			currentIndex := lastStartingPoint + 1.
			indexFound := true.
			[(currentIndex - lastStartingPoint + 1 <= aSubcollection size) & (indexFound = false) not] whileTrue:[
				(self at: currentIndex) =  (aSubcollection at: currentIndex - lastStartingPoint + 1) ifFalse: [indexFound := false].
				currentIndex := currentIndex + 1.
			].
		].
		indexFound = true ifTrue: [^lastStartingPoint] ifFalse: [lastStartingPoint := lastStartingPoint + 1].
	].

	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'operating'] value ! !
! SequenceableCollection methodsFor: 'operating' !
, aCollection 

	| result mySize |
	mySize := self size.
	result := self class new: mySize + aCollection size.

	1 to: mySize do: [:index |
		result at: index put: (self at: index)].

	1 to: aCollection size do: [:index |
		result at: index + mySize put: (aCollection at: index)].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'private'] value ! !
! SequenceableCollection methodsFor: 'private' !
species

	^OrderedCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'sorting'] value ! !
! SequenceableCollection methodsFor: 'sorting' !
sorted

	^self sortedBy: [:a :b | a < b]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'sorting'] value ! !
! SequenceableCollection methodsFor: 'sorting' !
sortedBy: aBlock
	^(Sorter new sortBlock: aBlock) sort: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection methodsFor: 'testing'] value ! !
! SequenceableCollection methodsFor: 'testing' !
endsWith: aCollection

	aCollection size = 0 ifTrue: [^false].
	self size < aCollection size ifTrue: [^false].

	aCollection keysAndValuesDo: [:index :value |
		(self at: self size - aCollection size + index) = value
			ifFalse: [^false].
		].

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection class methodsFor: 'instance creation'] value ! !
! SequenceableCollection class methodsFor: 'instance creation' !
from: aCollection

	| result |
	result := self new: aCollection size.
	1 to: aCollection size do: [:i | result at: i put: (aCollection at: i)].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection class methodsFor: 'instance creation'] value ! !
! SequenceableCollection class methodsFor: 'instance creation' !
new: size withAll: anObject 

	| newCollection |

	newCollection := self new: size.
	1 to: size do: [:index |
		newCollection at: index put: anObject].

	^newCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection class methodsFor: 'instance creation'] value ! !
! SequenceableCollection class methodsFor: 'instance creation' !
with: anObject 

	^(self new: 1)
		at: 1 put: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection class methodsFor: 'instance creation'] value ! !
! SequenceableCollection class methodsFor: 'instance creation' !
with: object1 with: object2 

	^(self new: 2)
		at: 1 put: object1;
		at: 2 put: object2;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection class methodsFor: 'instance creation'] value ! !
! SequenceableCollection class methodsFor: 'instance creation' !
with: object1 with: object2 with: object3 

	^(self new: 3)
		at: 1 put: object1;
		at: 2 put: object2;
		at: 3 put: object3;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceableCollection class methodsFor: 'instance creation'] value ! !
! SequenceableCollection class methodsFor: 'instance creation' !
with: object1 with: object2 with: object3 with: object4 

	^(self new: 4)
		at: 1 put: object1;
		at: 2 put: object2;
		at: 3 put: object3;
		at: 4 put: object4;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[ArrayedCollection class methodsFor: 'instance creation'] value ! !
! ArrayedCollection class methodsFor: 'instance creation' !
withAll: aCollection

	| newCollection index |
	newCollection := self new: aCollection size.
	index := 0.
	aCollection do: [:element | newCollection at: (index := index + 1) put: element].
	^newCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Array methodsFor: 'printing'] value ! !
! Array methodsFor: 'printing' !
printCollectionStartOn: aStream
	aStream nextPutAll: '#(' ! !
! Doit class methodsFor: 'doit' !
doit ^[Array methodsFor: 'private'] value ! !
! Array methodsFor: 'private' !
species

	^Array ! !
! Doit class methodsFor: 'doit' !
doit ^[Array methodsFor: 'testing'] value ! !
! Array methodsFor: 'testing' !
isArray

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteArray methodsFor: 'converting'] value ! !
! ByteArray methodsFor: 'converting' !
asByteArray

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteArray methodsFor: 'converting'] value ! !
! ByteArray methodsFor: 'converting' !
asString

	^ByteString withAll: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteArray methodsFor: 'printing'] value ! !
! ByteArray methodsFor: 'printing' !
printCollectionEndOn: aStream
	aStream nextPut: $] ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteArray methodsFor: 'printing'] value ! !
! ByteArray methodsFor: 'printing' !
printCollectionStartOn: aStream
	aStream nextPutAll: '#[' ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteArray methodsFor: 'printing'] value ! !
! ByteArray methodsFor: 'printing' !
printStringHex

	| stream |

	stream := WriteStream on: String new.
	stream nextPutAll: '#['.
	self do: [:each | stream nextPutAll: (each printStringRadix: 16)]
		separatedBy: [stream space].
	stream nextPut: $].
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteArray class methodsFor: 'instance creation'] value ! !
! ByteArray class methodsFor: 'instance creation' !
newFromImageSpace: aNumber

	<primitive: 120>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'accessing'] value ! !
! OrderedCollection methodsFor: 'accessing' !
at: aNumber 

	(aNumber between: 1 and: self size)
		ifFalse: [^self error: 'Index out of bounds'].
	^values at: aNumber + firstIndex - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'accessing'] value ! !
! OrderedCollection methodsFor: 'accessing' !
at: index put: anObject 

	(index = (self size + 1)) ifTrue: [self add: anObject. ^anObject].

	(index between: 1 and: self size)
		ifFalse: [^self error: 'Index out of bounds'].

	values at: index + firstIndex - 1 put: anObject.
	^anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'accessing'] value ! !
! OrderedCollection methodsFor: 'accessing' !
initializeSize: aNumber 

	firstIndex := 1.
	lastIndex := 0.
	values := Array new: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'accessing'] value ! !
! OrderedCollection methodsFor: 'accessing' !
last
	^ self at: self size. ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'accessing'] value ! !
! OrderedCollection methodsFor: 'accessing' !
privateValues

	^values  ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'accessing'] value ! !
! OrderedCollection methodsFor: 'accessing' !
size

	^lastIndex - firstIndex + 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
add: anObject 

	(lastIndex - values size) > 1 ifTrue: [
		self error: 'OrderedCollection broken: ', values class printString.
		].

	(lastIndex := lastIndex + 1) > values size ifTrue: [self grow].
	^values at: lastIndex put: anObject. ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
add: anObject beforeIndex: index

	| insertIndex |
	(lastIndex := lastIndex + 1) > values size ifTrue: [self grow].
	insertIndex := firstIndex - 1 + index.

	lastIndex to: insertIndex + 1 by: -1 do: [:i |
		values at: i put: (values at: i - 1)].

	^values at: insertIndex put: anObject. ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
addAll: aCollection 

	aCollection do: [:each | self add: each].
	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
addFirst: anObject 

	(lastIndex - values size) > 1 ifTrue: [
		self error: 'OrderedCollection broken: ', values class printString.
		].

	(firstIndex := firstIndex - 1) <= 0 ifTrue: [self growFirst].
	^values at: firstIndex put: anObject. ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
grow

	| newArray |
	newArray := Array new: (values size * 2 max: 5).

	1 to: values size do: [:index |
		newArray at: index put: (values at: index)].

	values := newArray ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
growFirst

	| newArray growSize |

	growSize := self growFirstSize.
	newArray := Array new: self size + growSize.
	firstIndex := firstIndex + growSize.
	lastIndex := lastIndex + growSize.

	firstIndex + 1 to: lastIndex do: [:index |
		newArray at: index put: (values at: index - growSize)].

	values := newArray ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
growFirstSize

	^10 ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
remove: object
	self size to: 1 by: -1 do: [:index | (self at: index) = object ifTrue: [self removeIndex: index]]. ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
removeAllSuchThat: aBlock 

	| copy sourceIndex |
	sourceIndex := 1.
	copy := self copy.
	1 to: self size do: [:index |
		(aBlock value: (copy at: index))
			ifTrue: [self removeIndex: sourceIndex]
			ifFalse: [sourceIndex := sourceIndex + 1].
		].
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
removeFirst

	^self removeIndex: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
removeIndex: removeIndex

	| index |
	index := firstIndex - 1 + removeIndex.
	[index < lastIndex]
		whileTrue: 
			[values at: index put: (values at: index+ 1).
			index := index+ 1].
	values at: lastIndex put: nil.
	lastIndex := lastIndex - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'adding and removing'] value ! !
! OrderedCollection methodsFor: 'adding and removing' !
removeLast

	| element |
	lastIndex >= firstIndex ifFalse: [^nil].
	element := values at: lastIndex.
	values at: lastIndex put: nil.
	lastIndex := lastIndex - 1.
	^element ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'converting'] value ! !
! OrderedCollection methodsFor: 'converting' !
asArray
	| array |
	array := Array new: (self size).
	
	1 to: self size do: [:index | array at: index put: (self at: index)].
	
	^array ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'copying'] value ! !
! OrderedCollection methodsFor: 'copying' !
copy

	| copy |
	copy := self class new: self size.
	self do: [:each | copy add: each].
	^copy ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'inspecting'] value ! !
! OrderedCollection methodsFor: 'inspecting' !
inspectorFieldAt: anInteger

	^self at: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'inspecting'] value ! !
! OrderedCollection methodsFor: 'inspecting' !
inspectorFields

	| indexedFields |

	indexedFields := OrderedCollection new.
	1 to: (self size min: 500) do: [:each | indexedFields add: each].
	^indexedFields  ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection methodsFor: 'operating'] value ! !
! OrderedCollection methodsFor: 'operating' !
, aCollection 

	| result mySize |
	mySize := self size.
	result := self class new: mySize + aCollection size.

	self do: [:element |
		result add: element].

	aCollection do: [:element |
		result add: element].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection class methodsFor: 'instance creation'] value ! !
! OrderedCollection class methodsFor: 'instance creation' !
new

	^self new: 10 ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection class methodsFor: 'instance creation'] value ! !
! OrderedCollection class methodsFor: 'instance creation' !
new: size 

	^(self basicNew) initializeSize: size; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection class methodsFor: 'instance creation'] value ! !
! OrderedCollection class methodsFor: 'instance creation' !
with: anObject 

	^(self new: 1)
		add: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection class methodsFor: 'instance creation'] value ! !
! OrderedCollection class methodsFor: 'instance creation' !
with: anObject with: object2

	^(self new: 10)
		add: anObject;
		add: object2;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection class methodsFor: 'instance creation'] value ! !
! OrderedCollection class methodsFor: 'instance creation' !
with: anObject with: object2 with: object3

	^(self new: 10)
		add: anObject;
		add: object2;
		add: object3;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[OrderedCollection class methodsFor: 'instance creation'] value ! !
! OrderedCollection class methodsFor: 'instance creation' !
with: anObject with: object2 with: object3 with: object4

	^(self new: 10)
		add: anObject;
		add: object2;
		add: object3;
		add: object4;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'accessing'] value ! !
! Set methodsFor: 'accessing' !
basicValues
	^values ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'accessing'] value ! !
! Set methodsFor: 'accessing' !
includes: anObject 

	| probe initialProbe |
	self isEmpty ifTrue: [^false].
	initialProbe := probe := anObject hash \\ values size + 1.
	[(values at: probe) isNil]
		whileFalse: 
			[(values at: probe)
				= anObject ifTrue: [^true].
			(probe := probe + 1) > values size ifTrue: [probe := 1].
			probe = initialProbe ifTrue: [self error: 'No nils left in set']].
	^false  ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'accessing'] value ! !
! Set methodsFor: 'accessing' !
size

	^numberOfElements ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'adding and removing'] value ! !
! Set methodsFor: 'adding and removing' !
add: anObject 

	| probe initialProbe |
	numberOfElements * 100 // values size > 70 ifTrue: [self grow].
	initialProbe := probe := anObject hash \\ values size + 1.
	[(values at: probe) isNil]
		whileFalse: 
			[(values at: probe)
				= anObject ifTrue: [^anObject].
			(probe := probe + 1) > values size ifTrue: [probe := 1].
			probe = initialProbe ifTrue: [self error: 'No nils left in set']].
	values at: probe put: anObject.
	numberOfElements := numberOfElements + 1.
	^anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'adding and removing'] value ! !
! Set methodsFor: 'adding and removing' !
addAll: aCollection 

	aCollection do: [:each | self add: each].
	^aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'adding and removing'] value ! !
! Set methodsFor: 'adding and removing' !
grow

	| newSet |
	
	newSet := self class new: (self size * 2 max: 10).

	self do: [:each | each isNil
		ifTrue: [nil]
		ifFalse: [newSet add: each]].

	values := newSet basicValues ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'enumerating'] value ! !
! Set methodsFor: 'enumerating' !
do: aBlock 

	values do: [:each | each notNil
			ifTrue: [aBlock value: each]] ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'initialize-release'] value ! !
! Set methodsFor: 'initialize-release' !
initialize: size 

	values := Array new: size.
	numberOfElements := 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'private'] value ! !
! Set methodsFor: 'private' !
species

	^Set ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'removing'] value ! !
! Set methodsFor: 'removing' !
remove: anObject 

	^self remove: anObject ifAbsent: [self error: 'Object not found in set'] ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'removing'] value ! !
! Set methodsFor: 'removing' !
remove: anObject ifAbsent: aBlock

	| probe initialProbe valuesToReHash rehashProbe |
	initialProbe := probe := anObject hash \\ values size + 1.

	[(values at: probe) = anObject]
		whileFalse: 
			[(values at: probe) isNil ifTrue: [
				aBlock value.
				^nil].
			(probe := probe + 1) > values size ifTrue: [probe := 1].
			probe = initialProbe ifTrue: [self error: 'No nils left in set'. ^nil]].

	values at: probe put: nil.
	numberOfElements := numberOfElements - 1.

	valuesToReHash := OrderedCollection new.
	(rehashProbe := probe + 1) > values size ifTrue: [rehashProbe := 1].
	
	[(values at: rehashProbe) isNil]
		whileFalse: 
			[valuesToReHash add: (values at: rehashProbe).
			values at: rehashProbe put: nil.
			numberOfElements := numberOfElements - 1.
			(rehashProbe := rehashProbe + 1) > values size ifTrue: [rehashProbe := 1].
			rehashProbe = initialProbe ifTrue: [self error: 'No nils left in set'. ^nil]].

	self addAll: valuesToReHash.

	^anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Set methodsFor: 'repairing'] value ! !
! Set methodsFor: 'repairing' !
recomputeTally
	| tally |
	tally := 0.
	self do: [:each | tally := tally + 1].
	numberOfElements := tally ! !
! Doit class methodsFor: 'doit' !
doit ^[Set class methodsFor: 'instance creation'] value ! !
! Set class methodsFor: 'instance creation' !
new

	^super new initialize: 10 ! !
! Doit class methodsFor: 'doit' !
doit ^[Set class methodsFor: 'instance creation'] value ! !
! Set class methodsFor: 'instance creation' !
new: size 

	^super new initialize: (size max: 10) ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'accessing'] value ! !
! SmallInteger methodsFor: 'accessing' !
basicAt: aNumber

	^self  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
<< aNumber

	^self bitShift: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
>> aNumber

	^self bitShift: aNumber negated ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
\\ aNumber 

	| remainder |
	remainder := self rem: aNumber.
	remainder < 0 ifTrue: [^remainder + aNumber].
	^remainder
   ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
asFloat

	<primitive: 13>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
bitAnd: aNumber

	<primitive: 90>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
bitInvert

	<primitive: 93>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
bitOr: aNumber

	<primitive: 91>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
bitShift: aNumber

	<primitive: 14>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
bitXOr: aNumber

	<primitive: 92>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
bitXor: aNumber

	<primitive: 92>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
divideWithRemainderBy: aNumber

	^self asLargeInteger divideWithRemainderBy: aNumber  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
leftRotate32: aNumber

	| temp lowerBits upperBits result masks |

	masks := #(2147483647 1073741823 536870911 268435455 134217727 67108863 33554431 16777215 8388607 4194303 2097151 1048575 524287 262143 131071 65535 32767 16383 8191 4095 2047 1023 511 255 127 63 31 15 7 3 1).

	temp := self \\ 4294967296.
	lowerBits := temp bitShift: aNumber - 32.
	upperBits := temp bitAnd: (masks at: aNumber).
	result := ((upperBits bitShift: aNumber) + lowerBits).
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
mod: aNumber 

	^self rem: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveDivide: aNumber 

	<primitive: 10>
	self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveGreaterThan: aNumber 

	<primitive: 4>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveGreaterThanOrEqualTo: aNumber 

	<primitive: 6>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveLessThan: aNumber 

	<primitive: 3>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveLessThanOrEqualTo: aNumber

	<primitive: 5>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveMinus: aNumber 

	<primitive: 2>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitivePlus: aNumber 

	<primitive: 1>
	self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveQuo: aNumber 

	<primitive: 12>
	self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveRem: aNumber 

	<primitive: 11>
	self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'arithmetic'] value ! !
! SmallInteger methodsFor: 'arithmetic' !
primitiveTimes: aNumber 

	<primitive: 9>
	self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'basicSize'] value ! !
! SmallInteger methodsFor: 'basicSize' !
basicSize
	^0  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'coercing'] value ! !
! SmallInteger methodsFor: 'coercing' !
coerceFloat: aFloat

	^aFloat  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'coercing'] value ! !
! SmallInteger methodsFor: 'coercing' !
coerceFraction: aFraction

	^aFraction  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'coercing'] value ! !
! SmallInteger methodsFor: 'coercing' !
coerceLargeInteger: aLargeInteger

	^aLargeInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'coercing'] value ! !
! SmallInteger methodsFor: 'coercing' !
coerceSmallInteger: aSmallInteger

	^aSmallInteger  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'coercing'] value ! !
! SmallInteger methodsFor: 'coercing' !
coerceTo: aNumber

	^aNumber coerceSmallInteger: self  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'coercing'] value ! !
! SmallInteger methodsFor: 'coercing' !
kind

	^#SmallInteger  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'comparing'] value ! !
! SmallInteger methodsFor: 'comparing' !
primitiveEqualTo: anObject 

	<primitive: 7>
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'comparing'] value ! !
! SmallInteger methodsFor: 'comparing' !
primitiveNotEqualTo: t1 

	<primitive: 8>
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'large integer support'] value ! !
! SmallInteger methodsFor: 'large integer support' !
asLargeInteger

	<primitive: 20>
	self primitiveFailed
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'large integer support'] value ! !
! SmallInteger methodsFor: 'large integer support' !
integerAt: aNumber

	aNumber = 1 ifTrue: [^self abs].
	^0
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger methodsFor: 'large integer support'] value ! !
! SmallInteger methodsFor: 'large integer support' !
reduce

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger class methodsFor: 'values'] value ! !
! SmallInteger class methodsFor: 'values' !
maxVal
	^1152921504606846975 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallInteger class methodsFor: 'values'] value ! !
! SmallInteger class methodsFor: 'values' !
minVal
	^-1152921504606846976 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'accessing'] value ! !
! Socket methodsFor: 'accessing' !
handle

	^handle ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'accessing'] value ! !
! Socket methodsFor: 'accessing' !
handle: anObject

	handle := anObject. ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'accessing'] value ! !
! Socket methodsFor: 'accessing' !
handleBlock

	^handleBlock
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'accessing'] value ! !
! Socket methodsFor: 'accessing' !
handleBlock: aBlock

	handleBlock := aBlock
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'accessing'] value ! !
! Socket methodsFor: 'accessing' !
stream

	^SocketStream on: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
FIONBIO

	^16r8004667e  ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
accept

	| newHandle |

	newHandle := self basicAccept.
	newHandle isInteger ifTrue: [^newHandle].

	^self class new
		handle: newHandle;
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
basicAccept

	<primitive: 202>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
bind

	<primitive: 203>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
close

	self handle isNil ifTrue: [^self].
	self primClose.
	self handle: nil. ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
connect

	<primitive: 204>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
family: family address: address port: port

	<primitive: 201>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
getPeerName

	<primitive: 205>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
getSockName

	<primitive: 206>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
getSockOptLevel: level optionName: optionName value: value length: length

	<primitive: 207>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
ioctl: cmd data: data

	<primitive: 221>
	self primitiveFailed  ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
listen: backlog

	<primitive: 208>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
makeNonBlocking

	self ioctl: self FIONBIO data: 1  ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
primClose

	<primitive: 218>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
read: buffer length: length

	<primitive: 209>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
shutdown: how

	<primitive: 216>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'actions'] value ! !
! Socket methodsFor: 'actions' !
write: buffer length: length

	<primitive: 212>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket methodsFor: 'testing'] value ! !
! Socket methodsFor: 'testing' !
isActive

	^handle notNil ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_appletalk

	^16 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_bth

	^32 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_inet

	^2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_inet6

	^23 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_ipx

	^6 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_irda

	^26 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_netbios

	^17 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
af_unspec

	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_icmp

	^1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_icpmv6

	^58 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_igmp

	^2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_rfcomm

	^3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_rm

	^113 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_tcp

	^6 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
ipproto_udp

	^17 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
sock_dgram

	^2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
sock_raw

	^3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
sock_rdm

	^4 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
sock_seqpacket

	^5 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'constants'] value ! !
! Socket class methodsFor: 'constants' !
sock_stream

	^1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'instance creation'] value ! !
! Socket class methodsFor: 'instance creation' !
basicNewInDomain: domain type: type protocol: protocol

	<primitive: 200> ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'instance creation'] value ! !
! Socket class methodsFor: 'instance creation' !
newInDomain: domain type: type protocol: protocol

	^self new
		handle: (self basicNewInDomain: domain type: type protocol: protocol);
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'instance creation'] value ! !
! Socket class methodsFor: 'instance creation' !
newTCPConnection

	^self
		newInDomain: self af_inet
		type: self sock_stream
		protocol: 0  ! !
! Doit class methodsFor: 'doit' !
doit ^[Socket class methodsFor: 'primitives'] value ! !
! Socket class methodsFor: 'primitives' !
poll: handles events: events revents: revents timeout: timeout

	<primitive: 219>
	self primitiveFail
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
events

	^events ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
events: anArray

	events := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
handlers

	^handlers ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
handlers: anArray

	handlers := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
revents

	^revents ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
revents: anArray

	revents := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
running

	^running ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
running: aBoolean

	running := aBoolean ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
socketHandles

	^socketHandles ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
socketHandles: anArray

	socketHandles := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
timeoutHandler

	^timeoutHandler ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
timeoutHandler: aHandler

	timeoutHandler := aHandler ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
timeoutInterval

	^timeoutInterval ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'accessing'] value ! !
! SocketDispatcher methodsFor: 'accessing' !
timeoutInterval: aNumber

	timeoutInterval := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'handlers'] value ! !
! SocketDispatcher methodsFor: 'handlers' !
addHandler: aSocketHandler

	aSocketHandler dispatcher: self.
	self handlers add: aSocketHandler.
	aSocketHandler startup
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'handlers'] value ! !
! SocketDispatcher methodsFor: 'handlers' !
removeHandler: aSocketHandler

	(self handlers includes: aSocketHandler) ifFalse: [^self].

	aSocketHandler shutdown.
	self handlers remove: aSocketHandler ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'handlers'] value ! !
! SocketDispatcher methodsFor: 'handlers' !
shutdown

	self handlers copy do: [:each | self removeHandler: each].
	running := false.
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'initializing'] value ! !
! SocketDispatcher methodsFor: 'initializing' !
initialize

	super initialize.
	self
		handlers: OrderedCollection new;
		running: true;
		timeoutInterval: 5000;
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'polling'] value ! !
! SocketDispatcher methodsFor: 'polling' !
POLLHUP

	^16 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'polling'] value ! !
! SocketDispatcher methodsFor: 'polling' !
POLLIN

	^1  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'polling'] value ! !
! SocketDispatcher methodsFor: 'polling' !
poll

	self setupPollStructures.

	^Socket
		poll: self socketHandles asArray
		events: self events asArray
		revents: self revents asArray
		timeout: self timeoutInterval
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'polling'] value ! !
! SocketDispatcher methodsFor: 'polling' !
setupPollStructures

	self
		socketHandles: (self handlers collect: [:each | each socket handle]) asArray;
		events: (Array new: self socketHandles size withAll: self POLLIN);
		revents: (Array new: self socketHandles size withAll: 0)  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketDispatcher methodsFor: 'polling'] value ! !
! SocketDispatcher methodsFor: 'polling' !
startPollLoop

	[self running] whileTrue: [
		| result |
		result := self poll.
		result = 0
			ifTrue: [self timeoutHandler isNil ifFalse: [self timeoutHandler handle]]
			ifFalse: [
				result < 0 ifTrue: [^self error: 'poll loop error: ', result printString].
				self revents keysAndValuesDo: [:index :value |
					(value bitAnd: self POLLHUP) = self POLLHUP ifTrue: [(self handlers at: index) socket close. (self handlers at: index) closeIfNeeded].
					(value bitAnd: self POLLIN) = self POLLIN ifTrue: [(self handlers at: index) handle] ] ] ]
   ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'accessing'] value ! !
! SocketHandler methodsFor: 'accessing' !
dispatcher

	^dispatcher  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'accessing'] value ! !
! SocketHandler methodsFor: 'accessing' !
dispatcher: aDispatcher

	dispatcher := aDispatcher  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'accessing'] value ! !
! SocketHandler methodsFor: 'accessing' !
socket

	^socket ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'accessing'] value ! !
! SocketHandler methodsFor: 'accessing' !
socket: aSocket

	socket := aSocket ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'handling'] value ! !
! SocketHandler methodsFor: 'handling' !
closeIfNeeded

	(self socket isActive not and: [self dispatcher notNil])
		ifTrue: [self dispatcher removeHandler: self] ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'handling'] value ! !
! SocketHandler methodsFor: 'handling' !
handle

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'handling'] value ! !
! SocketHandler methodsFor: 'handling' !
shutdown
 
	self socket isNil ifFalse: [self socket close]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'handling'] value ! !
! SocketHandler methodsFor: 'handling' !
startup
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler methodsFor: 'initializing'] value ! !
! SocketHandler methodsFor: 'initializing' !
initialize

	  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler class methodsFor: 'instance creation'] value ! !
! SocketHandler class methodsFor: 'instance creation' !
new

	^super new initialize; yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketHandler class methodsFor: 'instance creation'] value ! !
! SocketHandler class methodsFor: 'instance creation' !
startupOn: aSocket


	^self new
		socket: aSocket;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'accessing'] value ! !
! SocketAcceptHandler methodsFor: 'accessing' !
clientHandler

	^clientHandler ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'accessing'] value ! !
! SocketAcceptHandler methodsFor: 'accessing' !
clientHandler: aHandler

	clientHandler := aHandler ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'accessing'] value ! !
! SocketAcceptHandler methodsFor: 'accessing' !
portNumber

	^portNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'accessing'] value ! !
! SocketAcceptHandler methodsFor: 'accessing' !
portNumber: aNumber

	portNumber := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'handling'] value ! !
! SocketAcceptHandler methodsFor: 'handling' !
handle

	| result |

	result := self socket accept.
	result isInteger ifTrue: [
		self log: 'Socket accept error: ', result printString.
		^self].

	self dispatcher
		addHandler: (self clientHandler startupOn: result)


   ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'handling'] value ! !
! SocketAcceptHandler methodsFor: 'handling' !
shutdown

	self socket close  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketAcceptHandler methodsFor: 'handling'] value ! !
! SocketAcceptHandler methodsFor: 'handling' !
startup

	self socket: (Socket newTCPConnection	
		family: Socket af_inet address: 0 port: self portNumber;
		bind;
		listen: 10;
		makeNonBlocking;
		yourself).
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
commandHandlerClass

	^commandHandlerClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
commandHandlerClass: aClass

	commandHandlerClass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
screenHandlerClass

	^screenHandlerClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
screenHandlerClass: aClass

	screenHandlerClass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
startupReceiver

	^startupReceiver ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
startupReceiver: anObject

	startupReceiver := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
startupSelector

	^startupSelector ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'accessing'] value ! !
! SocketLauncher methodsFor: 'accessing' !
startupSelector: aSymbol

	startupSelector := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketLauncher methodsFor: 'startup'] value ! !
! SocketLauncher methodsFor: 'startup' !
startupOn: aSocket

	^self screenHandlerClass new
		socket: aSocket;
		commandHandler: self commandHandlerClass new;
		startupReceiver: self startupReceiver;
		startupSelector: self startupSelector;
		yourself
		 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketTimeoutHandler methodsFor: 'accessing'] value ! !
! SocketTimeoutHandler methodsFor: 'accessing' !
timeoutBlock

	^timeoutBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketTimeoutHandler methodsFor: 'accessing'] value ! !
! SocketTimeoutHandler methodsFor: 'accessing' !
timeoutBlock: aBlock

	timeoutBlock := aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketTimeoutHandler methodsFor: 'handling'] value ! !
! SocketTimeoutHandler methodsFor: 'handling' !
handle

	self timeoutBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
commandHandler

	^commandHandler  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
commandHandler: aCommandHandler

	commandHandler := aCommandHandler  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
socketState

	^socketState ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
socketState: aSymbol

	socketState := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
startupReceiver

	^startupReceiver ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
startupReceiver: anObject

	startupReceiver := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
startupSelector

	^startupSelector ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
startupSelector: aSymbol

	startupSelector := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
uiScreen

	^uiScreen ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
uiScreen: aUIScreen

	uiScreen := aUIScreen ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
webSocket

	^webSocket ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'accessing'] value ! !
! SocketUIScreenHandler methodsFor: 'accessing' !
webSocket: aWebSocket

	webSocket := aWebSocket ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'handling'] value ! !
! SocketUIScreenHandler methodsFor: 'handling' !
handle

	self withMyUIScreenDo: [
		| message |
		self socketState = #connecting ifTrue: [^self handleWebSocketConnection].
		message := self webSocket readContentMessage.
		message isNil
			ifTrue: [self socket close]
			ifFalse: [self processMessage: message]].

	self closeIfNeeded
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'handling'] value ! !
! SocketUIScreenHandler methodsFor: 'handling' !
handleWebSocketConnection

	self webSocket processConnectionMessage.
	self socketState: #connected.

	(self startupReceiver notNil and: [self startupSelector notNil]) ifTrue: [
		self withMyUIScreenDo: [self startupReceiver perform: self startupSelector]].

	self closeIfNeeded
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'handling'] value ! !
! SocketUIScreenHandler methodsFor: 'handling' !
processMessage: aMessage

	Error
		try: [
			self commandHandler processMessage: aMessage onWebSocket: self webSocket]
		catch: [:ex |
			Debugger openOn: thisContext message: ex message.
			ex return: true]
		finally: nil.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'handling'] value ! !
! SocketUIScreenHandler methodsFor: 'handling' !
startup

	webSocket := WebSocket new.

	uiScreen := UIScreen new
		webSocket: webSocket;
		yourself.

	webSocket
		socket: self socket;
		startupConnection;
		yourself.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'handling'] value ! !
! SocketUIScreenHandler methodsFor: 'handling' !
withMyUIScreenDo: aBlock

	| oldScreen |
	oldScreen := Smalltalk at: #CurrentScreen.
	Smalltalk at: #CurrentScreen put: self uiScreen.
	aBlock ensure: [Smalltalk at: #CurrentScreen put: oldScreen]
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketUIScreenHandler methodsFor: 'initializing'] value ! !
! SocketUIScreenHandler methodsFor: 'initializing' !
initialize

	super initialize.
	self socketState: #connecting

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'accessing'] value ! !
! Sorter methodsFor: 'accessing' !
partition: aCollection from: start to: end

	| pivotValue i j |

	pivotValue := aCollection at: end.
	(sortBlock value: pivotValue value: pivotValue) ifTrue: [^self partitionInclusive: aCollection from: start to: end].

	i := start.
	j := end.

	[
		"Find the index i of the first element that's out of order.  If none, then i = j."
		[
		i < j and: [sortBlock value: (aCollection at: i) value: pivotValue]] whileTrue: [i := i + 1].
	
		i = j ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifTrue: [^j + 1 min: end].
			^j].
	
		"Find the index j of the last element that's out of order.  If none, then j = i."
		[j > i and: [sortBlock value: pivotValue value: (aCollection at: j)]] whileTrue: [j := j - 1].
		j = i ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifTrue: [^j + 1 min: end].
			^j].

		self swap: aCollection from: i to: j.

			i := i + 1
	] whileTrue: [] ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'accessing'] value ! !
! Sorter methodsFor: 'accessing' !
sort: aCollection
	^self sort: aCollection from: 1 to: aCollection size ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'accessing'] value ! !
! Sorter methodsFor: 'accessing' !
sort: aCollection from: start to: end

	| centerIndex partitionsToSort |

	start >= end ifTrue: [^aCollection].

	partitionsToSort := OrderedCollection new
		add: (Array with: start with: end);
		yourself.

	[partitionsToSort isEmpty] whileFalse: [
		| partition partitionStart partitionEnd |
		
		partition := partitionsToSort removeLast.
		partitionStart := partition first.
		partitionEnd := partition last.
		partition := nil.
		
		centerIndex := self partition: aCollection from: partitionStart to: partitionEnd.
		"centerIndex is the index of the first element where the block evaluates to true"
		
		centerIndex - 1 > partitionStart ifTrue: [
			partitionsToSort add: (Array with: partitionStart with: centerIndex - 1)].
		centerIndex < partitionEnd ifTrue: [
			partitionsToSort add: (Array with: centerIndex with: partitionEnd)]].
	
	partitionsToSort := nil.
	^aCollection
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'accessing'] value ! !
! Sorter methodsFor: 'accessing' !
sortBlock
	^sortBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'accessing'] value ! !
! Sorter methodsFor: 'accessing' !
sortBlock: aBlock
	sortBlock := aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'sorting'] value ! !
! Sorter methodsFor: 'sorting' !
partitionInclusive: aCollection from: start to: end

	| pivotValue i j |

	pivotValue := aCollection at: end.

	i := start.
	j := end.

	[
		"Find the index i of the first element that's out of order.  If none, then i = j."
		[
		i < j and: [(sortBlock value: pivotValue value: (aCollection at: i)) not]] whileTrue: [i := i + 1].	
		i = j ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifFalse: [^j + 1 min: end].
			^j].
	
		"Find the index j of the last element that's out of order.  If none, then j = i."
		[j > i and: [(sortBlock value: (aCollection at: j) value: pivotValue) not]] whileTrue: [j := j - 1].
		j = i ifTrue: [
			(sortBlock value: pivotValue value: pivotValue)
				ifFalse: [^j + 1 min: end].
			^j].

		self swap: aCollection from: i to: j.

			i := i + 1
	] whileTrue: [] ! !
! Doit class methodsFor: 'doit' !
doit ^[Sorter methodsFor: 'sorting'] value ! !
! Sorter methodsFor: 'sorting' !
swap: aCollection from: i to: j

	| temp |
	temp :=  aCollection at: i.
	aCollection at: i put: (aCollection at: j).
	aCollection at: j put: temp ! !
! Doit class methodsFor: 'doit' !
doit ^[Stream methodsFor: 'accessing'] value ! !
! Stream methodsFor: 'accessing' !
readLimit

	^readLimit ! !
! Doit class methodsFor: 'doit' !
doit ^[Stream methodsFor: 'accessing'] value ! !
! Stream methodsFor: 'accessing' !
readLimit: aNumber 

	readLimit := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Stream methodsFor: 'positioning'] value ! !
! Stream methodsFor: 'positioning' !
position

	^position ! !
! Doit class methodsFor: 'doit' !
doit ^[Stream methodsFor: 'positioning'] value ! !
! Stream methodsFor: 'positioning' !
position: aNumber 

	position := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Stream methodsFor: 'positioning'] value ! !
! Stream methodsFor: 'positioning' !
skip: aNumber 

	((position := position + aNumber) < 0 or: [position > self readLimit])
		ifTrue: [self error: 'Position out of bounds'] ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream methodsFor: 'accessing'] value ! !
! InternalStream methodsFor: 'accessing' !
collection

	^collection ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream methodsFor: 'accessing'] value ! !
! InternalStream methodsFor: 'accessing' !
collection: aCollection 

	readLimit := (collection := aCollection) size ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream methodsFor: 'initialize-release'] value ! !
! InternalStream methodsFor: 'initialize-release' !
initialize

	self reset ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream methodsFor: 'initialize-release'] value ! !
! InternalStream methodsFor: 'initialize-release' !
reset

	position := 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream class methodsFor: 'instance creation'] value ! !
! InternalStream class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[InternalStream class methodsFor: 'instance creation'] value ! !
! InternalStream class methodsFor: 'instance creation' !
on: aCollection 

	^self new
		collection: aCollection;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
atEnd

	^position >= self readLimit ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
next

	position >= self readLimit ifTrue: [self error: 'Read past end of stream'].
	position := position + 1.
	^collection at: position ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
next: aNumber

	| stream |
	
	stream := WriteStream on: self collection class new.
	aNumber timesRepeat: [
		| next |
		next := self next.
		next isNil ifTrue: [^nil].
		stream nextPut: next].

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
nextAvailable: aNumber

	| stream |
	
	stream := WriteStream on: self collection class new.
	aNumber timesRepeat: [
		self atEnd ifFalse: [stream nextPut: self next]].

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
peek

	| item |

	self atEnd ifTrue: [^nil].
	item := self next.
	self skip: -1.
	^item ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
previous

	| item |

	position = 0 ifTrue: [^nil].
	self skip: -1.
	item := self next.
	^item   ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
throughAll: aCollection

	| contents |

	contents := OrderedCollection new.

	[self atEnd] whileFalse: [
		contents add: self next.
		(contents endsWith: aCollection) ifTrue: [
			^collection class withAll: contents]].

	^contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
upTo: anObject

	| stream |

	stream := WriteStream on: (collection class new: collection size).

	[self atEnd not and: [self peek ~= anObject]]
		whileTrue: [stream nextPut: self next].

	self atEnd ifFalse: [self next].

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
upToAll: aCollection

	| found |

	found := self throughAll: aCollection.
	^found copyFrom: 1 to: (found size - aCollection size) ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'accessing'] value ! !
! ReadStream methodsFor: 'accessing' !
upToEnd

	| outStream |

	outStream := WriteStream on: (String new: 10).
	[self atEnd] whileFalse: [
		outStream nextPut: self next].

	^outStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'fileIn/Out'] value ! !
! ReadStream methodsFor: 'fileIn/Out' !
fileIn

	^FileinReader fileIn: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadStream methodsFor: 'writing'] value ! !
! ReadStream methodsFor: 'writing' !
contents

	^collection copyFrom: 1 to: position ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
contents

	^collection copyFrom: 1 to: position ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
cr

	self nextPut: Character cr ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
grow

	| newCollection |
	newCollection := collection class new: (collection size * 2 max: 10).
	1 to: collection size do: [:index |
		newCollection at: index put: (collection at: index)].

	collection := newCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
nextPut: anObject 

	position >= collection size ifTrue: [self grow].
	position := position + 1.
	collection at: position put: anObject.
	readLimit := position ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
nextPutAll: aCollection 

	aCollection do: [:character | self nextPut: character] ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
print: aStream 

	aStream printOn: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
print: anObject limit: aNumber

	anObject printOn: self limit: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
space

	self nextPut: Character space ! !
! Doit class methodsFor: 'doit' !
doit ^[ReadWriteStream methodsFor: 'writing'] value ! !
! ReadWriteStream methodsFor: 'writing' !
tab

	self nextPut: Character tab ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
atEnd

	<primitive: 1509>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
basicNext

	self lineEndConvention notNil ifTrue: [^self lineEndConvention nextFor: self].
	^self primNext ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
basicNext: aNumber

	self lineEndConvention notNil ifTrue: [^self lineEndConvention next: aNumber for: self].
	^self primNext: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
basicUpToEnd

	self lineEndConvention notNil ifTrue: [^self lineEndConvention upToEndFor: self].
	^self primUpToEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
binary

	self isBinary: true ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
close

	<primitive: 1502>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
flush

	<primitive: 1510>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
handle

	^handle ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
handle: anObject

	handle := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
isBinary

	^isBinary ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
isBinary: anObject

	anObject
		ifTrue: [self lineEndConvention: nil]
		ifFalse: [self lineEndConvention: LineEndConventionCRLF new].
	isBinary := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
lineEndConvention
	^lineEndConvention ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
lineEndConvention: aLineEndConvention
	lineEndConvention := aLineEndConvention ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
next

	| result |
	
	result := self basicNext.
	^self isBinary
		ifTrue: [result]
		ifFalse: [Character value: result] ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
next: aNumber

	| result |

	result := self basicNext: aNumber.
	^self isBinary ifTrue: [result asByteArray] ifFalse: [result asString] ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
nextPut: anInteger

	self lineEndConvention notNil ifTrue: [^self lineEndConvention nextPut: anInteger for: self].
	^self primNextPut: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
nextPutAll: aCollection

	self lineEndConvention notNil ifTrue: [^self lineEndConvention nextPutAll: aCollection for: self].
	^self primNextPutAll: aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
open: aString

	self lineEndConvention: LineEndConventionCRLF new.
	^self primOpen: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
open: aString mode: aNullTerminatedString

	self lineEndConvention: LineEndConventionCRLF new.
	^self primOpen: aString mode: aNullTerminatedString ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
position

	<primitive: 1511>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
position: aNumber

	<primitive: 1512>
	^self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primNext

	<primitive: 1503>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primNext: aNumber

	<primitive: 1504>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primNextPut: anInteger

	<primitive: 1505>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primNextPutAll: aCollection

	<primitive: 1506>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primOpen: aString

	<primitive: 1500>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primOpen: aString mode: aNullTerminatedString

	<primitive: 1501>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primSkip: aNumber

	<primitive: 1507>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
primUpToEnd

	<primitive: 1508>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
skip: aNumber

	self lineEndConvention notNil ifTrue: [^self lineEndConvention skip: aNumber for: self].
	^self primSkip: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'accessing'] value ! !
! FileStream methodsFor: 'accessing' !
upToEnd

	| result |

	result := self basicUpToEnd.
	^self isBinary ifTrue: [result asByteArray] ifFalse: [result asString] ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream methodsFor: 'initialize-release'] value ! !
! FileStream methodsFor: 'initialize-release' !
initialize

	super initialize.
	isBinary := false ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
append

	^'ab' ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
appendableRead

	^'ab+' ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
overwrite

	^'wb+' ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
pathDelimiterString

	^'/' ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
read

	^'rb' ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
writableRead

	^'rb+' ! !
! Doit class methodsFor: 'doit' !
doit ^[FileStream class methodsFor: 'constants'] value ! !
! FileStream class methodsFor: 'constants' !
write

	^'wb' ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
atEnd

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
bufferSize

	^1024 ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
next

	internalStream atEnd ifTrue: [
		self read].
	internalStream atEnd ifTrue: [^nil].
	^internalStream next ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
peek

	internalStream atEnd ifTrue: [
		self read].
	^internalStream peek ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
read

	| byteArray length |

	byteArray := ByteArray new: self bufferSize.
	length := socket read: byteArray length: self bufferSize.
	internalStream collection: (byteArray copyFrom: 1 to: length).
	internalStream reset ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
socket

	^socket ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'accessing'] value ! !
! SocketStream methodsFor: 'accessing' !
socket: anObject

	socket := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'initialize-release'] value ! !
! SocketStream methodsFor: 'initialize-release' !
initialize

	super initialize.
	internalStream := ReadWriteStream on: ByteArray new.
	collection := ByteArray new ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'testing'] value ! !
! SocketStream methodsFor: 'testing' !
isActive

	^self socket isActive  ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'writing'] value ! !
! SocketStream methodsFor: 'writing' !
commit

	| byteArray |

	byteArray := internalStream contents.
	socket write: byteArray length: byteArray size.
	self reset ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'writing'] value ! !
! SocketStream methodsFor: 'writing' !
nextPut: anObject

	internalStream nextPut: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream methodsFor: 'writing'] value ! !
! SocketStream methodsFor: 'writing' !
reset

	internalStream := ReadWriteStream on: ByteArray new ! !
! Doit class methodsFor: 'doit' !
doit ^[SocketStream class methodsFor: 'instance creation'] value ! !
! SocketStream class methodsFor: 'instance creation' !
on: aSocket

	^self new
		socket: aSocket;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
asFilename

	^Filename named: self ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
asLowercase

	| newString |
	newString := self class new: self size.
	1 to: self size do: [:index |
		newString at: index put: (self at: index) asLowercase].
	^newString ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
asSimtalkString

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
asSymbol

	^ByteSymbol intern: self ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
asUppercase

	| newString |
	newString := self class new: self size.
	1 to: self size do: [:index |
		newString at: index put: (self at: index) asUppercase].
	^newString ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
convertLineEndingsTo2: aSymbol

	| inStream outStream |

	inStream := self readStream.
	outStream := WriteStream on: (String new: self size).

	[inStream atEnd] whileFalse: [
		| character |
		character := inStream next.
		character = Character cr ifTrue: [(inStream atEnd not and: [inStream peek = Character lf]) ifTrue: [inStream next]].
		character = Character lf ifTrue: [(inStream atEnd not and: [inStream peek = Character cr]) ifTrue: [inStream next]].
		(character = Character cr |  (character = Character lf))
			ifTrue: [
				aSymbol = #cr ifTrue: [outStream nextPut: Character cr].
				aSymbol = #lf ifTrue: [outStream nextPut: Character lf].
				aSymbol = #crlf ifTrue: [outStream nextPut: Character cr; nextPut: Character lf]]
			ifFalse: [outStream nextPut: character]
		].

	^outStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
convertLineEndingsTo: aSymbol

	| inStream outStream |

	inStream := self readStream.
	outStream := WriteStream on: (String new: self size).

	[inStream atEnd] whileFalse: [
		| character |
		character := inStream next.
		character = Character cr ifTrue: [(inStream atEnd not and: [inStream peek = Character lf]) ifTrue: [inStream next]].
		character = Character lf ifTrue: [(inStream atEnd not and: [inStream peek = Character cr]) ifTrue: [inStream next]].
		(character = Character cr |  (character = Character lf))
			ifTrue: [
				aSymbol = #cr ifTrue: [outStream nextPut: Character cr].
				aSymbol = #lf ifTrue: [outStream nextPut: Character lf].
				aSymbol = #crlf ifTrue: [outStream nextPut: Character cr; nextPut: Character lf]]
			ifFalse: [outStream nextPut: character]
		].

	^outStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
crToCRLF

	| in out |
	in := self readStream.
	out := WriteStream on: (String new: self size).

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		out nextPut: character.
		character = Character cr
			ifTrue: [out nextPut: Character lf]
		].

	^out contents
 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
crToLF

	| in out |
	in := self readStream.
	out := WriteStream on: (String new: self size).

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		character = Character cr
			ifTrue: [out nextPut: Character lf]
			ifFalse: [out nextPut: character]
		].

	^out contents
  ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
extractUTF8CharacterFrom: aStream

	| value |
	value := aStream next asInteger.
	(value bitAnd: 16r80) = 0 ifTrue: [^value].
	(value bitAnd: 16rE0) = 16rC0
		ifTrue: [^((value bitAnd: 16r1F) bitShift: 6) + (aStream next asInteger bitAnd: 16r3F)].
	(value bitAnd: 16rF0) = 16rE0
		ifTrue: [^((value bitAnd: 16r0F) bitShift: 12)
				+ ((aStream next asInteger bitAnd: 16r3F) bitShift: 6)
				+ (aStream next asInteger bitAnd: 16r3F)].
	(value bitAnd: 16rF8) = 16rF0
		ifTrue: [^(value bitAnd: 16r07) << 18
				+ ((aStream next asInteger bitAnd: 16r3F) bitShift: 12)
				+ ((aStream next asInteger bitAnd: 16r3F) bitShift: 6)
				+ (aStream next asInteger bitAnd: 16r3F)].

	self error: 'Invalid UTF-8 String' ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
lfToCR

	| in out |
	in := self readStream.
	out := WriteStream on: (String new: self size).

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		character = Character lf
			ifTrue: [out nextPut: Character cr]
			ifFalse: [out nextPut: character]
		].

	^out contents
  ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
trimSeparators

	| firstNonSeparator lastNonSeparator |

	firstNonSeparator := self findFirst: [:each | each isSeparator not].
	firstNonSeparator = 0 ifTrue: [^''].

	lastNonSeparator := self findLast: [:each | each isSeparator not].
	lastNonSeparator < firstNonSeparator ifTrue: [^''].
	
	^self copyFrom: firstNonSeparator to: lastNonSeparator ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'converting'] value ! !
! String methodsFor: 'converting' !
utf8Decode

	| decodedString stream |
	decodedString := OrderedCollection new.
	stream := self readStream.
	[stream atEnd] whileFalse: [
		decodedString add: (self extractUTF8CharacterFrom: stream).
		].

	^decodedString asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'json'] value ! !
! String methodsFor: 'json' !
jsonOn: aStream

	aStream nextPut: $".
	aStream nextPutAll: ((self copyReplaceAll: '\' with: '\\') copyReplaceAll: '"' with: '\"').
	aStream nextPut: $". ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'manipulation'] value ! !
! String methodsFor: 'manipulation' !
asByteArray

	| byteArray |
	byteArray := ByteArray new: self size.
	1 to: self size do: [:i |
		byteArray at: i put: (self at: i) asInteger].
	^byteArray ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'manipulation'] value ! !
! String methodsFor: 'manipulation' !
asString

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'manipulation'] value ! !
! String methodsFor: 'manipulation' !
capitalized

	^self asString copy at: 1 put: (self at: 1) asUppercase ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'manipulation'] value ! !
! String methodsFor: 'manipulation' !
subStringFrom: i to: j

	| subString |
	i < 0 ifTrue: [^self].
	j > self size ifTrue: [^self].
	subString := self class new: (j - i) + 1.
	i to: j do: [:index |
		subString at: (index - i + 1) put: (self at: index).
	].

	^subString ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'manipulation'] value ! !
! String methodsFor: 'manipulation' !
withCRs

	^self copyReplacing: $\ with: Character cr ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'printing'] value ! !
! String methodsFor: 'printing' !
printOn: aStream 

	self printPrefixOn: aStream.

	self do: [:t2 | 
		t2 = $' ifTrue: [aStream nextPut: $'].
		aStream nextPut: t2].

	self printSuffixOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'printing'] value ! !
! String methodsFor: 'printing' !
printPrefixOn: aStream 

	aStream nextPut: $' ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'printing'] value ! !
! String methodsFor: 'printing' !
printSuffixOn: aStream 

	aStream nextPut: $' ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'printing'] value ! !
! String methodsFor: 'printing' !
storeOn: aStream 

	^self printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'testing'] value ! !
! String methodsFor: 'testing' !
< aString

	^(self compareString: aString) = -1 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'testing'] value ! !
! String methodsFor: 'testing' !
<= aString

	^(self compareString: aString) <= 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'testing'] value ! !
! String methodsFor: 'testing' !
> aString

	^(self compareString: aString) = 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'testing'] value ! !
! String methodsFor: 'testing' !
>= aString

	^(self compareString: aString) >= 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'testing'] value ! !
! String methodsFor: 'testing' !
compareString: aString

	| index selfSize aStringSize|

	index := 1.
	selfSize := self size.
	aStringSize := aString size.

	[(index <= selfSize) and: [index <= aStringSize]] whileTrue: [
		| character1 character2 |
		character1 := self at: index.
		character2 := aString at: index.
		character1 < character2 ifTrue: [^-1].
		character1 > character2 ifTrue: [^1].
		index := index + 1].

	index <= selfSize ifTrue: [^1].
	index <= aStringSize ifTrue: [^-1].
	^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'testing'] value ! !
! String methodsFor: 'testing' !
isString

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'utilities'] value ! !
! String methodsFor: 'utilities' !
match: aString ignoreCase: aBoolean

	 ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'utilities'] value ! !
! String methodsFor: 'utilities' !
matches: aString

	^(StringMatcher pattern: self) match: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'utilities'] value ! !
! String methodsFor: 'utilities' !
splitBy: aCharacter

	| tokens stream |

	tokens := OrderedCollection new.
	stream := self readStream.
	[stream atEnd] whileFalse: [
		tokens add: (stream upTo: aCharacter)].

	^tokens ! !
! Doit class methodsFor: 'doit' !
doit ^[String methodsFor: 'utilities'] value ! !
! String methodsFor: 'utilities' !
tokensBasedOn: aCharacter

	^self splitBy: aCharacter ! !
! Doit class methodsFor: 'doit' !
doit ^[String class methodsFor: 'instance creation'] value ! !
! String class methodsFor: 'instance creation' !
implementationClass

	^ByteString ! !
! Doit class methodsFor: 'doit' !
doit ^[String class methodsFor: 'instance creation'] value ! !
! String class methodsFor: 'instance creation' !
new: anInteger

	^self implementationClass basicNew: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'accessing'] value ! !
! ByteString methodsFor: 'accessing' !
at: index 

	<primitive: 63>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'accessing'] value ! !
! ByteString methodsFor: 'accessing' !
at: index put: value 

	<primitive: 64>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'accessing'] value ! !
! ByteString methodsFor: 'accessing' !
basicAt: index 

	<primitive: 63>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'accessing'] value ! !
! ByteString methodsFor: 'accessing' !
basicAt: index put: value 

	<primitive: 64>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'converting'] value ! !
! ByteString methodsFor: 'converting' !
asInt

	| integer multiplier |
	multiplier := 10 raisedToInteger: self size - 1.
	integer := 0.
	1 to: self size do: [:index | 
			integer := integer + ((self at: index) asInteger - 48 * multiplier).
			multiplier := multiplier // 10].


^integer ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'converting'] value ! !
! ByteString methodsFor: 'converting' !
asTwoByteString

	| newString |
	newString := TwoByteString new: self size.
	1 to: self size do: [:index |
		newString at: index put: (self at: index)].
	^newString  ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteString methodsFor: 'printing'] value ! !
! ByteString methodsFor: 'printing' !
printStringHex

	| stream |

	stream := WriteStream on: String new.
	stream nextPutAll: '#['.
	self do: [:each |
		stream nextPutAll: (each asInteger printStringRadix: 16);
			space].
	stream nextPut: $].
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
index

	^index ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
index: aNumber

	index := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
parent

	^parent ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
parent: aStringMatcher

	parent := aStringMatcher ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
pattern

	^pattern ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
pattern: aString

	pattern := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'accessing'] value ! !
! StringMatcher methodsFor: 'accessing' !
submatchers

	^submatchers ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'adding and removing'] value ! !
! StringMatcher methodsFor: 'adding and removing' !
addSubmatcher: aStringMatcher

	self submatchers add: aStringMatcher.
	aStringMatcher parent: self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'adding and removing'] value ! !
! StringMatcher methodsFor: 'adding and removing' !
removeSubmatcher: aStringMatcher

	self submatchers remove: aStringMatcher
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'initializing'] value ! !
! StringMatcher methodsFor: 'initializing' !
initialize

	submatchers := OrderedCollection new.
	index := 1
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'matching'] value ! !
! StringMatcher methodsFor: 'matching' !
advance

	^self index: self index + 1
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'matching'] value ! !
! StringMatcher methodsFor: 'matching' !
fail

	self parent removeSubmatcher: self ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'matching'] value ! !
! StringMatcher methodsFor: 'matching' !
match: aString

	self setupSubmatchers.
	aString do: [:character |
		submatchers isEmpty ifTrue: [^false].
		submatchers copy do: [:submatcher |
			submatcher matchCharacter: character]].

	^submatchers anySatisfy: [:each | each isFinished]

 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'matching'] value ! !
! StringMatcher methodsFor: 'matching' !
matchCharacter: aCharacter

	| nextPatternCharacter |
	self index > self pattern size ifTrue: [self fail. ^self].
	nextPatternCharacter := self peekPattern.
	nextPatternCharacter = $? ifTrue: [^self advance].
	nextPatternCharacter = $* ifTrue: [
		| newSubmatcher |
		newSubmatcher := self class new
			pattern: self pattern;
			index: self index + 1;
			yourself.

		self parent addSubmatcher: newSubmatcher.
		newSubmatcher matchCharacter: aCharacter.

		^self].
	nextPatternCharacter = aCharacter
		ifTrue: [self advance]
		ifFalse: [self fail]

 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'matching'] value ! !
! StringMatcher methodsFor: 'matching' !
peekPattern

	^self pattern at: self index
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'matching'] value ! !
! StringMatcher methodsFor: 'matching' !
setupSubmatchers

	self addSubmatcher: (self class new
		pattern: self pattern;
		yourself)

 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher methodsFor: 'testing'] value ! !
! StringMatcher methodsFor: 'testing' !
isFinished

	^(self index > pattern size) or: [
		self index = pattern size and: [self peekPattern = $*]] ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher class methodsFor: 'instance creation'] value ! !
! StringMatcher class methodsFor: 'instance creation' !
new

	^super new initialize; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcher class methodsFor: 'instance creation'] value ! !
! StringMatcher class methodsFor: 'instance creation' !
pattern: aString

	^self new
		pattern: aString;
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'accessing'] value ! !
! Symbol methodsFor: 'accessing' !
numArgs

	(self allSatisfy: [:eachCharacter | eachCharacter isNonBinarySelectorCharacter]) ifFalse: [^1].
	^self occurrencesOf: $: ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'comparing'] value ! !
! Symbol methodsFor: 'comparing' !
= anObject

	^self == anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'comparing'] value ! !
! Symbol methodsFor: 'comparing' !
hash

	^self identityHash ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'converting'] value ! !
! Symbol methodsFor: 'converting' !
asSimTalkSymbol

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'converting'] value ! !
! Symbol methodsFor: 'converting' !
asSymbol

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'converting'] value ! !
! Symbol methodsFor: 'converting' !
eventKey

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'instance creation'] value ! !
! Symbol methodsFor: 'instance creation' !
isSymbol

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'operating'] value ! !
! Symbol methodsFor: 'operating' !
, aCollection 

	^self asString , aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'printing'] value ! !
! Symbol methodsFor: 'printing' !
printOn: aStream 

	(self allSatisfy: [:each | each isAlphaNumeric | (each = $_)])
		ifTrue: [aStream nextPut: $#; nextPutAll: self. ^self].
	super printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol methodsFor: 'printing'] value ! !
! Symbol methodsFor: 'printing' !
printPrefixOn: aStream 

	aStream nextPutAll: '#''' ! !
! Doit class methodsFor: 'doit' !
doit ^[Symbol class methodsFor: 'instance creation'] value ! !
! Symbol class methodsFor: 'instance creation' !
implementationClass

	^ByteSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteSymbol methodsFor: 'accessing'] value ! !
! ByteSymbol methodsFor: 'accessing' !
at: index 

	<primitive: 63>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteSymbol methodsFor: 'converting'] value ! !
! ByteSymbol methodsFor: 'converting' !
asString

	^ByteString from: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteSymbol class methodsFor: 'instance creation'] value ! !
! ByteSymbol class methodsFor: 'instance creation' !
intern: aString

	^self symbolTable at: aString  asString asSimtalkString ifAbsentPut: [
		self from: aString] ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteSymbol class methodsFor: 'symbol table'] value ! !
! ByteSymbol class methodsFor: 'symbol table' !
garbageCollectSymbolTable

	| symbols count |
	symbols := self symbolTable asArray.
	count := 0.

	symbols do: [:each |
		| references |
		self log: each.
		references := each allOwners size.
		self log: each , ' -> ', references printString.
		references = 4 ifTrue: [
			self symbolTable removeKey: each asString].
		count := count + 1.
		count = 20 ifTrue: [
			BeagleSystem globalGarbageCollect.
			count := 0] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[ByteSymbol class methodsFor: 'symbol table'] value ! !
! ByteSymbol class methodsFor: 'symbol table' !
symbolTable

	<primitive: 551>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'FormattedStrings'] value ! !
! Time methodsFor: 'FormattedStrings' !
showHourlyCountdown
		| minutePadder secondPadder |
		self minutes < 10 ifTrue: [minutePadder := '0'] ifFalse: [minutePadder := ''].
		(self totalSeconds \\ 60) < 10 ifTrue: [secondPadder := '0'] ifFalse: [secondPadder := ''].
		
		^minutePadder , self minutes , ':' , secondPadder , (self totalSeconds \\ 60) printString ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
hours
	^self totalHours \\ 24 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
milliseconds

	^milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
milliseconds: aNumber

	milliseconds := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
minutes
	^self totalMinutes \\ 60 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
seconds
	^self totalSeconds \\ 60 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
setMilliseconds: aNumber

	milliseconds := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
totalHours
	^self totalMinutes // 60 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
totalMilliseconds

	^milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
totalMinutes
	^self totalSeconds // 60 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'accessing'] value ! !
! Time methodsFor: 'accessing' !
totalSeconds
	^self totalMilliseconds // 1000 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'arithmetic'] value ! !
! Time methodsFor: 'arithmetic' !
- aTime 

	^(self class new) setMilliseconds: self totalMilliseconds - aTime totalMilliseconds; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'comparing'] value ! !
! Time methodsFor: 'comparing' !
< value

	^self milliseconds < value milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'comparing'] value ! !
! Time methodsFor: 'comparing' !
<= value

	^self milliseconds <= value milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'comparing'] value ! !
! Time methodsFor: 'comparing' !
> value

	^self milliseconds > value milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'comparing'] value ! !
! Time methodsFor: 'comparing' !
>= value

	^self milliseconds >= value milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'printing'] value ! !
! Time methodsFor: 'printing' !
printOn: aStream 

	| hours minutes seconds fractionalMilliseconds remainder |
	fractionalMilliseconds := milliseconds \\ 1000.
	seconds := (remainder := milliseconds // 1000) \\ 60.
	minutes := (remainder := remainder // 60) \\ 60.
	hours := remainder // 60.

	aStream print: hours; nextPut: $:.
	minutes < 10 ifTrue: [aStream nextPut: $0].

	aStream print: minutes; nextPut: $:.
	seconds < 10 ifTrue: [aStream nextPut: $0].

	aStream print: seconds; nextPut: $..
	fractionalMilliseconds < 100 ifTrue: [aStream nextPut: $0].
	fractionalMilliseconds < 10 ifTrue: [aStream nextPut: $0].
	aStream print: fractionalMilliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time methodsFor: 'printing'] value ! !
! Time methodsFor: 'printing' !
writeBinaryOn: aStream

	aStream nextPutInt32: self milliseconds ! !
! Doit class methodsFor: 'doit' !
doit ^[Time class methodsFor: 'instance creation'] value ! !
! Time class methodsFor: 'instance creation' !
fromSeconds: aNumber

	^(self new) setMilliseconds: aNumber * 1000; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Time class methodsFor: 'instance creation'] value ! !
! Time class methodsFor: 'instance creation' !
millisecondClockValue

	<primitive: 408>
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[Time class methodsFor: 'instance creation'] value ! !
! Time class methodsFor: 'instance creation' !
millisecondsToRun: aBlock

	| start end |
	start := self millisecondClockValue.
	aBlock value.
	end := self millisecondClockValue.
	^end - start
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Time class methodsFor: 'instance creation'] value ! !
! Time class methodsFor: 'instance creation' !
now

	^(self new) setMilliseconds: self millisecondClockValue; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Time class methodsFor: 'instance creation'] value ! !
! Time class methodsFor: 'instance creation' !
readBinaryFrom: 	aStream

	^self new
		milliseconds: aStream nextInt32;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
& aBoolean 

	^aBoolean ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
and: aBlock 

	^aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
ifFalse: aBlock 

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
ifFalse: falseBlock ifTrue: trueBlock 

	^trueBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
ifTrue: aBlock 

	^aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
ifTrue: trueBlock ifFalse: falseBlock 

	^trueBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
not

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
or: aBlock 

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'accessing'] value ! !
! True methodsFor: 'accessing' !
| aBoolean

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[True methodsFor: 'printing'] value ! !
! True methodsFor: 'printing' !
printOn: aStream 

	aStream nextPutAll: 'true' ! !
! Doit class methodsFor: 'doit' !
doit ^[TwoByteString methodsFor: 'accessing'] value ! !
! TwoByteString methodsFor: 'accessing' !
at: index

	^Character value: (self basicAt: index - 1 * 2 + 1) * 256 + (self basicAt: index - 1 * 2 + 2) ! !
! Doit class methodsFor: 'doit' !
doit ^[TwoByteString methodsFor: 'accessing'] value ! !
! TwoByteString methodsFor: 'accessing' !
at: index put: aCharacter

	self
		basicAt: index - 1 * 2 + 1 put: aCharacter asInteger // 256;
		basicAt: index - 1 * 2 + 2 put: aCharacter asInteger \\ 256  ! !
! Doit class methodsFor: 'doit' !
doit ^[TwoByteString methodsFor: 'accessing'] value ! !
! TwoByteString methodsFor: 'accessing' !
size

	^self basicSize // 2  ! !
! Doit class methodsFor: 'doit' !
doit ^[TwoByteString methodsFor: 'converting'] value ! !
! TwoByteString methodsFor: 'converting' !
asTwoByteString

	^self
  ! !
! Doit class methodsFor: 'doit' !
doit ^[TwoByteString class methodsFor: 'instance creation'] value ! !
! TwoByteString class methodsFor: 'instance creation' !
new: anInteger
 
	| newString |
	newString := self basicNew: anInteger * 2.
	1 to: newString basicSize do: [:i |
		newString basicAt: i put: 0].
	^newString ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'class creating'] value ! !
! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitSymbol;
		buildClass;
		newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'class creating'] value ! !
! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	flags: newFlags
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol

	^ClassCreator new
		name: aSymbol;
		flags: newFlags;
		instanceVariableNames: instVarNamesArray;
		classVariableNames: classVarNamesArray;
		classInstanceVariableNames: classInstVarNamesArray;
		superclass: self;
		environment: anEnvironment;
		kitName: aKitSymbol;
		buildClass;
		newClass ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'class creating'] value ! !
! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray

	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'class creating'] value ! !
! UndefinedObject methodsFor: 'class creating' !
subclassNamed: aSymbol
	instVarNames: instVarNamesArray
	classVarNames: classVarNamesArray
	classInstVarNames: classInstVarNamesArray
	environment: anEnvironment
	kitName: aKitSymbol


	^self subclassNamed: aSymbol
		flags: 0
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment
		kitName: aKitSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'controlling'] value ! !
! UndefinedObject methodsFor: 'controlling' !
ifNil: aBlock 

	^aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'controlling'] value ! !
! UndefinedObject methodsFor: 'controlling' !
ifNil: nilBlock ifNotNil: notNilBlock 

	^nilBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'controlling'] value ! !
! UndefinedObject methodsFor: 'controlling' !
ifNotNil: aBlock 

	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'creating'] value ! !
! UndefinedObject methodsFor: 'creating' !
modifyClass: existingClass
		flags: newFlags
		instVarNames: instVarNamesArray
		classVarNames: classVarNamesArray
		classInstVarNames: classInstVarNamesArray
		environment: anEnvironment ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'printing'] value ! !
! UndefinedObject methodsFor: 'printing' !
printOn: aStream 

	aStream nextPutAll: 'nil' ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'testing'] value ! !
! UndefinedObject methodsFor: 'testing' !
isNil

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[UndefinedObject methodsFor: 'testing'] value ! !
! UndefinedObject methodsFor: 'testing' !
notNil

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
bitSequenceFrom: i to: j
"Allows to reason about specific bits in an array of UninterpretedBytes. For example, the numeric value of only the first 3 bits."

	| total |
	total := 0.
	
	i to: j do: [:index | | byte mask |
		byte := self at: (index // 8) + 1.
		"System log: 'accessing byte: ' , byte printString , ' from byte index: ' , ((index // 8) + 1) printString , ' in search for the ' , index printString , 'th bit, using (' , index printString , ' / 8) + 1'."
		mask :=  1.
		byte := byte >> (7 - (index \\ 8)).
		byte := byte bitAnd: mask.
		total := total bitOr: (byte << (j - index))
		
	].

	^total ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
doubleAt: index put: aDouble 

	1 to: 8 do: [:i |
		self at: index + i put: (aDouble at: i)] ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
floatAt: index

	<primitive: 548>
	| myFloat |
	myFloat := Float new.
	1 to: 4 do: [:i |
		myFloat at: i put: (self at: index + i)].
	
	^myFloat ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
floatAt: index put: aFloat

	<primitive: 549>
	1 to: 4 do: [:i |
		self at: index + i put: (aFloat at: i)] ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
size

	^self basicSize ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
uint32At: offset 

	| total |
	total := 0.
	1 to: 4 do: [:index |
		total := total * 256 + (self at: offset + (5 - index))].

	^total ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
uint32At: index put: a32bitUnsignedInteger

	| remainder |
	remainder := a32bitUnsignedInteger.

	1 to: 4 do: [:i |
		self at: index + i put: (remainder \\ 256).
		remainder := remainder // 256]. ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
uint64At: offset 

	| total |
	total := 0.
	1 to: 8 do: [:index |
		total := total * 256 + (self at: offset + (9 - index))].

	^total ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'accessing'] value ! !
! UninterpretedBytes methodsFor: 'accessing' !
uint64At: index put: a64bitUnsignedInteger
	| remainder |
	remainder := a64bitUnsignedInteger.
	1 to: 8 do: [:i |
		self at: index + i put: (remainder \\ 256). remainder := remainder // 256] ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'converting'] value ! !
! UninterpretedBytes methodsFor: 'converting' !
asByteString
	| byteString |
	byteString := ByteString new: self size.
	
	1 to: self size do: [:index |
	byteString at: index put: (Character value: (self at: index)).
	].
	^byteString. ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'converting'] value ! !
! UninterpretedBytes methodsFor: 'converting' !
asString

	^self asByteString ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'converting'] value ! !
! UninterpretedBytes methodsFor: 'converting' !
floatArrayPrintString

	| stream |
	stream := WriteStream on: (ByteString new: 20).
	stream nextPut: ${.
	0 to: self size - 1 by: 4 do: [:i |
		(self floatAt: i) printOn: stream.
		stream space].
	stream nextPut: $}.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'converting'] value ! !
! UninterpretedBytes methodsFor: 'converting' !
hexString
	| stream |
	stream := WriteStream on: (String new: 20).
	1 to: self size do: [:i |
		(self at: i) printHexOn: stream padZeros: 2].
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'copying'] value ! !
! UninterpretedBytes methodsFor: 'copying' !
copy

	<primitive: 550>
	self primitiveFailed ! !
! Doit class methodsFor: 'doit' !
doit ^[UninterpretedBytes methodsFor: 'generating'] value ! !
! UninterpretedBytes methodsFor: 'generating' !
randomize

	| randomness |
	randomness := Random new.
	
	1 to: self size do: [:index | self at: index put: randomness nextSeed \\ 256] ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
+ aVector

	^self class
		x: self x + aVector x
		y: self y + aVector y
		z: self z + aVector z
		w: self defaultW ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
- aVector

	^self class
		x: self x - aVector x
		y: self y - aVector y
		z: self z - aVector z
		w: self defaultW ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber

	^elements at: rowNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
atRow: rowNumber column: columnNumber put: value

	elements at: rowNumber put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
columns

	^1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
defaultW

	^0.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
elements

	^elements ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
elements: anArray

	elements := anArray ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
printOn: aStream

	aStream nextPut: $<.

	elements do: [:each |
		each printOn: aStream.
		aStream space].

	aStream skip: -1.
	aStream nextPut: $> ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
rows

	^elements size ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
w

	^elements at: 4 ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
w: value

	^elements at: 4 put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
x

	^elements at: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
x: value

	^elements at: 1 put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
y

	^elements at: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
y: value

	^elements at: 2 put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
z

	^elements at: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'accessing'] value ! !
! Vector methodsFor: 'accessing' !
z: value

	^elements at: 3 put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector methodsFor: 'initializing'] value ! !
! Vector methodsFor: 'initializing' !
initialize

	elements := OrderedCollection with: 0.0 with: 0.0 with: 0.0 with: self defaultW ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector class methodsFor: 'instance creation'] value ! !
! Vector class methodsFor: 'instance creation' !
new

	^super new initialize; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Vector class methodsFor: 'instance creation'] value ! !
! Vector class methodsFor: 'instance creation' !
x: x y: y z: z w: w

	^self new
		x: x;
		y: y;
		z: z;
		w: w;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
close

	socket ifNotNil: [
		socket close.
		socket := nil]. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
isConnecting

	^isConnecting  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
isConnecting: aBoolean

	isConnecting := aBoolean  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
lengthFor: aString

	| length |

	length := aString size.
	length < 126 ifTrue: [^ByteArray with: length].
	length < 65536 ifTrue: [
		^(ByteArray new: 3)
			at: 1 put: 126;
			at: 2 put: (length // 16r100 \\ 16r100);
			at: 3 put: (length \\ 16r100);
			yourself].
	^(ByteArray new: 9)
		at: 1 put: 127;
		at: 2 put: (length // 16r100000000000000 \\ 16r100);
		at: 3 put: (length // 16r1000000000000 \\ 16r100);
		at: 4 put: (length // 16r10000000000 \\ 16r100);
		at: 5 put: (length // 16r100000000 \\ 16r100);
		at: 6 put: (length // 16r1000000 \\ 16r100);
		at: 7 put: (length // 16r10000 \\ 16r100);
		at: 8 put: (length // 16r100 \\ 16r100);
		at: 9 put: (length \\ 16r100);
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
mask

	^(ByteArray new: 4)
		at: 1 put: (random next * 256) truncated;
		at: 2 put: (random next * 256) truncated;
		at: 3 put: (random next * 256) truncated;
		at: 4 put: (random next * 256) truncated;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
onMessageReceive: aSocket do: aBlock

	^aBlock value

 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
openOnPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processMessages. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
processContentMessage: aMessage

	self raiseEvent: (MessageReceivedEvent new message: aMessage; yourself).
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
processMessage: aMessage

	(aMessage indexOfSubCollection: 'Connection: Upgrade' startingAt: 1) > 0 ifTrue: [
		^self processSocketConnectMessage: aMessage]. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
processMessages

	[self processWebSocketMessages]
		ensure: [self close] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
processWebSocketMessages

	socket isActive ifFalse: [^self].
	
	self processSocketConnectMessage: self readConnectionMessage.

	[self readAndProcessMessages.
		socket isActive] whileTrue: [].

	BeagleSystem finish ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
random

	^random  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
random: anObject

	random := anObject  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
readContentMessage

	| header length mask payload payload2 |

	stream reset.
	header := stream next: 2.
	header isNil ifTrue: [
		^nil].

	length := (header at: 2) bitAnd: 16r7F.
	length = 126 ifTrue: [length := stream next * 256 + stream next]
		ifFalse: [length = 127 ifTrue: [length := stream next * 256 + stream next * 256 + stream next * 256 + stream next * 256 + stream next * 256 + stream next]].

	mask := #[0 0 0 0].
	((header at: 2) bitAnd: 128) = 128 ifTrue: [
		mask := stream next: 4].
	
	payload := stream next: length.
	payload2 := self xorPayload: payload copy withMask: mask.

	^payload2 asString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
send: aString

	| payload |

	payload := aString asByteArray.
	
	stream
		reset;
		nextPut: 16r81;   "Final frame - text"
		nextPutAll: (self lengthFor: aString);
		nextPutAll: payload;
		commit ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
socket

	^socket ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
socket: anObject

	socket := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
stream

	^stream  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
stream: anObject

	stream := anObject  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'accessing'] value ! !
! WebSocket methodsFor: 'accessing' !
xorPayload: payload withMask: mask
	
	1 to: payload size do: [:index | payload at: index put: ((payload at: index) bitXor: (mask at: index - 1 \\ 4 + 1))].
	^payload ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
openClientFor: host onPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processClientMessages. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
openClientOnPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processClientMessages. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
openServerOnPort: portNumber

	"Create a socket, then show its name in the Transcript."

	| childSocket |

	socket := Socket newTCPConnection.
	socket family: Socket af_inet address: 0 port: portNumber.
	socket bind.
	socket listen: 10.
	childSocket := socket accept.

	"If no client solicited a connection, give up."
	childSocket isNil ifTrue: [socket close. ^self].

	stream := childSocket stream.
	random := Random new.

	self processServerMessages. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
processClientMessages

	[self processWebSocketClientMessages]
		ensure: [self close] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
processConnectionMessage

	self processSocketConnectMessage: self readConnectionMessage ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
processSocketClientConnectMessage: aMessage keyString: aString

	| key responseKey connectResponse |

	messageStream := aMessage readStream.
	messageStream throughAll: 'Sec-WebSocket-Accept:'.
	key := (messageStream upTo: Character cr) trimSeparators.
	responseKey := Base64Encoder new encodeStream: (SHA1 new hash: (aString, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11') asByteArray) readStream.
	responseKey = key ifFalse: [^self error: 'Unable to switch WebSocket protocol']. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
processSocketConnectMessage: aMessage

	| key responseKey connectResponse |

	messageStream := aMessage readStream.
	messageStream throughAll: 'Sec-WebSocket-Key:'.
	key := (messageStream upTo: Character cr) trimSeparators.
	responseKey := Base64Encoder new encodeStream: (SHA1 new hash: (key, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11') asByteArray) readStream.

	connectResponse := 'HTTP/1.1 101 Switching Protocols\Upgrade: websocket\Connection: Upgrade\Sec-WebSocket-Accept: ', responseKey, '\\' copyReplaceAll: '\' with: (String with: Character cr with: Character lf).

	stream
		reset;
		nextPutAll: connectResponse asByteArray;
		commit ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
processWebSocketClientMessages

	|  keyString |

	socket isActive ifFalse: [^self].

	keyString := self sendClientConnectMessage.
	self processSocketClientConnectMessage: self readConnectionMessage keyString: keyString.
	[self readAndProcessMessages.
		socket isActive] whileTrue: [].

	BeagleSystem finish ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'connecting'] value ! !
! WebSocket methodsFor: 'connecting' !
readConnectionMessage

	| line result |

	messageStream := WriteStream on: (String new: 30).
	[line := (stream upTo: Character lf asInteger) asString trimSeparators.
		messageStream nextPutAll: line; cr.
		line isEmpty] whileFalse: [].
	result := messageStream contents.
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
onMessageReceiveDo: aBlock

	aBlock value
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
processContentMessage

	Error
		try: [
			self processContentMessage: self readContentMessage.
			stream isActive ifFalse: [^self].
			true]
		catch: [:ex |
			Debugger openOn: thisContext message: ex message.
			self send: ex message.
			ex return: true]
		finally: nil.
  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
processServerMessages

	[self processWebSocketServerMessages]
		ensure: [self close] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
processSocketServerConnectMessage: aMessage

	| key responseKey connectResponse |

	messageStream := aMessage readStream.
	messageStream throughAll: 'Sec-WebSocket-Key:'.
	key := (messageStream upTo: Character cr) trimSeparators.
	responseKey := Base64Encoder new encodeStream: (SHA1 new hash: (key, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11') asByteArray) readStream.

	connectResponse := 'HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: ', responseKey, '

' copyReplaceAll: (String with: Character cr) with: (String with: Character cr with: Character lf).

	stream
		nextPutAll: connectResponse asByteArray;
		commit ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
processWebSocketServerMessages

	socket isActive ifFalse: [^self].
	
	self processSocketServerConnectMessage: self readConnectionMessage.
	[self readAndProcessMessages.
		socket isActive] whileTrue: [].

	BeagleSystem finish ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
readAndProcessMessages

	[self processContentMessage] whileTrue: []   ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
sendClientConnectMessage

	| key keyString connectRequest |

	key := ByteArray new: 16.
	1 to: 16 do: [:i | key at: i put: (random next * 256) truncated].
	keyString := Base64Encoder new encodeStream: key readStream.

	connectRequest := 'GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: ', keyString, '
Sec-WebSocket-Version: 13

' copyReplaceAll: (String with: Character cr) with: (String with: Character cr with: Character lf).

	stream
		nextPutAll: connectRequest asByteArray;
		commit.

	^keyString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'processing'] value ! !
! WebSocket methodsFor: 'processing' !
startupConnection

	self
		stream: self socket stream;
		random: Random new.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSocket methodsFor: 'testing'] value ! !
! WebSocket methodsFor: 'testing' !
isActive

	^self socket notNil and: [self socket isActive] ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
at: index put: value

	self collection at: index put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
bufferArrayFor: aVariable data: aCollection as: aSymbol

	| javaScriptType |

	aVariable attributeType = #float ifTrue: [javaScriptType := 'Float32Array'].
	aVariable attributeType = #unsignedByte ifTrue: [javaScriptType := 'Uint8Array'].

	self
		nextPutAll: self gl;
		nextPutAll: '.bufferData(';
		nextPutAll: self gl;
		nextPutAll: '.ARRAY_BUFFER, new ';
		nextPutAll: javaScriptType;
		nextPutAll: '(['.

	aCollection do: [:each | self nextPutAll: each printString]
		separatedBy: [self nextPutAll: ','].

	self nextPutAll: ']), ';
		nextPutAll: self gl;
		nextPutAll: '.'.

	aSymbol = #staticDraw ifTrue: [self nextPutAll: 'STATIC_DRAW'].

	self nextPutAll: ');';
	cr

  ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
contents

	^collection copyFrom: 1 to: position ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
cr

	self nextPut: Character cr ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
grow

	| newCollection |

	newCollection := collection class new: ((collection size * 2) max: 10).
	1 to: collection size do: [:index |
		newCollection at: index put: (collection at: index)].

	collection := newCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
lf

	self nextPut: Character lf ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
nextPut: anObject 

	position >= collection size ifTrue: [self grow].
	position := position + 1.
	collection at: position put: anObject.
	readLimit := position ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
nextPutAll: aCollection 

	aCollection do: [:each | self nextPut: each] ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
print: anObject 

	anObject printOn: self ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
print: anObject limit: aNumber

	anObject printOn: self limit: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
space

	self nextPut: Character space ! !
! Doit class methodsFor: 'doit' !
doit ^[WriteStream methodsFor: 'writing'] value ! !
! WriteStream methodsFor: 'writing' !
tab

	self nextPut: Character tab ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedClasses: #(Array ArrayedCollection Association Base64Encoder BeagleSystem Behavior BlockClosure Boolean ByteArray ByteString ByteSymbol CachedValue Character Class ClassCreator ClassDescription Collection CompiledBlock CompiledCode CompiledMethod ComputedField DateTime Dictionary Doit Error EventBase Exception ExceptionBase ExceptionHandler ExceptionList False FileStream Filename Float Fraction HaltException IdentityDictionary Integer IntegerArray InternalStream JunkClass Kit KitManager LargeInteger LargeNegativeInteger LargePositiveInteger LimitedPrecisionReal LineEndConvention LineEndConventionCR LineEndConventionCRLF LineEndConventionLF Magnitude Matrix MemorySpace MessageNotUnderstood Metaclass MethodDictionary Number OSHandle Object OrderedCollection Point PrimitiveFailedError Random ReadStream ReadWriteStream SHA1 SequenceableCollection Set SmallInteger Socket SocketAcceptHandler SocketDispatcher SocketHandler SocketLauncher SocketStream SocketTimeoutHandler SocketUIScreenHandler Sorter Stream String StringMatcher Symbol Time True TwoByteString TwoByteSymbol UndefinedObject UninterpretedBytes Vector Warning WebSocket WriteStream) andMethods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BeagleSystem methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BeagleSystem class methods: #(#allClasses #auditImage #badMetaclasses #becomeSystem #changesFile #changesFileName #checkClasses #checkClassesReferences #checkGlobals #checkKits #checkSystem #cleanupOrganizations #clearCurrent #clearSources #clearUndeclared #closeSourceFiles #current #fileinAllClasses #fileoutAllClasses #'findBytecodeSequence:inCompiledCode:into:' #'findBytecodeSequence:inMethod:into:' #'findBytecodeSequence:inMethodsOfClass:into:' #'findBytecodeSequence:inMethodsOfClassOrSubclasses:into:' #finish #fixBadMetaclasses #fixClassReferences #'fixClassReferencesIn:' #'getSource:' #'gettersOfInstanceVariable:inClass:' #'gettersOfInstanceVariable:inClass:into:' #globalGarbageCollect #imageName #'imageName:' #imageNameNoExtension #'implementersOf:' #isEmscripten #'log:' #'logObject:' #'matchesBytecodeInfo:with:' #methodsWithNoSources #new #openSourceFiles #'primSaveImage:' #'primitiveLog:' #reallocateObjectSpaces #'reallocateSpace:size:' #'referencesToAssociation:' #'referencesToClass:' #'referencesToInstanceVariable:inClass:' #'referencesToUndeclared:' #'runJavaScript:' #'runJavaScriptWithReturn:' #saveImage #'saveImage:' #'sendersOf:' #'settersOfInstanceVariable:inClass:' #'settersOfInstanceVariable:inClass:into:' #shutdown #sourceFileName #sourceFileNames #'sourceFileNames:' #sourceFiles #'sourceFiles:' #sourcesFile #sourcesFileName #spaceSize16 #specialSelectors #'specialSelectors:' #start #startAcceptSocket #webSocketPortNumber #'wellKnownAt:' #'wellKnownAt:put:' #wellKnownSize #writeAllFiles)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Behavior methods: #(#allInstVarNames #'allInstVarNamesInto:' #allInstances #allSubclasses #'allSubclassesInto:' #basicNew #'basicNew:' #'basicRemoveSubclass:' #'canUnderstand:' #'compiledMethodAt:' #'fileoutMethodNamed:on:' #'fileoutMethodsOn:' #'fileoutMethodsOn:forKit:' #flags #'flags:' #globalDictionaries #'inheritsFrom:' #initialize #instSize #'instVarNameForIndex:' #instVarNames #'instVarNames:' #methodDictionary #'methodDictionary:' #new #'new:' #'removeSelector:' #selectors #subclasses #'subclasses:' #superclass #'superclass:' #withAllSubclasses #'withAllSubclassesInto:' #withAllSuperclasses #'withAllSuperclassesInto:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Behavior class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockClosure methods: #(#allNestedLiterals #bytecodes #cache #copiedValues #'copiedValues:' #'cull:' #'cull:cull:' #'cull:cull:cull:' #'ensure:' #isBlock #isBlockClosure #method #'method:' #methodContext #'methodContext:' #numberOfArguments #'on:do:' #value #'value:' #'value:value:' #whileFalse #'whileFalse:' #whileTrue #'whileTrue:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockClosure class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Boolean methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Boolean class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Character methods: #(#'<' #'<=' #'=' #'>' #'>=' #asInteger #asLowercase #asString #asUppercase #digitValue #hash #isAlphaNumeric #isAlphabetic #isDigit #isLowercase #isNonBinarySelectorCharacter #isSeparator #isUppercase #isVowel #'printOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Character class methods: #(#backspace #cr #'digitValue:' #lf #space #tab #'value:' #vowels)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Class methods: #(#'byteSubclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'byteSubclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #classDictionaries #classInstVarNamesString #classTypeFlags #'classVarNames:' #environment #'environment:' #'fileoutBytesDefinitionOn:' #'fileoutDefinitionOn:' #'fileoutPlainClassDefinitionOn:' #fileoutSource #'fileoutSourceOn:' #'fileoutVariableDefinitionOn:' #globalDictionaries #instVarNamesString #isBytesClass #isVariableClass #kit #'kit:' #'migrateAllInstancesFrom:' #'migrateClassFrom:' #name #'name:' #'printOn:' #'removeSubclass:' #'subclassNamed:flags:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:flags:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #thisClass #'variableSubclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'variableSubclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Class class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ClassCreator methods: #(#addClassToEnvironment #addClassToKit #buildClass #classInstanceVariableNames #'classInstanceVariableNames:' #classVariableNames #'classVariableNames:' #createClass #environment #'environment:' #flags #'flags:' #hasDefinitionChanged #instanceVariableNames #'instanceVariableNames:' #kitName #'kitName:' #linkToSuperclass #migrateInstances #modifyClass #modifySubclasses #name #'name:' #newClass #'newClass:' #oldClass #'oldClass:' #'removeClass:' #removeClassFromEnvironment #'removeClassFromEnvironment:' #superclass #'superclass:' #unlinkFromSuperclass)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ClassCreator class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ClassDescription methods: #(#basicCleanupOrganization #cleanupOrganization #'methodsInOrganization:' #'newOrganization:' #organization #'organization:' #'organizationAt:add:' #'organizationFor:' #'removeSelector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ClassDescription class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompiledBlock methods: #(#isBlock #isCompiledBlock #outerMethod #'outerMethod:' #'printOn:' #rootMethod #value #'value:' #'value:value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompiledBlock class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompiledCode methods: #(#allNestedLiterals #bytecodes #'bytecodes:' #'callOffsetsIn:do:' #'findSendWithOffset:' #getSource #literals #localVariableNames #'localVariableNames:' #mclass #'mclass:' #methodOffsets #numberOfArguments #'numberOfArguments:' #numberOfLocals #'numberOfSendsIn:' #numberOfTemporaries #'numberOfTemporaries:' #sourceOffsets #'sourceOffsets:' #sourceOffsetsDictionary #'writeMethodOffsets:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompiledCode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompiledMethod methods: #(#allMessages #definingKit #'fileoutOn:' #isPrimitive #kit #'kit:' #organization #'printOn:' #rootMethod #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompiledMethod class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DateTime methods: #(#'<' #'addMilliseconds:' #asMilliseconds #day #'day:' #'daysIn:forYear:' #'difference:' #hours #'initFromSystemFormat:' #'isLeap:' #milliseconds #minutes #minutesAndSecondsPrintString #month #'month:' #'printOn:' #seconds #time #'time:' #'writeBinaryOn:' #year #'year:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DateTime class methods: #(#'fromSystemFormat:' #now #'readBinaryFrom:' #systemDate)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Doit methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Doit class methods: #(#doit)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Error methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Error class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EventBase methods: #(#eventRegistry #initialize #'onEvent:do:' #'raiseEvent:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EventBase class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Exception methods: #(#action #'action:' #asString #message #'message:' #pass #'printOn:' #raiseSignal #result #'result:' #resume #retry #return #'return:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Exception class methods: #(#',' #defaultErrorString #exceptionHandlers #'findSendWithOffset:' #'handlerFor:before:' #'handlesException:' #signal #'signal:' #'try:catch:' #'try:catch:finally:' #'try:finally:' #'unwindTo:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: False methods: #(#'&' #'and:' #'ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifTrue:ifFalse:' #not #'or:' #'printOn:' #'|')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: False class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Filename methods: #(#'/' #'\' #appendStream #asCoreFilename #asFilename #asString #'construct:' #'copyTo:' #exists #fileIn #fileSize #path #'path:' #readStream #'renameTo:' #writeStream)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Filename class methods: #(#'fileExists:' #getInternalPath #internalPath #'named:' #pathDelimiterString #'rename:to:' #'sizeOfFile:' #'unpackAssetToInternalPath:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Float methods: #(#'arcTan2:' #arccos #arcsin #arctan #asFloat #asInteger #'basicAt:' #basicSize #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #cos #decimalDigitsOfPrecision #exp #fractionPart #isFloat #kind #ln #log #'mod:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveTimes:' #'raisedToNegativeInteger:' #round #roundUp #sin #sqrt #tan #truncated)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Float class methods: #(#e #new #pi #unity #zero)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Fraction methods: #(#asFloat #asInteger #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #denominator #'denominator:' #hex #kind #numerator #'numerator:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveTimes:' #'printOn:' #reduce)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Fraction class methods: #(#'numerator:denominator:' #unity #zero)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HaltException methods: #(#raiseSignal2)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HaltException class methods: #(#'signal:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Integer methods: #(#'/' #asFraction #asInteger #denominator #even #factorial #'gcd:' #hex #intSqrt #isInteger #'lcm:' #numerator #odd #'printHexOn:padZeros:' #'printOn:' #'printOn:paddedWith:to:base:' #'printStringRadix:' #'timesRepeat:' #truncated)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Integer class methods: #(#'readFrom:' #'readHexFrom:' #unity #zero)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Kit methods: #(#'addClass:' #'addMethod:' #'addRequiredKit:' #'allDefinedClasses:andMethods:' #'allDefinedMethodsFor:methods:' #cantUnloadReason #definedClasses #'definedClasses:' #'definesClass:' #'ensureLoaded:' #extendedClasses #extendedMethods #'extendedMethods:' #'extendsMethodNamed:inClass:' #fileout #'fileoutDefinedClassesOn:' #'fileoutDefinedMethodsOn:' #'fileoutExtendedMethodsOn:' #'fileoutInventoryOn:' #'fileoutOn:' #'includedClasses:' #initialize #name #'name:' #'partialSortDefinedClassesDo:' #'printOn:' #'removeClass:' #'removeMethod:' #'removeRequiredKit:' #requiredKitNames #'requiredKitNames:' #sortDefinedClasses #subKits #'subKits:' #unload #versionName #'versionName:' #'writeLoadRequiredKitsOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Kit class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KitManager methods: #(#'addKit:' #'addKitNamed:' #'allDefinedClasses:andMethods:' #'allDefinedMethodsFor:methods:' #classesNotInKit #currentKit #'currentKit:' #'currentKitNamed:' #fileinAllKits #fileoutAllKits #finishFileinKit #'hasKitNamed:' #initialize #'kitForClass:' #'kitForClass:ifNone:' #'kitNamed:' #'kitNamedIfAbsentAdd:' #kits #kitsInLoadOrder #'removeKit:' #writeAllKits)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KitManager class methods: #(#clearDefault #current #default #new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargeInteger methods: #(#asFloat #asLargeInteger #'basicEqualTo:' #'basicGreaterThan:' #'basicGreaterThanOrEqual:' #'basicLessThan:' #'basicLessThanOrEqual:' #'basicNotEqualTo:' #bytes #'bytes:' #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #componentSize #'componentSize:' #'divideWithRemainderBy:' #hash #hex #initialize #'integerAt:' #isLargeInteger #kind #'mod:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveQuo:' #'primitiveRem:' #'primitiveTimes:' #'printHexOn:' #'printOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargeInteger class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargeNegativeInteger methods: #(#negative #positive #sign)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargeNegativeInteger class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargePositiveInteger methods: #(#negative #positive #sign)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargePositiveInteger class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LimitedPrecisionReal methods: #(#asInteger #fractionalValue #isReal #positive #'printOn:' #'printScientificNotationOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LimitedPrecisionReal class methods: #(#new #zero)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Magnitude methods: #(#'<' #'<=' #'>' #'>=' #'between:and:' #'max:' #'min:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Magnitude class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MemorySpace methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MemorySpace class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MessageNotUnderstood methods: #(#'printOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MessageNotUnderstood class methods: #(#defaultErrorString)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Metaclass methods: #(#classDictionaries #kit #name #'printOn:' #thisClass #'thisClass:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Metaclass class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Number methods: #(#'*' #'+' #'-' #'/' #'//' #'<' #'<=' #'=' #'>' #'>=' #'@' #abs #arccos #arcsin #'coerceTo:' #cos #cosh #cot #coth #csc #csch #degreesToRadians #exp #hash #isNumber #isZero #'jsonOn:' #kind #ln #log #negated #negative #positive #'quo:' #radiansToDegrees #'raisedTo:' #'raisedToInteger:' #'raisedToNegativeInteger:' #reciprocal #'rem:' #sec #sech #sign #sin #sinh #sqrt #squared #tan #tanh #'to:by:do:' #'to:do:' #'~=')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Number class methods: #(#'readFrom:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OSHandle methods: #(#contents)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OSHandle class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Point methods: #(#'*' #'+' #'-' #'/' #'=' #abs #copy #'corner:' #'dotProduct:' #'extent:' #hash #'max:' #'min:' #negated #'printOn:' #r #theta #transposed #x #'x:' #y #'y:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Point class methods: #(#'x:y:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PrimitiveFailedError methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PrimitiveFailedError class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SHA1 methods: #(#'hash:' #'write32:into:startingAt:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SHA1 class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmallInteger methods: #(#'<<' #'>>' #'\\' #asFloat #asLargeInteger #'basicAt:' #basicSize #'bitAnd:' #bitInvert #'bitOr:' #'bitShift:' #'bitXOr:' #'bitXor:' #'coerceFloat:' #'coerceFraction:' #'coerceLargeInteger:' #'coerceSmallInteger:' #'coerceTo:' #'divideWithRemainderBy:' #'integerAt:' #kind #'leftRotate32:' #'mod:' #'primitiveDivide:' #'primitiveEqualTo:' #'primitiveGreaterThan:' #'primitiveGreaterThanOrEqualTo:' #'primitiveLessThan:' #'primitiveLessThanOrEqualTo:' #'primitiveMinus:' #'primitiveNotEqualTo:' #'primitivePlus:' #'primitiveQuo:' #'primitiveRem:' #'primitiveTimes:' #reduce)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmallInteger class methods: #(#maxVal #minVal)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Socket methods: #(#FIONBIO #accept #basicAccept #bind #close #connect #'family:address:port:' #getPeerName #getSockName #'getSockOptLevel:optionName:value:length:' #handle #'handle:' #handleBlock #'handleBlock:' #'ioctl:data:' #isActive #'listen:' #makeNonBlocking #primClose #'read:length:' #'shutdown:' #stream #'write:length:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Socket class methods: #(#af_appletalk #af_bth #af_inet #af_inet6 #af_ipx #af_irda #af_netbios #af_unspec #'basicNewInDomain:type:protocol:' #ipproto_icmp #ipproto_icpmv6 #ipproto_igmp #ipproto_rfcomm #ipproto_rm #ipproto_tcp #ipproto_udp #'newInDomain:type:protocol:' #newTCPConnection #'poll:events:revents:timeout:' #sock_dgram #sock_raw #sock_rdm #sock_seqpacket #sock_stream)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketAcceptHandler methods: #(#clientHandler #'clientHandler:' #handle #portNumber #'portNumber:' #shutdown #startup)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketAcceptHandler class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketDispatcher methods: #(#POLLHUP #POLLIN #'addHandler:' #events #'events:' #handlers #'handlers:' #initialize #poll #'removeHandler:' #revents #'revents:' #running #'running:' #setupPollStructures #shutdown #socketHandles #'socketHandles:' #startPollLoop #timeoutHandler #'timeoutHandler:' #timeoutInterval #'timeoutInterval:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketDispatcher class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketHandler methods: #(#closeIfNeeded #dispatcher #'dispatcher:' #handle #initialize #shutdown #socket #'socket:' #startup)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketHandler class methods: #(#new #'startupOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketLauncher methods: #(#commandHandlerClass #'commandHandlerClass:' #screenHandlerClass #'screenHandlerClass:' #'startupOn:' #startupReceiver #'startupReceiver:' #startupSelector #'startupSelector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketLauncher class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketTimeoutHandler methods: #(#handle #timeoutBlock #'timeoutBlock:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketTimeoutHandler class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketUIScreenHandler methods: #(#commandHandler #'commandHandler:' #handle #handleWebSocketConnection #initialize #'processMessage:' #socketState #'socketState:' #startup #startupReceiver #'startupReceiver:' #startupSelector #'startupSelector:' #uiScreen #'uiScreen:' #webSocket #'webSocket:' #'withMyUIScreenDo:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketUIScreenHandler class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Time methods: #(#'-' #'<' #'<=' #'>' #'>=' #hours #milliseconds #'milliseconds:' #minutes #'printOn:' #seconds #'setMilliseconds:' #showHourlyCountdown #totalHours #totalMilliseconds #totalMinutes #totalSeconds #'writeBinaryOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Time class methods: #(#'fromSeconds:' #millisecondClockValue #'millisecondsToRun:' #now #'readBinaryFrom:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: True methods: #(#'&' #'and:' #'ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifTrue:ifFalse:' #not #'or:' #'printOn:' #'|')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: True class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UndefinedObject methods: #(#'ifNil:' #'ifNil:ifNotNil:' #'ifNotNil:' #isNil #'modifyClass:flags:instVarNames:classVarNames:classInstVarNames:environment:' #notNil #'printOn:' #'subclassNamed:flags:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:flags:instVarNames:classVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classInstVarNames:environment:kitName:' #'subclassNamed:instVarNames:classVarNames:classInstVarNames:environment:kitName:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UndefinedObject class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Warning methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Warning class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WebSocket methods: #(#close #isActive #isConnecting #'isConnecting:' #'lengthFor:' #mask #'onMessageReceive:do:' #'onMessageReceiveDo:' #'openClientFor:onPort:' #'openClientOnPort:' #'openOnPort:' #'openServerOnPort:' #processClientMessages #processConnectionMessage #processContentMessage #'processContentMessage:' #'processMessage:' #processMessages #processServerMessages #'processSocketClientConnectMessage:keyString:' #'processSocketConnectMessage:' #'processSocketServerConnectMessage:' #processWebSocketClientMessages #processWebSocketMessages #processWebSocketServerMessages #random #'random:' #readAndProcessMessages #readConnectionMessage #readContentMessage #'send:' #sendClientConnectMessage #socket #'socket:' #startupConnection #stream #'stream:' #'xorPayload:withMask:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WebSocket class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Object methods: #(#'->' #'=' #'==' #allOwners #asString #'at:' #'at:put:' #'basicAt:' #'basicAt:put:' #'basicPrintOn:' #basicPrintString #basicSize #'become:' #class #copy #displayString #'error:' #halt #hash #identityHash #'ifNil:' #'ifNil:ifNotNil:' #'ifNotNil:' #initialize #'instVarAt:' #'instVarAt:put:' #isArray #isBlock #isBlockClosure #isCollection #isCompiledBlock #isDictionary #isFloat #isIndexed #isInteger #'isKindOf:' #isLargeInteger #'isMemberOf:' #isNil #isNumber #isReal #isString #isSymbol #isUI #isVMMigrationNew #'log:' #markNewVersion #markVMMigrationNew #'migrateFrom:instVarMapping:' #notNil #'perform:' #'perform:with:' #'perform:with:with:' #'perform:with:with:with:' #'perform:withArguments:' #postCopy #primitiveFailed #primitiveHalt #'printOn:' #printString #'remote_instVarAt:' #'remote_instVarAt:put:' #'setClass:' #shallowCopy #'shallowCopyTo:' #size #'storeOn:' #storeString #walkback #yourself #'~=' #'~~')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Object class methods: #(#'log:' #systemDictionary)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Base64Encoder methods: #(#base64Characters #'base64ToInteger:' #decodeBlock #'decodeStream:' #'encode1:' #'encode2:with:' #'encode3:with:with:' #'encodeStream:' #encodeTriple #'integerToBase64:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Base64Encoder class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ExceptionBase methods: #(#catchBlock #'catchBlock:' #finallyBlock #'finallyBlock:' #unwind)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ExceptionBase class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ExceptionHandler methods: #(#catchBlock #'catchBlock:' #exceptionClass #'exceptionClass:' #finallyBlock #'finallyBlock:' #'handlesException:' #unwind)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ExceptionHandler class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ExceptionList methods: #(#',' #'addException:' #exceptionHandlers #exceptions #'exceptions:' #'handlesException:' #initialize #'try:catch:' #'try:catch:finally:' #'try:finally:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ExceptionList class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ComputedField methods: #(#action #'action:' #asString #isComputedField #name #'name:' #'printOn:' #'valueFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ComputedField class methods: #(#'name:action:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Array methods: #(#isArray #'printCollectionStartOn:' #species)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Array class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ArrayedCollection methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ArrayedCollection class methods: #(#'withAll:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Association methods: #(#'=' #hash #key #'key:' #'printOn:' #value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Association class methods: #(#'key:value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteArray methods: #(#asByteArray #asString #'printCollectionEndOn:' #'printCollectionStartOn:' #printStringHex)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteArray class methods: #(#'newFromImageSpace:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteString methods: #(#asInt #asTwoByteString #'at:' #'at:put:' #'basicAt:' #'basicAt:put:' #printStringHex)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteString class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteSymbol methods: #(#asString #'at:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteSymbol class methods: #(#garbageCollectSymbolTable #'intern:' #symbolTable)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Collection methods: #(#'allSatisfy:' #'anySatisfy:' #asArray #asByteArray #asOrderedCollection #asSet #'collect:' #'detect:' #'detect:ifNone:' #'do:' #'do:separatedBy:' #'includes:' #'inject:into:' #isCollection #isEmpty #notEmpty #'occurrencesOf:' #'printCollectionEndOn:' #'printCollectionStartOn:' #'printOn:' #'printOn:limit:' #'reject:' #'remove:' #'removeAll:' #'select:' #size #species #'storeOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Collection class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConventionCRLF methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConventionCRLF class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Dictionary methods: #(#'addAssociation:' #'associationAt:' #'associationAt:ifAbsent:' #associations #'associationsDo:' #'at:' #'at:ifAbsent:' #'at:ifAbsentPut:' #'at:put:' #basicValues #'bindingFor:' #copy #copyWithAssociations #'do:' #'doesKey:match:' #'findIndex:' #growIfNeeded #'includesKey:' #'initialProbeFor:' #'initialize:' #isDictionary #keys #'keysAndValuesDo:' #'keysDo:' #'privateRemoveKey:' #rehash #'removeKey:' #'removeKey:ifAbsent:' #size #values)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Dictionary class methods: #(#new #'new:' #rehashAllDictionaries)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: FileStream methods: #(#atEnd #basicNext #'basicNext:' #basicUpToEnd #binary #close #flush #handle #'handle:' #initialize #isBinary #'isBinary:' #lineEndConvention #'lineEndConvention:' #next #'next:' #'nextPut:' #'nextPutAll:' #'open:' #'open:mode:' #position #'position:' #primNext #'primNext:' #'primNextPut:' #'primNextPutAll:' #'primOpen:' #'primOpen:mode:' #'primSkip:' #primUpToEnd #'skip:' #upToEnd)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: FileStream class methods: #(#append #appendableRead #overwrite #pathDelimiterString #read #writableRead #write)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IdentityDictionary methods: #(#'doesKey:match:' #'initialProbeFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IdentityDictionary class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IntegerArray methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IntegerArray class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InternalStream methods: #(#collection #'collection:' #initialize #reset)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InternalStream class methods: #(#new #'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConvention methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConvention class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConventionCR methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConventionCR class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConventionLF methods: #(#'next:for:' #'nextFor:' #'nextPut:for:' #'nextPutAll:for:' #'skip:for:' #'upToEndFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LineEndConventionLF class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Matrix methods: #(#'*' #'+' #'-' #a00 #a01 #a02 #a03 #a10 #a11 #a12 #a13 #a20 #a21 #a22 #a23 #a30 #a31 #a32 #a33 #as2DPoint #'atRow:column:' #'atRow:column:put:' #b00 #b01 #b02 #b03 #b10 #b11 #b12 #b13 #b20 #b21 #b22 #b23 #b30 #b31 #b32 #b33 #columns #determinant4D #elements #'from3x3Array:' #'from4x4Array:' #'fromArray:' #inverse #inverse2D #inverse4D #javascriptString #makeIdentity #'printOn:' #rows #'rows:columns:' #w #x #y #z)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Matrix class methods: #(#'columnVectorFromArray:' #'from3x3Array:' #'from4x4Array:' #'fromArray:' #'identityRows:columns:' #'rows:columns:' #'twoDFromPoint:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodDictionary methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodDictionary class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OrderedCollection methods: #(#',' #'add:' #'add:beforeIndex:' #'addAll:' #'addFirst:' #asArray #'at:' #'at:put:' #copy #grow #growFirst #growFirstSize #'initializeSize:' #'inspectorFieldAt:' #inspectorFields #last #privateValues #'remove:' #'removeAllSuchThat:' #removeFirst #'removeIndex:' #removeLast #size)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OrderedCollection class methods: #(#new #'new:' #'with:' #'with:with:' #'with:with:with:' #'with:with:with:with:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Random methods: #(#initialize #next #nextSeed #seed #'seed:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Random class methods: #(#new #'seed:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReadStream methods: #(#atEnd #contents #fileIn #next #'next:' #'nextAvailable:' #peek #previous #'throughAll:' #'upTo:' #'upToAll:' #upToEnd)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReadStream class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReadWriteStream methods: #(#contents #cr #grow #'nextPut:' #'nextPutAll:' #'print:' #'print:limit:' #space #tab)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReadWriteStream class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SequenceableCollection methods: #(#',' #'=' #'at:ifAbsent:' #'collect:' #copy #'copyFrom:to:' #'copyReplaceAll:with:' #'copyReplacing:with:' #'copyWith:' #'copyWithout:' #'do:' #'do:separatedBy:' #'endsWith:' #'findFirst:' #'findLast:' #first #'firstIndexOf:startingAt:' #hash #'indexOf:' #'indexOfSubCollection:startingAt:' #'jsonOn:' #'keysAndValuesDo:' #last #'lastIndexOf:' #'printItWith:' #readStream #readWriteStream #reverse #'reverseDo:' #'select:' #sorted #'sortedBy:' #species #'splitOn:' #'with:do:' #writeStream)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SequenceableCollection class methods: #(#'from:' #'new:withAll:' #'with:' #'with:with:' #'with:with:with:' #'with:with:with:with:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Set methods: #(#'add:' #'addAll:' #basicValues #'do:' #grow #'includes:' #'initialize:' #recomputeTally #'remove:' #'remove:ifAbsent:' #size #species)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Set class methods: #(#new #'new:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketStream methods: #(#atEnd #bufferSize #commit #initialize #isActive #next #'nextPut:' #peek #read #reset #socket #'socket:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SocketStream class methods: #(#'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Sorter methods: #(#'partition:from:to:' #'partitionInclusive:from:to:' #'sort:' #'sort:from:to:' #sortBlock #'sortBlock:' #'swap:from:to:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Sorter class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Stream methods: #(#position #'position:' #readLimit #'readLimit:' #'skip:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Stream class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: String methods: #(#'<' #'<=' #'>' #'>=' #asByteArray #asFilename #asLowercase #asSimtalkString #asString #asSymbol #asUppercase #capitalized #'compareString:' #'convertLineEndingsTo2:' #'convertLineEndingsTo:' #crToCRLF #crToLF #'extractUTF8CharacterFrom:' #isString #'jsonOn:' #lfToCR #'match:ignoreCase:' #'matches:' #'printOn:' #'printPrefixOn:' #'printSuffixOn:' #'splitBy:' #'storeOn:' #'subStringFrom:to:' #'tokensBasedOn:' #trimSeparators #utf8Decode #withCRs)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: String class methods: #(#implementationClass #'new:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StringMatcher methods: #(#'addSubmatcher:' #advance #fail #index #'index:' #initialize #isFinished #'match:' #'matchCharacter:' #parent #'parent:' #pattern #'pattern:' #peekPattern #'removeSubmatcher:' #setupSubmatchers #submatchers)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StringMatcher class methods: #(#new #'pattern:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Symbol methods: #(#',' #'=' #asSimTalkSymbol #asSymbol #eventKey #hash #isSymbol #numArgs #'printOn:' #'printPrefixOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Symbol class methods: #(#implementationClass)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TwoByteString methods: #(#asTwoByteString #'at:' #'at:put:' #size)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TwoByteString class methods: #(#'new:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TwoByteSymbol methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TwoByteSymbol class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UninterpretedBytes methods: #(#asByteString #asString #'bitSequenceFrom:to:' #copy #'doubleAt:put:' #floatArrayPrintString #'floatAt:' #'floatAt:put:' #hexString #randomize #size #'uint32At:' #'uint32At:put:' #'uint64At:' #'uint64At:put:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UninterpretedBytes class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Vector methods: #(#'+' #'-' #'atRow:column:' #'atRow:column:put:' #columns #defaultW #elements #'elements:' #initialize #'printOn:' #rows #w #'w:' #x #'x:' #y #'y:' #z #'z:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Vector class methods: #(#new #'x:y:z:w:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WriteStream methods: #(#'at:put:' #'bufferArrayFor:data:as:' #contents #cr #grow #lf #'nextPut:' #'nextPutAll:' #'print:' #'print:limit:' #space #tab)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WriteStream class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JunkClass methods: #(#ifFalseIfTrueTest #ifFalseReturnTest #ifFalseTest #ifTrueIfFalseTest #initialize #junkMethod #junkMethod10 #junkMethod2 #junkMethod3 #junkMethod4 #junkMethod5 #junkMethod6 #junkMethod7 #junkMethod8 #'method2:' #nonLocalReturn #nonLocalReturnA #'nonLocalReturnB:' #nonLocalReturnC)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JunkClass class methods: #(#classVar1Variable)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CachedValue methods: #(#block #'block:' #resetValue #value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CachedValue class methods: #(#'block:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default finishFileinKit] value ! !
! Doit class methodsFor: 'doit' !
doit ^[('kits' asFilename construct: 'Compiler.kit') fileIn] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKitNamed: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit ensureLoaded: #('Core')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #BytecodeSpec
	instVarNames: 'number name type numberOfBytes argumentSpec decompileString'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object variableSubclassNamed: #CodeContext
	instVarNames: 'frame stackOffset pcOffset method methodContext contextId'
	classInstVarNames: 'bytecodeBlocks'
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object variableSubclassNamed: #CodeSimulator
	instVarNames: 'currentContext frames stopFrame stopMethod'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #CommandHandler
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Error subclassNamed: #CompileError
	instVarNames: 'startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Warning subclassNamed: #CompileWarning
	instVarNames: 'startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #DecompileStream
	instVarNames: 'byteStream compiledCode'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Decompiler
	instVarNames: 'literals targetClass offsetStream decompiledCodeStream formattedBytecodeStream byteStream resultStream numberOfArguments numberOfTemporaries numberOfCopiedVariables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CommandHandler subclassNamed: #DevelopmentCommandHandler
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #FileinReader
	instVarNames: 'stream readingString quoting chunkStream readingComment starting precedingEmptyChunk'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader subclassNamed: #ClassFileinReader
	instVarNames: 'targetClass organization'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #IndirectVariableList
	instVarNames: 'variables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #LexicalAnalyzer
	instVarNames: 'stream next next2 parseTree position startSourceOffset endSourceOffset tokens'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer subclassNamed: #JSONLexicalAnalyzer
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ParseTreeNode
	instVarNames: 'startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #BinaryHeaderNode
	instVarNames: 'selector argument'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #BinaryMessageNode
	instVarNames: 'receiver selector argument'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #BlockNode
	instVarNames: 'arguments statements scope hasReturn parent'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #BlockParameterListNode
	instVarNames: 'variables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #CascadeNode
	instVarNames: 'receiver messages'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #GlobalVariableAssignmentNode
	instVarNames: 'variable value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #GlobalVariableReferenceNode
	instVarNames: 'variable'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #InstanceVariableAssignmentNode
	instVarNames: 'variable value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #InstanceVariableReferenceNode
	instVarNames: 'variable'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #KeywordHeaderNode
	instVarNames: 'selector arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #KeywordMessageNode
	instVarNames: 'receiver selector arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #LocalVariableAssignmentNode
	instVarNames: 'variable value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #LocalVariableReferenceNode
	instVarNames: 'variable scopeNumber'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #MethodNode
	instVarNames: 'header body pragmas scope'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #NamespaceVariableAssignmentNode
	instVarNames: 'variable value nameComponents'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #NamespaceVariableReferenceNode
	instVarNames: 'nameComponents'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #ParenthesisNode
	instVarNames: 'expression'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ParseTreeVisitor
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor subclassNamed: #CodeGenerator
	instVarNames: 'literals bytecodeStream targetClass globalDictionaries selector hasReturned pragmas nodeStack isInlinedBlock nestedVariablesRead nestedVariablesWritten methodLocalVariableAnalysis returnLevel outerMethod sourceOffsets'
	classInstVarNames: 'bytecodesByIndex bytecodesByName'
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor subclassNamed: #MethodLocalVariableAnalysisVisitor
	instVarNames: 'rootNode scopeStack scopes'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Parser
	instVarNames: 'currentRule'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser subclassNamed: #JSONParser
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ParserRule
	instVarNames: 'parser parentRule tokenStream result produceBlock errorString'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #OneOfParserRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #OneOrMoreParserRule
	instVarNames: 'nodes passed'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #OptionalParserRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #ParseMethodRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #PragmaNode
	instVarNames: 'selector arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #ReturnNode
	instVarNames: 'value returnLevel'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #RootRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Scope
	instVarNames: 'variables scopeNumber parentScope childScopes'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #ScopeAnalysisResult
	instVarNames: 'node temporaryVariables copiedVariables indirectVariables hasReturn parent children arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #SequenceNode
	instVarNames: 'sequence'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #SequenceParserRule
	instVarNames: 'allPassed sequence rulesRun'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer subclassNamed: #SmalltalkLexicalAnalyzer
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser subclassNamed: #SmalltalkParser
	instVarNames: 'scopeStack scopes targetClass globalDictionaries tokensToExpect currentMethodName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #StatementListNode
	instVarNames: 'variables statements'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #TempVarListNode
	instVarNames: 'variables'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser subclassNamed: #TestParser
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Token
	instVarNames: 'value startSourceOffset endSourceOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #ArrayLiteralToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #AssignToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #BarToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #BinaryToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #BlockArgumentToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #ByteArrayLiteralToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #CharacterToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #CloseBraceToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #CloseParenthesisToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #CloseSquareBracketToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #ColonToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #CommaToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #CompoundWordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #ErrorToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #FloatToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #IntegerToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #KeywordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #LeftAngleToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #OpenBraceToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #OpenParenthesisToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #OpenSquareBracketToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #PeriodToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #ReturnToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #RightAngleToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #SemicolonToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #SpecialWordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #StringToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #SymbolToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #TokenNode
	instVarNames: 'token'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #TokenRule
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #UnaryHeaderNode
	instVarNames: 'selector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #UnaryMessageNode
	instVarNames: 'receiver selector'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode subclassNamed: #ValueNode
	instVarNames: 'value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueNode subclassNamed: #LiteralNode
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LiteralNode subclassNamed: #BlockLiteralNode
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueNode subclassNamed: #ObjectNode
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueNode subclassNamed: #SpecialNode
	instVarNames: 'special'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Variable
	instVarNames: 'variableName'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable subclassNamed: #GlobalVariable
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable subclassNamed: #InstanceVariable
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable subclassNamed: #LocalVariable
	instVarNames: 'scope scopeNumber indirect isArgument'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable subclassNamed: #NamespaceVariable
	instVarNames: 'namespaceComponents'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable subclassNamed: #SelfVariable
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token subclassNamed: #WordToken
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule subclassNamed: #ZeroOrMoreParserRule
	instVarNames: 'nodes passed'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Compiler'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
argumentSpec

	^argumentSpec ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
argumentSpec: anObject

	argumentSpec := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
decompileString

	^decompileString ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
decompileString: anObject

	decompileString := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
name: anObject

	name := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
number

	^number ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
number: anObject

	number := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
numberOfBytes

	^numberOfBytes ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
numberOfBytes: anObject

	numberOfBytes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
type

	^type ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'accessing'] value ! !
! BytecodeSpec methodsFor: 'accessing' !
type: anObject

	type := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BytecodeSpec methodsFor: 'printing'] value ! !
! BytecodeSpec methodsFor: 'printing' !
printOn: aStream

	aStream nextPutAll: self decompileString ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
allLocalNames

	| localNames |

	localNames := OrderedCollection new.
	self method localVariableNames do: [:each |
		each isArray
			ifTrue: [localNames addAll: each]
			ifFalse: [localNames add: each]].
	^localNames ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
basicLocalAt: aNumber

	frame isNil ifTrue: [^nil].
	^frame basicAt: (frame stackOffset + aNumber + 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
basicLocalAt: aNumber put: anObject

	frame isNil ifTrue: [^nil].
	frame basicAt: (frame stackOffset + aNumber + 1) put: anObject  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
contextId

	^contextId ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
contextId: anObject

	contextId := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
frame

	^frame ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
frame: aCodeContext

	frame := aCodeContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
getSelf

	self method isCompiledBlock ifTrue: [
		^self rootSelfFor: self method outerMethod].
	^self receiver ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
localAt: aNumber

	| localNumber |

	frame isNil ifTrue: [^nil].

	localNumber := 1.
	self method localVariableNames keysAndValuesDo: [:key :value |
		value isArray
			ifTrue: [
				(aNumber between: localNumber and: localNumber + value size - 1)
					ifTrue: [
						^(self basicLocalAt: key) at: aNumber - localNumber + 1].
				localNumber := localNumber + value size]
			ifFalse: [
				localNumber = aNumber ifTrue: [^self basicLocalAt: key].
				localNumber := localNumber + 1]
		].
	^nil  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
method
	^method ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
method: aCompiledMethod

	method := aCompiledMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
methodClass

	^self rootMethod mclass ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
methodContext

	^methodContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
methodContext: aCodeContext

	methodContext := aCodeContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
pcOffset
	^pcOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
pcOffset: aNumber

	pcOffset := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
receiver

	^self basicLocalAt: 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
rootContext

	| frame method |

	frame := self.
	method := self rootMethod.
	[frame method == method] whileFalse: [
		frame := frame frame.
		frame isNil ifTrue: [^nil].
		].


	^frame ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
rootMethod

	^self method rootMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
rootMethodClass

	^self rootMethod mclass ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
rootSelfFor: aCompiledMethod

	| frame |

	frame := self.
	[frame method == aCompiledMethod] whileFalse: [
		frame := frame frame.
		frame isNil ifTrue: [^nil].
		].


	^frame getSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
sender
	^frame ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
stackAt: aNumber

	^self basicAt: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
stackNames

	| stackNames |

	stackNames := OrderedCollection new.
	1 to: self stackOffset do: [:each |
		stackNames add: each printString].

	^stackNames ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
stackOffset
	^stackOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'accessing'] value ! !
! CodeContext methodsFor: 'accessing' !
stackOffset: aNumber

	stackOffset := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'dumping'] value ! !
! CodeContext methodsFor: 'dumping' !
allFrames

	| context frames |

	context := self.
	frames := OrderedCollection new.

	[context notNil] whileTrue: [
		context method isNil ifFalse: [
			frames add: context].
		context := context sender].

	^frames ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'dumping'] value ! !
! CodeContext methodsFor: 'dumping' !
walkback
	| context stream |

	context := self.
	stream := WriteStream on: (String new: 1000).

	[context notNil] whileTrue: [
		context method isNil ifFalse: [
			stream
				nextPutAll: context method mclass printString.
			(context method isBlock) ifFalse: [
				stream
					nextPutAll: ' >> ';
					nextPutAll: context method selector].
			stream cr].
		context := context sender].
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'initializing'] value ! !
! CodeContext methodsFor: 'initializing' !
initialize

	stackOffset := 0.
	pcOffset := 0. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'printing'] value ! !
! CodeContext methodsFor: 'printing' !
printOn: aStream

	self receiver class ~= self method mclass ifTrue: [
		aStream nextPut: $(;
			print: self receiver class;
			nextPut: $);
			space].

	aStream print: self method ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
doBytecode: aNumber

	^(self class bytecodeBlocks at: aNumber + 1) value: self ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
dropCascadeReceiver

	| object |

	object := self pop.
	self pop.
	self push: object ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
dup

	| object |
	object := self pop.
	self push: object; push: object
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
findCompiledMethod: selector startingAt: aBehavior

	| behavior |

	behavior := aBehavior.
	[behavior methodDictionary includesKey: selector] whileFalse: [
		behavior := behavior superclass.
		behavior isNil ifTrue: [^nil]].

	^behavior methodDictionary at: selector

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
grow

	| newInstance |
	newInstance := self class new: (self basicSize + 6).
	self shallowCopyTo: newInstance.
	self become: newInstance ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
jump: anInteger

	pcOffset := pcOffset + anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
jumpIfFalse: anInteger

	self pop == true ifFalse: [pcOffset := pcOffset + anInteger] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
jumpIfTrue: anInteger

	self pop == true ifTrue: [pcOffset := pcOffset + anInteger] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
nextBytecode

	^method bytecodes at: (pcOffset := pcOffset + 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
nextFourBytecodes

	^(((self nextBytecode * 256) + self nextBytecode) * 256 + self nextBytecode) * 256 + self nextBytecode  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
nextFourSignedBytes

	| byte |
	byte := self nextFourBytecodes.
	^byte >= 2147483648
		ifTrue: [byte - 4294967296]
		ifFalse: [byte]  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
nextSignedByte

	| byte |
	byte := self nextBytecode.
	^byte >= 128
		ifTrue: [byte - 256]
		ifFalse: [byte] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
nextTwoBytecodes

	^(self nextBytecode * 256) + self nextBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
nextTwoSignedBytes

	| byte |
	byte := self nextTwoBytecodes.
	^byte >= 32768
		ifTrue: [byte - 65536]
		ifFalse: [byte] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
peek

	^self basicAt: stackOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
peek: aNumber

	^self basicAt: stackOffset - aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
peekBytecode

	^method bytecodes at: pcOffset + 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pop

	| result |
	result := self basicAt: stackOffset.
	stackOffset := stackOffset - 1.
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
push: anObject

	stackOffset := stackOffset + 1.
	stackOffset > self basicSize ifTrue: [self grow].
	self basicAt: stackOffset put: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushCopyingBlock: aNumber copiedVariables: numberOfCopiedVariables

	| copiedVariables compiledBlock |

	compiledBlock := method basicAt: aNumber + 1.

	copiedVariables := Array new: numberOfCopiedVariables.
	numberOfCopiedVariables to: 1 by: -1 do: [:index |
		copiedVariables at: index put: self pop].

	self push: (BlockClosure new
		method: compiledBlock;
		copiedValues: copiedVariables;
		yourself)
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushFullBlock: aNumber copiedVariables: numberOfCopiedVariables

	| copiedVariables compiledBlock |

	compiledBlock := method basicAt: aNumber + 1.

	copiedVariables := Array new: numberOfCopiedVariables.
	numberOfCopiedVariables to: 1 by: -1 do: [:index |
		copiedVariables at: index put: self pop].

	self push: (BlockClosure new
		method: compiledBlock;
		copiedValues: copiedVariables;
		methodContext: (self methodContext ifNil: [self contextId]);
		yourself)
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushGlobal: aNumber

	self push: (self method basicAt: aNumber + 1) value ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushInstVar: aNumber

	self push: (self receiver instVarAt: aNumber + 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushLiteral: aNumber

	self push: (self method basicAt: aNumber + 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushLocal: aNumber

	self push: (self basicLocalAt: aNumber + 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushLocal: aNumber indirect: varNumber

	| localObject instSize |
	localObject := self basicLocalAt: aNumber + 1.
	instSize := localObject class instSize.
	self push: (varNumber <= instSize
		ifTrue: [localObject instVarAt: varNumber + 1]
		ifFalse: [localObject basicAt: varNumber + 1 - instSize])  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushSelf

	self push: self receiver ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
pushSelfInstVar: aNumber

	self push: (self receiver instVarAt: aNumber + 1)  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
restart

	stackOffset := 0.
	pcOffset := 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
storeGlobal: aNumber

	(self method basicAt: aNumber + 1) value: self pop ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
storeInstVar: aNumber

	self receiver instVarAt: aNumber + 1 put: self peek ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
storeLocal: aNumber

	self basicLocalAt: aNumber + 1 put: self peek ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
storeLocal: aNumber indirect: varNumber

	| localObject instSize |
	localObject := self basicLocalAt: aNumber + 1.
	instSize := localObject class instSize.
	varNumber <= instSize
		ifTrue: [localObject instVarAt: varNumber + 1 put: self peek]
		ifFalse: [localObject basicAt: varNumber + 1 - instSize put: self peek]  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
storeNewArray: size local: localNumber

	self basicLocalAt: localNumber + 1 put: (Array new: size)
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'simulating'] value ! !
! CodeContext methodsFor: 'simulating' !
storeSelfInstVar: aNumber

	self receiver instVarAt: aNumber + 1 put: self peek  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext methodsFor: 'testing'] value ! !
! CodeContext methodsFor: 'testing' !
isBlockContext

	^(method isMemberOf: CompiledMethod) not ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
bytecodeBlockAt: bytecodeNumber

	^bytecodeBlocks at: bytecodeNumber + 1

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
bytecodeBlockAt: bytecodeNumber put: aBlock

	bytecodeBlocks at: bytecodeNumber + 1 put: aBlock

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
bytecodeBlocks

	bytecodeBlocks isNil ifTrue: [self setupBytecodeBlocks].
	^bytecodeBlocks ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
callReturnBytecodes

	self
		bytecodeBlockAt: 16rC0 put: [:simulator | simulator call: 0 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 1"
		bytecodeBlockAt: 16rC1 put: [:simulator | simulator call: 1 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 2"
		bytecodeBlockAt: 16rC2 put: [:simulator | simulator call: 2 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 3"
		bytecodeBlockAt: 16rC3 put: [:simulator | simulator call: 3 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 4"
		bytecodeBlockAt: 16rC4 put: [:simulator | simulator call: 4 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 5"
		bytecodeBlockAt: 16rC5 put: [:simulator | simulator call: 5 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 6"
		bytecodeBlockAt: 16rC6 put: [:simulator | simulator call: 6 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 7"
		bytecodeBlockAt: 16rC7 put: [:simulator | simulator call: 7 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 8"
		bytecodeBlockAt: 16rC8 put: [:simulator | simulator call: 8 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 9"
		bytecodeBlockAt: 16rC9 put: [:simulator | simulator call: 9 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 10"
		bytecodeBlockAt: 16rCA put: [:simulator | simulator call: 10 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 11"
		bytecodeBlockAt: 16rCB put: [:simulator | simulator call: 11 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 12"
		bytecodeBlockAt: 16rCC put: [:simulator | simulator call: 12 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 13"
		bytecodeBlockAt: 16rCD put: [:simulator | simulator call: 13 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 14"
		bytecodeBlockAt: 16rCE put: [:simulator | simulator call: 14 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 15"
		bytecodeBlockAt: 16rCF put: [:simulator | simulator call: 15 arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal 16"

		bytecodeBlockAt: 16rD0 put: [:simulator | simulator superCall: 0 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 1"
		bytecodeBlockAt: 16rD1 put: [:simulator | simulator superCall: 1 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 2"
		bytecodeBlockAt: 16rD2 put: [:simulator | simulator superCall: 2 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 3"
		bytecodeBlockAt: 16rD3 put: [:simulator | simulator superCall: 3 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 4"
		bytecodeBlockAt: 16rD4 put: [:simulator | simulator superCall: 4 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 5"
		bytecodeBlockAt: 16rD5 put: [:simulator | simulator superCall: 5 arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal 6"

		bytecodeBlockAt: 16rD6 put: [:simulator | simulator callWellKnown: simulator currentContext nextBytecode; yourself]; 		"Call well known"
		bytecodeBlockAt: 16rD7 put: [:simulator | simulator call: simulator currentContext nextBytecode arguments: simulator currentContext nextBytecode; yourself]; 		"Call literal"
		bytecodeBlockAt: 16rD8 put: [:simulator | simulator call: simulator currentContext nextTwoBytecodes arguments literals: simulator currentContext nextTwoBytecodes; yourself]; 		"Call literal extended"
		bytecodeBlockAt: 16rD9 put: [:simulator | simulator superCall: simulator currentContext nextBytecode arguments: simulator currentContext nextBytecode; yourself]; 		"Super call literal"
		bytecodeBlockAt: 16rDA put: [:simulator | simulator superCall: simulator currentContext nextTwoBytecodes arguments literals: simulator currentContext nextTwoBytecodes; yourself]; 		"Super call literal extended"
		bytecodeBlockAt: 16rDB put: [:simulator | simulator callPrimitive: simulator currentContext nextBytecode arguments: simulator currentContext nextBytecode; yourself]; 		"Call primitive"

		bytecodeBlockAt: 16rDC put: [:simulator | simulator return; yourself]; 		"Return"
		bytecodeBlockAt: 16rDD put: [:simulator | simulator blockReturn; yourself]; 		"Block Return"
		bytecodeBlockAt: 16rDE put: [:simulator | simulator nonLocalReturn; yourself]; 		"Non Local Return"
		bytecodeBlockAt: 16rDF put: [:simulator | simulator primitiveReturn; yourself]; 		"Primitive Return"
		yourself

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
clearBytecodeBlocks

	bytecodeBlocks := nil ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
jumpBytecodes

	self
		bytecodeBlockAt: 16rB0 put: [:simulator | simulator currentContext jump: simulator currentContext nextSignedByte; yourself]; 		"Jump"
		bytecodeBlockAt: 16rB1 put: [:simulator | simulator currentContext jump: simulator currentContext nextTwoSignedBytes; yourself]; 		"Jump Extended"
		bytecodeBlockAt: 16rB2 put: [:simulator | simulator currentContext jumpIfTrue: simulator currentContext nextSignedByte; yourself]; 		"Jump If True"
		bytecodeBlockAt: 16rB3 put: [:simulator | simulator currentContext jumpIfTrue: simulator currentContext nextTwoSignedBytes; yourself]; 		"Jump If True Extended"
		bytecodeBlockAt: 16rB4 put: [:simulator | simulator currentContext jumpIfFalse: simulator currentContext nextSignedByte; yourself]; 		"Jump If False"
		bytecodeBlockAt: 16rB5 put: [:simulator | simulator currentContext jumpIfFalse: simulator currentContext nextTwoSignedBytes; yourself]; 		"Jump If False Extended"
		yourself

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
pushGlobalBytecodes

	self
		bytecodeBlockAt: 16r40 put: [:simulator | simulator currentContext pushGlobal: 0; yourself]; 		"Push Global 0"
		bytecodeBlockAt: 16r41 put: [:simulator | simulator currentContext pushGlobal: 1; yourself]; 		"Push Global 1"
		bytecodeBlockAt: 16r42 put: [:simulator | simulator currentContext pushGlobal: 2; yourself]; 		"Push Global 2"
		bytecodeBlockAt: 16r43 put: [:simulator | simulator currentContext pushGlobal: 3; yourself]; 		"Push Global 3"
		bytecodeBlockAt: 16r44 put: [:simulator | simulator currentContext pushGlobal: 4; yourself]; 		"Push Global 4"
		bytecodeBlockAt: 16r45 put: [:simulator | simulator currentContext pushGlobal: 5; yourself]; 		"Push Global 5"
		bytecodeBlockAt: 16r46 put: [:simulator | simulator currentContext pushGlobal: 6; yourself]; 		"Push Global 6"
		bytecodeBlockAt: 16r47 put: [:simulator | simulator currentContext pushGlobal: 7; yourself]; 		"Push Global 7"
		bytecodeBlockAt: 16r48 put: [:simulator | simulator currentContext pushGlobal: 8; yourself]; 		"Push Global 8"
		bytecodeBlockAt: 16r49 put: [:simulator | simulator currentContext pushGlobal: 9; yourself]; 		"Push Global 9"
		bytecodeBlockAt: 16r4A put: [:simulator | simulator currentContext pushGlobal: 10; yourself]; 		"Push Global 10"
		bytecodeBlockAt: 16r4B put: [:simulator | simulator currentContext pushGlobal: 11; yourself]; 		"Push Global 11"
		bytecodeBlockAt: 16r4C put: [:simulator | simulator currentContext pushGlobal: 12; yourself]; 		"Push Global 12"
		bytecodeBlockAt: 16r4D put: [:simulator | simulator currentContext pushGlobal: 13; yourself]; 		"Push Global 13"
		bytecodeBlockAt: 16r4E put: [:simulator | simulator currentContext pushGlobal: 14; yourself]; 		"Push Global 14"
		bytecodeBlockAt: 16r4F put: [:simulator | simulator currentContext pushGlobal: 15; yourself]; 		"Push Global 15"
		bytecodeBlockAt: 16r9A put: [:simulator | simulator currentContext pushGlobal: simulator currentContext nextBytecode; yourself]; 		"Push Global"
		bytecodeBlockAt: 16r9B put: [:simulator | simulator currentContext pushGlobal: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Global Extended"
		yourself

  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
pushInstVarBytecodes

	self
		bytecodeBlockAt: 16r00 put: [:simulator | simulator currentContext pushInstVar: 0; yourself]; 		"Push Inst Var 0"
		bytecodeBlockAt: 16r01 put: [:simulator | simulator currentContext pushInstVar: 1; yourself]; 		"Push Inst Var 1"
		bytecodeBlockAt: 16r02 put: [:simulator | simulator currentContext pushInstVar: 2; yourself]; 		"Push Inst Var 2"
		bytecodeBlockAt: 16r03 put: [:simulator | simulator currentContext pushInstVar: 3; yourself]; 		"Push Inst Var 3"
		bytecodeBlockAt: 16r04 put: [:simulator | simulator currentContext pushInstVar: 4; yourself]; 		"Push Inst Var 4"
		bytecodeBlockAt: 16r05 put: [:simulator | simulator currentContext pushInstVar: 5; yourself]; 		"Push Inst Var 5"
		bytecodeBlockAt: 16r06 put: [:simulator | simulator currentContext pushInstVar: 6; yourself]; 		"Push Inst Var 6"
		bytecodeBlockAt: 16r07 put: [:simulator | simulator currentContext pushInstVar: 7; yourself]; 		"Push Inst Var 7"
		bytecodeBlockAt: 16r08 put: [:simulator | simulator currentContext pushInstVar: 8; yourself]; 		"Push Inst Var 8"
		bytecodeBlockAt: 16r09 put: [:simulator | simulator currentContext pushInstVar: 9; yourself]; 		"Push Inst Var 9"
		bytecodeBlockAt: 16r0A put: [:simulator | simulator currentContext pushInstVar: 10; yourself]; 		"Push Inst Var 10"
		bytecodeBlockAt: 16r0B put: [:simulator | simulator currentContext pushInstVar: 11; yourself]; 		"Push Inst Var 11"
		bytecodeBlockAt: 16r0C put: [:simulator | simulator currentContext pushInstVar: 12; yourself]; 		"Push Inst Var 12"
		bytecodeBlockAt: 16r0D put: [:simulator | simulator currentContext pushInstVar: 13; yourself]; 		"Push Inst Var 13"
		bytecodeBlockAt: 16r0E put: [:simulator | simulator currentContext pushInstVar: 14; yourself]; 		"Push Inst Var 14"
		bytecodeBlockAt: 16r0F put: [:simulator | simulator currentContext pushInstVar: 15; yourself]; 		"Push Inst Var 15"
		bytecodeBlockAt: 16r94 put: [:simulator | simulator currentContext pushInstVar: simulator currentContext nextBytecode; yourself]; 		"Push Inst Var"
		bytecodeBlockAt: 16r95 put: [:simulator | simulator currentContext pushInstVar: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Inst Var Extended"
		bytecodeBlockAt: 16rB7 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Push Self Inst Var"
		bytecodeBlockAt: 16rB8 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Local Indirect Extended"
		yourself

  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
pushIntegerBytecodes

	self
		bytecodeBlockAt: 16r60 put: [:simulator | simulator currentContext push: 1; yourself]; 		"Push 1"
		bytecodeBlockAt: 16r61 put: [:simulator | simulator currentContext push: 2; yourself]; 		"Push 2"
		bytecodeBlockAt: 16r62 put: [:simulator | simulator currentContext push: 3; yourself]; 		"Push 3"
		bytecodeBlockAt: 16r63 put: [:simulator | simulator currentContext push: 4; yourself]; 		"Push 4"
		bytecodeBlockAt: 16r64 put: [:simulator | simulator currentContext push: 5; yourself]; 		"Push 5"
		bytecodeBlockAt: 16r65 put: [:simulator | simulator currentContext push: 6; yourself]; 		"Push 6"
		bytecodeBlockAt: 16r66 put: [:simulator | simulator currentContext push: 7; yourself]; 		"Push 7"
		bytecodeBlockAt: 16r67 put: [:simulator | simulator currentContext push: 8; yourself]; 		"Push 8"
		bytecodeBlockAt: 16r68 put: [:simulator | simulator currentContext push: 9; yourself]; 		"Push 9"
		bytecodeBlockAt: 16r69 put: [:simulator | simulator currentContext push: 10; yourself]; 		"Push 10"
		bytecodeBlockAt: 16r6A put: [:simulator | simulator currentContext push: 11; yourself]; 		"Push 11"
		bytecodeBlockAt: 16r6B put: [:simulator | simulator currentContext push: 12; yourself]; 		"Push 12"
		bytecodeBlockAt: 16r6C put: [:simulator | simulator currentContext push: 13; yourself]; 		"Push 13"
		bytecodeBlockAt: 16r6D put: [:simulator | simulator currentContext push: 14; yourself]; 		"Push 14"
		bytecodeBlockAt: 16r6E put: [:simulator | simulator currentContext push: 15; yourself]; 		"Push 15"
		bytecodeBlockAt: 16r6F put: [:simulator | simulator currentContext push: 16; yourself]; 		"Push 16"
		bytecodeBlockAt: 16r70 put: [:simulator | simulator currentContext push: 0; yourself]; 		"Push 0"
		bytecodeBlockAt: 16r71 put: [:simulator | simulator currentContext push: -1; yourself]; 		"Push -1"
		bytecodeBlockAt: 16r72 put: [:simulator | simulator currentContext push: -2; yourself]; 		"Push -2"
		bytecodeBlockAt: 16r73 put: [:simulator | simulator currentContext push: -3; yourself]; 		"Push -3"
		bytecodeBlockAt: 16r74 put: [:simulator | simulator currentContext push: -4; yourself]; 		"Push -4"
		bytecodeBlockAt: 16r75 put: [:simulator | simulator currentContext push: -5; yourself]; 		"Push -5"
		bytecodeBlockAt: 16r76 put: [:simulator | simulator currentContext push: -6; yourself]; 		"Push -6"
		bytecodeBlockAt: 16r77 put: [:simulator | simulator currentContext push: -7; yourself]; 		"Push -7"
		bytecodeBlockAt: 16r78 put: [:simulator | simulator currentContext push: -8; yourself]; 		"Push -8"
		bytecodeBlockAt: 16r79 put: [:simulator | simulator currentContext push: -9; yourself]; 		"Push -9"
		bytecodeBlockAt: 16r7A put: [:simulator | simulator currentContext push: -10; yourself]; 		"Push -10"
		bytecodeBlockAt: 16r7B put: [:simulator | simulator currentContext push: -11; yourself]; 		"Push -11"
		bytecodeBlockAt: 16r7C put: [:simulator | simulator currentContext push: -12; yourself]; 		"Push -12"
		bytecodeBlockAt: 16r7D put: [:simulator | simulator currentContext push: -13; yourself]; 		"Push -13"
		bytecodeBlockAt: 16r7E put: [:simulator | simulator currentContext push: -14; yourself]; 		"Push -14"
		bytecodeBlockAt: 16r7F put: [:simulator | simulator currentContext push: -15; yourself]; 		"Push -15"

		bytecodeBlockAt: 16r9E put: [:simulator | simulator currentContext push: simulator currentContext nextSignedByte; yourself]; 			"Push Integer"
		bytecodeBlockAt: 16r9F put: [:simulator | simulator currentContext push: simulator currentContext nextTwoSignedBytes; yourself]; 		"Push Two Byte Integer"
		bytecodeBlockAt: 16rA0 put: [:simulator | simulator currentContext push: simulator currentContext nextFourSignedBytes; yourself]; 	"Push Four Byte Integer"
		yourself

  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
pushLiteralBytecodes

	self
		bytecodeBlockAt: 16r80 put: [:simulator | simulator currentContext pushLiteral: 0; yourself]; 		"Push Literal 0"
		bytecodeBlockAt: 16r81 put: [:simulator | simulator currentContext pushLiteral: 1; yourself]; 		"Push Literal 1"
		bytecodeBlockAt: 16r82 put: [:simulator | simulator currentContext pushLiteral: 2; yourself]; 		"Push Literal 2"
		bytecodeBlockAt: 16r83 put: [:simulator | simulator currentContext pushLiteral: 3; yourself]; 		"Push Literal 3"
		bytecodeBlockAt: 16r84 put: [:simulator | simulator currentContext pushLiteral: 4; yourself]; 		"Push Literal 4"
		bytecodeBlockAt: 16r85 put: [:simulator | simulator currentContext pushLiteral: 5; yourself]; 		"Push Literal 5"
		bytecodeBlockAt: 16r86 put: [:simulator | simulator currentContext pushLiteral: 6; yourself]; 		"Push Literal 6"
		bytecodeBlockAt: 16r87 put: [:simulator | simulator currentContext pushLiteral: 7; yourself]; 		"Push Literal 7"
		bytecodeBlockAt: 16r88 put: [:simulator | simulator currentContext pushLiteral: 8; yourself]; 		"Push Literal 8"
		bytecodeBlockAt: 16r89 put: [:simulator | simulator currentContext pushLiteral: 9; yourself]; 		"Push Literal 9"
		bytecodeBlockAt: 16r8A put: [:simulator | simulator currentContext pushLiteral: 10; yourself]; 		"Push Literal 10"
		bytecodeBlockAt: 16r8B put: [:simulator | simulator currentContext pushLiteral: 11; yourself]; 		"Push Literal 11"
		bytecodeBlockAt: 16r8C put: [:simulator | simulator currentContext pushLiteral: 12; yourself]; 		"Push Literal 12"
		bytecodeBlockAt: 16r8D put: [:simulator | simulator currentContext pushLiteral: 13; yourself]; 		"Push Literal 13"
		bytecodeBlockAt: 16r8E put: [:simulator | simulator currentContext pushLiteral: 14; yourself]; 		"Push Literal 14"
		bytecodeBlockAt: 16r8F put: [:simulator | simulator currentContext pushLiteral: 15; yourself]; 		"Push Literal 15"
		bytecodeBlockAt: 16r9C put: [:simulator | simulator currentContext pushLiteral: simulator currentContext nextBytecode; yourself]; 		"Push Literal"
		bytecodeBlockAt: 16r9D put: [:simulator | simulator currentContext pushLiteral: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Literal Extended"
		yourself

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
pushLocalBytecodes

	self
		bytecodeBlockAt: 16r20 put: [:simulator | simulator currentContext pushLocal: 0; yourself]; 		"Push Local 1"
		bytecodeBlockAt: 16r21 put: [:simulator | simulator currentContext pushLocal: 1; yourself]; 		"Push Local 2"
		bytecodeBlockAt: 16r22 put: [:simulator | simulator currentContext pushLocal: 2; yourself]; 		"Push Local 3"
		bytecodeBlockAt: 16r23 put: [:simulator | simulator currentContext pushLocal: 3; yourself]; 		"Push Local 4"
		bytecodeBlockAt: 16r24 put: [:simulator | simulator currentContext pushLocal: 4; yourself]; 		"Push Local 5"
		bytecodeBlockAt: 16r25 put: [:simulator | simulator currentContext pushLocal: 5; yourself]; 		"Push Local 6"
		bytecodeBlockAt: 16r26 put: [:simulator | simulator currentContext pushLocal: 6; yourself]; 		"Push Local 7"
		bytecodeBlockAt: 16r27 put: [:simulator | simulator currentContext pushLocal: 7; yourself]; 		"Push Local 8"
		bytecodeBlockAt: 16r28 put: [:simulator | simulator currentContext pushLocal: 8; yourself]; 		"Push Local 9"
		bytecodeBlockAt: 16r29 put: [:simulator | simulator currentContext pushLocal: 9; yourself]; 		"Push Local 10"
		bytecodeBlockAt: 16r2A put: [:simulator | simulator currentContext pushLocal: 10; yourself]; 		"Push Local 11"
		bytecodeBlockAt: 16r2B put: [:simulator | simulator currentContext pushLocal: 11; yourself]; 		"Push Local 12"
		bytecodeBlockAt: 16r2C put: [:simulator | simulator currentContext pushLocal: 12; yourself]; 		"Push Local 13"
		bytecodeBlockAt: 16r2D put: [:simulator | simulator currentContext pushLocal: 13; yourself]; 		"Push Local 14"
		bytecodeBlockAt: 16r2E put: [:simulator | simulator currentContext pushLocal: 14; yourself]; 		"Push Local 15"
		bytecodeBlockAt: 16r2F put: [:simulator | simulator currentContext pushLocal: 15; yourself]; 		"Push Local 16"
		bytecodeBlockAt: 16r96 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextBytecode; yourself]; 		"Push Local"
		bytecodeBlockAt: 16r97 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Local Extended"

		bytecodeBlockAt: 16r98 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Push Local Indirect"
		bytecodeBlockAt: 16r99 put: [:simulator | simulator currentContext pushLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Push Local Indirect Extended"

		yourself

  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
setupBytecodeBlocks

	bytecodeBlocks := Array new: 256 withAll: [:simulator | self error: 'Unknown bytecode'].
	self
		pushInstVarBytecodes;
		storeInstVarBytecodes;
		pushLocalBytecodes;
		storeLocalBytecodes;
		pushGlobalBytecodes;
		storeGlobalBytecodes;
		pushIntegerBytecodes;
		pushLiteralBytecodes;
		callReturnBytecodes;
		jumpBytecodes;
		setupMiscBytecodes

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
setupMiscBytecodes

	self
		bytecodeBlockAt: 16r90 put: [:simulator | simulator currentContext push: true; yourself]; 		"Push true"
		bytecodeBlockAt: 16r91 put: [:simulator | simulator currentContext push: false; yourself]; 		"Push false"
		bytecodeBlockAt: 16r92 put: [:simulator | simulator currentContext push: nil; yourself]; 		"Push nil"
		bytecodeBlockAt: 16r93 put: [:simulator | simulator currentContext pushSelf; yourself]; 		"Push self"
		bytecodeBlockAt: 16rAC put: [:simulator | simulator currentContext pop; yourself]; 		"Pop"
		bytecodeBlockAt: 16rAD put: [:simulator | simulator currentContext dup; yourself]; 		"Dup"
		bytecodeBlockAt: 16rAE put: [:simulator | simulator currentContext dropCascadeReceiver; yourself]; 		"Drop Cascade Receiver"

		bytecodeBlockAt: 16rA1 put: [:simulator | simulator currentContext pushCopyingBlock: simulator currentContext nextBytecode copiedVariables: simulator currentContext nextBytecode; yourself]; 		"Push Copying Block"
		bytecodeBlockAt: 16rA2 put: [:simulator | simulator currentContext pushFullBlock: simulator currentContext nextBytecode copiedVariables: simulator currentContext nextBytecode; yourself]; 		"Push Full Block"
		bytecodeBlockAt: 16rAB put: [:simulator | simulator currentContext storeNewArray: simulator currentContext nextBytecode local: simulator currentContext nextBytecode; yourself]; 		"Store New Array"

		yourself

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
storeGlobalBytecodes

	self
		bytecodeBlockAt: 16r50 put: [:simulator | simulator currentContext storeGlobal: 0; yourself]; 		"store Global 0"
		bytecodeBlockAt: 16r51 put: [:simulator | simulator currentContext storeGlobal: 1; yourself]; 		"store Global 1"
		bytecodeBlockAt: 16r52 put: [:simulator | simulator currentContext storeGlobal: 2; yourself]; 		"store Global 2"
		bytecodeBlockAt: 16r53 put: [:simulator | simulator currentContext storeGlobal: 3; yourself]; 		"store Global 3"
		bytecodeBlockAt: 16r54 put: [:simulator | simulator currentContext storeGlobal: 4; yourself]; 		"store Global 4"
		bytecodeBlockAt: 16r55 put: [:simulator | simulator currentContext storeGlobal: 5; yourself]; 		"store Global 5"
		bytecodeBlockAt: 16r56 put: [:simulator | simulator currentContext storeGlobal: 6; yourself]; 		"store Global 6"
		bytecodeBlockAt: 16r57 put: [:simulator | simulator currentContext storeGlobal: 7; yourself]; 		"store Global 7"
		bytecodeBlockAt: 16r58 put: [:simulator | simulator currentContext storeGlobal: 8; yourself]; 		"store Global 8"
		bytecodeBlockAt: 16r59 put: [:simulator | simulator currentContext storeGlobal: 9; yourself]; 		"store Global 9"
		bytecodeBlockAt: 16r5A put: [:simulator | simulator currentContext storeGlobal: 10; yourself]; 		"store Global 10"
		bytecodeBlockAt: 16r5B put: [:simulator | simulator currentContext storeGlobal: 11; yourself]; 		"store Global 11"
		bytecodeBlockAt: 16r5C put: [:simulator | simulator currentContext storeGlobal: 12; yourself]; 		"store Global 12"
		bytecodeBlockAt: 16r5D put: [:simulator | simulator currentContext storeGlobal: 13; yourself]; 		"store Global 13"
		bytecodeBlockAt: 16r5E put: [:simulator | simulator currentContext storeGlobal: 14; yourself]; 		"store Global 14"
		bytecodeBlockAt: 16r5F put: [:simulator | simulator currentContext storeGlobal: 15; yourself]; 		"store Global 15"
		bytecodeBlockAt: 16rA9 put: [:simulator | simulator currentContext storeGlobal: simulator current nextBytecode; yourself]; 		"store Global"
		bytecodeBlockAt: 16rAA put: [:simulator | simulator currentContext storeGlobal: simulator current nextTwoBytecodes; yourself]; 		"store Global Extended"
		yourself

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
storeInstVarBytecodes

	self
		bytecodeBlockAt: 16r10 put: [:simulator | simulator currentContext storeInstVar: 0; yourself]; 		"Store Inst Var 0"
		bytecodeBlockAt: 16r11 put: [:simulator | simulator currentContext storeInstVar: 1; yourself]; 		"Store Inst Var 1"
		bytecodeBlockAt: 16r12 put: [:simulator | simulator currentContext storeInstVar: 2; yourself]; 		"Store Inst Var 2"
		bytecodeBlockAt: 16r13 put: [:simulator | simulator currentContext storeInstVar: 3; yourself]; 		"Store Inst Var 3"
		bytecodeBlockAt: 16r14 put: [:simulator | simulator currentContext storeInstVar: 4; yourself]; 		"Store Inst Var 4"
		bytecodeBlockAt: 16r15 put: [:simulator | simulator currentContext storeInstVar: 5; yourself]; 		"Store Inst Var 5"
		bytecodeBlockAt: 16r16 put: [:simulator | simulator currentContext storeInstVar: 6; yourself]; 		"Store Inst Var 6"
		bytecodeBlockAt: 16r17 put: [:simulator | simulator currentContext storeInstVar: 7; yourself]; 		"Store Inst Var 7"
		bytecodeBlockAt: 16r18 put: [:simulator | simulator currentContext storeInstVar: 8; yourself]; 		"Store Inst Var 8"
		bytecodeBlockAt: 16r19 put: [:simulator | simulator currentContext storeInstVar: 9; yourself]; 		"Store Inst Var 9"
		bytecodeBlockAt: 16r1A put: [:simulator | simulator currentContext storeInstVar: 10; yourself]; 		"Store Inst Var 10"
		bytecodeBlockAt: 16r1B put: [:simulator | simulator currentContext storeInstVar: 11; yourself]; 		"Store Inst Var 11"
		bytecodeBlockAt: 16r1C put: [:simulator | simulator currentContext storeInstVar: 12; yourself]; 		"Store Inst Var 12"
		bytecodeBlockAt: 16r1D put: [:simulator | simulator currentContext storeInstVar: 13; yourself]; 		"Store Inst Var 13"
		bytecodeBlockAt: 16r1E put: [:simulator | simulator currentContext storeInstVar: 14; yourself]; 		"Store Inst Var 14"
		bytecodeBlockAt: 16r1F put: [:simulator | simulator currentContext storeInstVar: 15; yourself]; 		"Store Inst Var 15"
		bytecodeBlockAt: 16rA3 put: [:simulator | simulator currentContext storeInstVar: simulator currentContext nextBytecode; yourself]; 		"Store Inst Var"
		bytecodeBlockAt: 16rA4 put: [:simulator | simulator currentContext storeInstVar: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Inst Var Extended"
		bytecodeBlockAt: 16rB9 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Store Local Indirect"
		bytecodeBlockAt: 16rBA put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Local Indirect Extended"
		yourself

  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'bytecodes'] value ! !
! CodeContext class methodsFor: 'bytecodes' !
storeLocalBytecodes

	self
		bytecodeBlockAt: 16r30 put: [:simulator | simulator currentContext storeLocal: 0; yourself]; 		"Store Local 0"
		bytecodeBlockAt: 16r31 put: [:simulator | simulator currentContext storeLocal: 1; yourself]; 		"Store Local 1"
		bytecodeBlockAt: 16r32 put: [:simulator | simulator currentContext storeLocal: 2; yourself]; 		"Store Local 2"
		bytecodeBlockAt: 16r33 put: [:simulator | simulator currentContext storeLocal: 3; yourself]; 		"Store Local 3"
		bytecodeBlockAt: 16r34 put: [:simulator | simulator currentContext storeLocal: 4; yourself]; 		"Store Local 4"
		bytecodeBlockAt: 16r35 put: [:simulator | simulator currentContext storeLocal: 5; yourself]; 		"Store Local 5"
		bytecodeBlockAt: 16r36 put: [:simulator | simulator currentContext storeLocal: 6; yourself]; 		"Store Local 6"
		bytecodeBlockAt: 16r37 put: [:simulator | simulator currentContext storeLocal: 7; yourself]; 		"Store Local 7"
		bytecodeBlockAt: 16r38 put: [:simulator | simulator currentContext storeLocal: 8; yourself]; 		"Store Local 8"
		bytecodeBlockAt: 16r39 put: [:simulator | simulator currentContext storeLocal: 9; yourself]; 		"Store Local 9"
		bytecodeBlockAt: 16r3A put: [:simulator | simulator currentContext storeLocal: 10; yourself]; 		"Store Local 10"
		bytecodeBlockAt: 16r3B put: [:simulator | simulator currentContext storeLocal: 11; yourself]; 		"Store Local 11"
		bytecodeBlockAt: 16r3C put: [:simulator | simulator currentContext storeLocal: 12; yourself]; 		"Store Local 12"
		bytecodeBlockAt: 16r3D put: [:simulator | simulator currentContext storeLocal: 13; yourself]; 		"Store Local 13"
		bytecodeBlockAt: 16r3E put: [:simulator | simulator currentContext storeLocal: 14; yourself]; 		"Store Local 14"
		bytecodeBlockAt: 16r3F put: [:simulator | simulator currentContext storeLocal: 15; yourself]; 		"Store Local 15"
		bytecodeBlockAt: 16rA5 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextBytecode; yourself]; 		"Store Local"
		bytecodeBlockAt: 16rA6 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Local Extended"


		bytecodeBlockAt: 16rA7 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextBytecode indirect: simulator currentContext nextBytecode; yourself]; 		"Store Local Indirect"
		bytecodeBlockAt: 16rA8 put: [:simulator | simulator currentContext storeLocal: simulator currentContext nextTwoBytecodes indirect: simulator currentContext nextTwoBytecodes; yourself]; 		"Store Local Indirect Extended"
		yourself

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeContext class methodsFor: 'instance creation'] value ! !
! CodeContext class methodsFor: 'instance creation' !
new

	^super new initialize
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
currentContext

	^currentContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
currentContext: aCodeContext

	currentContext := aCodeContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
frames

	^frames ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
frames: aCollection

	frames := aCollection.
	self currentContext: aCollection first
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
stopFrame

	^stopFrame ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
stopFrame: aCodeContext

	stopFrame := aCodeContext
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
stopMethod

	^stopMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'accessing'] value ! !
! CodeSimulator methodsFor: 'accessing' !
stopMethod: aCompiledMethod

	stopMethod := aCompiledMethod
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
blockReturn

	| returnValue |

	returnValue := currentContext pop.
	frames removeFirst.
	currentContext := frames first.
	currentContext push: returnValue
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
buildFrameFor: aCompiledMethod

	self frames addFirst: (currentContext := CodeContext new
		method: aCompiledMethod;
		frame: currentContext;
		contextId: currentContext contextId - self class headerSize;
		yourself).
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
call: literalNumber arguments: aNumber

	| selector compiledMethod receiver args |

	args := Array new: aNumber.

	selector := self currentContext method basicAt: literalNumber + 1.
	compiledMethod := self currentContext findCompiledMethod: selector startingAt: (self currentContext peek: aNumber) class.
	compiledMethod isNil ifTrue: [^self error: 'Message not understood'].

	compiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].
	compiledMethod numberOfTemporaries timesRepeat: [currentContext pop].

	aNumber to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.

	self invoke: compiledMethod on: receiver selector: selector arguments: args
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
callSelector: aSymbol arguments: aNumber

	| selector compiledMethod receiver args |

	args := Array new: aNumber.

	compiledMethod := self currentContext findCompiledMethod: aSymbol startingAt: (self currentContext peek: aNumber) class.

	compiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].
	compiledMethod numberOfTemporaries timesRepeat: [currentContext pop].

	aNumber to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.

	self invoke: compiledMethod on: receiver selector: aSymbol arguments: args
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
callWellKnown: aNumber

	| receiver selector args |

	selector := CodeGenerator specialSelectors at: aNumber + 1.

	args := Array new: selector numArgs.

	args size to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.
	(selector = #perform:withArguments:) ifTrue: [
		currentContext push: receiver.
		(args at: 2) do: [:each | currentContext push: each].
		self callSelector: args first arguments: args first numArgs.
		^self].

	currentContext push: (receiver perform: selector withArguments: args)
	
	
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
getMethodStartFrame

	| currentMethod |

	currentMethod := self currentContext rootMethod.

	self frames reverseDo: [:context |
		(context isBlockContext not and: [context method = currentMethod]) ifTrue: [
			^context]].

	^nil


 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
into

	| bytecode |
	self stopFrame: nil; stopMethod: nil.

	bytecode := currentContext nextBytecode.
	self runBytecode: bytecode.
	self runToImportantBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
invoke: aCompiledMethod on: receiver selector: aSymbol arguments: anArray

	(aCompiledMethod selector = #halt) ifTrue: [
		currentContext push: receiver.
		^self].

	aCompiledMethod isPrimitive ifTrue: [
		(aCompiledMethod mclass = BlockClosure and: [#(value value: value:value: value:withArguments:) includes: aCompiledMethod selector]) ifTrue: [
			^self invokeBlock: receiver method: aCompiledMethod arguments: anArray].
		^self currentContext push: (receiver perform: aSymbol withArguments: anArray)].

	aCompiledMethod isNil ifTrue: [^receiver doesNotUnderstand: aSymbol ].
	self buildFrameFor: aCompiledMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
invokeBlock: aBlockClosure method: aCompiledMethod arguments: anArray

	| previousStackOffset |

	"Simulate a call into the value... method"
	self frames addFirst: (currentContext := CodeContext new
		method: aCompiledMethod ;
		frame: currentContext;
		pcOffset: 3;
		contextId: currentContext contextId - self class headerSize;
		yourself).


	currentContext push: 0.

	previousStackOffset := currentContext stackOffset.

	currentContext push: aBlockClosure.

	anArray do: [:each | currentContext push: each].
	aBlockClosure copiedValues notNil ifTrue: [
		aBlockClosure copiedValues do: [:each | currentContext push: each]].

	aCompiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].

	currentContext stackOffset: previousStackOffset.

	self frames addFirst: (currentContext := CodeContext new
		method: aBlockClosure method;
		frame: currentContext;
		methodContext: aBlockClosure methodContext;
		contextId: currentContext contextId - self class headerSize;
		yourself).

	

  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
isImportantBytecode: aBytecode

	^#(call super callWellKnown return blockReturn nonLocalReturn primitive storeInstVar storeLocal storeGlobal storeLocalIndirect)
		includes: (CodeGenerator bytecodesByIndex at: aBytecode + 1) type ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
isReturnBytecode: aBytecode

	^#(return nonLocalReturn)
		includes: (CodeGenerator bytecodesByIndex at: aBytecode + 1) type ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
nonLocalReturn

	| returnValue stop |

	returnValue := currentContext pop.
	stop := false.

	frames detect: [:each | each contextId == currentContext methodContext] ifNone: [^self error: 'This block has already returned'].

	[frames notEmpty and: [frames first contextId ~~ currentContext methodContext]] whileTrue: [
		frames first method == self stopMethod ifTrue: [stop := true].
		frames removeFirst].

	currentContext := frames first.
	stop ifTrue: [
		self
			stopMethod: nil;
			stopFrame: nil].

	currentContext push: returnValue.
	self return
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
over

	| bytecode |
	self stopFrame: self currentContext; stopMethod: nil.
	(self isImportantBytecode: currentContext peekBytecode)
		ifTrue: [
			(self isReturnBytecode: currentContext peekBytecode)
				ifTrue: [self runBytecode: currentContext peekBytecode]
				ifFalse: [self runBytecodes]].
	self runToImportantBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
primitiveReturn

	| topOfStack result |

	topOfStack := currentContext pop.
	result := currentContext pop.

	result = 0
		ifTrue: [currentContext push: topOfStack. self return]
		ifFalse: [currentContext push: result]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
reinvokeMethod

	| startFrame receiver |

	startFrame := self getMethodStartFrame.
	receiver := startFrame receiver.

	self currentContext: startFrame.
	self returnToCurrentFrame.
	self currentContext method: (self currentContext method mclass compiledMethodAt: self currentContext method selector).
	self restart

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
restart

	self currentContext restart

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
return

	| returnValue |

	returnValue := currentContext pop.
	frames removeFirst.
	currentContext := frames first.
	currentContext push: returnValue
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
returnToCurrentFrame

	[frames first == self currentContext] whileFalse: [
		frames removeFirst].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
returnToFrame: aFrame

	[frames first == aFrame] whileFalse: [
		frames removeFirst].

	self currentContext: aFrame
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
runBytecode: bytecode

	(CodeContext bytecodeBlockAt: bytecode) value: self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
runBytecodes

	[
	self runBytecode: currentContext nextBytecode.
	self shouldContinueRunning] whileTrue: []

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
runToContext: aCodeContext

	self stopContext: aCodeContext; stopMethod: nil.
	self runBytecodes

 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
runToImportantBytecode

	| bytecode |
	[bytecode := currentContext peekBytecode.
	self isImportantBytecode: bytecode] whileFalse: [
		currentContext nextBytecode.
		self runBytecode: bytecode] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
shouldContinueRunning

	(self stopFrame isNil & self stopMethod isNil) ifTrue: [^false].
	(self stopFrame notNil and: [self currentContext == self stopFrame]) ifTrue: [^false].
	(self stopMethod notNil and: [self currentContext method rootMethod == self stopMethod]) ifTrue: [^false].
	^true


 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
stepBytecode

	| bytecode |
	self stopFrame: nil; stopMethod: nil.

	bytecode := currentContext nextBytecode.
	self runBytecode: bytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
superCall: literalNumber arguments: aNumber

	| selector compiledMethod  receiver args startingClass |

	args := Array new: aNumber.

	selector := self currentContext method basicAt: literalNumber + 1.
	compiledMethod := self currentContext findCompiledMethod: selector startingAt: (self currentContext peek: 0) superclass.

	compiledMethod numberOfTemporaries timesRepeat: [currentContext push: nil].
	compiledMethod numberOfTemporaries timesRepeat: [currentContext pop].

	startingClass := currentContext pop.

	aNumber to: 1 by: -1 do: [:i |
		args at: i put: currentContext pop].

	receiver := currentContext pop.

	self invoke: compiledMethod on: receiver selector: selector arguments: args
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator methodsFor: 'simulating'] value ! !
! CodeSimulator methodsFor: 'simulating' !
through

	| bytecode |
	self stopFrame: nil; stopMethod: self currentContext method rootMethod.

	(self isImportantBytecode: currentContext peekBytecode)
		ifTrue: [
			(self isReturnBytecode: currentContext peekBytecode)
				ifTrue: [self runBytecode: currentContext peekBytecode]
				ifFalse: [self runBytecodes]].
	self runToImportantBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeSimulator class methodsFor: 'accessing'] value ! !
! CodeSimulator class methodsFor: 'accessing' !
headerSize

	^40 ! !
! Doit class methodsFor: 'doit' !
doit ^[CommandHandler methodsFor: 'processing'] value ! !
! CommandHandler methodsFor: 'processing' !
processMessage: aMessage onWebSocket: aWebSocket

	| commandStream command |

	commandStream := (aMessage isString ifTrue: [aMessage] ifFalse: [aMessage message]) readStream.
	command := commandStream upTo: Character space.

	command = 'printit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult printString.
		^true].
	command = 'storeit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult storeString.
		^true].
	command = 'doit' ifTrue: [
		SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '"Done"'.
		^true].
	command = 'filein' ifTrue: [
		commandStream upToEnd readStream fileIn.
		aWebSocket send: '"Done"'.
		^true].
	command = 'showstring' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult.
		^true].
	command = 'close' ifTrue: [
		aWebSocket close.
		^false].
	command = 'shutdown' ifTrue: [
		BeagleSystem shutdown.
		^false].
	command = 'renderit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '~', evaluateResult.
		^true].
	command = 'keydown' ifTrue: [
		aWebSocket send: 'Key: ', commandStream upToEnd.
		^true].
	command = 'mouseMove' ifTrue: [
		aWebSocket send: 'MouseMove: ', commandStream upToEnd.
		^true].
	command = 'mouseDown' ifTrue: [
		aWebSocket send: 'MouseDown: ', commandStream upToEnd.
		^true].
	command = 'mouseUp' ifTrue: [
		aWebSocket send: 'MouseUp: ', commandStream upToEnd.
		^true].
	command = 'wheel' ifTrue: [
		aWebSocket send: 'Wheel: ', commandStream upToEnd.
		^true].
	command = 'evaluateJSON' ifTrue: [
		JSONParser evaluateJsonString: commandStream upToEnd.
		^true].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileError methodsFor: 'accessing'] value ! !
! CompileError methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset ifNil: [-1] ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileError methodsFor: 'accessing'] value ! !
! CompileError methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileError methodsFor: 'accessing'] value ! !
! CompileError methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileError methodsFor: 'accessing'] value ! !
! CompileError methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileWarning methodsFor: 'accessing'] value ! !
! CompileWarning methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileWarning methodsFor: 'accessing'] value ! !
! CompileWarning methodsFor: 'accessing' !
endSourceOffset: aNumber

	endSourceOffset := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileWarning methodsFor: 'accessing'] value ! !
! CompileWarning methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[CompileWarning methodsFor: 'accessing'] value ! !
! CompileWarning methodsFor: 'accessing' !
startSourceOffset: aNumber

	startSourceOffset := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream methodsFor: 'accessing'] value ! !
! DecompileStream methodsFor: 'accessing' !
byteStream

	^byteStream ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream methodsFor: 'accessing'] value ! !
! DecompileStream methodsFor: 'accessing' !
byteStream: aStream

	byteStream := aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream methodsFor: 'accessing'] value ! !
! DecompileStream methodsFor: 'accessing' !
compiledCode

	^compiledCode ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream methodsFor: 'accessing'] value ! !
! DecompileStream methodsFor: 'accessing' !
compiledCode: aStream

	compiledCode := aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream methodsFor: 'reading'] value ! !
! DecompileStream methodsFor: 'reading' !
atEnd

	^byteStream atEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream methodsFor: 'reading'] value ! !
! DecompileStream methodsFor: 'reading' !
next

	| bytecode position bytecodeSpec additionalBytes |

	self atEnd ifTrue: [^nil].

	position := byteStream position.
	bytecode := byteStream next.
	bytecodeSpec := (CodeGenerator bytecodesByIndex at: bytecode + 1).
	additionalBytes := byteStream nextAvailable: bytecodeSpec numberOfBytes - 1.

	^Array with: position with: bytecode with: bytecodeSpec with: additionalBytes ! !
! Doit class methodsFor: 'doit' !
doit ^[DecompileStream class methodsFor: 'instance creation'] value ! !
! DecompileStream class methodsFor: 'instance creation' !
on: aCompiledCode

	^self new
		compiledCode: aCompiledCode;
		byteStream: aCompiledCode bytecodes readStream;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
finishLine

	| string |
	string := (WriteStream on: String new)
				nextPutAll: offsetStream contents;
				nextPutAll: ':   ';
				nextPutAll: formattedBytecodeStream contents;
				nextPutAll: (String new: (25 - formattedBytecodeStream contents size) // 4
							withAll: Character tab);
				nextPutAll: decompiledCodeStream contents;
				contents.

	self resetLineStreams.

	resultStream nextPutAll: string; cr ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
finishLineNoBytes

	| string |
	string := (WriteStream on: String new)
				nextPutAll: offsetStream contents;
				nextPutAll: ':   ';
				nextPutAll: decompiledCodeStream contents;
				contents.

	self resetLineStreams.

	resultStream nextPutAll: string; cr ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
literals

	^literals ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
literals: anObject

	literals := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
numberOfArguments

	^numberOfArguments ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
numberOfArguments: anObject

	numberOfArguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
numberOfCopiedVariables

	^numberOfCopiedVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
numberOfCopiedVariables: anObject

	numberOfCopiedVariables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
numberOfTemporaries

	^numberOfTemporaries ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
numberOfTemporaries: anObject

	numberOfTemporaries := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
resetLineStreams

	offsetStream := WriteStream on: String new.
	formattedBytecodeStream := WriteStream on: String new.
	decompiledCodeStream := WriteStream on: String new ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
result

	^resultStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
targetClass

	^targetClass ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'accessing'] value ! !
! Decompiler methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompile

	self writeHeader.
	[byteStream atEnd] whileFalse: 
			[self decompileNextBytecode.
				self finishLine]. ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompile: aByteArray

	byteStream := aByteArray readStream.
	self resetLineStreams.

	self decompile.
	^self result ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompileNextBytecode

	| byte byteString stream |
	self writeOffset.
	byte := self writeNextBytecode.

	byteString := (CodeGenerator bytecodesByIndex at: byte + 1) decompileString.

	stream := byteString readStream.

	[stream atEnd] whileFalse: [
		| character |
		character := stream next.
		character = $%
			ifTrue: [self readEscapeSequenceFrom: stream]
			ifFalse: [decompiledCodeStream nextPut: character] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompileNoBytes

	self writeHeader.
	[byteStream atEnd] whileFalse: 
			[self decompileNextBytecode.
				self finishLineNoBytes]. ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompileNoBytes: aByteArray

	byteStream := aByteArray readStream.
	self resetLineStreams.

	self decompileNoBytes.
	^self result ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompileSingleBytecode

	self decompileNextBytecode.
	self finishLine  ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
decompileSingleBytecodeFrom: aByteArray startingAt: offset

	byteStream := aByteArray readStream.
	byteStream position: offset.
	self resetLineStreams.

	self decompileSingleBytecode.
	^self result  ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
readEscapeSequenceFrom: aStream

	| number character |

	number := Integer readFrom: aStream.

	character := aStream next.
	character = $b ifTrue: [
		| integer |
		integer := 0.
		number = 0 ifTrue: [number := 1].
		number timesRepeat: [integer := integer * 256 + self writeNextBytecode].
		integer >= (2 raisedToInteger: ((number * 8) - 1)) ifTrue: [
			integer := integer - (2 raisedToInteger: (number * 8))].
		number := integer.
		character := aStream next].

	character = $u ifTrue: [
		| integer |
		integer := 0.
		number = 0 ifTrue: [number := 1].
		number timesRepeat: [integer := integer * 256 + self writeNextBytecode].
		number := integer.
		character := aStream next].

	character = $I ifTrue: [decompiledCodeStream nextPutAll: number printString].
	character = $i ifTrue: [decompiledCodeStream nextPutAll: (targetClass allInstVarNames at: number + 1)].
	character = $l ifTrue: [decompiledCodeStream nextPutAll: ' literal ', number printString, ' '; nextPutAll: (literals at: number + 1) printString].
	character = $g ifTrue: [
		| assoc |
		assoc := (literals at: number + 1).
		decompiledCodeStream nextPutAll: ' literal ', number printString, ' ', (assoc isNil ifTrue: ['<undeclared>'] ifFalse: [assoc key]) printString].
	character = $o ifTrue: [decompiledCodeStream nextPutAll: '16r', ((byteStream position + number) printStringRadix: 16)].
	character = $t ifTrue: [decompiledCodeStream nextPutAll: 't', number printString].
	character = $L ifTrue: [decompiledCodeStream nextPutAll: 't', (number // 65536) printString, '_', (number \\ 65536 // 256) printString, '_', (number \\ 256) printString].
	character = $w ifTrue: [decompiledCodeStream nextPutAll: number printString, ' #', (CodeGenerator specialSelectors at: number + 1)]. ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
writeHeader

	resultStream
		nextPutAll: 'Args: ';
		print: self numberOfArguments;
		nextPutAll: ' Temporaries: ';
		print: self numberOfTemporaries;
		nextPutAll: ' Copied: ';
		print: self numberOfCopiedVariables;
		cr ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
writeNextBytecode

	| byte |

	byte := byteStream next.
	byte
		printOn: formattedBytecodeStream
		paddedWith: $0
		to: 2
		base: 16.
	formattedBytecodeStream space.
	^byte ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'decompiling'] value ! !
! Decompiler methodsFor: 'decompiling' !
writeOffset

	byteStream position
		printOn: offsetStream
		paddedWith: Character space
		to: 3
		base: 16 ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler methodsFor: 'initialize-release'] value ! !
! Decompiler methodsFor: 'initialize-release' !
initialize

	self resetLineStreams.
	resultStream := WriteStream on: (String new: 100). ! !
! Doit class methodsFor: 'doit' !
doit ^[Decompiler class methodsFor: 'instance creation'] value ! !
! Decompiler class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[DevelopmentCommandHandler methodsFor: 'handling'] value ! !
! DevelopmentCommandHandler methodsFor: 'handling' !
processMessage: aMessage onWebSocket: aWebSocket

	| commandStream command |

	commandStream := (aMessage isString ifTrue: [aMessage] ifFalse: [aMessage message]) readStream.
	command := commandStream upTo: Character space.

	command = 'printit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult printString.
		^true].
	command = 'storeit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult storeString.
		^true].
	command = 'doit' ifTrue: [
		SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '"Done"'.
		^true].
	command = 'filein' ifTrue: [
		commandStream upToEnd readStream fileIn.
		aWebSocket send: '"Done"'.
		^true].
	command = 'showstring' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: evaluateResult asString.
		^true].
	command = 'close' ifTrue: [
		aWebSocket close.
		^false].
	command = 'shutdown' ifTrue: [
		BeagleSystem shutdown.
		^false].
	command = 'renderit' ifTrue: [
		| evaluateResult |
		evaluateResult := SmalltalkParser evaluate: commandStream upToEnd.
		aWebSocket send: '~', evaluateResult.
		^true].
	command = 'keydown' ifTrue: [
		aWebSocket send: 'Key: ', commandStream upToEnd.
		^true].
	command = 'mouseMove' ifTrue: [
		aWebSocket send: 'MouseMove: ', commandStream upToEnd.
		^true].
	command = 'mouseDown' ifTrue: [
		aWebSocket send: 'MouseDown: ', commandStream upToEnd.
		^true].
	command = 'mouseUp' ifTrue: [
		aWebSocket send: 'MouseUp: ', commandStream upToEnd.
		^true].
	command = 'wheel' ifTrue: [
		aWebSocket send: 'Wheel: ', commandStream upToEnd.
		^true].
	command = 'evaluateJSON' ifTrue: [
		JSONParser evaluateJsonString: commandStream upToEnd.
		^true]. ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
captureCharacter: aCharacter

	quoting ifTrue: [chunkStream nextPut: aCharacter. quoting := false. ^true].
	
	readingString ifTrue: [
		aCharacter = $'
			ifTrue: [
				(stream atEnd not and: [stream peek = $'])
					ifTrue: [chunkStream nextPut: $'; nextPut: $'. stream next. ^true].
				chunkStream nextPut: $'. readingString := false. ^true].
			chunkStream nextPut: aCharacter.
			^true].

	readingComment ifTrue: [
		aCharacter = $"
			ifTrue: [
				(stream atEnd not and: [stream peek = $"])
					ifTrue: [chunkStream nextPut: $"; nextPut: $". stream next. ^true].
				chunkStream nextPut: $". readingComment := false. ^true].
			chunkStream nextPut: aCharacter.
			^true].

	aCharacter = $' ifTrue: [
		chunkStream nextPut: $'.
		readingString := true.
		^true].

	aCharacter = $" ifTrue: [
		chunkStream nextPut: $".
		readingComment := true.
		^true].

	aCharacter = $$ ifTrue: [
		chunkStream nextPut: $$.
		quoting := true.
		^true].

	aCharacter = $! ifTrue: [
		(stream atEnd not and: [stream peek = $!])
			ifTrue: [chunkStream nextPut: $!; nextPut: $!. stream next. ^true].
		^false].

	chunkStream nextPut: aCharacter.
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
fileIn
	| result |
	
	[stream atEnd] whileFalse: [
		result := self fileInChunk].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
fileInChunk

	| chunk result |

	chunk := self readChunk.
	chunk isEmpty ifTrue: [
		precedingEmptyChunk := true.
		^self].

	precedingEmptyChunk ifFalse: [
		^self runDoit: chunk].

	result := (self runDoit: chunk)
		fileInFrom: stream.

	precedingEmptyChunk := false.
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
readChunk

	| continue |

	chunkStream := WriteStream on: (String new: 10).
	readingString := false.
	readingComment := false.
	quoting := false.
	continue := true.

	[stream atEnd not and: [stream peek isSeparator]] whileTrue: [stream next].

	[stream atEnd or: [continue not]] whileFalse: [
		continue := self captureCharacter: stream next].

	^chunkStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
runDoit: aString

	| trimmedString |

	trimmedString := aString trimSeparators.
	trimmedString isEmpty ifTrue: [
		precedingEmptyChunk := true.
		^self].
	precedingEmptyChunk := false.
	^SmalltalkParser evaluate: trimmedString ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
stream

	^stream ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader methodsFor: 'accessing'] value ! !
! FileinReader methodsFor: 'accessing' !
stream: anObject

	stream := anObject.
	precedingEmptyChunk := false ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader class methodsFor: 'instance creation'] value ! !
! FileinReader class methodsFor: 'instance creation' !
fileIn: aStream

	^(self on: aStream) fileIn ! !
! Doit class methodsFor: 'doit' !
doit ^[FileinReader class methodsFor: 'instance creation'] value ! !
! FileinReader class methodsFor: 'instance creation' !
on: aStream

	^self new
		stream: aStream;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassFileinReader methodsFor: 'accessing'] value ! !
! ClassFileinReader methodsFor: 'accessing' !
fileInFrom: aStream

	| chunk method |

	stream := aStream.
	[chunk := self readChunk.
	chunk isEmpty] whileFalse: [

		method := SmalltalkParser
			generateForClass: targetClass
			globals: targetClass globalDictionaries
			methodString: chunk
			organization: self organization
			writeChangesInto: BeagleSystem changesFile.
		
		(method isKindOf: String) ifTrue: [
			^self error: method].

		targetClass methodDictionary at: method selector put: method.
		targetClass organizationAt: self organization add: method selector].

	^method ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassFileinReader methodsFor: 'accessing'] value ! !
! ClassFileinReader methodsFor: 'accessing' !
fixLineEndConventionsIn: aString
	| inStream outStream lfReceived crReceived char cr lf |
	lfReceived := false.
	crReceived := false.
	inStream := aString readStream.
	cr := Character cr.
	lf := Character lf.
	
	outStream := WriteStream on: (String new: aString size).
	
	[inStream atEnd] whileFalse: [
		char := inStream next.
		char = cr
			ifTrue: [lfReceived ifTrue: [lfReceived := false. outStream nextPut: cr] ifFalse: [crReceived := true]]
			ifFalse: [char = lf
				ifTrue: [crReceived ifTrue: [crReceived := false. outStream nextPut: cr] ifFalse: [lfReceived := true]]
				ifFalse: [
					crReceived | lfReceived ifTrue: [outStream nextPut: cr].
					crReceived := false.
					lfReceived := false.
					outStream nextPut: char]]].

	^outStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassFileinReader methodsFor: 'accessing'] value ! !
! ClassFileinReader methodsFor: 'accessing' !
organization

	^organization ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassFileinReader methodsFor: 'accessing'] value ! !
! ClassFileinReader methodsFor: 'accessing' !
organization: anObject

	organization := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassFileinReader methodsFor: 'accessing'] value ! !
! ClassFileinReader methodsFor: 'accessing' !
targetClass

	^targetClass ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassFileinReader methodsFor: 'accessing'] value ! !
! ClassFileinReader methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'accessing'] value ! !
! IndirectVariableList methodsFor: 'accessing' !
variables

	^variables ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'accessing'] value ! !
! IndirectVariableList methodsFor: 'accessing' !
variables: anObject

	variables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'initialize-release'] value ! !
! IndirectVariableList methodsFor: 'initialize-release' !
initialize

	variables := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'printing'] value ! !
! IndirectVariableList methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' variables: '.
	self variables do: [:each | each printOn: aStream. aStream space] ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'testing'] value ! !
! IndirectVariableList methodsFor: 'testing' !
isIndirectList

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'testing'] value ! !
! IndirectVariableList methodsFor: 'testing' !
isIndirectVariableList

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'testing'] value ! !
! IndirectVariableList methodsFor: 'testing' !
isReturnContext

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList methodsFor: 'testing'] value ! !
! IndirectVariableList methodsFor: 'testing' !
isSelf

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[IndirectVariableList class methodsFor: 'instance creation'] value ! !
! IndirectVariableList class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
next2

	^next2 ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
next2: anObject

	next2 := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
next: anObject

	next := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
position

	^position ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
position: anObject

	position := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
stream

	^stream ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'accessing'] value ! !
! LexicalAnalyzer methodsFor: 'accessing' !
stream: anObject

	stream := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'api'] value ! !
! LexicalAnalyzer methodsFor: 'api' !
tokens

	| token |
	tokens := OrderedCollection new.
	self start.
	[(token := self nextToken) notNil] whileTrue: [tokens add: token].
	^tokens ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'errors'] value ! !
! LexicalAnalyzer methodsFor: 'errors' !
reportError: aString start: start end: end

	^(CompileError new)
		message: aString;
		startSourceOffset: start;
		endSourceOffset: end;
		raiseSignal ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
advance

	next := next2.
	stream atEnd
		ifTrue: [
			next = self finishedCharacter ifFalse: [
				position := position + 1].
			next2 := self finishedCharacter]
		ifFalse: [
			next2 := stream next.
			position := position + 1]. ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
captureOffsetsIn: parseBlock creating: createBlock

	startSourceOffset := self position.
	parseBlock value.
	endSourceOffset := self next = self finishedCharacter
				ifTrue: [self position]
				ifFalse: [self position - 1].
	^(createBlock value)
		startSourceOffset: startSourceOffset;
		endSourceOffset: endSourceOffset;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
finishedCharacter

	^Character value: 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
next

	^next ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
nextCharacter

	stream atEnd ifTrue: [^self finishedCharacter].
	^stream next ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
nextToken

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
skipComment

	 ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
skipSeparator

	self subclassResponsibility ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
skipSeparators

	[self skipSeparator] whileTrue: [] ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'parsing'] value ! !
! LexicalAnalyzer methodsFor: 'parsing' !
start
	position := stream position.
	next := self nextCharacter.
	next2 := self nextCharacter ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer methodsFor: 'testing'] value ! !
! LexicalAnalyzer methodsFor: 'testing' !
isDigit: aCharacter radix: aNumber

	^aCharacter digitValue between: 0 and: aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LexicalAnalyzer class methodsFor: 'instance creation'] value ! !
! LexicalAnalyzer class methodsFor: 'instance creation' !
on: aStream

	^self new
		stream: aStream;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
nextToken

	self skipSeparators.
	self next = self finishedCharacter ifTrue: [^nil].
	self next isAlphabetic ifTrue: [^self parseWord].
	(self next isDigit or: [self next = $- and: [self next2 isDigit]])
		ifTrue: [^self parseNumber].
	self next = $, ifTrue: [^self parseComma].
	self next = $: ifTrue: [^self parseColon].
	self next = $[ ifTrue: [^self parseOpenSquareBracket].
	self next = $] ifTrue: [^self parseCloseSquareBracket].
	self next = ${ ifTrue: [^self parseOpenBrace].
	self next = $} ifTrue: [^self parseCloseBrace].
	self next = $" ifTrue: [^self parseStringLiteral].
	self log: 'nextToken: ', self next printString, self next2 printString, ' position: ', stream position printString.
	^self reportError: 'Unknown token' start: self position end: self position ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseCloseBrace

	^self captureOffsetsIn: [self advance]
		creating: [CloseBraceToken new value: $}] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseCloseSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [CloseSquareBracketToken new value: $]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseColon

	^self captureOffsetsIn: [self advance]
		creating: [ColonToken new value: $:] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseComma

	^self captureOffsetsIn: [self advance]
		creating: [CommaToken new value: $,] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseNumber

	| number |
	^self captureOffsetsIn: [number := self readNumber]
		creating: 
			[(number isInteger ifTrue: [IntegerToken new] ifFalse: [FloatToken new])
				value: number;
				yourself] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseOpenBrace

	^self captureOffsetsIn: [self advance]
		creating: [OpenBraceToken new value: ${] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseOpenSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [OpenSquareBracketToken new value: $[] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseStringLiteral

	| string |
	^self captureOffsetsIn: 
			[string := self readStringLiteral.
			string isNil
				ifTrue: 
					[self reportError: 'Missing end quote' start: self startSourceOffset end: self position]]
		creating: [StringToken new value: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
parseWord

	| word |
	^self captureOffsetsIn: [word := self readWord]
		creating: [self wordTokenFor: word] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
readAlphaNumericWord

	| wordStream |
	wordStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^wordStream contents].
	self next isAlphaNumeric or: [self next = $_]]
			whileTrue: 
				[wordStream nextPut: self next.
				self advance].
	^wordStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
skipSeparator

	self next = self finishedCharacter ifTrue: [^false].
	self next isSeparator ifTrue: [self advance. ^true].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'parsing'] value ! !
! JSONLexicalAnalyzer methodsFor: 'parsing' !
wordTokenFor: word

	word = 'null' ifTrue: [^SpecialWordToken new value: 'null'].
	word = 'true' ifTrue: [^SpecialWordToken new value: 'true'].
	word = 'false' ifTrue: [^SpecialWordToken new value: 'false'].
	^WordToken new value: word ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readDecimalPart: integerPart

	| value factor |
	factor := 0.1.
	value := integerPart asFloat.
	[self next isDigit] whileTrue: 
			[value := value positive
						ifTrue: [value + (self next digitValue * factor)]
						ifFalse: [value - (self next digitValue * factor)].
			factor := factor / 10.0.
			self advance].
	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readExponent

	| value |
	value := 0.
	[self next isDigit] whileTrue: 
			[value := value * 10 + self next digitValue.
			self advance].
	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readFloatStartingWith: aNumber

	| value |
	value := aNumber asFloat.
	(self next = $. and: [self next2 isDigit])
		ifTrue: 
			[self advance.
			value := self readDecimalPart: aNumber].
	self next asLowercase = $e ifFalse: [^value].
	self advance.
	^value asFloat * (10 ** self readExponent) ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readInteger

	| number sign |
	number := 0.
	sign := 1.
	self next = $-
		ifTrue: 
			[sign := -1.
			self advance].
	[self next isDigit] whileTrue: 
			[number := number * 10 + self next digitValue.
			self advance].
	^sign * number ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readNumber

	| number |
	number := self readInteger.
	self next = self finishedCharacter ifTrue: [^number].
	((self next = $. and: [self next2 isDigit]) or: [self next asLowercase = $e])
		ifTrue: [^self readFloatStartingWith: number].
	^number ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readStringLiteral

	| literalStream |
	self advance.
	literalStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^nil].
	self next = $"]
			whileFalse: 
				[self next = $\
					ifTrue: [self readStringQuotedCharacterInto: literalStream]
					ifFalse: [literalStream nextPut: self next].
				self advance].
	self advance.
	^literalStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readStringQuotedCharacterInto: aStream

	self advance.
	self next = $" ifTrue: [^aStream nextPut: $"].
	self next = $\ ifTrue: [^aStream nextPut: $\].
	self next = $/ ifTrue: [^aStream nextPut: $/].
	self next = $b ifTrue: [^aStream nextPut: Character backspace].
	self next = $f ifTrue: [^aStream nextPut: Character newPage].
	self next = $r ifTrue: [^aStream nextPut: Character cr].
	self next = $n ifTrue: [^aStream nextPut: Character lf].
	self next = $t ifTrue: [^aStream nextPut: Character tab].
	self error: 'Illegal quoted character' ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONLexicalAnalyzer methodsFor: 'reading'] value ! !
! JSONLexicalAnalyzer methodsFor: 'reading' !
readWord

	| wordStream |
	wordStream := WriteStream on: (String new: 100).
	wordStream nextPutAll: self readAlphaNumericWord.
	^wordStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'accessing'] value ! !
! ParseTreeNode methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'accessing'] value ! !
! ParseTreeNode methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'accessing'] value ! !
! ParseTreeNode methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'accessing'] value ! !
! ParseTreeNode methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isBinaryHeaderNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isBinaryMessageNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isBlockLiteralNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isBlockNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isBlockParameterListNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isCascadeNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isKeywordHeaderNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isKeywordMessageNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isLiteralNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isMethodNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isParenthesisNode

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'testing'] value ! !
! ParseTreeNode methodsFor: 'testing' !
isSequence

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode methodsFor: 'visiting'] value ! !
! ParseTreeNode methodsFor: 'visiting' !
acceptVisitor: aVisitor ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeNode class methodsFor: 'instance creation'] value ! !
! ParseTreeNode class methodsFor: 'instance creation' !
on: anObject

	^self new
		value: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode methodsFor: 'accessing'] value ! !
! BinaryHeaderNode methodsFor: 'accessing' !
argument

	^argument ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode methodsFor: 'accessing'] value ! !
! BinaryHeaderNode methodsFor: 'accessing' !
argument: anObject

	argument := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode methodsFor: 'accessing'] value ! !
! BinaryHeaderNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode methodsFor: 'accessing'] value ! !
! BinaryHeaderNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode methodsFor: 'testing'] value ! !
! BinaryHeaderNode methodsFor: 'testing' !
isBinaryHeaderNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode methodsFor: 'visiting'] value ! !
! BinaryHeaderNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBinaryHeader: self ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryHeaderNode class methodsFor: 'instance creation'] value ! !
! BinaryHeaderNode class methodsFor: 'instance creation' !
selector: selectorToken argument: argument

	^self new
		selector: selectorToken;
		argument: argument;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
argument

	^argument ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
argument: anObject

	argument := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
arguments

	^Array with: self argument ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
receiver

	^receiver ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'accessing'] value ! !
! BinaryMessageNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'testing'] value ! !
! BinaryMessageNode methodsFor: 'testing' !
isBinaryMessageNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode methodsFor: 'visiting'] value ! !
! BinaryMessageNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitMessageNodeStart: self.
	self receiver ifNotNil: [self receiver acceptVisitor: anObject].
	self argument acceptVisitor: anObject.
	anObject visitMessageNodeEnd: self ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode class methodsFor: 'instance creation'] value ! !
! BinaryMessageNode class methodsFor: 'instance creation' !
receiver: receiver selector: selector argument: argument

	^self new
		receiver: receiver;
		selector: selector;
		argument: argument;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode class methodsFor: 'instance creation'] value ! !
! BinaryMessageNode class methodsFor: 'instance creation' !
receiver: receiver selector: selector argument: argument startSourceOffset: sourceOffset endSourceOffset: endOffset

	^self new
		receiver: receiver;
		selector: selector;
		argument: argument;
		startSourceOffset: sourceOffset;
		endSourceOffset: endOffset;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[BinaryMessageNode class methodsFor: 'instance creation'] value ! !
! BinaryMessageNode class methodsFor: 'instance creation' !
selector: selector argument: argument

	^self new
		selector: selector;
		argument: argument;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
addVariableAssignment: aVariable

	scope addVariable: aVariable. ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
addVariableReference: aVariable

	scope addVariable: aVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
arguments

	^arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
hasReturn

	^hasReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
hasReturn: anObject

	hasReturn := anObject.
	self parent ifNotNil: [:aBlockNode | aBlockNode hasReturn: anObject] ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
parent

	^parent ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
parent: anObject

	parent := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
scope

	^scope ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
scope: anObject

	scope := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
statements

	^statements ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'accessing'] value ! !
! BlockNode methodsFor: 'accessing' !
statements: anObject

	statements := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'testing'] value ! !
! BlockNode methodsFor: 'testing' !
isBlockNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockNode methodsFor: 'visiting'] value ! !
! BlockNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBlockNodeStart: self.
	self arguments ifNotNil: [self arguments acceptVisitor: anObject].
	self statements
		ifNil: [anObject visitEmptyStatements]
		ifNotNil: [self statements acceptVisitor: anObject].

	anObject visitBlockNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockParameterListNode methodsFor: 'accessing'] value ! !
! BlockParameterListNode methodsFor: 'accessing' !
variables

	^variables ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockParameterListNode methodsFor: 'accessing'] value ! !
! BlockParameterListNode methodsFor: 'accessing' !
variables: anObject

	variables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockParameterListNode methodsFor: 'testing'] value ! !
! BlockParameterListNode methodsFor: 'testing' !
isBlockParameterListNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockParameterListNode methodsFor: 'visiting'] value ! !
! BlockParameterListNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBlockParameterListNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode methodsFor: 'accessing'] value ! !
! CascadeNode methodsFor: 'accessing' !
messages

	^messages ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode methodsFor: 'accessing'] value ! !
! CascadeNode methodsFor: 'accessing' !
messages: anObject

	messages := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode methodsFor: 'accessing'] value ! !
! CascadeNode methodsFor: 'accessing' !
receiver

	^receiver ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode methodsFor: 'accessing'] value ! !
! CascadeNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode methodsFor: 'testing'] value ! !
! CascadeNode methodsFor: 'testing' !
isCascadeNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode methodsFor: 'visiting'] value ! !
! CascadeNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self receiver acceptVisitor: anObject.
	anObject visitCascadeStart: self.

	self messages
		do: [:eachMessage | eachMessage acceptVisitor: anObject]
		separatedBy: [anObject visitCascadeInterMessage: self].

	anObject visitCascadeEnd: self ! !
! Doit class methodsFor: 'doit' !
doit ^[CascadeNode class methodsFor: 'instance creation'] value ! !
! CascadeNode class methodsFor: 'instance creation' !
receiver: receiver messages: messages

	^self new
		receiver: receiver;
		messages: messages;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! GlobalVariableAssignmentNode methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! GlobalVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! GlobalVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! GlobalVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableAssignmentNode methodsFor: 'visiting'] value ! !
! GlobalVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitGlobalVariableAssignmentNode: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableAssignmentNode class methodsFor: 'instance creation'] value ! !
! GlobalVariableAssignmentNode class methodsFor: 'instance creation' !
variable: variable value: value

	^self new
		variable: variable;
		value: value;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableReferenceNode methodsFor: 'accessing'] value ! !
! GlobalVariableReferenceNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableReferenceNode methodsFor: 'accessing'] value ! !
! GlobalVariableReferenceNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableReferenceNode methodsFor: 'visiting'] value ! !
! GlobalVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitGlobalVariableReferenceNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariableReferenceNode class methodsFor: 'instance creation'] value ! !
! GlobalVariableReferenceNode class methodsFor: 'instance creation' !
variable: aToken

	^self new
		variable: aToken;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! InstanceVariableAssignmentNode methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! InstanceVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! InstanceVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! InstanceVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableAssignmentNode methodsFor: 'visiting'] value ! !
! InstanceVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitInstanceVariableAssignmentNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableAssignmentNode class methodsFor: 'instance creation'] value ! !
! InstanceVariableAssignmentNode class methodsFor: 'instance creation' !
variable: variable value: value

	^self new
		variable: variable;
		value: value;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableReferenceNode methodsFor: 'accessing'] value ! !
! InstanceVariableReferenceNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableReferenceNode methodsFor: 'accessing'] value ! !
! InstanceVariableReferenceNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableReferenceNode methodsFor: 'visiting'] value ! !
! InstanceVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitInstanceVariableReferenceNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariableReferenceNode class methodsFor: 'instance creation'] value ! !
! InstanceVariableReferenceNode class methodsFor: 'instance creation' !
variable: aToken

	^self new
		variable: aToken;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode methodsFor: 'accessing'] value ! !
! KeywordHeaderNode methodsFor: 'accessing' !
arguments

	^arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode methodsFor: 'accessing'] value ! !
! KeywordHeaderNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode methodsFor: 'accessing'] value ! !
! KeywordHeaderNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode methodsFor: 'accessing'] value ! !
! KeywordHeaderNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode methodsFor: 'testing'] value ! !
! KeywordHeaderNode methodsFor: 'testing' !
isKeywordHeaderNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode methodsFor: 'visiting'] value ! !
! KeywordHeaderNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitKeywordHeader: self ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordHeaderNode class methodsFor: 'instance creation'] value ! !
! KeywordHeaderNode class methodsFor: 'instance creation' !
selector: selector arguments: arguments

	^self new
		selector: selector;
		arguments: arguments;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'accessing'] value ! !
! KeywordMessageNode methodsFor: 'accessing' !
arguments

	^arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'accessing'] value ! !
! KeywordMessageNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'accessing'] value ! !
! KeywordMessageNode methodsFor: 'accessing' !
receiver

	^receiver ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'accessing'] value ! !
! KeywordMessageNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'accessing'] value ! !
! KeywordMessageNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'accessing'] value ! !
! KeywordMessageNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'testing'] value ! !
! KeywordMessageNode methodsFor: 'testing' !
isInlinedSelector: aSymbol

	(aSymbol = #ifTrue: and: [self arguments first isBlockLiteralNode])
		ifTrue: [^true].
		
	(aSymbol = #ifFalse: and: [self arguments first isBlockLiteralNode])
		ifTrue: [^true].
	
	(aSymbol = #ifTrue:ifFalse: and: [self arguments allSatisfy: [:eachNode | eachNode isBlockLiteralNode]])
		ifTrue: [^true].

	(aSymbol = #ifFalse:ifTrue: and: [self arguments allSatisfy: [:eachNode | eachNode isBlockLiteralNode]])
		ifTrue: [^true].

	(aSymbol = #whileTrue: and: [self receiver isBlockLiteralNode and: [self arguments first isBlockLiteralNode]])
		ifTrue: [^true].

	(aSymbol = #whileFalse: and: [self receiver isBlockLiteralNode and: [self arguments first isBlockLiteralNode]])
		ifTrue: [^true].

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'testing'] value ! !
! KeywordMessageNode methodsFor: 'testing' !
isKeywordMessageNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
acceptVisitor: anObject

	(self isInlinedSelector: self selector) ifTrue: [
		^self visitInlinedObject: anObject].
	anObject visitMessageNodeStart: self.
	self receiver ifNotNil: [self receiver acceptVisitor: anObject].
	self arguments do: [:eachArgument | eachArgument acceptVisitor: anObject].
	anObject visitMessageNodeEnd: self ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitIfFalse: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfFalseBlock: self arguments first ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitIfFalseIfTrue: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfFalseBlock: self arguments first ifTrueBlock: self arguments last ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitIfTrue: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfTrueBlock: self arguments first ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitIfTrueIfFalse: anObject

	self receiver acceptVisitor: anObject.
	anObject visitIfTrueBlock: self arguments first ifFalseBlock: self arguments last ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitInlinedObject: anObject

	self selector = #ifTrue: ifTrue: [^self visitIfTrue: anObject].
	self selector = #ifFalse: ifTrue: [^self visitIfFalse: anObject].
	self selector = #ifTrue:ifFalse: ifTrue: [^self visitIfTrueIfFalse: anObject].
	self selector = #ifFalse:ifTrue: ifTrue: [^self visitIfFalseIfTrue: anObject].
	self selector = #whileTrue: ifTrue: [^self visitWhileTrue: anObject].
	self selector = #whileFalse: ifTrue: [^self visitWhileFalse: anObject].
	self error: 'Bad inlined selector ', self selector printString ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitWhileFalse: anObject

	anObject visitWhileFalseBlock: self receiver doBlock: self arguments first ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode methodsFor: 'visiting'] value ! !
! KeywordMessageNode methodsFor: 'visiting' !
visitWhileTrue: anObject

	anObject visitWhileTrueBlock: self receiver doBlock: self arguments first ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode class methodsFor: 'instance creation'] value ! !
! KeywordMessageNode class methodsFor: 'instance creation' !
receiver: receiver selector: selectorToken arguments: argumentsArray

	^self new
		receiver: receiver;
		selector: selectorToken;
		arguments: argumentsArray;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[KeywordMessageNode class methodsFor: 'instance creation'] value ! !
! KeywordMessageNode class methodsFor: 'instance creation' !
selector: selectorToken arguments: argumentsArray

	^self new
		selector: selectorToken;
		arguments: argumentsArray;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! LocalVariableAssignmentNode methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! LocalVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! LocalVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableAssignmentNode methodsFor: 'accessing'] value ! !
! LocalVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableAssignmentNode methodsFor: 'visiting'] value ! !
! LocalVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitLocalVariableAssignmentNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableAssignmentNode class methodsFor: 'instance creation'] value ! !
! LocalVariableAssignmentNode class methodsFor: 'instance creation' !
variable: variable value: value

	^self new
		variable: variable;
		value: value;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableReferenceNode methodsFor: 'accessing'] value ! !
! LocalVariableReferenceNode methodsFor: 'accessing' !
scopeNumber

	^scopeNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableReferenceNode methodsFor: 'accessing'] value ! !
! LocalVariableReferenceNode methodsFor: 'accessing' !
scopeNumber: anObject

	scopeNumber := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableReferenceNode methodsFor: 'accessing'] value ! !
! LocalVariableReferenceNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableReferenceNode methodsFor: 'accessing'] value ! !
! LocalVariableReferenceNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariableReferenceNode methodsFor: 'visiting'] value ! !
! LocalVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitLocalVariableReferenceNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'accessing'] value ! !
! MethodNode methodsFor: 'accessing' !
body

	^body ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'accessing'] value ! !
! MethodNode methodsFor: 'accessing' !
body: anObject

	body := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'accessing'] value ! !
! MethodNode methodsFor: 'accessing' !
header

	^header ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'accessing'] value ! !
! MethodNode methodsFor: 'accessing' !
header: anObject

	header := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'accessing'] value ! !
! MethodNode methodsFor: 'accessing' !
pragmas

	^pragmas ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'accessing'] value ! !
! MethodNode methodsFor: 'accessing' !
pragmas: anObject

	pragmas := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'testing'] value ! !
! MethodNode methodsFor: 'testing' !
isMethodNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode methodsFor: 'visiting'] value ! !
! MethodNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitMethodNodeStart: self.
	self header acceptVisitor: anObject.
	self pragmas do: [:pragma | pragma acceptVisitor: anObject].
	self body isNil
		ifTrue: [anObject visitEmptyMethodNode: self]
		ifFalse: [
			self body acceptVisitor: anObject.
			anObject visitMethodNode: self] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode class methodsFor: 'instance creation'] value ! !
! MethodNode class methodsFor: 'instance creation' !
header: header body: body

	^self new
		header: header;
		body: body;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodNode class methodsFor: 'instance creation'] value ! !
! MethodNode class methodsFor: 'instance creation' !
header: header pragmas: pragmas body: body

	^self new
		header: header;
		pragmas: pragmas;
		body: body;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
nameComponents

	^nameComponents ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
nameComponents: anObject

	nameComponents := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
variable

	^variable ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'accessing'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'accessing' !
variable: anObject

	variable := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode methodsFor: 'visiting'] value ! !
! NamespaceVariableAssignmentNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self value acceptVisitor: anObject.
	anObject visitNamespaceVariableAssignmentNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode class methodsFor: 'instance creation'] value ! !
! NamespaceVariableAssignmentNode class methodsFor: 'instance creation' !
nameComponents: variableNames value: value

	^self new
		nameComponents: variableNames;
		value: value;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableAssignmentNode class methodsFor: 'instance creation'] value ! !
! NamespaceVariableAssignmentNode class methodsFor: 'instance creation' !
variable: aVariable value: value

	^self new
		variable: aVariable;
		value: value;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableReferenceNode methodsFor: 'accessing'] value ! !
! NamespaceVariableReferenceNode methodsFor: 'accessing' !
nameComponents

	^nameComponents ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableReferenceNode methodsFor: 'accessing'] value ! !
! NamespaceVariableReferenceNode methodsFor: 'accessing' !
nameComponents: anObject

	nameComponents := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariableReferenceNode methodsFor: 'visiting'] value ! !
! NamespaceVariableReferenceNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitNamespaceVariableReferenceNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ParenthesisNode methodsFor: 'accessing'] value ! !
! ParenthesisNode methodsFor: 'accessing' !
expression

	^expression ! !
! Doit class methodsFor: 'doit' !
doit ^[ParenthesisNode methodsFor: 'accessing'] value ! !
! ParenthesisNode methodsFor: 'accessing' !
expression: anObject

	expression := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParenthesisNode methodsFor: 'testing'] value ! !
! ParenthesisNode methodsFor: 'testing' !
isParenthesisNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[ParenthesisNode methodsFor: 'visiting'] value ! !
! ParenthesisNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self expression acceptVisitor: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParenthesisNode class methodsFor: 'instance creation'] value ! !
! ParenthesisNode class methodsFor: 'instance creation' !
expression: aNode

	^self new
		expression: aNode;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'initialize-release'] value ! !
! ParseTreeVisitor methodsFor: 'initialize-release' !
initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'messages'] value ! !
! ParseTreeVisitor methodsFor: 'messages' !
visitIfFalseBlock: aBlockLiteralNode

	aBlockLiteralNode value acceptVisitor: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'messages'] value ! !
! ParseTreeVisitor methodsFor: 'messages' !
visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode

	falseBlockLiteralNode value acceptVisitor: self.
	trueBlockLiteralNode value acceptVisitor: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'messages'] value ! !
! ParseTreeVisitor methodsFor: 'messages' !
visitIfTrueBlock: aBlockLiteralNode

	aBlockLiteralNode value acceptVisitor: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'messages'] value ! !
! ParseTreeVisitor methodsFor: 'messages' !
visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode

	trueBlockLiteralNode value acceptVisitor: self.
	falseBlockLiteralNode value acceptVisitor: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'messages'] value ! !
! ParseTreeVisitor methodsFor: 'messages' !
visitWhileFalseBlock: conditionBlock doBlock: doBlock

	conditionBlock value acceptVisitor: self.
	doBlock value acceptVisitor: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'messages'] value ! !
! ParseTreeVisitor methodsFor: 'messages' !
visitWhileTrueBlock: conditionBlock doBlock: doBlock

	conditionBlock value acceptVisitor: self.
	doBlock value acceptVisitor: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visit: aNode

	^aNode acceptVisitor: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitArgument: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBinaryHeader: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockLiteralNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockNodeStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitBlockParameterListNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitCascadeEnd: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitCascadeInterMessage: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitCascadeStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitEmptyMethodNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitEmptyStatements ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitGlobalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitGlobalVariableReferenceNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitInstanceVariableAssignmentNode: aNode

	aNode value acceptVisitor: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitInstanceVariableReferenceNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitKeywordHeader: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitLiteralNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitLocalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitLocalVariableReferenceNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMessageNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMessageNodeEnd: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMessageNodeStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMethodNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitMethodNodeStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitNamespaceVariableAssignmentNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitNamespaceVariableReferenceNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitPragma: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitReceiver: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitReturnNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitSpecialNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementList: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementListEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementListEnd: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementListStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitStatementSeparator ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor methodsFor: 'visitor handling'] value ! !
! ParseTreeVisitor methodsFor: 'visitor handling' !
visitUnaryHeader: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor class methodsFor: 'instance creation'] value ! !
! ParseTreeVisitor class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
addBytecode: aByte

	^bytecodeStream nextPut: aByte ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
addGlobalDictionary: aDictionary

	globalDictionaries add: aDictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
bytecodeFor: aSymbol

	^(self class bytecodesByName at: aSymbol) number ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
bytecodeStream

	^bytecodeStream ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
bytecodeStream: anObject

	bytecodeStream := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
bytecodes

	^bytecodeStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
globalDictionaries

	^globalDictionaries ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
globalDictionaries: anObject

	globalDictionaries := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
hasReturned

	^hasReturned ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
hasReturned: anObject

	hasReturned := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
isInlinedBlock

	^isInlinedBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
isInlinedBlock: anObject

	isInlinedBlock := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
literals

	^literals ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
literals: anObject

	literals := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
method

	| method scope |

	scope := self methodLocalVariableAnalysis scopeFor: self methodLocalVariableAnalysis rootNode.

	method := (CompiledMethod new: self literals size)
		numberOfTemporaries: scope temporaryVariables size;
		numberOfArguments: scope arguments size;
		bytecodes: self bytecodes;
		mclass: self targetClass;
		selector: self selector;
		localVariableNames: scope localVariableNames asArray;
		sourceOffsets: self sourceOffsets;
		yourself.

	self writeLiteralsInto: method";
		writePICInto: method".
	
	^method ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
methodLocalVariableAnalysis

	^methodLocalVariableAnalysis ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
methodLocalVariableAnalysis: anObject

	methodLocalVariableAnalysis := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
nodeStack

	^nodeStack ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
nodeStack: anObject

	nodeStack := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
outerMethod

	^outerMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
outerMethod: anObject

	outerMethod := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
popNode

	self nodeStack removeLast ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
pragmas

	^pragmas ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
pragmas: anObject

	pragmas := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
pushNode: aNode

	self nodeStack add: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
returnLevel

	^returnLevel ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
returnLevel: anObject

	returnLevel := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
sourceOffsets

	^sourceOffsets ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
sourceOffsets: anObject

	sourceOffsets := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
targetClass

	^targetClass ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
writeLiteralsInto: method

	self literals keysAndValuesDo: [:eachIndex :eachLiteral |
		method basicAt: eachIndex put: eachLiteral.
		eachLiteral isCompiledBlock ifTrue: [
			eachLiteral outerMethod: method].

		eachLiteral isBlockClosure
			ifTrue: [eachLiteral method outerMethod: method]] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'accessing'] value ! !
! CodeGenerator methodsFor: 'accessing' !
writePICInto: method

	| picOffset |

	picOffset := 1.
	method polymorphicInlineCache: (Array new: self numberOfSends * 9).
	"self callOffsetsDo: [:offset |
			method polymorphicInlineCache
				at: picOffset put: offset;
				at: picOffset + 1 put: offset;
				at: picOffset + 2 put: nil;
				at: picOffset + 3 put: nil;
				at: picOffset + 4 put: nil;
				at: picOffset + 5 put: nil;
				at: picOffset + 6 put: nil;
				at: picOffset + 7 put: nil;
				at: picOffset + 8 put: nil.
			picOffset := picOffset + 9]" ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'blocks'] value ! !
! CodeGenerator methodsFor: 'blocks' !
createBlockFor: newCodeGenerator variablesToCopy: variablesToCopy

	| locals block scope |

	locals := (self methodLocalVariableAnalysis scopeFor: self nodeStack last) allLocals.
	variablesToCopy do: [:eachVariable |
		| index |
		index := locals indexOf: eachVariable.
		index = 0
			ifTrue: [
				eachVariable isSelf
					ifTrue: [self pushSelf]
					ifFalse: [self compileError: 'Compile error 1']]
			ifFalse: [self pushLocalVariableNumber: index]].

	scope := newCodeGenerator methodLocalVariableAnalysis scopeFor: newCodeGenerator nodeStack last.

	block := (CompiledBlock new: newCodeGenerator literals size)
				numberOfTemporaries: scope temporaryVariables size;
				numberOfArguments: scope arguments size;
				bytecodes: newCodeGenerator bytecodeStream contents;
				localVariableNames: scope localVariableNames asArray;
				mclass: self targetClass;
				sourceOffsets: (newCodeGenerator sourceOffsets asArray);
				yourself.

	newCodeGenerator
		writeLiteralsInto: block;
		writePICInto: block.

	^self addLiteral: block ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'blocks'] value ! !
! CodeGenerator methodsFor: 'blocks' !
pushCopyBlock: newCodeGenerator variablesToCopy: variablesToCopy

	| literalNumber |
	
	literalNumber := self createBlockFor: newCodeGenerator variablesToCopy: variablesToCopy.

	self
		addBytecode: self bytecodePushCopyingBlock;
		addBytecode: literalNumber - 1;
		addBytecode: variablesToCopy size ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'blocks'] value ! !
! CodeGenerator methodsFor: 'blocks' !
pushFullBlock: newCodeGenerator variablesToCopy: variablesToCopy

	| literalNumber |

	literalNumber := self createBlockFor: newCodeGenerator variablesToCopy: variablesToCopy.

	self
		addBytecode: self bytecodePushFullBlock;
		addBytecode: literalNumber - 1;
		addBytecode: variablesToCopy size ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
addDup
	^self addBytecode: self bytecodeDup ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
addPop
	^self addBytecode: self bytecodePop ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeBlockReturn

	^self bytecodeFor: #blockReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallOneByte

	^self bytecodeFor: #callLiteral ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallOneByteSuper

	^self bytecodeFor: #callSuperLiteral ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallShort

	^self bytecodeFor: #callLiteral1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallShortSuper

	^self bytecodeFor: #superCallLiteral1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallSuperTwoBytes

	^self bytecodeFor: #superCallLiteralExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallTwoBytes

	^self bytecodeFor: #callLiteralExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeCallWellKnown

	^self bytecodeFor: #callWellKnown ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeDropCascadeReceiver

	^self bytecodeFor: #dropCascadeReceiver ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeDup

	^self bytecodeFor: #dup ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfFalseOneByte

	^self bytecodeFor: #jumpIfFalse ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfFalseTwoBytes

	^self bytecodeFor: #jumpIfFalseExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfTrueOneByte

	^self bytecodeFor: #jumpIfTrue ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpIfTrueTwoBytes

	^self bytecodeFor: #jumpIfTrueExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpOneByte

	^self bytecodeFor: #jump ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeJumpTwoBytes

	^self bytecodeFor: #jumpExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeNonLocalReturn

	^self bytecodeFor: #nonLocalReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePop

	^self bytecodeFor: #pop ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePrimitive

	^self bytecodeFor: #callPrimitive ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePrimitiveReturn

	^self bytecodeFor: #primitiveReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushCopyingBlock

	^self bytecodeFor: #pushCopyingBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushFalse

	^self bytecodeFor: #pushFalse ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushFourByteInteger

	^self bytecodeFor: #pushFourByteInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushFullBlock

	^self bytecodeFor: #pushFullBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushLocalIndirect

	^self bytecodeFor: #pushLocalIndirect ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushNil

	^self bytecodeFor: #pushNil ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteGlobal

	^self bytecodeFor: #pushGlobal ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteInstanceVariable

	^self bytecodeFor: #pushInstVar ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteInteger

	^self bytecodeFor: #pushOneByteInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteLiteral

	^self bytecodeFor: #pushLiteral ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushOneByteLocalVariable

	^self bytecodeFor: #pushLocal ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSelf

	^self bytecodeFor: #pushSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSelfInstvarIndirect

	^self bytecodeFor: #pushSelfInstvarIndirect ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushShortGlobal

	^self bytecodeFor: #pushGlobal1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushShortInstanceVariable

	^self bytecodeFor: #pushInstVar1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushShortLocalVariable

	^self bytecodeFor: #pushLocal1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSmallLiteral

	^self bytecodeFor: #pushLiteral1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSmallNegativeInteger

	^self bytecodeFor: #pushInteger0 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushSmallPositiveInteger

	^self bytecodeFor: #pushInteger1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushThisContext

	^self bytecodeFor: #pushThisContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTrue

	^self bytecodeFor: #pushTrue ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteGlobal

	^self bytecodeFor: #pushGlobalExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteInstanceVariable

	^self bytecodeFor: #pushInstVarExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteInteger

	^self bytecodeFor: #pushTwoByteInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodePushTwoByteLiteral

	^self bytecodeFor: #pushLiteralExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeReturn

	^self bytecodeFor: #return ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreLocalIndirect

	^self bytecodeFor: #storeLocalIndirect ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreNewArray

	^self bytecodeFor: #storeNewArray ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreOneByteGlobal

	^self bytecodeFor: #storeGlobal ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreOneByteInstanceVariable

	^self bytecodeFor: #storeInstVar ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreOneByteLocalVariable

	^self bytecodeFor: #storeLocal ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreSelfInstvarIndirect

	^self bytecodeFor: #storeSelfInstVarIndirect ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreShortGlobalVariable

	^self bytecodeFor: #storeGlobal1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreShortInstanceVariable

	^self bytecodeFor: #storeInstVar1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreShortLocalVariable

	^self bytecodeFor: #storeLocal1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreTwoByteGlobalVariable

	^self bytecodeFor: #storeGlobalExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreTwoByteInstanceVariable

	^self bytecodeFor: #storeInstVarExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'bytecodes'] value ! !
! CodeGenerator methodsFor: 'bytecodes' !
bytecodeStoreTwoByteLocalVariable

	^self bytecodeFor: #storeLocalExtended ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callLiteral: literalNumber args: anInteger

	| numberOfArguments |
	numberOfArguments := (literals at: literalNumber) numArgs.
	
	literalNumber <= 16 ifTrue: [^self callShortLiteral: literalNumber args: anInteger].
	literalNumber <= 256 ifTrue: [^self callOneByteLiteral: literalNumber args: anInteger].
	literalNumber <= 65536 ifTrue: [^self callTwoByteLiteral: literalNumber args: anInteger].
	
	self compileError: 'Too many literals' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callOneByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallOneByte;
		addBytecode: literalNumber - 1;
		addBytecode: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callShortLiteral: literalNumber args: anInteger

	self
		addBytecode: (self bytecodeCallShort + literalNumber - 1);
		addBytecode: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callSpecialSelector: aSymbol
	| numberOfArguments |

	numberOfArguments := aSymbol numArgs.
	self
		addBytecode: (self bytecodeCallWellKnown);
		addBytecode: (self class specialSelectors indexOf: aSymbol) - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callSuperLiteral: literalNumber args: anInteger

	literalNumber <= 6 ifTrue: [^self callSuperShortLiteral: literalNumber args: anInteger].
	literalNumber < 256 ifTrue: [^self callSuperOneByteLiteral: literalNumber args: anInteger].
	self callSuperTwoByteLiteral: literalNumber args: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callSuperOneByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallOneByteSuper;
		addBytecode: literalNumber - 1;
		addBytecode: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callSuperShortLiteral: literalNumber args: anInteger

	self addBytecode: (self bytecodeCallShortSuper + literalNumber - 1);
		addBytecode: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callSuperTwoByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallSuperTwoBytes;
		addBytecode: literalNumber - 1 // 256;
		addBytecode: literalNumber - 1 \\ 256;
		addBytecode: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'calls'] value ! !
! CodeGenerator methodsFor: 'calls' !
callTwoByteLiteral: literalNumber args: anInteger

	self
		addBytecode: self bytecodeCallTwoBytes;
		addBytecode: literalNumber - 1 // 256;
		addBytecode: literalNumber - 1 \\ 256;
		addBytecode: anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'decompiling'] value ! !
! CodeGenerator methodsFor: 'decompiling' !
callOffsetsDo: aBlock

	| decompileStream line matchNext offset|

	matchNext := false.

	decompileStream := self decompileNoBytes readStream.
	decompileStream upTo: Character cr.

	[decompileStream atEnd] whileFalse: [
		line := decompileStream upTo: Character cr.
		matchNext ifTrue: [
			offset := line trimSeparators readStream upTo: $:.
			aBlock value: (Integer readHexFrom: offset readStream).
			matchNext := false].
		((line indexOfSubCollection: 'Call' startingAt: 1) > 0) ifTrue: [matchNext := true].
		((line indexOfSubCollection: 'call' startingAt: 1) > 0) ifTrue: [matchNext := true]
		] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'decompiling'] value ! !
! CodeGenerator methodsFor: 'decompiling' !
decompile

	^Decompiler new
		literals: self literals;
		targetClass: self targetClass;
		decompile: self bytecodes ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'decompiling'] value ! !
! CodeGenerator methodsFor: 'decompiling' !
decompileNoBytes

	^Decompiler new
		literals: self literals;
		targetClass: self targetClass;
		decompileNoBytes: self bytecodes ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'decompiling'] value ! !
! CodeGenerator methodsFor: 'decompiling' !
numberOfSends

	| numberOfSends |
	numberOfSends := 0.
	self callOffsetsDo: [:offset |
		numberOfSends := numberOfSends + 1].

	^numberOfSends ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'errors'] value ! !
! CodeGenerator methodsFor: 'errors' !
compileError: aString

	self halt
	"^(CompileError new)
		message: aString;
		startSourceOffset: start;
		endSourceOffset: end;
		raiseSignal" ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'errors'] value ! !
! CodeGenerator methodsFor: 'errors' !
compileError: aString node: aParseNode

	^(CompileError new)
		message: aString;
		startSourceOffset: aParseNode startSourceOffset;
		endSourceOffset: aParseNode endSourceOffset;
		raiseSignal ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'errors'] value ! !
! CodeGenerator methodsFor: 'errors' !
compileWarning: aString
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'errors'] value ! !
! CodeGenerator methodsFor: 'errors' !
compileWarning: aString node: aParseNode

	^(CompileWarning new)
		message: aString;
		startSourceOffset: aParseNode startSourceOffset;
		endSourceOffset: aParseNode endSourceOffset;
		raiseSignal ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'initialize-release'] value ! !
! CodeGenerator methodsFor: 'initialize-release' !
initialize

	literals := OrderedCollection new.
	bytecodeStream := WriteStream on: (ByteArray new).
	hasReturned := false.
	self pragmas: OrderedCollection new.
	globalDictionaries := OrderedCollection new.
	nodeStack := OrderedCollection new.
	isInlinedBlock := false.
	nestedVariablesRead := Set new.
	nestedVariablesWritten := Set new.
	returnLevel := 0.
	sourceOffsets := OrderedCollection with: 0 with: 0 with: 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
addLiteral: anObject

	| literalNumber |

	anObject isNil ifTrue: [self  halt. self compileError: 'Compile error 3'].
	(literalNumber := literals indexOf: anObject) = 0 ifTrue: [
		literals add: anObject.
		literalNumber := literals size].

	^literalNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushFourByteInteger: anInteger

	| twoByteInteger |

	anInteger positive ifTrue: [
		self
			addBytecode: self bytecodePushFourByteInteger;
			addBytecode: anInteger // 16777216;
			addBytecode: (anInteger bitAnd: 16rFF0000) // 65536;
			addBytecode: (anInteger bitAnd: 16rFF00) // 256;
			addBytecode: (anInteger bitAnd: 16rFF).
		^self].

	twoByteInteger := 4294967296 + anInteger.

	self
		addBytecode: self bytecodePushFourByteInteger;
		addBytecode: twoByteInteger // 16777216;
		addBytecode: (twoByteInteger bitAnd: 16rFF0000) // 65536;
		addBytecode: (twoByteInteger bitAnd: 16rFF00) // 256;
		addBytecode: (twoByteInteger bitAnd: 16rFF) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushInteger: integer

	(integer between: 1 and: 16) ifTrue: [^self pushSmallPositiveInteger: integer].
	(integer between: -15 and: 0) ifTrue: [^self pushSmallNegativeInteger: integer].
	(integer between: -128 and: 127) ifTrue: [^self pushOneByteInteger: integer].
	(integer between: -32768 and: 32767) ifTrue: [^self pushTwoByteInteger: integer].
	(integer between: -2147483648 and: 2147483647) ifTrue: [^self pushFourByteInteger: integer].
	self pushLiteral: integer ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushLiteral: anObject

	| literalNumber |

	literalNumber := self addLiteral: anObject.

	literalNumber <= 16 ifTrue: [^self pushShortLiteral: literalNumber].
	literalNumber <= 256 ifTrue: [^self pushOneByteLiteral: literalNumber].
	self pushTwoByteLiteral: literalNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushOneByteInteger: anInteger

	anInteger positive ifTrue: [^
		self
			addBytecode: self bytecodePushOneByteInteger;
			addBytecode: anInteger].

	self
		addBytecode: self bytecodePushOneByteInteger;
		addBytecode: 256 + anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushOneByteLiteral: literalNumber

	self
		addBytecode: self bytecodePushOneByteLiteral;
		addBytecode: literalNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushShortLiteral: literalNumber

	self addBytecode: self bytecodePushSmallLiteral + (literalNumber - 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushSmallNegativeInteger: anInteger

	self addBytecode: self bytecodePushSmallNegativeInteger + anInteger negated ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushSmallPositiveInteger: anInteger

	self addBytecode: self bytecodePushSmallPositiveInteger + (anInteger - 1) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushTwoByteInteger: anInteger

	| twoByteInteger |

	anInteger positive ifTrue: [
		self
			addBytecode: self bytecodePushTwoByteInteger;
			addBytecode: anInteger // 256;
			addBytecode: anInteger \\ 256.
		^self].

	twoByteInteger := 65536 + anInteger.

	self
		addBytecode: self bytecodePushTwoByteInteger;
		addBytecode: twoByteInteger // 256;
		addBytecode: twoByteInteger \\ 256. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'literals'] value ! !
! CodeGenerator methodsFor: 'literals' !
pushTwoByteLiteral: literalNumber

	self
		addBytecode: self bytecodePushTwoByteLiteral;
		addBytecode: literalNumber - 1 // 256;
		addBytecode: literalNumber - 1 \\ 256 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: aBlockLiteralNode

	^self visitIfFalseBlock: aBlockLiteralNode useLongJumps: false ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode

	^self visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: false ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex hasFalseReturned jump1Offset jump2Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	"push receiver
	jump if false - jump1
	code for ifTrue
	jump - jump 2
	code for ifFalse"

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfTrueTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfTrueOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		falseBlockLiteralNode value acceptVisitor: self].

	hasFalseReturned := self hasReturned.
	self hasReturned: false.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: 0].

	jump2Offset := self bytecodes size.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self whileEmbeddedBlockDo: [
		trueBlockLiteralNode value acceptVisitor: self].

	"Fix the jump 2 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump2Offset.
			self bytecodeStream
				at: jump2Offset - 1 put: (forwardJump // 256);
				at: jump2Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump2Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfFalseBlock: falseBlockLiteralNode ifTrueBlock: trueBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at:  jump2Offset put: forwardJump].

	self hasReturned: (self hasReturned & hasFalseReturned) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfFalseBlock: aBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jump1Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfTrueTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfTrueOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		aBlockLiteralNode value acceptVisitor: self].

	self
		addBytecode: self bytecodeJumpOneByte;
		addBytecode: 1.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfFalseBlock: aBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self addBytecode: self bytecodePushNil.

	self hasReturned: false.  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: aBlockLiteralNode

	^self visitIfTrueBlock: aBlockLiteralNode useLongJumps: false ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode

	^self visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: false ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex hasTrueReturned jump1Offset jump2Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfFalseTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfFalseOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		trueBlockLiteralNode value acceptVisitor: self].

	hasTrueReturned := self hasReturned.
	self hasReturned: false.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: 0].

	jump2Offset := self bytecodes size.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self whileEmbeddedBlockDo: [
		falseBlockLiteralNode value acceptVisitor: self].

	"Fix the jump 2 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump2Offset.
			self bytecodeStream
				at: jump2Offset - 1 put: (forwardJump // 256);
				at: jump2Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump2Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfTrueBlock: trueBlockLiteralNode ifFalseBlock: falseBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at:  jump2Offset put: forwardJump].

	self hasReturned: (self hasReturned & hasTrueReturned) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitIfTrueBlock: aBlockLiteralNode useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jump1Offset forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfFalseTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfFalseOneByte;
				addBytecode: 0].

	jump1Offset := self bytecodes size.

	self whileEmbeddedBlockDo: [
		aBlockLiteralNode value acceptVisitor: self].

	self
		addBytecode: self bytecodeJumpOneByte;
		addBytecode: 1.

	"Fix the jump 1 offsets"
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jump1Offset.
			self bytecodeStream
				at: jump1Offset - 1 put: (forwardJump // 256);
				at: jump1Offset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jump1Offset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitIfTrueBlock: aBlockLiteralNode useLongJumps: true].
			self bytecodeStream
				at: jump1Offset put: forwardJump].

	self addBytecode: self bytecodePushNil.

	self hasReturned: false.  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitWhileFalseBlock: conditionBlock doBlock: doBlock

	self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: false ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jumpForwardOffset backwardJump forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	self whileEmbeddedBlockDo: [conditionBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfTrueTwoBytes;
				addBytecode: 0;
				addBytecode: 0.
			jumpForwardOffset := self bytecodes size]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfTrueOneByte;
				addBytecode: 0.
			jumpForwardOffset := self bytecodes size].

	self whileEmbeddedBlockDo: [doBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			backwardJump := 65536 - (self bytecodes size + 4 - startBytecodeIndex).
			
			self
				addPop;
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: backwardJump // 256;
				addBytecode: backwardJump \\ 256]
		ifFalse: [
			backwardJump := self bytecodes size + 3 - startBytecodeIndex.
			backwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			backwardJump := 256 - backwardJump.

			self
				addPop;
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: backwardJump].
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			self bytecodeStream
				at: jumpForwardOffset - 1 put: (forwardJump // 256);
				at: jumpForwardOffset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			self bytecodeStream
				at: jumpForwardOffset put: forwardJump].

	self pushSelf  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitWhileTrueBlock: conditionBlock doBlock: doBlock

	self visitWhileTrueBlock: conditionBlock doBlock: doBlock useLongJumps: false
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
visitWhileTrueBlock: conditionBlock doBlock: doBlock useLongJumps: aBoolean

	| startBytecodeIndex startLiteralIndex jumpForwardOffset backwardJump forwardJump |

	startBytecodeIndex := self bytecodeStream position.
	startLiteralIndex := self literals size.

	self whileEmbeddedBlockDo: [conditionBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			self
				addBytecode: self bytecodeJumpIfFalseTwoBytes;
				addBytecode: 0;
				addBytecode: 0]
		ifFalse: [
			self
				addBytecode: self bytecodeJumpIfFalseOneByte;
				addBytecode: 0].

	jumpForwardOffset := self bytecodes size.

	self whileEmbeddedBlockDo: [doBlock value acceptVisitor: self].

	aBoolean
		ifTrue: [
			backwardJump := 65536 - (self bytecodes size + 4 - startBytecodeIndex).
			
			self
				addPop;
				addBytecode: self bytecodeJumpTwoBytes;
				addBytecode: backwardJump // 256;
				addBytecode: backwardJump \\ 256]
		ifFalse: [
			backwardJump := self bytecodes size + 3 - startBytecodeIndex.
			backwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			backwardJump := 256 - backwardJump.

			self
				addPop;
				addBytecode: self bytecodeJumpOneByte;
				addBytecode: backwardJump].
	aBoolean
		ifTrue: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			self bytecodeStream
				at: jumpForwardOffset - 1 put: (forwardJump // 256);
				at: jumpForwardOffset put: (forwardJump \\ 256)]
		ifFalse: [
			forwardJump := self bytecodes size - jumpForwardOffset.
			forwardJump >= 128 ifTrue: [
				self bytecodeStream position: startBytecodeIndex.
				self literals: (self literals copyFrom: 1 to: startLiteralIndex).
				^self visitWhileFalseBlock: conditionBlock doBlock: doBlock useLongJumps: true].
			self bytecodeStream
				at: jumpForwardOffset put: forwardJump].

	self pushSelf  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'messages'] value ! !
! CodeGenerator methodsFor: 'messages' !
whileEmbeddedBlockDo: aBlock

	| oldEmbedded |
	oldEmbedded := self isInlinedBlock.
	self isInlinedBlock: true.
	"self log: 'Start embeddedBlock'."
	aBlock value.
	"self log: 'Finish embeddedBlock'."
	self isInlinedBlock: oldEmbedded ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushCopiedSelf

	| selfVariable |
	selfVariable := self selfVariable.
	self pushLocalVariableReference: selfVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushFalse
	self addBytecode: self bytecodePushFalse ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushNil
	self addBytecode: self bytecodePushNil ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushReturn
	self addBytecode: self bytecodeReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushSelf
	self nodeStack last isBlockNode ifTrue: [^self pushCopiedSelf].
	self addBytecode: self bytecodePushSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushThisContext
	self addBytecode: self bytecodePushThisContext ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
pushTrue
	self addBytecode: self bytecodePushTrue ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'special words'] value ! !
! CodeGenerator methodsFor: 'special words' !
selfVariable

	| selfVariable |
	selfVariable := (self methodLocalVariableAnalysis scopeFor: nodeStack last)
				copiedVariables detect: [:eachVariable | eachVariable isSelf]
					ifNone: [self compileError: 'Compiler error'].
	^selfVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
globalAssociationFor: aVariable

	| currentDictionary result |

	currentDictionary := globalDictionaries detect: [:dictionary | dictionary notNil and: [dictionary includesKey: aVariable variableName]] ifNone: [
		^nil].

	^currentDictionary bindingFor: aVariable variableName.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
isGlobalVariable: aVariable

	| variableSymbol |

	aVariable isGlobalVariable ifFalse: [^false].
	variableSymbol := aVariable variableName asSymbol.
	^globalDictionaries anySatisfy: [:each | each includesKey: variableSymbol] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
isInlined

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
isInstanceVariable: aVariable

	targetClass isNil ifTrue: [^false].
	aVariable isInstanceVariable ifFalse: [^false].
	^targetClass allInstVarNames includes: aVariable variableName asString ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
isLocalVariable: aVariableNode

	aVariableNode isLocalVariable ifFalse: [^false].
	^(self scopeForLocalVariable: aVariableNode) notNil ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
isNamespaceGlobal: anArray

	^(self namespaceGlobalAssociationFor: anArray) notNil ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
isSpecialSelector: aSymbol

	^self class specialSelectors includes: aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'testing'] value ! !
! CodeGenerator methodsFor: 'testing' !
namespaceGlobalAssociationFor: anArray

	| currentDictionary association |

	currentDictionary := globalDictionaries detect: [:dictionary | dictionary includesKey: anArray first asSymbol] ifNone: [^nil].
	1 to: anArray size - 1 do: [:each |
		currentDictionary := currentDictionary at: (anArray at: each) asSymbol ifAbsent: [^nil]].

	(currentDictionary includesKey: anArray last asSymbol) ifFalse: [^nil].
	^currentDictionary associationAt: anArray last asSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushGlobalReference: aVariable

	| variableNumber association |

	association := self globalAssociationFor: aVariable.
	association isNil ifTrue: [
		self compileWarning: 'Undeclared variable: ', aVariable variableName.
		Undeclared at: aVariable variableName ifAbsentPut: [nil].
		association := Undeclared associationAt: aVariable variableName.
		].
	
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals size].

	variableNumber := variableNumber.

	variableNumber <= 16 ifTrue: [^self pushShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushGlobalReference: aVariable node: aNode

	| variableNumber association |

	association := self globalAssociationFor: aVariable.
	association isNil ifTrue: [
		Undeclared at: aVariable variableName ifAbsentPut: [nil].
		association := Undeclared associationAt: aVariable variableName.
		self compileError: 'Undeclared variable: ', aVariable variableName node: aNode].
	
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals size].

	variableNumber := variableNumber.

	variableNumber <= 16 ifTrue: [^self pushShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushIndirectLocalVariableReference: anArray

	self
		addBytecode: self bytecodePushLocalIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushIndirectVariableArrayFor: aScopeAnalysisResult

	aScopeAnalysisResult indirectVariables variables isEmpty ifTrue: [^self].

	(aScopeAnalysisResult indirectVariables variables size = 0
		or: [aScopeAnalysisResult temporaryVariables size = 0]) ifTrue: [self compileError: 'Compile error 2'].

	self
		addBytecode: self bytecodeStoreNewArray;
		addBytecode: aScopeAnalysisResult indirectVariables variables size;
		addBytecode: (aScopeAnalysisResult variableNumberOf: aScopeAnalysisResult indirectVariables) - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushInstVarReference: aVariable

	| variableNumber |

	variableNumber := targetClass allInstVarNames indexOf: aVariable variableName asString.
	(self nodeStack notEmpty and: [self nodeStack last isBlockNode]) ifTrue: [
		| selfVariableNumber |
		selfVariableNumber := self methodLocalVariableAnalysis variableNumberOf: self selfVariable inNode: self nodeStack last.
		^self pushSelfInstanceVariableReference: (Array with: selfVariableNumber with: variableNumber)].

	variableNumber <= 16 ifTrue: [^self pushShortInstVar: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteInstVar: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteInstVar: variableNumber].

	self compileError: 'Too many instance variables' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushLocalVariableNumber: aVariableNumber

	aVariableNumber <= 16 ifTrue: [^self pushShortLocalVar: aVariableNumber].
	aVariableNumber <= 256 ifTrue: [^self pushOneByteLocalVar: aVariableNumber].

	self compileError: 'Too many temp vars' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushLocalVariableReference: aVariable

	| variableNumber |

	variableNumber := self methodLocalVariableAnalysis variableNumberOf: aVariable inNode: self nodeStack last.
	variableNumber = 0 ifTrue: [^self compileError: 'Compiler error - can''t find variable ', aVariable variableName].
	variableNumber isCollection ifTrue: [^self pushIndirectLocalVariableReference: variableNumber].

	self pushLocalVariableNumber: variableNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushNamespaceGlobalReference: anArray

	| variableNumber association |

	association := self namespaceGlobalAssociationFor: anArray.
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals indexOf: association].

	variableNumber <= 16 ifTrue: [^self pushShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self pushOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self pushTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushOneByteGlobal: variableNumber

	self
		addBytecode: self bytecodePushOneByteGlobal;
		addBytecode: variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushOneByteInstVar: variableNumber

	self
		addBytecode: self bytecodePushOneByteInstanceVariable;
		addBytecode: variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushOneByteLocalVar: variableNumber

	self
		addBytecode: self bytecodePushOneByteLocalVariable;
		addBytecode: variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushSelfInstanceVariableReference: anArray

	self
		addBytecode: self bytecodePushSelfInstvarIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushShortGlobal: variableNumber

	self addBytecode: self bytecodePushShortGlobal + variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushShortInstVar: variableNumber

	self
		addBytecode: self bytecodePushShortInstanceVariable + variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushShortLocalVar: variableNumber

	self
		addBytecode: self bytecodePushShortLocalVariable + variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushTwoByteGlobal: variableNumber

	self
		addBytecode: self bytecodePushTwoByteGlobal;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
pushTwoByteInstVar: variableNumber

	self
		addBytecode: self bytecodePushTwoByteInstanceVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeGlobalVariableAssignment: aVariable node: aGlobalVariableAssignmentNode

	| variableNumber association |

	association := self globalAssociationFor: aVariable.
	association isNil ifTrue: [^self compileError: 'Undeclared variable: ', aVariable variableName node: aGlobalVariableAssignmentNode].
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals size].

	variableNumber <= 16 ifTrue: [^self storeShortGlobal: variableNumber].
	variableNumber <= 256 ifTrue: [^self storeOneByteGlobal: variableNumber].
	variableNumber <= 65536 ifTrue: [^self storeTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeIndirectLocalVariableAssignment: anArray

	self
		addBytecode: self bytecodeStoreLocalIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeInstanceVariableAssignment: aVariable

	| variableNumber |

	variableNumber := (targetClass allInstVarNames indexOf: aVariable variableName asString).

	(self nodeStack notEmpty and: [self nodeStack last isBlockNode]) ifTrue: [
		| selfVariableNumber |
		selfVariableNumber := self methodLocalVariableAnalysis variableNumberOf: self selfVariable inNode: self nodeStack last.
		^self storeSelfInstvarAssignment: (Array with: selfVariableNumber with: variableNumber)].

	variableNumber <= 16 ifTrue: [^self storeShortInstanceVariable: variableNumber].
	variableNumber <= 256 ifTrue: [^self storeOneByteInstanceVariable: variableNumber].
	variableNumber <= 65536 ifTrue: [^self storeTwoByteInstanceVariable: variableNumber].

	self compileError: 'Too many instance variables' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeLocalVariableAssignment: aVariable

	| variableNumber |

	variableNumber := self methodLocalVariableAnalysis variableNumberOf: aVariable inNode: self nodeStack last.
	variableNumber = 0 ifTrue: [^self compileError: 'Compiler error - can''t find variable ', aVariable variableName].

	variableNumber isCollection ifTrue: [^self storeIndirectLocalVariableAssignment: variableNumber].

	variableNumber <= 16 ifTrue: [^self storeShortLocalVar: variableNumber].
	variableNumber <= 256 ifTrue: [^self storeOneByteLocalVar: variableNumber].
	variableNumber <= 65536 ifTrue: [^self storeTwoByteLocalVar: variableNumber].

	self compileError: 'Too many local vars' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeNamespaceGlobalAssignment: aNode

	| variableNumber association |

	association := self namespaceGlobalAssociationFor: aNode nameComponents.
	variableNumber := literals indexOf: association.

	variableNumber = 0 ifTrue: [
		self addLiteral: association.
		variableNumber := literals indexOf: association].

	variableNumber = 0 ifTrue: [^self compileError: 'Global isn''t a literal'].

	self recordSourceOffsetsFor: aNode.

	variableNumber <= 16 ifTrue: [^self storeShortGlobal: variableNumber].
	variableNumber < 256 ifTrue: [^self storeOneByteGlobal: variableNumber].
	variableNumber < 65536 ifTrue: [^self storeTwoByteGlobal: variableNumber].

	self compileError: 'Too many global references' ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeOneByteGlobal: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteGlobal;
		addBytecode: variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeOneByteInstanceVariable: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteInstanceVariable;
		addBytecode: variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeOneByteLocalVar: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteLocalVariable;
		addBytecode: variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeSelfInstvarAssignment: anArray

	self
		addBytecode: self bytecodeStoreSelfInstvarIndirect;
		addBytecode: anArray first - 1;
		addBytecode: anArray last - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeShortGlobal: variableNumber

	self addBytecode: self bytecodeStoreShortGlobalVariable + variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeShortInstanceVariable: variableNumber

	self
		addBytecode: self bytecodeStoreShortInstanceVariable + variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeShortLocalVar: variableNumber

	self
		addBytecode: self bytecodeStoreShortLocalVariable + variableNumber - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeTwoByteGlobal: variableNumber

	self
		addBytecode: self bytecodeStoreTwoByteGlobalVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeTwoByteInstanceVariable: variableNumber

	self
		addBytecode: self bytecodeStoreTwoByteInstanceVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'variables'] value ! !
! CodeGenerator methodsFor: 'variables' !
storeTwoByteLocalVar: variableNumber

	self
		addBytecode: self bytecodeStoreOneByteLocalVariable;
		addBytecode: variableNumber - 1 // 256;
		addBytecode: variableNumber - 1 \\ 256 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
recordSourceOffsetsFor: aNode

	self sourceOffsets
		add: self bytecodeStream position;
		add: aNode startSourceOffset;
		add: aNode endSourceOffset. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitArgument: aNode

	^aNode acceptVisitor: self ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitBinaryHeader: aNode

	self selector: aNode selector. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitBlockLiteralNode: aNode

	| newCodeGenerator variablesToCopy nodeScope block scope |

	newCodeGenerator := self class new
		methodLocalVariableAnalysis: self methodLocalVariableAnalysis;
		targetClass: self targetClass;
		selector: self selector;
		globalDictionaries: self globalDictionaries;
		literals: OrderedCollection new;
		returnLevel: self returnLevel + 1;
		yourself.

	newCodeGenerator pushNode: aNode.
	"self log: 'Start block analysis'."
	aNode acceptVisitor: newCodeGenerator.
	"self log: 'End block analysis'."

	nodeScope := self methodLocalVariableAnalysis scopeFor: aNode.
	variablesToCopy := nodeScope copiedVariables.

	nodeScope hasReturn ifTrue: [
		^self pushFullBlock: newCodeGenerator variablesToCopy: variablesToCopy].
	
	variablesToCopy notEmpty ifTrue: [
		^self pushCopyBlock: newCodeGenerator variablesToCopy: variablesToCopy].

	scope := newCodeGenerator methodLocalVariableAnalysis scopeFor: aNode.

	block := (CompiledBlock new: newCodeGenerator literals size)
			numberOfTemporaries: scope temporaryVariables size;
			numberOfArguments: scope arguments size;
			bytecodes: newCodeGenerator bytecodeStream contents;
			localVariableNames: scope localVariableNames asArray;
			sourceOffsets: (newCodeGenerator sourceOffsets asArray);
			mclass: self targetClass;
			yourself.

	newCodeGenerator
		writeLiteralsInto: block;
		writePICInto: block.

	self pushLiteral: (BlockClosure new
		method: block;
		copiedValues: Array new;
		yourself). ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitBlockNode: aNode

	self isInlinedBlock ifTrue: [^self].
	self hasReturned ifFalse: [
		self addBytecode: self bytecodeBlockReturn] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitBlockNodeStart: aNode

	self isInlinedBlock ifTrue: [^self].
	self pushIndirectVariableArrayFor: (self methodLocalVariableAnalysis scopeFor: aNode) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitBlockParameterListNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitCascadeEnd: aNode

	self addBytecode: self bytecodeDropCascadeReceiver ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitCascadeInterMessage: aNode

	self
		addPop;
		addDup ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitCascadeStart: aNode

	self addDup ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitEmptyMethodNode: aNode

	self pushSelf.
	self pushReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitEmptyStatements

	self pushSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitGlobalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.
	self recordSourceOffsetsFor: aNode.

	self storeGlobalVariableAssignment: aNode variable node: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitGlobalVariableReferenceNode: aNode

	self pushGlobalReference: aNode variable node: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitInstanceVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.
	self recordSourceOffsetsFor: aNode.

	self storeInstanceVariableAssignment: aNode variable ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitInstanceVariableReferenceNode: aNode

	self pushInstVarReference: aNode variable ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitKeywordHeader: aNode

	self selector: aNode selector. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitLiteralNode: aNode

	aNode value isInteger ifTrue: [^self pushInteger: aNode value].
	self pushLiteral: aNode value ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitLocalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.
	self recordSourceOffsetsFor: aNode.

	self storeLocalVariableAssignment: aNode variable ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitLocalVariableReferenceNode: aNode

	self pushLocalVariableReference: aNode variable ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitMessageNodeEnd: aNode

	| literalNumber |

	(self isSpecialSelector: aNode selector) ifTrue: [
		self recordSourceOffsetsFor: aNode.
		^self callSpecialSelector: aNode selector].

	literalNumber := self addLiteral: aNode selector.

	((aNode receiver isMemberOf: SpecialNode) and: [aNode receiver special = 'super']) ifTrue: [
		| numberOfArguments |
		numberOfArguments := (literals at: literalNumber) numArgs.
		self pushLiteral: targetClass.
		self recordSourceOffsetsFor: aNode.
		^self callSuperLiteral: literalNumber args: aNode selector numArgs].

	self recordSourceOffsetsFor: aNode.
	self callLiteral: literalNumber args: aNode selector numArgs ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitMessageNodeStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitMethodNode: aNode

	self hasReturned ifFalse: [
		self
			addPop;
			pushSelf;
			pushReturn] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitMethodNodeStart: aNode

	self pushNode: aNode.
	self methodLocalVariableAnalysis: MethodLocalVariableAnalysisVisitor new.
	aNode acceptVisitor: self methodLocalVariableAnalysis.
	self pushIndirectVariableArrayFor: (self methodLocalVariableAnalysis scopeFor: aNode) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitNamespaceVariableAssignmentNode: aNode

	| variableName |
	
	variableName := aNode nameComponents.

	(self isNamespaceGlobal: variableName) ifTrue: [^self storeNamespaceGlobalAssignment: aNode ].

	self compileError: 'Undeclared variable: ', variableName ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitNamespaceVariableReferenceNode: aNode

	| nameComponents |
	
	nameComponents := aNode nameComponents.

	(self isNamespaceGlobal: nameComponents) ifTrue: [^self pushNamespaceGlobalReference: nameComponents].

	self compileError: 'Undeclared variable: ', nameComponents printString ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitPragma: aNode

	self pragmas add: (Array with: aNode selector with: aNode arguments).
	aNode selector = #primitive: ifTrue: [
		self
			addBytecode: self bytecodePrimitive;
			addBytecode: aNode arguments first // 256;
			addBytecode: aNode arguments first \\ 256;
			addBytecode: self bytecodePrimitiveReturn]. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitReceiver: aNode

	^aNode acceptVisitor: self ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitReturnNode: aNode

	self recordSourceOffsetsFor: aNode.
	self nodeStack last isBlockNode
		ifTrue: [self addBytecode: self bytecodeNonLocalReturn]
		ifFalse: [self pushReturn].
	self hasReturned: true ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitSpecialNode: aNode

	| specialName |
	
	specialName := aNode special.

	specialName = 'true' ifTrue: [^self pushTrue].
	specialName = 'false' ifTrue: [^self pushFalse].
	specialName = 'nil' ifTrue: [^self pushNil].
	specialName = 'self' ifTrue: [^self pushSelf].
	specialName = 'super' ifTrue: [^self pushSelf].
	specialName = 'thisContext' ifTrue: [^self pushThisContext].

	self compileError: 'Unknown special word ', specialName ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitStatementListEnd: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitStatementListStart: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitStatementSeparator

	self hasReturned ifFalse: [self addPop] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator methodsFor: 'visitor handling'] value ! !
! CodeGenerator methodsFor: 'visitor handling' !
visitUnaryHeader: aNode

	self selector: aNode selector. ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator class methodsFor: 'class initialization'] value ! !
! CodeGenerator class methodsFor: 'class initialization' !
bytecodesByIndex

	^bytecodesByIndex ifNil: [self initialize. bytecodesByIndex] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator class methodsFor: 'class initialization'] value ! !
! CodeGenerator class methodsFor: 'class initialization' !
bytecodesByName

	^bytecodesByName ifNil: [self initialize. bytecodesByName] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator class methodsFor: 'class initialization'] value ! !
! CodeGenerator class methodsFor: 'class initialization' !
initialize

	| bytecodeTable |

	bytecodesByIndex := Array new: 256.
	bytecodesByName := IdentityDictionary new.
	bytecodeTable := self bytecodeTable.
	BeagleSystem wellKnownAt: 27 put: bytecodeTable.

	1 to: bytecodeTable size by: 3 do: [:index |
		| bytecodeSpec argumentSpec |
		
		argumentSpec := bytecodeTable at: index + 2.
		bytecodeSpec := BytecodeSpec new
			number: index - 1 // 3;
			name: (bytecodeTable at: index);
			decompileString: (bytecodeTable at: index + 1);
			argumentSpec: argumentSpec;
			type: (argumentSpec at: 1);
			numberOfBytes: (argumentSpec at: 2);
			yourself.
		bytecodesByIndex at: bytecodeSpec number + 1 put: bytecodeSpec.
		bytecodesByName at: bytecodeSpec name put: bytecodeSpec] ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator class methodsFor: 'instance creation'] value ! !
! CodeGenerator class methodsFor: 'instance creation' !
bytecodeTable

	^#(
"00"		#pushInstVar1					'Push inst var 0  %0i'							#(#pushInstVar 1 #instVarImplicit 0)
"01"		#pushInstVar2					'Push inst var 1  %1i'							#(#pushInstVar 1 #instVarImplicit 1)
"02"		#pushInstVar3					'Push inst var 2  %2i'							#(#pushInstVar 1 #instVarImplicit 2)
"03"		#pushInstVar4					'Push inst var 3  %3i'							#(#pushInstVar 1 #instVarImplicit 3)
"04"		#pushInstVar5					'Push inst var 4  %4i'							#(#pushInstVar 1 #instVarImplicit 4)
"05"		#pushInstVar6					'Push inst var 5  %5i'							#(#pushInstVar 1 #instVarImplicit 5)
"06"		#pushInstVar7					'Push inst var 6  %6i'							#(#pushInstVar 1 #instVarImplicit 6)
"07"		#pushInstVar8					'Push inst var 7  %7i'							#(#pushInstVar 1 #instVarImplicit 7)
"08"		#pushInstVar9					'Push inst var 8  %8i'							#(#pushInstVar 1 #instVarImplicit 8)
"09"		#pushInstVar10					'Push inst var 9  %9i'							#(#pushInstVar 1 #instVarImplicit 9)
"0A"		#pushInstVar11					'Push inst var 10  %10i'						#(#pushInstVar 1 #instVarImplicit 10)
"0B"		#pushInstVar12					'Push inst var 11  %11i'						#(#pushInstVar 1 #instVarImplicit 11)
"0C"		#pushInstVar13					'Push inst var 12  %12i'						#(#pushInstVar 1 #instVarImplicit 12)
"0D"		#pushInstVar14					'Push inst var 13  %13i'						#(#pushInstVar 1 #instVarImplicit 13)
"0E"		#pushInstVar15					'Push inst var 14  %14i'						#(#pushInstVar 1 #instVarImplicit 14)
"0F"		#pushInstVar16					'Push inst var 15  %15i'						#(#pushInstVar 1 #instVarImplicit 15)
"10"		#storeInstVar1					'Store inst var 0  %0i'							#(#storeInstVar 1 #instVarImplicit 0)
"11"		#storeInstVar2					'Store inst var 1  %1i'							#(#storeInstVar 1 #instVarImplicit 1)
"12"		#storeInstVar3					'Store inst var 2  %2i'							#(#storeInstVar 1 #instVarImplicit 2)
"13"		#storeInstVar4					'Store inst var 3  %3i'							#(#storeInstVar 1 #instVarImplicit 3)
"14"		#storeInstVar5					'Store inst var 4  %4i'							#(#storeInstVar 1 #instVarImplicit 4)
"15"		#storeInstVar6					'Store inst var 5  %5i'							#(#storeInstVar 1 #instVarImplicit 5)
"16"		#storeInstVar7					'Store inst var 6  %6i'							#(#storeInstVar 1 #instVarImplicit 6)
"17"		#storeInstVar8					'Store inst var 7  %7i'							#(#storeInstVar 1 #instVarImplicit 7)
"18"		#storeInstVar9					'Store inst var 8  %8i'							#(#storeInstVar 1 #instVarImplicit 8)
"19"		#storeInstVar10					'Store inst var 9  %9i'							#(#storeInstVar 1 #instVarImplicit 9)
"1A"		#storeInstVar11					'Store inst var 10  %10i'						#(#storeInstVar 1 #instVarImplicit 10)
"1B"		#storeInstVar12					'Store inst var 11  %11i'						#(#storeInstVar 1 #instVarImplicit 11)
"1C"		#storeInstVar13					'Store inst var 12  %12i'						#(#storeInstVar 1 #instVarImplicit 12)
"1D"		#storeInstVar14					'Store inst var 13  %13i'						#(#storeInstVar 1 #instVarImplicit 13)
"1E"		#storeInstVar15					'Store inst var 14  %14i'						#(#storeInstVar 1 #instVarImplicit 14)
"1F"		#storeInstVar16					'Store inst var 15  %15i'						#(#storeInstVar 1 #instVarImplicit 15)
"20"		#pushLocal1						'Push local 0    %0t'							#(#pushLocal 1 #localImplicit 0)
"21"		#pushLocal2						'Push local 1    %1t'							#(#pushLocal 1 #localImplicit 1)
"22"		#pushLocal3						'Push local 2    %2t'							#(#pushLocal 1 #localImplicit 2)
"23"		#pushLocal4						'Push local 3    %3t'							#(#pushLocal 1 #localImplicit 3)
"24"		#pushLocal5						'Push local 4    %4t'							#(#pushLocal 1 #localImplicit 4)
"25"		#pushLocal6						'Push local 5    %5t'							#(#pushLocal 1 #localImplicit 5)
"26"		#pushLocal7						'Push local 6    %6t'							#(#pushLocal 1 #localImplicit 6)
"27"		#pushLocal8						'Push local 7    %7t'							#(#pushLocal 1 #localImplicit 7)
"28"		#pushLocal9						'Push local 8    %8t'							#(#pushLocal 1 #localImplicit 8)
"29"		#pushLocal10					'Push local 9    %9t'							#(#pushLocal 1 #localImplicit 9)
"2A"		#pushLocal11					'Push local 10    %10t'							#(#pushLocal 1 #localImplicit 10)
"2B"		#pushLocal12					'Push local 11    %11t'							#(#pushLocal 1 #localImplicit 11)
"2C"		#pushLocal13					'Push local 12    %12t'							#(#pushLocal 1 #localImplicit 12)
"2D"		#pushLocal14					'Push local 13    %13t'							#(#pushLocal 1 #localImplicit 13)
"2E"		#pushLocal15					'Push local 14    %14t'							#(#pushLocal 1 #localImplicit 14)
"2F"		#pushLocal16					'Push local 15    %15t'							#(#pushLocal 1 #localImplicit 15)
"30"		#storeLocal1					'Store local 0    %0t'							#(#storeLocal 1 #localImplicit 0)
"31"		#storeLocal2					'Store local 1    %1t'							#(#storeLocal 1 #localImplicit 1)
"32"		#storeLocal3					'Store local 2    %2t'							#(#storeLocal 1 #localImplicit 2)
"33"		#storeLocal4					'Store local 3    %3t'							#(#storeLocal 1 #localImplicit 3)
"34"		#storeLocal5					'Store local 4    %4t'							#(#storeLocal 1 #localImplicit 4)
"35"		#storeLocal6					'Store local 5    %5t'							#(#storeLocal 1 #localImplicit 5)
"36"		#storeLocal7					'Store local 6    %6t'							#(#storeLocal 1 #localImplicit 6)
"37"		#storeLocal8					'Store local 7    %7t'							#(#storeLocal 1 #localImplicit 7)
"38"		#storeLocal9					'Store local 8    %8t'							#(#storeLocal 1 #localImplicit 8)
"39"		#storeLocal10					'Store local 9    %9t'							#(#storeLocal 1 #localImplicit 9)
"3A"		#storeLocal11					'Store local 10    %10t'						#(#storeLocal 1 #localImplicit 10)
"3B"		#storeLocal12					'Store local 11    %11t'						#(#storeLocal 1 #localImplicit 11)
"3C"		#storeLocal13					'Store local 12    %12t'						#(#storeLocal 1 #localImplicit 12)
"3D"		#storeLocal14					'Store local 13    %13t'						#(#storeLocal 1 #localImplicit 13)
"3E"		#storeLocal15					'Store local 14    %14t'						#(#storeLocal 1 #localImplicit 14)
"3F"		#storeLocal16					'Store local 15    %15t'						#(#storeLocal 1 #localImplicit 15)
"40"		#pushGlobal1					'Push global 0    %0g'							#(#pushGlobal 1 #globalImplicit 0)
"41"		#pushGlobal2					'Push global 1    %1g'							#(#pushGlobal 1 #globalImplicit 1)
"42"		#pushGlobal3					'Push global 2    %2g'							#(#pushGlobal 1 #globalImplicit 2)
"43"		#pushGlobal4					'Push global 3    %3g'							#(#pushGlobal 1 #globalImplicit 3)
"44"		#pushGlobal5					'Push global 4    %4g'							#(#pushGlobal 1 #globalImplicit 4)
"45"		#pushGlobal6					'Push global 5    %5g'							#(#pushGlobal 1 #globalImplicit 5)
"46"		#pushGlobal7					'Push global 6    %6g'							#(#pushGlobal 1 #globalImplicit 6)
"47"		#pushGlobal8					'Push global 7    %7g'							#(#pushGlobal 1 #globalImplicit 7)
"48"		#pushGlobal9					'Push global 8    %8g'							#(#pushGlobal 1 #globalImplicit 8)
"49"		#pushGlobal10					'Push global 9    %9g'							#(#pushGlobal 1 #globalImplicit 9)
"4A"		#pushGlobal11					'Push global 10    %10g'						#(#pushGlobal 1 #globalImplicit 10)
"4B"		#pushGlobal12					'Push global 11    %11g'						#(#pushGlobal 1 #globalImplicit 11)
"4C"		#pushGlobal13					'Push global 12    %12g'						#(#pushGlobal 1 #globalImplicit 12)
"4D"		#pushGlobal14					'Push global 13    %13g'						#(#pushGlobal 1 #globalImplicit 13)
"4E"		#pushGlobal15					'Push global 14    %14g'						#(#pushGlobal 1 #globalImplicit 14)
"4F"		#pushGlobal16					'Push global 15    %15g'						#(#pushGlobal 1 #globalImplicit 15)
"50"		#storeGlobal1					'Store global 0    %0g'							#(#storeGlobal 1 #globalImplicit 0)
"51"		#storeGlobal2					'Store global 1    %1g'							#(#storeGlobal 1 #globalImplicit 1)
"52"		#storeGlobal3					'Store global 2    %2g'							#(#storeGlobal 1 #globalImplicit 2)
"53"		#storeGlobal4					'Store global 3    %3g'							#(#storeGlobal 1 #globalImplicit 3)
"54"		#storeGlobal5					'Store global 4    %4g'							#(#storeGlobal 1 #globalImplicit 4)
"55"		#storeGlobal6					'Store global 5    %5g'							#(#storeGlobal 1 #globalImplicit 5)
"56"		#storeGlobal7					'Store global 6    %6g'							#(#storeGlobal 1 #globalImplicit 6)
"57"		#storeGlobal8					'Store global 7    %7g'							#(#storeGlobal 1 #globalImplicit 7)
"58"		#storeGlobal9					'Store global 8    %8g'							#(#storeGlobal 1 #globalImplicit 8)
"59"		#storeGlobal10					'Store global 9    %9g'							#(#storeGlobal 1 #globalImplicit 9)
"5A"		#storeGlobal11					'Store global 10    %10g'						#(#storeGlobal 1 #globalImplicit 10)
"5B"		#storeGlobal12					'Store global 11    %11g'						#(#storeGlobal 1 #globalImplicit 11)
"5C"		#storeGlobal13					'Store global 12    %12g'						#(#storeGlobal 1 #globalImplicit 12)
"5D"		#storeGlobal14					'Store global 13    %13g'						#(#storeGlobal 1 #globalImplicit 13)
"5E"		#storeGlobal15					'Store global 14    %14g'						#(#storeGlobal 1 #globalImplicit 14)
"5F"		#storeGlobal16					'Store global 15    %15g'						#(#storeGlobal 1 #globalImplicit 15)
"60"		#pushInteger1					'Push integer 1'								#(#pushInteger 1 #integerImplicit 1)
"61"		#pushInteger2					'Push integer 2'								#(#pushInteger 1 #integerImplicit 2)
"62"		#pushInteger3					'Push integer 3'								#(#pushInteger 1 #integerImplicit 3)
"63"		#pushInteger4					'Push integer 4'								#(#pushInteger 1 #integerImplicit 4)
"64"		#pushInteger5					'Push integer 5'								#(#pushInteger 1 #integerImplicit 5)
"65"		#pushInteger6					'Push integer 6'								#(#pushInteger 1 #integerImplicit 6)
"66"		#pushInteger7					'Push integer 7'								#(#pushInteger 1 #integerImplicit 7)
"67"		#pushInteger8					'Push integer 8'								#(#pushInteger 1 #integerImplicit 8)
"68"		#pushInteger9					'Push integer 9'								#(#pushInteger 1 #integerImplicit 9)
"69"		#pushInteger10					'Push integer 10'								#(#pushInteger 1 #integerImplicit 10)
"6A"		#pushInteger11					'Push integer 11'								#(#pushInteger 1 #integerImplicit 11)
"6B"		#pushInteger12					'Push integer 12'								#(#pushInteger 1 #integerImplicit 12)
"6C"		#pushInteger13					'Push integer 13'								#(#pushInteger 1 #integerImplicit 13)
"6D"		#pushInteger14					'Push integer 14'								#(#pushInteger 1 #integerImplicit 14)
"6E"		#pushInteger15					'Push integer 15'								#(#pushInteger 1 #integerImplicit 15)
"6F"		#pushInteger16					'Push integer 16'								#(#pushInteger 1 #integerImplicit 16)
"70"		#pushInteger0					'Push integer 0'								#(#pushInteger 1 #integerImplicit 0)
"71"		#'pushInteger-1'				'Push integer -1'								#(#pushInteger 1 #integerImplicit -1)
"72"		#'pushInteger-2'				'Push integer -2'								#(#pushInteger 1 #integerImplicit -2)
"73"		#'pushInteger-3'				'Push integer -3'								#(#pushInteger 1 #integerImplicit -3)
"74"		#'pushInteger-4'				'Push integer -4'								#(#pushInteger 1 #integerImplicit -4)
"75"		#'pushInteger-5'				'Push integer -5'								#(#pushInteger 1 #integerImplicit -5)
"76"		#'pushInteger-6'				'Push integer -6'								#(#pushInteger 1 #integerImplicit -6)
"77"		#'pushInteger-7'				'Push integer -7'								#(#pushInteger 1 #integerImplicit -7)
"78"		#'pushInteger-8'				'Push integer -8'								#(#pushInteger 1 #integerImplicit -8)
"79"		#'pushInteger-9'				'Push integer -9'								#(#pushInteger 1 #integerImplicit -9)
"7A"		#'pushInteger-10'				'Push integer -10'								#(#pushInteger 1 #integerImplicit -10)
"7B"		#'pushInteger-11'				'Push integer -11'								#(#pushInteger 1 #integerImplicit -11)
"7C"		#'pushInteger-12'				'Push integer -12'								#(#pushInteger 1 #integerImplicit -12)
"7D"		#'pushInteger-13'				'Push integer -13'								#(#pushInteger 1 #integerImplicit -13)
"7E"		#'pushInteger-14'				'Push integer -14'								#(#pushInteger 1 #integerImplicit -14)
"7F"		#'pushInteger-15'				'Push integer -15'								#(#pushInteger 1 #integerImplicit -15)
"80"		#pushLiteral1					'Push %0l'										#(#pushLiteral 1 #literalImplicit 0)
"81"		#pushLiteral2					'Push %1l'										#(#pushLiteral 1 #literalImplicit 1)
"82"		#pushLiteral3					'Push %2l'										#(#pushLiteral 1 #literalImplicit 2)
"83"		#pushLiteral4					'Push %3l'										#(#pushLiteral 1 #literalImplicit 3)
"84"		#pushLiteral5					'Push %4l'										#(#pushLiteral 1 #literalImplicit 4)
"85"		#pushLiteral6					'Push %5l'										#(#pushLiteral 1 #literalImplicit 5)
"86"		#pushLiteral7					'Push %6l'										#(#pushLiteral 1 #literalImplicit 6)
"87"		#pushLiteral8					'Push %7l'										#(#pushLiteral 1 #literalImplicit 7)
"88"		#pushLiteral9					'Push %8l'										#(#pushLiteral 1 #literalImplicit 8)
"89"		#pushLiteral10					'Push %9l'										#(#pushLiteral 1 #literalImplicit 9)
"8A"		#pushLiteral11					'Push %10l'										#(#pushLiteral 1 #literalImplicit 10)
"8B"		#pushLiteral12					'Push %11l'										#(#pushLiteral 1 #literalImplicit 11)
"8C"		#pushLiteral13					'Push %12l'										#(#pushLiteral 1 #literalImplicit 12)
"8D"		#pushLiteral14					'Push %13l'										#(#pushLiteral 1 #literalImplicit 13)
"8E"		#pushLiteral15					'Push %14l'										#(#pushLiteral 1 #literalImplicit 14)
"8F"		#pushLiteral16					'Push %15l'										#(#pushLiteral 1 #literalImplicit 15)
"90"		#pushTrue						'Push true'										#(pushTrue 1)
"91"		#pushFalse						'Push false'									#(pushFalse 1)
"92"		#pushNil						'Push nil'										#(pushNil 1)
"93"		#pushSelf						'Push self'										#(pushSelf 1)
"94"		#pushInstVar					'Push inst var %1ui'							#(pushInstVar 2 #instVarOneByte)
"95"		#pushInstVarExtended			'Push inst var %2ui'							#(pushInstVar 3 #instVarTwoBytes)
"96"		#pushLocal						'Push local %1ut'								#(pushLocal 2 #localOneByte)
"97"		#pushLocalExtended				'Push local %2ut'								#(pushLocal 3 #localTwoBytes)
"98"		#pushLocalIndirect				'Push local indirect %1uI %1uI'					#(pushLocalIndirect 3 #indirectLocalOneByte #indirectLocalVariableOneByte)
"99"		#pushLocalIndirectExtended		'Push Local Indirect %4L'						#(pushLocalIndirect 5 #indirectLocalTwoBytes #indirectLocalVariableTwoBytes)
"9A"		#pushGlobal						'Push global %1ug'								#(pushGlobal 2 #globalOneByte)
"9B"		#pushGlobalExtended				'Push global %2ug'								#(pushGlobal 3 #globalTwoBytes)
"9C"		#pushLiteral					'Push %1ul'										#(pushLiteral 2 #literalOneByte)
"9D"		#pushLiteralExtended			'Push %2ul'										#(pushLiteral 3 #literalTwoBytes)
"9E"		#pushOneByteInteger				'Push integer %1bI'								#(pushInteger 2 #integerOneByte)
"9F"		#pushTwoByteInteger				'Push integer %2bI'								#(pushInteger 3 #integerTwoBytes)
"A0"		#pushFourByteInteger			'Push integer %4bI'								#(pushInteger 5 #integerFourBytes)

"A1"		#pushCopyingBlock				'Push Copying Block %1ul %1uI'					#(pushCopyingBlock 3 #literalOneByte #unsignedOneByte)
"A2"		#pushFullBlock					'Push Full Block %1ul %1uI'						#(pushFullBlock 3 #literalOneByte #unsignedOneByte)

"A3"		#storeInstVar					'Store inst var %ui'							#(storeInstVar 2 #instVarOneByte)
"A4"		#storeInstVarExtended			'Store inst var %2ui'							#(storeInstVar 3 #instVarTwoBytes)
"A5"		#storeLocal						'Store local %ut'								#(storeLocal 2 #localOneByte)
"A6"		#storeLocalExtended				'Store local %u2t'								#(storeLocal 2 #localTwoBytes)
"A7"		#storeLocalIndirect				'Store Local Indirect local %1uI index %1uI'	#(storeLocalIndirect 3 #indirectLocalOneByte #unsignedOneByte)
"A8"		#storeLocalIndirectExtended		'Store Local Indirect %2uI %2uI'				#(storeLocalIndirect 5 #indirectLocalTwoBytes #unsignedTwoBytes)
"A9"		#storeGlobal					'Store global %ug'								#(storeGlobal 2 #globalOneByte)
"AA"		#storeGlobalExtended			'Store global %2ug'								#(storeGlobal 2 #globalTwoBytes)
"AB"		#storeNewArray					'Store New Array size %1uI local %1uI'			#(storeNewArray 3 #sizeOneByte #localOneByte)

"AC"		#pop							'Pop'											#(pop 1)
"AD"		#dup							'Dup'											#(dup 1)
"AE"		#dropCascadeReceiver			'Drop Cascade Receiver'							#(dropCascadeReceiver 1)
"AF"		#undefined						'' 									#(undefined 0)
"B0"		#jump							'Jump %bo'										#(jump 2 #offsetOneByte)
"B1"		#jumpExtended					'Jump %2bo'										#(jump 3 #offsetTwoBytes)
"B2"		#jumpIfTrue						'Jump if true %bo'								#(jumpIfTrue 2 #offsetOneByte)
"B3"		#jumpIfTrueExtended				'Jump if true %2bo'								#(jumpIfTrue 3 #offsetTwoBytes)
"B4"		#jumpIfFalse					'Jump if false %bo'								#(jumpIfFalse 2 #offsetOneByte)
"B5"		#jumpIfFalseExtended			'Jump if false %2bo'							#(jumpIfFalse 3 #offsetTwoBytes)
"B6"		#pushThisContext				'Push this context'								#(pushThisContext 1)
"B7"		#pushSelfInstvarIndirect			'Push self instvar indirect %1uI %1uI' 			#(pushSelfInstvarIndirect 3 #indirectLocalOneByte #indirectLocalVariableOneByte)
"B8"		#undefined						'' 									#(undefined 0)
"B9"		#storeSelfInstVarIndirect			'Store self instvar indirect %1uI %1uI' 			#(storeSelfInstvarIndirect 3 #indirectLocalOneByte #indirectLocalVariableOneByte)
"BA"		#undefined						'' 									#(undefined 0)
"BB"		#undefined						'' 									#(undefined 0)
"BC"		#undefined						'' 									#(undefined 0)
"BD"		#undefined						'' 									#(undefined 0)
"BE"		#undefined						'' 									#(undefined 0)
"BF"		#undefined						'' 									#(undefined 0)

"C0"		#callLiteral1					'Call %0l args %1bI'							#(#call 2 #literalImplicit 0 #argumentOneByte)
"C1"		#callLiteral2					'Call %1l args %1bI'							#(#call 2 #literalImplicit 1 #argumentOneByte)
"C2"		#callLiteral3					'Call %2l args %1bI'							#(#call 2 #literalImplicit 2 #argumentOneByte)
"C3"		#callLiteral4					'Call %3l args %1bI'							#(#call 2 #literalImplicit 3 #argumentOneByte)
"C4"		#callLiteral5					'Call %4l args %1bI'							#(#call 2 #literalImplicit 4 #argumentOneByte)
"C5"		#callLiteral6					'Call %5l args %1bI'							#(#call 2 #literalImplicit 5 #argumentOneByte)
"C6"		#callLiteral7					'Call %6l args %1bI'							#(#call 2 #literalImplicit 6 #argumentOneByte)
"C7"		#callLiteral8					'Call %7l args %1bI'							#(#call 2 #literalImplicit 7 #argumentOneByte)
"C8"		#callLiteral9					'Call %8l args %1bI'							#(#call 2 #literalImplicit 8 #argumentOneByte)
"C9"		#callLiteral10					'Call %9l args %1bI'							#(#call 2 #literalImplicit 9 #argumentOneByte)
"CA"		#callLiteral11					'Call %10l args %1bI'							#(#call 2 #literalImplicit 10 #argumentOneByte)
"CB"		#callLiteral12					'Call %11l args %1bI'							#(#call 2 #literalImplicit 11 #argumentOneByte)
"CC"		#callLiteral13					'Call %12l args %1bI'							#(#call 2 #literalImplicit 12 #argumentOneByte)
"CD"		#callLiteral14					'Call %13l args %1bI'							#(#call 2 #literalImplicit 13 #argumentOneByte)
"CE"		#callLiteral15					'Call %14l args %1bI'							#(#call 2 #literalImplicit 14 #argumentOneByte)
"CF"		#callLiteral16					'Call %15l args %1bI'							#(#call 2 #literalImplicit 15 #argumentOneByte)
"D0"		#superCallLiteral1				'Super call %0l args %1bI'						#(#super 2 #literalImplicit 0 #argumentOneByte)
"D1"		#superCallLiteral2				'Super call %1l args %1bI'						#(#super 2 #literalImplicit 1 #argumentOneByte)
"D2"		#superCallLiteral3				'Super call %2l args %1bI'						#(#super 2 #literalImplicit 2 #argumentOneByte)
"D3"		#superCallLiteral4				'Super call %3l args %1bI'						#(#super 2 #literalImplicit 3 #argumentOneByte)
"D4"		#superCallLiteral5				'Super call %4l args %1bI'						#(#super 2 #literalImplicit 4 #argumentOneByte)
"D5"		#superCallLiteral6				'Super call %5l args %1bI'						#(#super 2 #literalImplicit 5 #argumentOneByte)
"D6"		#callWellKnown					'Call well known %1bw'							#(callWellKnown 2 #oneByteWellKnown)
"D7"		#callLiteral					'Call %1ul args %1bI'							#(call 3 #literalOneByte #argumentOneByte)
"D8"		#callLiteralExtended			'Call literal %2ul args %1bI'					#(call 4 #literalTwoBytes #argumentOneByte)
"D9"		#callSuperLiteral				'Super call %ul args %1bI'						#(super 3 #literalOneByte #argumentOneByte)
"DA"		#superCallLiteralExtended		'Super call %2ul args %1bI'						#(super 4 #literalTwoBytes #argumentOneByte)
"DB"		#callPrimitive					'Primitive %2uI'								#(primitive 3 #unsignedTwoBytes)
"DC"		#return							'Return'										#(return 1)
"DD"		#blockReturn					'Block Return'									#(blockReturn 1)
"DE"		#nonLocalReturn					'Non local return' 								#(nonLocalReturn 1)
"DF"		#primitiveReturn				'Primitive Return'								#(primitiveReturn 1)

"E0"		#callLiteralBreak1				'Call with break %0l args %1bI'					#(#call 2 #literalImplicit 0 #argumentOneByte)
"E1"		#callLiteralBreak2				'Call with break %1l args %1bI'					#(#call 2 #literalImplicit 1 #argumentOneByte)
"E2"		#callLiteralBreak3				'Call with break %2l args %1bI'					#(#call 2 #literalImplicit 2 #argumentOneByte)
"E3"		#callLiteralBreak4				'Call with break %3l args %1bI'					#(#call 2 #literalImplicit 3 #argumentOneByte)
"E4"		#callLiteralBreak5				'Call with break %4l args %1bI'					#(#call 2 #literalImplicit 4 #argumentOneByte)
"E5"		#callLiteralBreak6				'Call with break %5l args %1bI'					#(#call 2 #literalImplicit 5 #argumentOneByte)
"E6"		#callLiteralBreak7				'Call with break %6l args %1bI'					#(#call 2 #literalImplicit 6 #argumentOneByte)
"E7"		#callLiteralBreak8				'Call with break %7l args %1bI'					#(#call 2 #literalImplicit 7 #argumentOneByte)
"E8"		#callLiteralBreak9				'Call with break %8l args %1bI'					#(#call 2 #literalImplicit 8 #argumentOneByte)
"E9"		#callLiteralBreak10				'Call with break %9l args %1bI'					#(#call 2 #literalImplicit 9 #argumentOneByte)
"EA"		#callLiteralBreak11				'Call with break %10l args %1bI'				#(#call 2 #literalImplicit 10 #argumentOneByte)
"EB"		#callLiteralBreak12				'Call with break %11l args %1bI'				#(#call 2 #literalImplicit 11 #argumentOneByte)
"EC"		#callLiteralBreak13				'Call with break %12l args %1bI'				#(#call 2 #literalImplicit 12 #argumentOneByte)
"ED"		#callLiteralBreak14				'Call with break %13l args %1bI'				#(#call 2 #literalImplicit 13 #argumentOneByte)
"EE"		#callLiteralBreak15				'Call with break %14l args %1bI'				#(#call 2 #literalImplicit 14 #argumentOneByte)
"EF"		#callLiteralBreak16				'Call with break %15l args %1bI'				#(#call 2 #literalImplicit 15 #argumentOneByte)
"F0"		#superCallLiteralBreak1			'Super call with break %0l args %1bI'			#(#super 2 #literalImplicit 0 #argumentOneByte)
"F1"		#superCallLiteralBreak2			'Super call with break %1l args %1bI'			#(#super 2 #literalImplicit 1 #argumentOneByte)
"F2"		#superCallLiteralBreak3			'Super call with break %2l args %1bI'			#(#super 2 #literalImplicit 2 #argumentOneByte)
"F3"		#superCallLiteralBreak4			'Super call with break %3l args %1bI'			#(#super 2 #literalImplicit 3 #argumentOneByte)
"F4"		#superCallLiteralBreak5			'Super call with break %4l args %1bI'			#(#super 2 #literalImplicit 4 #argumentOneByte)
"F5"		#superCallLiteralBreak6			'Super call with break %5l args %1bI'			#(#super 2 #literalImplicit 5 #argumentOneByte)
"F6"		#callWellKnownBreak				'Call well known with break %1bw'				#(callWellKnown 2 #oneByteWellKnown)
"F7"		#callLiteralBreak				'Call with break %1ul args %1bI'				#(call 3 #literalOneByte #argumentOneByte)
"F8"		#callLiteralExtendedBreak		'Call literal with break %2ul args %1bI'		#(call 4 #literalTwoBytes #argumentOneByte)
"F9"		#callSuperLiteralBreak			'Super call with break %ul args %1bI'			#(super 3 #literalOneByte #argumentOneByte)
"FA"		#superCallLiteralExtendedBreak	'Super call with break %2ul args %1bI'			#(super 4 #literalTwoBytes #argumentOneByte)
"FB"		#callPrimitiveBreak				'Primitive with break %2uI'						#(primitive 3 #unsignedTwoBytes)
"FC"		#returnBreak					'Return with break'								#(return 1)
"FD"		#blockReturnBreak				'Block Return with break'						#(blockReturn 1)
"FE"		#nonLocalReturnBreak			'Non local return with break' 					#(nonLocalReturn 1)
"FF"		#primitiveReturnBreak			'Primitive Return with break'					#(primitiveReturn 1)
	) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator class methodsFor: 'instance creation'] value ! !
! CodeGenerator class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeGenerator class methodsFor: 'instance creation'] value ! !
! CodeGenerator class methodsFor: 'instance creation' !
specialSelectors

	^#(
"00"		+
"01"		-
"02"		*
"03"		not
"04"		==
"05"		~~
"06"		=
"07"		~=
"08"		isNil
"09"		notNil
"0A"		>
"0B"		<
"0C"		>=
"0D"		<=
"0E"		evaluate:
"0F"		printString
"10"		raiseSignal
"11"		perform:withArguments:
"12"		primitiveHalt
"13"		debugIt:
"14"		evaluateJsonString:
) ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
numArgs

	^self rootNode header selector numArgs ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
numTempsOnly

	^self localsNeededFor: self rootNode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
rootNode

	^rootNode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
rootNode: anObject

	rootNode := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopeStack

	^scopeStack ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopeStack: anObject

	scopeStack := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopes

	^scopes ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'accessing'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'accessing' !
scopes: anObject

	scopes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'initialize-release'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'initialize-release' !
initialize

	scopes := Dictionary new.
	scopeStack := OrderedCollection new. ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
argumentsFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
copiedVariablesFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope copiedVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
findVariableDefinition: aVariable

	^self scopes detect: [:eachScope | eachScope definesVariable: aVariable] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
localsNeededFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope localsNeeded ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
localsToCopyFor: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
scopeFor: aNode

	^self scopes at: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
temporariesFor: aNode

	| scope |

	scope := self scopeFor: aNode.
	^scope temporaryVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
variableNumberOf: aVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'utility'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'utility' !
variableNumberOf: aVariable inNode: aNode

	^(self scopeFor: aNode) variableNumberOf: aVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
declareSelf

	| scope variable |

	variable := SelfVariable new.
	scope := self findVariableDefinition: variable.
	scope = scopeStack last
		ifFalse: [scopeStack last addCopiedVariable: variable] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
endBlockNode: aNode

	self scopeStack removeLast ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
startBlockNode: aNode

	self scopeStack add: (ScopeAnalysisResult new 
		parent: self scopeStack last;
		node: aNode;
		yourself).
	self scopes at: aNode put: self scopeStack last ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBinaryHeader: aNode

	self scopeStack last addArgument: aNode argument ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBlockLiteralNode: aNode

	self startBlockNode: aNode.
	aNode acceptVisitor: self.
	self endBlockNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBlockNode: aNode

	(aNode statements isNil or: [aNode statements statements isEmpty]) ifTrue: [
		self declareSelf] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitBlockParameterListNode: aNode

	aNode variables do: [:eachVariable | self scopeStack last addArgument: eachVariable] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitInstanceVariableAssignmentNode: aNode

	self declareSelf.
	super visitInstanceVariableAssignmentNode: aNode. ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitInstanceVariableReferenceNode: aNode

	self declareSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitKeywordHeader: aNode

	aNode arguments do: [:eachArgument |
		self scopeStack last addArgument: eachArgument] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitLocalVariableAssignmentNode: aNode

	| variable scope |

	aNode value acceptVisitor: self.
	variable := aNode variable.
	variable isArgument ifTrue: [
		^self error: 'Can''t assign to an argument'].

	scope := self findVariableDefinition: variable.
	scope = scopeStack last ifFalse: [
		scopeStack last makeIndirect: variable inScope: scope] ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitLocalVariableReferenceNode: aNode

	| variable scope |

	variable := aNode variable.

	scope := self findVariableDefinition: variable.
	scope = scopeStack last ifTrue: [^self].
	
	variable isArgument
		ifTrue: [^scopeStack last addCopiedVariable: variable].

	scopeStack last makeIndirect: variable inScope: scope ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitMethodNodeStart: aNode

	self scopeStack add: (ScopeAnalysisResult new node: aNode; yourself).
	self scopes at: aNode put: self scopeStack last.
	self rootNode: aNode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitReturnNode: aNode

	self scopeStack size = 1 ifTrue: [^self].
	self scopeStack last markReturns ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitSpecialNode: aNode

	| specialName |

	specialName := aNode special.
	(specialName = 'self' or: [specialName = 'super']) ifFalse: [^self].

	self declareSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling'] value ! !
! MethodLocalVariableAnalysisVisitor methodsFor: 'visitor handling' !
visitStatementListStart: aNode

	aNode variables do: [:eachVariable |
		self scopeStack last addTemporaryVariable: eachVariable] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'accessing'] value ! !
! Parser methodsFor: 'accessing' !
currentRule

	^currentRule ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'accessing'] value ! !
! Parser methodsFor: 'accessing' !
currentRule: anObject

	currentRule := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'accessing'] value ! !
! Parser methodsFor: 'accessing' !
errorMessage

	^self currentRule errorString ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'accessing'] value ! !
! Parser methodsFor: 'accessing' !
result

	^self currentRule result ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'error handling'] value ! !
! Parser methodsFor: 'error handling' !
commitAndFailWithMessage: aString if: aBlock

	self currentRule commitAndFailWithMessage: aString if: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'error handling'] value ! !
! Parser methodsFor: 'error handling' !
commitWithMessage: aString if: aBlock

	self currentRule commitWithMessage: aString if: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
oneOf: aBlock

	self currentRule choice: [
		self
			rule: OneOfParserRule new;
			process: aBlock] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
oneOrMore: aBlock

	self currentRule choice: [
		self
			rule: OneOrMoreParserRule new;
			process: aBlock] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
optional: aBlock

	self currentRule choice: [
		self
			rule: OptionalParserRule new;
			process: aBlock] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
parse: aBlock

	self currentRule parse: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
produce: aBlock

	self currentRule produceBlock: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
sequence: aBlock

	self currentRule choice: [
		self
			rule: SequenceParserRule new;
			process: aBlock] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
token: aClass

	self currentRule choice: [
		self rule: (TokenRule new
			tokenStream: self currentRule tokenStream;
			yourself).
		self currentRule token: aClass] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
token: aClass produce: aBlock

	self currentRule choice: [
		self rule: (TokenRule new produceBlock: aBlock; yourself).
		self currentRule token: aClass] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'helping'] value ! !
! Parser methodsFor: 'helping' !
zeroOrMore: aBlock

	self currentRule choice: [
		self
			rule: ZeroOrMoreParserRule new;
			process: aBlock] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'rules'] value ! !
! Parser methodsFor: 'rules' !
fail

	self currentRule parentRule isNil ifTrue: [^self].

	self currentRule parentRule fail: self currentRule.
	self currentRule: self currentRule parentRule ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'rules'] value ! !
! Parser methodsFor: 'rules' !
initialRule: aHelper

	aHelper parser: self.
		
	self currentRule: aHelper ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'rules'] value ! !
! Parser methodsFor: 'rules' !
pass

	self currentRule parentRule pass: self currentRule.
	self currentRule: self currentRule parentRule ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'rules'] value ! !
! Parser methodsFor: 'rules' !
process: aBlock

	self currentRule process: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'rules'] value ! !
! Parser methodsFor: 'rules' !
rule: aRule

	aRule
		parser: self;
		parentRule: self currentRule;
		tokenStream: (self currentRule tokenStream) copy.

	self currentRule: aRule ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'setup'] value ! !
! Parser methodsFor: 'setup' !
tokens: anArray

	self initialRule: (RootRule new
		tokenStream: anArray readStream;
		yourself) ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'testing'] value ! !
! Parser methodsFor: 'testing' !
atEnd

	^self currentRule tokenStream atEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'testing'] value ! !
! Parser methodsFor: 'testing' !
isFinished

	^self atEnd and: [self isRootRule] ! !
! Doit class methodsFor: 'doit' !
doit ^[Parser methodsFor: 'testing'] value ! !
! Parser methodsFor: 'testing' !
isRootRule

	^self currentRule isMemberOf: RootRule ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseArray
	"array ::= OPENSQUAREBRACKET objectSequence CLOSESQUAREBRACKET"

	self sequence: 
			[self
				token: OpenSquareBracketToken;
				zeroOrMore: [self parse: [self parseObjectSequence]];
				token: CloseSquareBracketToken;
				produce: [:rule | (rule sequence at: 2) sequence first asArray]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseDictionary
	"dictionary ::= OPENBRACE keyValueSequence CLOSEBRACE"

	self sequence: 
			[self
				token: OpenBraceToken;
				parse: [self parseOptionalKeyValueSequence];
				token: CloseBraceToken;
				produce: [:rule |
					| dictionary |
					dictionary := Dictionary new.
					(rule sequence at: 2) do: [:assoc | dictionary at: assoc key put: assoc value].
					dictionary]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseKeyValuePair
	"keyValuePair ::= STRING COLON object"

	self sequence: 
			[self
				token: StringToken;
				token: ColonToken;
				parse: [self parseObject];
				produce: [:rule | rule sequence first token value -> (rule sequence at: 3)]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseKeyValueSequence
	"keyValuePair (COMMA keyValuePair)*"

	self sequence: 
			[self
				parse: [self parseKeyValuePair];
				optional: [
					self sequence: [
						self token: CommaToken;
						parse: [self parseKeyValueSequence]]];
				produce: [:rule |
					rule sequence size = 1
						ifTrue: [rule sequence]
						ifFalse: [((rule sequence at: 2) sequence at: 2) addFirst: rule sequence first; yourself]]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseObject
	"object ::= primitiveObject | array | dictionary"

	self oneOf: 
			[self
				parse: [self parsePrimitiveObject];
				parse: [self parseArray];
				parse: [self parseDictionary];
				produce: [:rule | rule result]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseObjectSequence
	"objectSequence ::= object (COMMA object)*"

	self sequence: 
			[self
				parseObject;
				optional: [
					self sequence: [
						self token: CommaToken;
							parse: [self parseObjectSequence]]];
				produce: [:rule |
					rule sequence size = 1
						ifTrue: [rule sequence]
						ifFalse: [((rule sequence at: 2) sequence at: 2) addFirst: rule sequence first; yourself]]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parseOptionalKeyValueSequence
	"parseKeyValueSequence?"

	self
		optional: [self parseKeyValueSequence];
		produce: [:rule | rule result] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser methodsFor: 'parsing'] value ! !
! JSONParser methodsFor: 'parsing' !
parsePrimitiveObject
	"primitiveObject ::= special | integer | float | string"

	self oneOf: 
			[self
				token: SpecialWordToken;
				token: IntegerToken;
				token: FloatToken;
				token: StringToken;
				produce: [:rule | rule result token value]] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser class methodsFor: 'evaluating'] value ! !
! JSONParser class methodsFor: 'evaluating' !
evaluate: aCollection

	^JSONEvaluator new evaluate: aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser class methodsFor: 'evaluating'] value ! !
! JSONParser class methodsFor: 'evaluating' !
evaluate: aCollection inSession: aSession

	^JSONEvaluator new
		webSession: aSession;
		evaluate: aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser class methodsFor: 'evaluating'] value ! !
! JSONParser class methodsFor: 'evaluating' !
evaluateJsonString: aString

	^self evaluate: (self parseString: aString) ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONParser class methodsFor: 'instance creation'] value ! !
! JSONParser class methodsFor: 'instance creation' !
parseString: aString
	^(self new
		tokens: (JSONLexicalAnalyzer on: aString readStream) tokens;
		parseObject) result ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
errorString

	^errorString ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
errorString: anObject

	errorString := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
parentRule

	^parentRule ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
parentRule: anObject

	parentRule := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
parser

	^parser ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
parser: anObject

	parser := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
produceBlock

	^produceBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
produceBlock: anObject

	produceBlock := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
result

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
result: anObject

	result := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
tokenStream

	^tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'accessing'] value ! !
! ParserRule methodsFor: 'accessing' !
tokenStream: anObject

	tokenStream := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'error handling'] value ! !
! ParserRule methodsFor: 'error handling' !
commitAndFailWithMessage: aString if: aBlock

	(aBlock value: self) ifTrue: [
		| start end affectedToken |
		start := end := 0.
		affectedToken := tokenStream peek ifNil: [tokenStream previous].

		(affectedToken notNil and: [affectedToken startSourceOffset notNil]) ifTrue: [
			start := affectedToken startSourceOffset].

		(affectedToken notNil and: [affectedToken endSourceOffset notNil]) ifTrue: [
			end := affectedToken endSourceOffset].

		CompileError new
			startSourceOffset: start;
			endSourceOffset: end;			
			message: (aString copyReplaceAll: '%t' with: affectedToken value asString);
			raiseSignal.

		self fail: self]  ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'error handling'] value ! !
! ParserRule methodsFor: 'error handling' !
commitWithMessage: aString if: aBlock

	| affectedToken start end |

	start := end := 0.
	affectedToken := tokenStream previous ifNil: [tokenStream peek].

	(affectedToken notNil and: [affectedToken startSourceOffset notNil]) ifTrue: [
		start := affectedToken startSourceOffset].

	(affectedToken notNil and: [affectedToken endSourceOffset notNil]) ifTrue: [
		end := affectedToken endSourceOffset].

	(aBlock value: self) ifTrue: [self errorString: (CompileError new
		message: aString;
		startSourceOffset: start;
		endSourceOffset: end;
		yourself)]  ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'pass and fail'] value ! !
! ParserRule methodsFor: 'pass and fail' !
fail

	self parser fail ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'pass and fail'] value ! !
! ParserRule methodsFor: 'pass and fail' !
fail: aRule

	aRule errorString notNil ifTrue: [
		self errorString: aRule errorString] ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'pass and fail'] value ! !
! ParserRule methodsFor: 'pass and fail' !
pass

	self produceBlock ifNotNil: [:block | self result: (block value: self)].
	self parser pass ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'pass and fail'] value ! !
! ParserRule methodsFor: 'pass and fail' !
pass: aRule ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'processing'] value ! !
! ParserRule methodsFor: 'processing' !
choice: aBlock

	aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'processing'] value ! !
! ParserRule methodsFor: 'processing' !
parse: aBlock

	self choice: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'processing'] value ! !
! ParserRule methodsFor: 'processing' !
produce: aBlock

	self result notNil ifTrue: [self result: aBlock value] ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'rules'] value ! !
! ParserRule methodsFor: 'rules' !
finished

	self errorString notNil ifTrue: [^self fail]. ! !
! Doit class methodsFor: 'doit' !
doit ^[ParserRule methodsFor: 'rules'] value ! !
! ParserRule methodsFor: 'rules' !
process: aBlock

	aBlock value.
	self finished ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOfParserRule methodsFor: 'pass and fail'] value ! !
! OneOfParserRule methodsFor: 'pass and fail' !
pass: aRule

	self
		result: aRule result;
		tokenStream: aRule tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOfParserRule methodsFor: 'processing'] value ! !
! OneOfParserRule methodsFor: 'processing' !
choice: aBlock

	self result isNil ifTrue: [aBlock value] ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOfParserRule methodsFor: 'processing'] value ! !
! OneOfParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self result isNil
		ifTrue: [self fail]
		ifFalse: [self pass] ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'accessing'] value ! !
! OneOrMoreParserRule methodsFor: 'accessing' !
nodes

	^nodes ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'accessing'] value ! !
! OneOrMoreParserRule methodsFor: 'accessing' !
nodes: anObject

	nodes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'accessing'] value ! !
! OneOrMoreParserRule methodsFor: 'accessing' !
passed

	^passed ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'accessing'] value ! !
! OneOrMoreParserRule methodsFor: 'accessing' !
passed: anObject

	passed := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'initialize-release'] value ! !
! OneOrMoreParserRule methodsFor: 'initialize-release' !
initialize

	self nodes: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'pass and fail'] value ! !
! OneOrMoreParserRule methodsFor: 'pass and fail' !
fail: aRule

	self passed: false.
	super fail: aRule ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'pass and fail'] value ! !
! OneOrMoreParserRule methodsFor: 'pass and fail' !
pass: aRule

	aRule result ifNotNil: [self nodes add: aRule result].
	self passed: true.
	self tokenStream: aRule tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'processing'] value ! !
! OneOrMoreParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self result: (SequenceNode sequence: self nodes).
	self nodes size >= 1
		ifTrue: [self pass]
		ifFalse: [self fail] ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule methodsFor: 'rules'] value ! !
! OneOrMoreParserRule methodsFor: 'rules' !
process: aBlock

	[aBlock value. self passed] whileTrue: [].
	self finished ! !
! Doit class methodsFor: 'doit' !
doit ^[OneOrMoreParserRule class methodsFor: 'instance creation'] value ! !
! OneOrMoreParserRule class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[OptionalParserRule methodsFor: 'pass and fail'] value ! !
! OptionalParserRule methodsFor: 'pass and fail' !
pass: aRule

	self
		result: aRule result;
		tokenStream: aRule tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[OptionalParserRule methodsFor: 'processing'] value ! !
! OptionalParserRule methodsFor: 'processing' !
choice: aBlock

	self result isNil ifTrue: [aBlock value] ! !
! Doit class methodsFor: 'doit' !
doit ^[OptionalParserRule methodsFor: 'processing'] value ! !
! OptionalParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self pass ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseMethodRule methodsFor: 'pass and fail'] value ! !
! ParseMethodRule methodsFor: 'pass and fail' !
pass

	self parser pass ! !
! Doit class methodsFor: 'doit' !
doit ^[PragmaNode methodsFor: 'accessing'] value ! !
! PragmaNode methodsFor: 'accessing' !
arguments

	^arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[PragmaNode methodsFor: 'accessing'] value ! !
! PragmaNode methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[PragmaNode methodsFor: 'accessing'] value ! !
! PragmaNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[PragmaNode methodsFor: 'accessing'] value ! !
! PragmaNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[PragmaNode methodsFor: 'visiting'] value ! !
! PragmaNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitPragma: self ! !
! Doit class methodsFor: 'doit' !
doit ^[PragmaNode class methodsFor: 'instance creation'] value ! !
! PragmaNode class methodsFor: 'instance creation' !
selector: selector arguments: arguments

	^self new
		selector: selector;
		arguments: arguments;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[ReturnNode methodsFor: 'accessing'] value ! !
! ReturnNode methodsFor: 'accessing' !
returnLevel

	^returnLevel ! !
! Doit class methodsFor: 'doit' !
doit ^[ReturnNode methodsFor: 'accessing'] value ! !
! ReturnNode methodsFor: 'accessing' !
returnLevel: anObject

	returnLevel := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ReturnNode methodsFor: 'accessing'] value ! !
! ReturnNode methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[ReturnNode methodsFor: 'accessing'] value ! !
! ReturnNode methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ReturnNode methodsFor: 'visiting'] value ! !
! ReturnNode methodsFor: 'visiting' !
acceptVisitor: anObject

	self value acceptVisitor: anObject.
	anObject visitReturnNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[ReturnNode class methodsFor: 'instance creation'] value ! !
! ReturnNode class methodsFor: 'instance creation' !
value: anObject

	^self new
		value: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RootRule methodsFor: 'pass and fail'] value ! !
! RootRule methodsFor: 'pass and fail' !
pass

	self parser pass ! !
! Doit class methodsFor: 'doit' !
doit ^[RootRule methodsFor: 'pass and fail'] value ! !
! RootRule methodsFor: 'pass and fail' !
pass: aRule

	result := aRule result.
	self tokenStream: aRule tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
addVariable: aVariable

	self variables add: aVariable.
	aVariable scope: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
addVariables: aCollection

	aCollection do: [:eachVariable | self addVariable: eachVariable] ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
childScopes

	^childScopes ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
childScopes: anObject

	childScopes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
parentScope

	^parentScope ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
parentScope: anObject

	parentScope := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
scopeNumber

	^scopeNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
scopeNumber: anObject

	scopeNumber := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
variableNamed: aString

	| symbol |

	symbol := aString asSymbol.
	^self variables detect: [:each | each variableName = symbol] ifNone: [nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
variableNumber: aVariable

	^self variables indexOf: aVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
variables

	^variables ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'accessing'] value ! !
! Scope methodsFor: 'accessing' !
variables: anObject

	variables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'adding'] value ! !
! Scope methodsFor: 'adding' !
addScope: aScope

	self childScopes add: aScope.
	aScope parentScope: self ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope methodsFor: 'initialize-release'] value ! !
! Scope methodsFor: 'initialize-release' !
initialize

	variables := OrderedCollection new.
	childScopes := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[Scope class methodsFor: 'instance creation'] value ! !
! Scope class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
allLocals

	^self arguments, self copiedVariables, self temporaryVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
arguments

	^arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
children

	^children ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
children: anObject

	children := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
copiedVariables

	^copiedVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
copiedVariables: anObject

	copiedVariables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
hasReturn

	^hasReturn ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
hasReturn: anObject

	hasReturn := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
indirectVariables

	^indirectVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
indirectVariables: anObject

	indirectVariables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
localVariableNames

	^self localVariables asArray collect: [:eachVariable |
		eachVariable isIndirectVariableList
			ifTrue: [eachVariable variables asArray collect: [:eachIndirectVariable | eachIndirectVariable variableName]]
			ifFalse: [eachVariable variableName]] ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
localVariables

	^self arguments, self copiedVariables, self temporaryVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
node

	^node ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
node: anObject

	node := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
numberOfArguments

	^self arguments size ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
parent

	^parent ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
parent: anObject

	parent := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
temporaryVariables

	^temporaryVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'accessing'] value ! !
! ScopeAnalysisResult methodsFor: 'accessing' !
temporaryVariables: anObject

	temporaryVariables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'adding'] value ! !
! ScopeAnalysisResult methodsFor: 'adding' !
addArgument: aVariable

	(self arguments includes: aVariable) ifTrue: [^self].
	self arguments add: aVariable. ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'adding'] value ! !
! ScopeAnalysisResult methodsFor: 'adding' !
addCopiedVariable: aVariable

	(self localVariables includes: aVariable) ifTrue: [^self].
	self parent isNil ifTrue: [^self].

	self parent addCopiedVariable: aVariable.

	self copiedVariables add: aVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'adding'] value ! !
! ScopeAnalysisResult methodsFor: 'adding' !
addTemporaryVariable: aVariable

	self temporaryVariables add: aVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'initialize-release'] value ! !
! ScopeAnalysisResult methodsFor: 'initialize-release' !
initialize

	temporaryVariables := OrderedCollection new.
	copiedVariables := OrderedCollection new.
	indirectVariables := IndirectVariableList new.
	arguments := OrderedCollection new.
	hasReturn := false ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'testing'] value ! !
! ScopeAnalysisResult methodsFor: 'testing' !
definesVariable: aVariable

	(self parent isNil and: [aVariable isSelf]) ifTrue: [^true].

	aVariable isIndirectList ifTrue: [^self indirectVariables == aVariable].

	(self temporaryVariables includes: aVariable) ifTrue: [^true].
	(self arguments includes: aVariable) ifTrue: [^true].
	(self indirectVariables variables includes: aVariable) ifTrue: [^true].
	(self copiedVariables includes: aVariable) ifTrue: [^true].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'testing'] value ! !
! ScopeAnalysisResult methodsFor: 'testing' !
variableNumberOf: aVariable

	self localVariables keysAndValuesDo: [:index :eachVariable |
		eachVariable == aVariable ifTrue: [^index].
		eachVariable isIndirectList
			ifTrue: [
				| indexInIndirect |
				indexInIndirect := eachVariable variables indexOf: aVariable.
				indexInIndirect > 0 ifTrue: [^Array with: index with: indexInIndirect] ] ].
		^0 ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'utility'] value ! !
! ScopeAnalysisResult methodsFor: 'utility' !
localsNeeded

	^self temporaryVariables size ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'utility'] value ! !
! ScopeAnalysisResult methodsFor: 'utility' !
makeIndirect: aVariable inScope: aScope

	(self indirectVariables variables includes: aVariable) ifTrue: [^self].
	(self temporaryVariables includes: aVariable) ifTrue: [
		self temporaryVariables remove: aVariable.
		self indirectVariables variables add: aVariable.
		(self temporaryVariables includes: self indirectVariables) ifFalse: [
			self temporaryVariables add: self indirectVariables].
		^aVariable indirect: true].

	aVariable isSelf ifTrue: [
		^self addCopiedVariable: aVariable].

	self parent makeIndirect: aVariable inScope: aScope.
	self addCopiedVariable: aScope indirectVariables. ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult methodsFor: 'utility'] value ! !
! ScopeAnalysisResult methodsFor: 'utility' !
markReturns

	self hasReturn: true.
	self parent notNil ifTrue: [
		self parent markReturns]. ! !
! Doit class methodsFor: 'doit' !
doit ^[ScopeAnalysisResult class methodsFor: 'instance creation'] value ! !
! ScopeAnalysisResult class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceNode methodsFor: 'accessing'] value ! !
! SequenceNode methodsFor: 'accessing' !
sequence

	^sequence ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceNode methodsFor: 'accessing'] value ! !
! SequenceNode methodsFor: 'accessing' !
sequence: anObject

	sequence := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceNode methodsFor: 'testing'] value ! !
! SequenceNode methodsFor: 'testing' !
isSequence

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceNode class methodsFor: 'instance creation'] value ! !
! SequenceNode class methodsFor: 'instance creation' !
sequence: aCollection

	^self new
		sequence: aCollection;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'accessing'] value ! !
! SequenceParserRule methodsFor: 'accessing' !
errorString: aString

	errorString := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'accessing'] value ! !
! SequenceParserRule methodsFor: 'accessing' !
rulesRun

	^rulesRun ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'accessing'] value ! !
! SequenceParserRule methodsFor: 'accessing' !
rulesRun: anObject

	rulesRun := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'accessing'] value ! !
! SequenceParserRule methodsFor: 'accessing' !
sequence

	^sequence ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'accessing'] value ! !
! SequenceParserRule methodsFor: 'accessing' !
sequence: anObject

	sequence := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'initialize-release'] value ! !
! SequenceParserRule methodsFor: 'initialize-release' !
initialize

	allPassed := true.
	sequence := OrderedCollection new.
	rulesRun := 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'pass and fail'] value ! !
! SequenceParserRule methodsFor: 'pass and fail' !
fail: aRule

	allPassed := false.
	super fail: aRule ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'pass and fail'] value ! !
! SequenceParserRule methodsFor: 'pass and fail' !
pass: aRule

	aRule result ifNotNil: [sequence add: aRule result].
	self tokenStream: aRule tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'pass and fail'] value ! !
! SequenceParserRule methodsFor: 'pass and fail' !
tokensToExpect
	^#(#PeriodToken #CloseParenthesisToken #CloseSquareBracketToken) ,
					(self parser tokensToExpect isEmpty ifTrue: [#()] ifFalse: [Array with: self parser tokensToExpect last]) ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'processing'] value ! !
! SequenceParserRule methodsFor: 'processing' !
choice: aBlock

	rulesRun := rulesRun + 1.
	allPassed ifFalse: [^self].
	aBlock value ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'processing'] value ! !
! SequenceParserRule methodsFor: 'processing' !
finished

	self result: (SequenceNode sequence: sequence).
	allPassed
		ifTrue: [
			errorString := nil.
			self pass]
		ifFalse: [self fail] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'processing'] value ! !
! SequenceParserRule methodsFor: 'processing' !
parse: aBlock

	allPassed ifTrue: [self choice: aBlock] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'testing'] value ! !
! SequenceParserRule methodsFor: 'testing' !
allPassedSoFar

	^self sequence size = self rulesRun ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule methodsFor: 'testing'] value ! !
! SequenceParserRule methodsFor: 'testing' !
lastZeroOrMoreProducedResult

	^self sequence notEmpty
			and: [self sequence last sequence notEmpty] ! !
! Doit class methodsFor: 'doit' !
doit ^[SequenceParserRule class methodsFor: 'instance creation'] value ! !
! SequenceParserRule class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
binaryCharacters

	^'~`@%&*-+=|\?,/<>' ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
nextToken

	self skipSeparators.
	self next = self finishedCharacter ifTrue: [^nil].
	self next isAlphabetic | (self next = $_) ifTrue: [^self parseWord].
	self next = $( ifTrue: [^self parseOpenParenthesis].
	self next = $) ifTrue: [^self parseCloseParenthesis].
	self next = $[ ifTrue: [^self parseOpenSquareBracket].
	self next = $] ifTrue: [^self parseCloseSquareBracket].
	(self next = $: and: [self next2 isAlphabetic])
		ifTrue: [^self parseBlockArgument].
	(self next = $: and: [self next2 = $=]) ifTrue: [^self parseAssignment].
	(self next isDigit or: [self next = $- and: [self next2 isDigit]])
		ifTrue: [^self parseNumber].
	self next = $$ ifTrue: [^self parseCharacterLiteral].
	self next = $' ifTrue: [^self parseStringLiteral].
	(self next = $# and: [self next2 isAlphabetic or: [self next2 = $_]])
		ifTrue: [^self parseSymbolLiteral].
	(self next = $# and: [self binaryCharacters includes: self next2])
		ifTrue: [^self parseBinarySymbolLiteral].
	(self next = $# and: [self next2 = $'])
		ifTrue: [^self parseQuotedSymbolLiteral].
	(self next = $# and: [self next2 = $(]) ifTrue: [^self parseArrayLiteral].
	(self next = $# and: [self next2 = $[])
		ifTrue: [^self parseByteArrayLiteral].
	(self next = $| and: [(self binaryCharacters includes: self next2) not])
		ifTrue: [^self parseBar].
	(self next = $< and: [(self binaryCharacters includes: self next2) not])
		ifTrue: [^self parseLeftAngle].
	(self next = $> and: [(self binaryCharacters includes: self next2) not])
		ifTrue: [^self parseRightAngle].
	(self binaryCharacters includes: self next) ifTrue: [^self parseBinary].
	self next = $. ifTrue: [^self parsePeriod].
	self next = $; ifTrue: [^self parseSemicolon].
	self next = $^ ifTrue: [^self parseReturn].
	self log: 'Unknown token - ' , self next printString.
	self log: 'Parsed tokens: ' , tokens asArray printString.
	self log: 'Next: ' , (stream nextAvailable: 200).
	^self reportError: 'Unknown token' start: self position end: self position ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseArrayLiteral

	| elements |
	^self captureOffsetsIn: 
			[
			| startOffset |
			startOffset := self startSourceOffset + 1.
			self
				advance;
				advance.
			elements := self readArrayLiteralElements.
			self next = $)
				ifFalse: 
					[^self reportError: 'Missing end parenthesis' start: startOffset end: startOffset].
			self advance]
		creating: [ArrayLiteralToken new value: elements asArray]  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseAssignment

	^self captureOffsetsIn: 
			[self
				advance;
				advance]
		creating: [AssignToken new value: ':='] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBar

	^self captureOffsetsIn: [self advance] creating: [BarToken new value: #|] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBinary

	| binary |
	^self captureOffsetsIn: [binary := self readBinary]
		creating: [BinaryToken new value: binary asSymbol] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBinarySymbolLiteral

	| binary |
	^self captureOffsetsIn: 
			[self advance.
			binary := self readBinary]
		creating: [SymbolToken new value: binary asSymbol] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseBlockArgument

	| word |
	^self captureOffsetsIn: 
			[self advance.
			word := self readAlphaNumericWord]
		creating: [BlockArgumentToken new value: word] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseByteArrayLiteral

	| elements |
	^self captureOffsetsIn: [
			| startOffset |
			startOffset := self startSourceOffset + 1.
			self
				advance;
				advance.
			elements := self readByteArrayLiteralElements.
			self next = $]
				ifFalse: 
					[^self reportError: 'Missing end square bracket' start: startOffset  end: startOffset ].
			self advance]
		creating: [ByteArrayLiteralToken new value: (ByteArray withAll: elements)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseCharacterLiteral

	| character |
	^self captureOffsetsIn: 
			[self advance.
			self next = self finishedCharacter
				ifTrue: 
					[^self reportError: 'Expected a character' start: self startSourceOffset end: self position].
			character := self next.
			self advance]
		creating: [CharacterToken new value: character] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseCloseParenthesis

	^self captureOffsetsIn: [self advance]
		creating: [CloseParenthesisToken new value: $)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseCloseSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [CloseSquareBracketToken new value: $]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseLeftAngle

	^self captureOffsetsIn: [self advance]
		creating: [LeftAngleToken new value: #<] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseNumber

	| number |
	^self captureOffsetsIn: [number := self readNumber]
		creating: 
			[(number isInteger ifTrue: [IntegerToken new] ifFalse: [FloatToken new])
				value: number;
				yourself] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseOpenParenthesis

	^self captureOffsetsIn: [self advance]
		creating: [OpenParenthesisToken new value: $(] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseOpenSquareBracket

	^self captureOffsetsIn: [self advance]
		creating: [OpenSquareBracketToken new value: $[] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parsePeriod

	^self captureOffsetsIn: [self advance]
		creating: [PeriodToken new value: '.'] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseQuotedSymbolLiteral

	| string |
	^self captureOffsetsIn: 
			[self advance.
			string := self readStringLiteral.
			string isNil
				ifTrue: 
					[^self reportError: 'Missing end quote' start: self startSourceOffset end: self startSourceOffset]]
		creating: [SymbolToken new value: string asSymbol] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseReturn

	^self captureOffsetsIn: [self advance]
		creating: [ReturnToken new value: $^] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseRightAngle

	^self captureOffsetsIn: [self advance]
		creating: [RightAngleToken new value: #>] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseSemicolon

	^self captureOffsetsIn: [self advance]
		creating: [SemicolonToken new value: ';'] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseStringLiteral

	| string |
	^self captureOffsetsIn: 
			[string := self readStringLiteral.
			string isNil
				ifTrue: 
					[self reportError: 'Missing end quote' start: self startSourceOffset end: self startSourceOffset]]
		creating: [StringToken new value: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseSymbolLiteral

	| word |
	^self captureOffsetsIn: 
			[self advance.
			word := self readSymbolWord]
		creating: [SymbolToken new value: word asSymbol] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
parseWord

	| word |
	^self captureOffsetsIn: [word := self readWord]
		creating: [self wordTokenFor: word] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
readAlphaNumericWord

	| wordStream |
	wordStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^wordStream contents].
	self next isAlphaNumeric or: [self next = $_]]
			whileTrue: 
				[wordStream nextPut: self next.
				self advance].
	^wordStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
skipComment

	self advance.
	
	[self next = self finishedCharacter ifTrue: [^false].
	self next = $" and: [self next2 ~= $"]]
			whileFalse: [self advance].
	self advance.
	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
skipSeparator

	self next = self finishedCharacter ifTrue: [^false].
	self next isSeparator ifTrue: [self advance. ^true].
	self next = $" ifTrue: [^self skipComment].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'parsing'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'parsing' !
wordTokenFor: word

	(word includes: $:) ifTrue: [^KeywordToken new value: word].
	(word includes: $.)
		ifTrue: [^CompoundWordToken new value: (word tokensBasedOn: $.) asArray].
	word = 'self' ifTrue: [^SpecialWordToken new value: 'self'].
	word = 'super' ifTrue: [^SpecialWordToken new value: 'super'].
	word = 'nil' ifTrue: [^SpecialWordToken new value: 'nil'].
	word = 'true' ifTrue: [^SpecialWordToken new value: 'true'].
	word = 'false' ifTrue: [^SpecialWordToken new value: 'false'].
	word = 'thisContext' ifTrue: [^SpecialWordToken new value: 'thisContext'].
	^WordToken new value: word ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readArrayLiteralElement

	(self next isDigit or: [self next = $- and: [self next2 isDigit]])
		ifTrue: [^self parseNumber value].
	self next = $$ ifTrue: [^self parseCharacterLiteral value].
	self next = $' ifTrue: [^self parseStringLiteral value].
	(self next = $# and: [self next2 isAlphabetic])
		ifTrue: [^self parseSymbolLiteral value].
	(self next = $# and: [self next2 = $'])
		ifTrue: [^self parseQuotedSymbolLiteral value].
	(self next = $# and: [self next2 = $(])
		ifTrue: [^self parseArrayLiteral value].
	self next = $( ifTrue: [^self readSubArrayLiteral].
	self next isAlphabetic ifTrue: [
		| word |
		word := self parseWord value.
		word = 'nil' ifTrue: [^nil].
		word = 'true' ifTrue: [^true].
		word = 'false' ifTrue: [^false].
		^word asSymbol].
	(self binaryCharacters includes: self next)
		ifTrue: [^self parseBinary value asSymbol].
	^self ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readArrayLiteralElements

	| elements element |
	elements := OrderedCollection new.
	
	[self skipSeparators.
	(element := self readArrayLiteralElement) ~~ self]
			whileTrue: [elements add: element].
	^elements ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readBinary

	| binaryStream |
	binaryStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^binaryStream contents].
	self binaryCharacters includes: self next]
			whileTrue: 
				[binaryStream nextPut: self next.
				self advance].
	^binaryStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readByteArrayLiteralElement

	self next isDigit
		ifTrue: 
			[| value |
			value := self parseNumber value.
			(value between: 0 and: 255) ifTrue: [^value]].
	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readByteArrayLiteralElements

	| elements element |
	elements := OrderedCollection new.
	
	[self skipSeparators.
	(element := self readByteArrayLiteralElement) notNil]
			whileTrue: 
				["self log: 'readByteArrayLiteralElements ', element printString, ' size: ', elements size printString."
				elements add: element].
	^elements ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readCompoundWordOn: aStream

	[self next = $. and: [self next2 isAlphabetic or: [self next2 = $_]]]
		whileTrue: 
			[self advance.
			aStream
				nextPut: $.;
				nextPutAll: self readAlphaNumericWord].
	^aStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readDecimalPart: integerPart

	| value digits |
	digits := OrderedCollection new: 20.

	[self next isDigit] whileTrue: [
		digits add: self next digitValue.
		self advance].

	value := 0 asFloat.

	digits reverseDo: [:eachDigit |
		value := value / 10 asFloat + eachDigit asFloat].

	^integerPart positive
		ifTrue: [integerPart asFloat + (value / 10 asFloat)]
		ifFalse: [integerPart asFloat - (value / 10 asFloat)] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readExponent

	| value negated |
	value := 0.
	
	negated := 1.
	self next = $- ifTrue: [
		negated := -1.
		self advance].
	
	[self next isDigit] whileTrue: 
			[value := value * 10 + self next digitValue.
			self advance].
	^value * negated ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readFloatStartingWith: aNumber

	| value |
	value := aNumber asFloat.
	(self next = $. and: [self next2 isDigit])
		ifTrue: 
			[self advance.
			value := self readDecimalPart: aNumber].
	self next = $e ifFalse: [^value].
	self advance.
	^value asFloat * (10 asFloat raisedToInteger: self readExponent) ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readFloatStartingWith: aNumber sign: signNumber
	| value |
	value := aNumber asFloat.
	(self next = $. and: [self next2 isDigit])
		ifTrue: 
			[self advance.
			value := self readDecimalPart: aNumber].
	self next = $e ifFalse: [^value * signNumber].
	self advance.
	^value asFloat * (10 asFloat raisedToInteger: self readExponent) * signNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readInteger

	| number sign |
	number := 0.
	sign := 1.
	self next = $-
		ifTrue: 
			[sign := -1.
			self advance].
	[self next isDigit] whileTrue: 
			[number := number * 10 + self next digitValue.
			self advance].
	^sign * number ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readKeywordOn: aStream

	[self next = $: and: [self next2 ~= $=]] whileTrue: 
			[| nextWord |
			self advance.
			aStream nextPut: $:.
			nextWord := self readAlphaNumericWord.
			nextWord isEmpty ifTrue: [^aStream contents].
			aStream nextPutAll: nextWord].
	^aStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readNumber

	| number sign |
	sign := self next = $- ifTrue: [-1.0] ifFalse: [1.0].

	number := self readInteger.
	self next = self finishedCharacter ifTrue: [^number].
	((self next = $. and: [self next2 isDigit]) or: [self next = $e])
		ifTrue: [^self readFloatStartingWith: number abs sign: sign].
	self next = $r ifTrue: [^self readNumberRadix: number].
	^number ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readNumberRadix: radixNumber

	| radix sign number |
	self advance.
	sign := radixNumber sign.
	radix := radixNumber abs.
	number := 0.
	[self isDigit: self next radix: radix] whileTrue: 
			[number := number * radix + self next digitValue.
			self advance].
	^sign * number ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readStringLiteral

	| literalStream |
	self advance.
	literalStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^nil].
	self next = $' and: [self next2 ~= $']]
			whileFalse: 
				[literalStream nextPut: self next.
				self next = $' ifTrue: [self advance].
				self advance].
	self advance.
	^literalStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readSubArrayLiteral

	| elements |
	self advance.
	elements := self readArrayLiteralElements.
	self next = $) ifFalse: [^nil].
	self advance.
	^elements asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readSymbolWord

	| wordStream |
	wordStream := WriteStream on: String new.
	
	[self next = self finishedCharacter ifTrue: [^wordStream contents].
	self next isAlphaNumeric or: [self next = $_ or: [self next = $:]]]
			whileTrue: 
				[wordStream nextPut: self next.
				self advance].
	^wordStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkLexicalAnalyzer methodsFor: 'reading'] value ! !
! SmalltalkLexicalAnalyzer methodsFor: 'reading' !
readWord

	| wordStream |
	wordStream := WriteStream on: (String new: 100).
	wordStream nextPutAll: self readAlphaNumericWord.
	(self next = $: and: [self next2 ~= $=])
		ifTrue: [^self readKeywordOn: wordStream].
	(self next = $. and: [self next2 isAlphabetic or: [self next2 = $_]])
		ifTrue: [^self readCompoundWordOn: wordStream].
	^wordStream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
addScope: aScope

	self scopeStack notEmpty ifTrue: [self scopeStack last addScope: aScope].
	self scopeStack add: aScope.
	self scopes add: aScope.
	aScope scopeNumber: self scopeStack size ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
addScopeVariable: aScopeVariable

	self scopeStack last addVariable: aScopeVariable.
	aScopeVariable scopeNumber: self scopeStack last scopeNumber.
	^aScopeVariable ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
globalDictionaries

	^globalDictionaries ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
globalDictionaries: anObject

	globalDictionaries := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
newScope

	self addScope: Scope new ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
popScope

	scopeStack removeLast ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
scopeStack

	^scopeStack ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
scopeStack: anObject

	scopeStack := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
scopes

	^scopes ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
scopes: anObject

	scopes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
targetClass

	^targetClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
targetClass: anObject

	targetClass := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
tokensToExpect

	^tokensToExpect ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'accessing'] value ! !
! SmalltalkParser methodsFor: 'accessing' !
tokensToExpect: anObject

	tokensToExpect := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildAssignStatementList: rule

	| nextStatement |
	rule sequence size = 1 ifTrue: [^StatementListNode new
			statements: (Array with: rule sequence first);
			yourself].

	nextStatement := (rule sequence at: 2) sequence size >= 2
			ifTrue: [(rule sequence at: 2) sequence at: 2]
			ifFalse: [^StatementListNode new
				statements: (Array with: rule sequence first);
				yourself].
	(nextStatement isKindOf: StatementListNode) ifFalse: [
		^StatementListNode new
			statements: (Array with: rule sequence first with: nextStatement) ].

	^StatementListNode new
			statements: (OrderedCollection new
				add: rule sequence first;
				addAll: nextStatement statements;
				yourself) asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildBinaryExpression: rule

	| argument |
	rule result isSequence ifFalse: [^rule result].
	rule result sequence size = 1 ifTrue: [^rule result sequence first].

	argument := (rule sequence at: 2) sequence at: 2.

	^(BinaryMessageNode
			receiver: rule sequence first 
			selector: (rule sequence at: 2) sequence first token value
			argument: argument)
		startSourceOffset: (rule sequence at: 2) sequence first startSourceOffset;
		endSourceOffset: (rule sequence at: 2) sequence first endSourceOffset;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildBinaryMessageHeader: aRule

	| variable methodName |

	variable := self addScopeVariable: (LocalVariable argumentNamed: (aRule result sequence at: 2) token value asSymbol).

	methodName := aRule result sequence first token value asSymbol.
	self currentMethodName: methodName.
	^BinaryHeaderNode selector: methodName argument: variable ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildBlock: rule

	| newNode |

	newNode := BlockNode new
		scope: scopes last;
		yourself.

	rule sequence do: [:node |
		node isBlockParameterListNode ifTrue: [
			newNode arguments: node].
		(node isKindOf: StatementListNode) ifTrue: [
			newNode statements: node].
		].
	
	^newNode ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildBlockParameters: aRule

	| parameterNames variables |

	parameterNames := OrderedCollection new.
	variables:= OrderedCollection new.

	aRule sequence first sequence do: [:node |
		| variable |
		parameterNames add: node token value.
		variable := LocalVariable argumentNamed: node token value.
		variables add: variable.
		self addScopeVariable: variable].
	
	^BlockParameterListNode new
		variables: variables;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildCascadeNode: aRule

	| receiver messages |

	(aRule sequence at: 2) sequence isEmpty ifTrue: [^aRule sequence first].

	receiver := aRule sequence first receiver.
	messages := OrderedCollection new.

	messages add: aRule sequence first.
	messages first receiver: nil.

	(aRule sequence at: 2) sequence do: [:sequenceNode |
		| message |
		message := sequenceNode sequence at: 2.
		message receiver: nil.
		messages add: message].

	^CascadeNode receiver: receiver messages: messages ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildKeywordExpression: rule

	| keywordStream arguments keywordSequence |
	(keywordSequence := rule sequence at: 2) sequence isEmpty ifTrue: [^rule sequence first].

	keywordStream := WriteStream on: (String new).
	arguments := OrderedCollection new.

	keywordSequence sequence do: [:keyWordArgument |
		keywordStream nextPutAll: keyWordArgument sequence first token value.
		arguments add: (keyWordArgument sequence at: 2)].

	^(KeywordMessageNode
			receiver: rule sequence first 
			selector: keywordStream contents asSymbol
			arguments: arguments)
		startSourceOffset: keywordSequence sequence first sequence first startSourceOffset;
		endSourceOffset: keywordSequence sequence first sequence first endSourceOffset;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildKeywordMessageFrom: aRule

	| keywordStream arguments |

	keywordStream := WriteStream on: (String new).
	arguments := OrderedCollection new.
	
	aRule result sequence do: [:sequenceNode |
		keywordStream nextPutAll: sequenceNode sequence first token value.
		arguments add: (sequenceNode sequence at: 2)].

	^KeywordMessageNode
		selector: keywordStream contents asSymbol
		arguments: arguments asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildKeywordMethodHeaderFrom: aRule

	| keywordStream arguments methodName |
	arguments := OrderedCollection new.
	keywordStream := WriteStream on: String new.

	aRule nodes do: 
			[:node |
			| argument |
			argument := LocalVariable argumentNamed: (node sequence at: 2) token value.
			keywordStream nextPutAll: node sequence first token value.
			arguments add: argument.
			self addScopeVariable: argument].

	methodName := keywordStream contents asSymbol.
	self currentMethodName: methodName.
	^KeywordHeaderNode
		selector: methodName
		arguments: arguments asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildLeftToRightBinaryExpression: rule

	| binaryMessageNode |

	rule result isBinaryMessageNode ifFalse: [^rule result].

	binaryMessageNode := rule result.
	
	binaryMessageNode argument isBinaryMessageNode ifFalse: [
		^binaryMessageNode].

	[binaryMessageNode argument isBinaryMessageNode]
		whileTrue: [
			binaryMessageNode := BinaryMessageNode
				receiver: (BinaryMessageNode
					receiver:  binaryMessageNode receiver
					selector: binaryMessageNode selector
					argument: binaryMessageNode argument receiver
					startSourceOffset: binaryMessageNode startSourceOffset
					endSourceOffset:  binaryMessageNode endSourceOffset)
				selector: binaryMessageNode argument selector
				argument: binaryMessageNode argument argument
				startSourceOffset: binaryMessageNode argument startSourceOffset
				endSourceOffset: binaryMessageNode argument endSourceOffset].

	^binaryMessageNode ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildPragma: rule

	self halt ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildPragmaMessage: rule

	| keywordStream arguments |

	(rule result isKindOf: TokenNode) ifTrue: [
		^PragmaNode selector: rule result token value asSymbol arguments: #()].

	keywordStream := WriteStream on: String new.
	arguments := OrderedCollection new.

	rule result sequence do: [:keywordPair |
		keywordStream nextPutAll: keywordPair sequence first token value.
		arguments add: (keywordPair sequence at: 2) token value].

	^PragmaNode selector: keywordStream contents asSymbol arguments: arguments asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildStatementBody: rule

	rule sequence isEmpty ifTrue: [^nil].
	rule sequence size = 1 ifTrue: [^rule sequence first].

	^(rule sequence at: 2)
		variables: rule sequence first variables;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildTempVar: aRule

	| variables |

	variables := (aRule nodes collect: [:each | LocalVariable named: each token value]) asArray.
	scopes last addVariables: variables.
	^TempVarListNode variables: variables ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildUnaryMessageFor: aRule

	| object messages |

	object := aRule sequence first.
	messages := aRule sequence at: 2.
	^messages sequence isEmpty
		ifTrue: [object]
		ifFalse: 
			[messages sequence inject: object
				into: 
					[:node :each |
					(UnaryMessageNode receiver: node selector: each token value asSymbol)
						startSourceOffset: each token startSourceOffset;
						endSourceOffset: each token endSourceOffset;
						yourself]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'building'] value ! !
! SmalltalkParser methodsFor: 'building' !
buildVariableAssignNode: aRule

	| value assignmentNode |

	value := aRule sequence at: 2.

	aRule sequence first sequence reverseDo: [:assignment |
		| variableNameToken handled |
		handled := false.
		variableNameToken := assignment sequence first token.
		(self isNamespaceVariable: variableNameToken) ifTrue: [
			value := NamespaceVariableAssignmentNode nameComponents: variableNameToken value value: value.
			value
				startSourceOffset: (assignment sequence at: 1) startSourceOffset;
				endSourceOffset: (assignment sequence at: 1) endSourceOffset.
			assignmentNode := value.
			handled := true].

		(handled not and: [self isLocalVariable: variableNameToken]) ifTrue: [
			| scopeAndVariable |
			scopeAndVariable := self findLocalVariableNamed: variableNameToken value.
			value := LocalVariableAssignmentNode variable: scopeAndVariable value value: value.
			value
				startSourceOffset: (assignment sequence at: 1) startSourceOffset;
				endSourceOffset: (assignment sequence at: 1) endSourceOffset.

			scopeAndVariable key == scopeStack last ifFalse: [scopeAndVariable value indirect: true].
			assignmentNode := value.
			handled := true].

		(handled not and: [self isInstanceVariable: variableNameToken]) ifTrue: [
			value := InstanceVariableAssignmentNode variable: (InstanceVariable named: variableNameToken value) value: value.
			value
				startSourceOffset: (assignment sequence at: 1) startSourceOffset;
				endSourceOffset: (assignment sequence at: 1) endSourceOffset.
			assignmentNode := value.
			handled := true].

		(handled not and: [self isGlobalVariable: variableNameToken])
			ifTrue: [
				value := GlobalVariableAssignmentNode variable: (GlobalVariable named: variableNameToken value) value: value.
				value
					startSourceOffset: (assignment sequence at: 1) startSourceOffset;
					endSourceOffset: (assignment sequence at: 1) endSourceOffset.
				assignmentNode := value.
				handled := true] ].

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'expecting'] value ! !
! SmalltalkParser methodsFor: 'expecting' !
expectToken: aTokenClass

	self currentRule allPassedSoFar ifFalse: [^self].
	self tokensToExpect add: aTokenClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'expecting'] value ! !
! SmalltalkParser methodsFor: 'expecting' !
stopExpectingToken: aTokenClass

	self tokensToExpect removeLast ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'initialize-release'] value ! !
! SmalltalkParser methodsFor: 'initialize-release' !
initialize

	self scopeStack: OrderedCollection new.
	self scopes: OrderedCollection new.
	self globalDictionaries: OrderedCollection new.
	self tokensToExpect: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
currentMethodName
	^currentMethodName ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
currentMethodName: aSymbol
	currentMethodName := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseAssignStatement
	"assignStatement ::= ((WORD | COMPOUNDWORD) ASSIGN)* cascadeExpression"

	self sequence: [
		self zeroOrMore: [
			self sequence: [
				self
					oneOf: [
							self token: WordToken;
								token: CompoundWordToken];
					token: AssignToken]];
		commitWithMessage: 'Bad assignment' if: [:rule | rule lastZeroOrMoreProducedResult];
		parse: [self parseCascadeExpression];
		commitAndFailWithMessage: '%t not expected' if: [:rule |
			rule errorString isNil and: [
			rule tokenStream atEnd not and: [
				(rule tokensToExpect includes: rule tokenStream peek class name) not]]];
		produce: [:rule | self buildVariableAssignNode: rule] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseAssignStatementList
	"assignStatementList ::= assignStatement | (PERIOD statementList)* "

	self sequence: [self
			parse: [self parseAssignStatement];
			optional: [self
				sequence: [self
					token: PeriodToken;
					parse: [self parseStatementList ] ] ];
		produce: [:rule | self buildAssignStatementList: rule] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseBinaryExpression
	"binaryExpression ::= unaryExpression ((BINARY | BAR | LEFTANGLE | RIGHTANGLE) binaryExpression)?"

	self
		sequence: [
			self parse: [self parseUnaryExpression];
				optional: [
					self sequence: [
						self oneOf: [
							self token: BinaryToken;
								token: BarToken;
								token: LeftAngleToken;
								token: RightAngleToken];
							parse: [self parseBinaryExpression] ] ];
				produce: [:rule | self buildBinaryExpression: rule] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseBinaryMethodHeader
	"binaryMethodHeader ::= (BAR | LEFTANGLE | RIGHTANGLE | BINARY) WORD"

	self sequence: 
			[self
				oneOf: 
						[self
							token: BarToken;
							token: LeftAngleToken;
							token: RightAngleToken;
							token: BinaryToken];
				commitWithMessage: 'Invalid method header' if: [:rule | rule allPassedSoFar];
				token: WordToken;
				produce: 
						[:rule | self buildBinaryMessageHeader: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseBlock
	"block ::= OPENSQUARE  (blockParams)? statementBody CLOSESQUARE"

	self sequence: 
			[self
				token: OpenSquareBracketToken produce: [:rule | self newScope. rule result];
				commitWithMessage: 'Unmatched square bracket' if: [:rule | rule allPassedSoFar];
				optional: [self parse: [self parseBlockParams]];
				parse: [self parseStatementBody];
				token: CloseSquareBracketToken produce: [:rule | rule result];
				produce: [:rule |
					| blockNode |
					blockNode := self buildBlock: rule.
					self popScope.
					blockNode]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseBlockParams
	"blockParams ::= (BLOCKPARAM)+ BAR"

	self sequence: 
			[self
				oneOrMore: [self token: BlockArgumentToken];
				token: BarToken;
				produce: [:rule | self buildBlockParameters: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseCascadeExpression
	"cascadeExpression ::= keywordExpression (SEMICOLON cascadeMessage)*"

	self sequence: [
			self parse: [self parseKeywordExpression];
				zeroOrMore: [
					self sequence: [
						self token: SemicolonToken;
							parse: [self parseCascadeMessage] ] ];
				produce: [:rule | self buildCascadeNode: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseCascadeMessage
	"cascadeMessage ::= WORD | BAR unaryExpression | LEFTANGLE unaryExpression | RIGHTANGLE unaryExpression |
		BINARY unaryExpression | (KEYWORD leftToRightBinaryExpression)+"

	self oneOf: [
			self oneOf: [
				self token: WordToken
					produce: [:rule | 
						(UnaryMessageNode selector: rule result token value asSymbol)
						startSourceOffset: rule result token startSourceOffset;
						endSourceOffset: rule result token endSourceOffset;
						yourself] ];
			sequence: [
				self token: BarToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			sequence: [
				self token: LeftAngleToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			sequence: [
				self token: RightAngleToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			sequence: [
				self token: BinaryToken;
					parse: [self parseUnaryExpression];
					produce: [:rule |
						(BinaryMessageNode
								selector: rule sequence first token value asSymbol
								argument: (rule sequence at: 2))
							startSourceOffset: rule sequence first token startSourceOffset;
							endSourceOffset: rule sequence first token endSourceOffset;
							yourself] ];
			oneOrMore: [
				self sequence: [
					self token: KeywordToken;
						parse: [self parseLeftToRightBinaryExpression] ];
				produce: [:rule |
					(self buildKeywordMessageFrom: rule)
							startSourceOffset: rule result sequence first sequence first token startSourceOffset;
							endSourceOffset: rule result sequence first sequence first token endSourceOffset;
							yourself
					] ] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseExpression

	self parseCascadeExpression ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseKeywordExpression
	"keywordExpression ::= leftToRightBinaryExpression (KEYWORD leftToRightBinaryExpression)*"

	self
		sequence: [
			self parse: [self parseLeftToRightBinaryExpression];
				zeroOrMore: [
					self sequence: [
						self token: KeywordToken;
							parse: [self parseLeftToRightBinaryExpression] ] ];
				produce: [:rule | self buildKeywordExpression: rule] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseKeywordMethodHeader
	"keywordMethodHeader ::= (KEYWORD WORD)+"

	self oneOrMore: 
			[self
				sequence: 
						[self
							token: KeywordToken;
							commitWithMessage: 'Invalid method header' if: [:rule | rule allPassedSoFar];
							token: WordToken];
				produce: [:rule | self buildKeywordMethodHeaderFrom: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseLeftToRightBinaryExpression
	"leftToRightBinaryExpression ::= binaryExpression"

	self
		oneOf: [
			self parse: [self parseBinaryExpression];
				produce: [:rule | self buildLeftToRightBinaryExpression: rule] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseLiteral
	"literal ::= INTEGER | FLOAT | CHARACTER | ARRAY | BYTEARRAY | STRING | SYMBOL | block"

	self oneOf: 
			[self
				token: IntegerToken;
				token: FloatToken;
				token: CharacterToken;
				token: ArrayLiteralToken;
				token: ByteArrayLiteralToken;
				token: StringToken;
				token: SymbolToken;
				parse: [self parseBlock];
				produce: [:rule |
					rule result isBlockNode
						ifTrue: [BlockLiteralNode value: rule result]
						ifFalse: [(LiteralNode value: rule result token value)							startSourceOffset: rule result token startSourceOffset;							endSourceOffset: rule result token endSourceOffset;							yourself]]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseMethod
	"method ::= methodHeader pragma * statementBody"

	self newScope.

	self sequence: 
			[self
				parse: [self parseMethodHeader];
				zeroOrMore: [self parse: [self parsePragma]];
				parse: [self parseStatementBody];
				produce: [:rule |
					MethodNode
						header: rule sequence first
						pragmas: (rule sequence at: 2) sequence asArray
						body: (rule sequence size >= 3 ifTrue: [rule sequence at: 3] ifFalse: [nil])]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseMethodHeader
	"methodHeader ::= unaryMethodHeader | binaryMethodHeader | keywordMethodHeader"

	self
		oneOf: [self
				parse: [self parseUnaryMethodHeader];
				parse: [self parseBinaryMethodHeader];
				parse: [self parseKeywordMethodHeader]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseObject
	"object ::= literal | WORD | COMPOUNDWORD | SPECIALWORD | parenthesisExpression"

	self oneOf: 
			[self
				parse: [self parseLiteral];
				token: WordToken
					produce: [:rule | self createVariableReferenceFor: rule];
				token: CompoundWordToken
					produce: [:rule | NamespaceVariableReferenceNode new nameComponents: rule result token value];
				token: SpecialWordToken
					produce: [:rule |
						| token |
						token := rule result token.
						(SpecialNode special: rule result token value)
							startSourceOffset: token startSourceOffset;
							endSourceOffset: token endSourceOffset;
							yourself];
				parse: [self parseParenthesisExpression];
				produce: [:rule | rule result]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseParenthesisExpression
	"parenthesisExpression ::= OPENPAREN assignStatementList CLOSEPAREN"

	self sequence: [self
			token: OpenParenthesisToken;
			commitWithMessage: 'Unmatched parenthesis' if: [:rule | rule allPassedSoFar];
			parse: [self parseAssignStatementList];
			token: CloseParenthesisToken;
			produce: [:rule | ParenthesisNode expression: (rule sequence at: 2)] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parsePragma

	"pragma ::= LEFTANGLE pragmaMessage RIGHTANGLE"

	self sequence: [
		self token: LeftAngleToken;
			commitWithMessage: 'Bad pragma' if: [:rule | rule allPassedSoFar];
			parse: [self pragmaMessage];
			token: RightAngleToken;
			produce: [:rule | rule sequence at: 2]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseReturnStatement
	"returnStatement ::= RETURN assignStatement (PERIOD)?"

	self sequence: 
			[self
				token: ReturnToken;
				commitWithMessage: 'Bad return' if: [:rule | rule allPassedSoFar];
				parse: [self parseAssignStatement];
				optional: [self token: PeriodToken];
				produce: [:rule |
					| returnToken |
					returnToken := (rule sequence at: 2).
					(ReturnNode value: returnToken)
						startSourceOffset: rule sequence first startSourceOffset;
						endSourceOffset: rule sequence first endSourceOffset;
						yourself]]  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseStatementBody
	"statementBody ::= (tempVars)? statementList"

	self sequence: [
		self optional: [
			self parse: [self parseTempVars]];
		parse: [self parseStatementList];
		produce: [:rule | self buildStatementBody: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseStatementList
	"statementList ::= returnStatement | assignStatementList "

	self optional: [self oneOf: [self
			parse: [self parseReturnStatement
				produce: [:rule | StatementListNode statements: (Array with: rule result)] ];
			parse: [self parseAssignStatementList
				produce: [:rule | rule result] ] ] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseTempVars
	"tempVars ::= BAR (WORD)* BAR"

	self sequence: 
			[self
				token: BarToken;
				zeroOrMore: 
						[self
							token: WordToken;
							produce: [:rule | self buildTempVar: rule] ];
				token: BarToken;
				produce: [:rule | rule sequence at: 2]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseUnaryExpression
	"unaryExpression ::= object (WORD)*"

	self sequence: 
			[self
				parse: [self parseObject];
				zeroOrMore: [self token: WordToken];
				produce: [:rule | self buildUnaryMessageFor: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
parseUnaryMethodHeader
	"unaryMethodHeader ::= WORD"

	self token: WordToken
		produce: [:rule |
			| methodName |
			methodName := rule result token value asSymbol.
			self currentMethodName: methodName.
			UnaryHeaderNode selector: methodName] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
pragmaLiteral

	"pragmaLiteral ::= INTEGER | FLOAT | CHARACTER | ARRAY | BYTEARRAY | STRING | SYMBOL"

	self oneOf: [
		self token: IntegerToken;
			token: FloatToken;
			token: CharacterToken;
			token: ArrayLiteralToken;
			token: ByteArrayLiteralToken;
			token: StringToken;
			token: SymbolToken] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'parsing'] value ! !
! SmalltalkParser methodsFor: 'parsing' !
pragmaMessage

	"pragmaMessage ::= WORD | (KEYWORD pragmaLiteral)+"

	self oneOf: [
		self token: WordToken;
			oneOrMore: [self
				sequence: [self
					token: KeywordToken;
					parse: [self pragmaLiteral]]];
			produce: [:rule | self buildPragmaMessage: rule]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'testing'] value ! !
! SmalltalkParser methodsFor: 'testing' !
isGlobalVariable: aToken

	(globalDictionaries anySatisfy: [:eachDictionary |
		eachDictionary notNil and: [eachDictionary includesKey: aToken value asSymbol] ]) ifTrue: [^true].

	Undeclared at: aToken value asSymbol ifAbsentPut: [nil].

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'testing'] value ! !
! SmalltalkParser methodsFor: 'testing' !
isInstanceVariable: aToken

	^self targetClass
		ifNil: [false]
		ifNotNil: [:class | class allInstVarNames includes: aToken value asString] ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'testing'] value ! !
! SmalltalkParser methodsFor: 'testing' !
isLocalVariable: aToken

	^(self scopeAndLocalVariableFor: aToken) notNil ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'testing'] value ! !
! SmalltalkParser methodsFor: 'testing' !
isNamespaceVariable: aToken

	| value |

	(aToken isMemberOf: CompoundWordToken) ifFalse: [^false].

	value := globalDictionaries
		detect: [:eachDictionary | eachDictionary includesKey: aToken value first asSymbol ]
		ifNone: [nil].

	value isNil ifTrue: [^false].

	aToken value do: [:eachVariableName |
		value isLikeNameSpace ifFalse: [^false].
		value := value at: eachVariableName asSymbol].

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'testing'] value ! !
! SmalltalkParser methodsFor: 'testing' !
scopeAndLocalVariableFor: aToken

	scopes do: [:eachScope |
			eachScope variables do: [:eachVariable |
				eachVariable variableName = aToken value asSymbol
					ifTrue: [^eachScope -> eachVariable] ] ].
	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'variables'] value ! !
! SmalltalkParser methodsFor: 'variables' !
createVariableReferenceFor: aRule

	| variableName localVariable |

	variableName := aRule result token value asSymbol.

	localVariable := self findLocalVariableNamed: variableName.

	localVariable notNil ifTrue: [^LocalVariableReferenceNode new
		scopeNumber: localVariable key;
		variable: localVariable value;
		startSourceOffset: aRule result token startSourceOffset;
		endSourceOffset: aRule result token endSourceOffset;
		yourself].

	self targetClass ifNotNil: [
		| index variable |
		index := self targetClass allInstVarNames indexOf: variableName asString.
		variable := InstanceVariable named: variableName.
		index > 0 ifTrue: [^(InstanceVariableReferenceNode new variable: variable)
					startSourceOffset: aRule result token startSourceOffset;
					endSourceOffset: aRule result token endSourceOffset;
					yourself] ].

	^GlobalVariableReferenceNode new
		variable: (GlobalVariable named: variableName);
		startSourceOffset: aRule result token startSourceOffset;
		endSourceOffset: aRule result token endSourceOffset;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser methodsFor: 'variables'] value ! !
! SmalltalkParser methodsFor: 'variables' !
findLocalVariableNamed: variableName

	self scopeStack reverseDo: [:scope |
		(scope variableNamed: variableName) ifNotNil: [:variable |
			^scope -> variable]].

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'evaluating'] value ! !
! SmalltalkParser class methodsFor: 'evaluating' !
debugIt: aString

	self
		compile: 'doit ^[self halt. [', aString, '] value'
		inClass: Doit class
		organization: 'doit'.
	^Doit perform: #doit ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'evaluating'] value ! !
! SmalltalkParser class methodsFor: 'evaluating' !
evaluate: aString

	self
		compile: 'doit ^[', aString, '] value'
		inClass: Doit class
		organization: 'doit'.
	^Doit perform: #doit ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'evaluating'] value ! !
! SmalltalkParser class methodsFor: 'evaluating' !
evaluate: aString for: anObject

	| result |

	self
		compile: 'doit ^[', aString, '] value'
		inClass: anObject class
		organization: 'doit'.

	result := anObject perform: #doit.
	anObject class removeSelector: #doit.
	^result  ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'instance creation'] value ! !
! SmalltalkParser class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
compile: aString inClass: aClass organization: organizationString

	| method |

	method := self
		generateForClass: aClass
		methodString: aString
		organization: organizationString.
		
	(method isKindOf: String) ifTrue: [^self error: method].

	aClass methodDictionary at: method selector put: method ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
fileoutMethod: aString forClass: aClass on: changesFile

	| offset1 offset2 sourceString |
	
	aClass ifNil: [^Array with: 0 with: 0].

	changesFile
		nextPutAll: '! ', aClass name, ' methods !'; cr.

	sourceString := aString.

	offset1 := changesFile position.
	changesFile
		nextPutAll: (sourceString convertLineEndingsTo: #cr).
	
	offset2 := changesFile position.
	changesFile
		nextPutAll: ' ! !'; cr.

	^Array with: offset1 with: offset2 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
fileoutMethod: aString forClass: aClass organization: organizationString on: changesFile

	| offset1 offset2 sourceString |
	
	aClass ifNil: [^Array with: 0 with: 0].

	changesFile
		nextPutAll: '! ', aClass name, ' methodsFor: ', organizationString printString, ' !'; cr.

	sourceString := aString.

	offset1 := changesFile position.
	changesFile
		nextPutAll: (sourceString convertLineEndingsTo: #cr).
	
	offset2 := changesFile position.
	changesFile
		nextPutAll: ' ! !'; cr.

	^Array with: offset1 with: offset2 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
generateForClass: aClass globals: aCollection methodString: aString organization: organizationString writeChangesInto: aFile

	| codeGenerator parser methodOffsets |

	codeGenerator := CodeGenerator new
		targetClass: aClass;
		globalDictionaries: aCollection;
		yourself.

	parser := self parseForClass: aClass globals: aCollection methodString: aString.
	parser errorMessage isNil ifFalse: [
		^parser errorMessage raiseSignal].

	parser isFinished ifFalse: [
		| token |
		token := parser currentRule tokenStream peek.
		CompileError new
			message: (token value asString, ' not expected');
			startSourceOffset: token startSourceOffset;
			endSourceOffset: token endSourceOffset;
			raiseSignal].

	parser result acceptVisitor: codeGenerator.

	aFile isNil ifFalse: [
		methodOffsets := self fileoutMethod: aString forClass: aClass organization: organizationString on: aFile.
		aFile flush].

	^codeGenerator method
		sourceOffsets: codeGenerator sourceOffsets asArray;
		writeMethodOffsets: methodOffsets;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
generateForClass: aClass globals: aCollection organization: organizationString methodString: aString

	^self generateForClass: aClass
		globals: aCollection
		methodString: aString
		organization: organizationString
		writeChangesInto: BeagleSystem changesFile ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
generateForClass: aClass methodString: aString organization: organizationString

	^self
		generateForClass: aClass
		globals: (aClass ifNil: [nil] ifNotNil: [:class | class globalDictionaries])
		organization: organizationString
		methodString: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseBlockBody: tokens

	^self new
		tokens: tokens;
		parseStatementBody ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseBlockBodyString: aString

	^self parseBlockBody: (SmalltalkLexicalAnalyzer on: aString) tokens ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass globals: aCollection method: tokens

	^self new
		targetClass: aClass;
		globalDictionaries: (aCollection ifNil: [#()]);
		tokens: tokens;
		parseMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass globals: aCollection methodString: aString

	^self
		parseForClass: aClass
		globals: aCollection
		method: (SmalltalkLexicalAnalyzer on: aString readStream) tokens ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass method: tokens

	^self parseForClass: aClass globals: nil method: tokens ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass methodString: aString

	^self parseForClass: aClass globals: nil methodString: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseForClass: aClass selector: aSymbol

	^self parseForClass: aClass globals: nil methodString: (aClass compiledMethodAt: aSymbol) getSource ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseMethod: tokens

	^self parseForClass: nil method: tokens ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
parseMethodString: aString

	^self parseForClass: nil methodString: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
quietGenerateForClass: aClass globals: aCollection methodString: aString organization: organization

	^self generateForClass: aClass
		globals: aCollection
		methodString: aString
		organization: organization
		writeChangesInto: nil ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
quietGenerateForClass: aClass methodString: aString organization: organization

	^self
		quietGenerateForClass: aClass
		globals: (aClass ifNil: [nil] ifNotNil: [:class | class globalDictionaries])
		methodString: aString
		organization: organization ! !
! Doit class methodsFor: 'doit' !
doit ^[SmalltalkParser class methodsFor: 'parsing'] value ! !
! SmalltalkParser class methodsFor: 'parsing' !
quietRecompileMethod: aCompiledMethod inClass: aClass

	| method |

	[method := self	
			quietGenerateForClass: aClass
			methodString: aCompiledMethod getSource
			organization: aCompiledMethod organization]
	on: CompileWarning
	do: [:ex | ex resume].
		
	(method isKindOf: String) ifTrue: [^self error: method].

	method writeMethodOffsets: aCompiledMethod methodOffsets.
	aClass methodDictionary at: method selector put: method ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode methodsFor: 'accessing'] value ! !
! StatementListNode methodsFor: 'accessing' !
statements

	^statements ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode methodsFor: 'accessing'] value ! !
! StatementListNode methodsFor: 'accessing' !
statements: anObject

	statements := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode methodsFor: 'accessing'] value ! !
! StatementListNode methodsFor: 'accessing' !
variables

	^variables ifNil: [#()] ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode methodsFor: 'accessing'] value ! !
! StatementListNode methodsFor: 'accessing' !
variables: anObject

	variables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode methodsFor: 'visiting'] value ! !
! StatementListNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitStatementListStart: self.
	self statements
		do: [:statement | statement acceptVisitor: anObject]
		separatedBy: [anObject visitStatementSeparator].
	anObject visitStatementListEnd: self ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode class methodsFor: 'instance creation'] value ! !
! StatementListNode class methodsFor: 'instance creation' !
statements: aCollection

	^self new
		statements: aCollection;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[StatementListNode class methodsFor: 'instance creation'] value ! !
! StatementListNode class methodsFor: 'instance creation' !
variables: variables statements: statements

	^self new
		variables: variables;
		statements: statements;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TempVarListNode methodsFor: 'accessing'] value ! !
! TempVarListNode methodsFor: 'accessing' !
variableNames

	^(self variables collect: #variableName) asArray ! !
! Doit class methodsFor: 'doit' !
doit ^[TempVarListNode methodsFor: 'accessing'] value ! !
! TempVarListNode methodsFor: 'accessing' !
variables

	^variables ! !
! Doit class methodsFor: 'doit' !
doit ^[TempVarListNode methodsFor: 'accessing'] value ! !
! TempVarListNode methodsFor: 'accessing' !
variables: anObject

	variables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[TempVarListNode class methodsFor: 'instance creation'] value ! !
! TempVarListNode class methodsFor: 'instance creation' !
variables: aCollection

	^self new
		variables: aCollection;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TestParser methodsFor: 'accessing'] value ! !
! TestParser methodsFor: 'accessing' !
parseOneOfRule

	self sequence: [
		self oneOf: [
			self token: IntegerToken;
				token: BinaryToken;
				token: WordToken].
		self token: BarToken] ! !
! Doit class methodsFor: 'doit' !
doit ^[TestParser methodsFor: 'accessing'] value ! !
! TestParser methodsFor: 'accessing' !
parseOneOrMoreRule

	self sequence: [
		self oneOrMore: [
			self token: IntegerToken].
		self token: BarToken] ! !
! Doit class methodsFor: 'doit' !
doit ^[TestParser methodsFor: 'accessing'] value ! !
! TestParser methodsFor: 'accessing' !
parseOptionalRule

	self sequence: [
		self optional: [
			self token: IntegerToken].
		self token: BarToken] ! !
! Doit class methodsFor: 'doit' !
doit ^[TestParser methodsFor: 'accessing'] value ! !
! TestParser methodsFor: 'accessing' !
parseSequenceRule

	self sequence: [
		self token: IntegerToken;
			token: BinaryToken;
			token: WordToken] ! !
! Doit class methodsFor: 'doit' !
doit ^[TestParser methodsFor: 'accessing'] value ! !
! TestParser methodsFor: 'accessing' !
parseZeroOrMoreRule

	self sequence: [
		self zeroOrMore: [
			self token: IntegerToken].
		self token: BarToken] ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'accessing'] value ! !
! Token methodsFor: 'accessing' !
endSourceOffset

	^endSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'accessing'] value ! !
! Token methodsFor: 'accessing' !
endSourceOffset: anObject

	endSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'accessing'] value ! !
! Token methodsFor: 'accessing' !
startSourceOffset

	^startSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'accessing'] value ! !
! Token methodsFor: 'accessing' !
startSourceOffset: anObject

	startSourceOffset := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'accessing'] value ! !
! Token methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'accessing'] value ! !
! Token methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Token methodsFor: 'printing'] value ! !
! Token methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream space; print: self value printString ! !
! Doit class methodsFor: 'doit' !
doit ^[CompoundWordToken methodsFor: 'accessing'] value ! !
! CompoundWordToken methodsFor: 'accessing' !
words

	^self value ! !
! Doit class methodsFor: 'doit' !
doit ^[TokenNode methodsFor: 'accessing'] value ! !
! TokenNode methodsFor: 'accessing' !
token

	^token ! !
! Doit class methodsFor: 'doit' !
doit ^[TokenNode methodsFor: 'accessing'] value ! !
! TokenNode methodsFor: 'accessing' !
token: anObject

	token := anObject.
	startSourceOffset := token startSourceOffset.
	endSourceOffset := token endSourceOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[TokenNode methodsFor: 'printing'] value ! !
! TokenNode methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream space nextPutAll: self token printString ! !
! Doit class methodsFor: 'doit' !
doit ^[TokenNode class methodsFor: 'instance creation'] value ! !
! TokenNode class methodsFor: 'instance creation' !
token: anObject

	^(self new)
		token: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TokenRule methodsFor: 'matching'] value ! !
! TokenRule methodsFor: 'matching' !
token: aClass

	(self tokenStream peek isMemberOf: aClass)
		ifFalse: [^self fail].
	
	self result: (TokenNode token: self tokenStream next).
	self pass ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryHeaderNode methodsFor: 'accessing'] value ! !
! UnaryHeaderNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryHeaderNode methodsFor: 'accessing'] value ! !
! UnaryHeaderNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryHeaderNode methodsFor: 'visiting'] value ! !
! UnaryHeaderNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitUnaryHeader: self ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryHeaderNode class methodsFor: 'instance creation'] value ! !
! UnaryHeaderNode class methodsFor: 'instance creation' !
selector: aToken

	^self new
		selector: aToken;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode methodsFor: 'accessing'] value ! !
! UnaryMessageNode methodsFor: 'accessing' !
arguments

	^#() ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode methodsFor: 'accessing'] value ! !
! UnaryMessageNode methodsFor: 'accessing' !
receiver

	^receiver ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode methodsFor: 'accessing'] value ! !
! UnaryMessageNode methodsFor: 'accessing' !
receiver: anObject

	receiver := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode methodsFor: 'accessing'] value ! !
! UnaryMessageNode methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode methodsFor: 'accessing'] value ! !
! UnaryMessageNode methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode methodsFor: 'visiting'] value ! !
! UnaryMessageNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitMessageNodeStart: self.
	self receiver ifNotNil: [self receiver acceptVisitor: anObject].
	anObject visitMessageNodeEnd: self ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode class methodsFor: 'instance creation'] value ! !
! UnaryMessageNode class methodsFor: 'instance creation' !
receiver: anObject selector: aToken

	^self new
		receiver: anObject;
		selector: aToken;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[UnaryMessageNode class methodsFor: 'instance creation'] value ! !
! UnaryMessageNode class methodsFor: 'instance creation' !
selector: aToken

	^self new
		selector: aToken;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueNode methodsFor: 'accessing'] value ! !
! ValueNode methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueNode methodsFor: 'accessing'] value ! !
! ValueNode methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueNode class methodsFor: 'instance creation'] value ! !
! ValueNode class methodsFor: 'instance creation' !
value: anObject

	^self new
		value: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[LiteralNode methodsFor: 'printing'] value ! !
! LiteralNode methodsFor: 'printing' !
isLiteralNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LiteralNode methodsFor: 'printing'] value ! !
! LiteralNode methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream space.
	self value printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[LiteralNode methodsFor: 'visiting'] value ! !
! LiteralNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitLiteralNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockLiteralNode methodsFor: 'testing'] value ! !
! BlockLiteralNode methodsFor: 'testing' !
isBlockLiteralNode

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[BlockLiteralNode methodsFor: 'visiting'] value ! !
! BlockLiteralNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitBlockLiteralNode: self value. ! !
! Doit class methodsFor: 'doit' !
doit ^[SpecialNode methodsFor: 'accessing'] value ! !
! SpecialNode methodsFor: 'accessing' !
special

	^special ! !
! Doit class methodsFor: 'doit' !
doit ^[SpecialNode methodsFor: 'accessing'] value ! !
! SpecialNode methodsFor: 'accessing' !
special: anObject

	special := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SpecialNode methodsFor: 'visiting'] value ! !
! SpecialNode methodsFor: 'visiting' !
acceptVisitor: anObject

	anObject visitSpecialNode: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SpecialNode class methodsFor: 'instance creation'] value ! !
! SpecialNode class methodsFor: 'instance creation' !
special: aToken

	^self new
		special: aToken;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'accessing'] value ! !
! Variable methodsFor: 'accessing' !
variableName

	^variableName ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'accessing'] value ! !
! Variable methodsFor: 'accessing' !
variableName: anObject

	variableName := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'comparing'] value ! !
! Variable methodsFor: 'comparing' !
= aVariable

	aVariable class = self class ifFalse: [^false].
	^self variableName = aVariable variableName ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'comparing'] value ! !
! Variable methodsFor: 'comparing' !
hash

	^self variableName hash ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'initialize-release'] value ! !
! Variable methodsFor: 'initialize-release' !
initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'printing'] value ! !
! Variable methodsFor: 'printing' !
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' named: ';
		print: self variableName ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isGlobalVariable

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isIndirectList

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isIndirectVariableList

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isInstanceVariable

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isLocalVariable

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isReturnContext

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable methodsFor: 'testing'] value ! !
! Variable methodsFor: 'testing' !
isSelf

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable class methodsFor: 'instance creation'] value ! !
! Variable class methodsFor: 'instance creation' !
named: aSymbol

	^self new
		variableName: aSymbol asSymbol;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Variable class methodsFor: 'instance creation'] value ! !
! Variable class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[GlobalVariable methodsFor: 'testing'] value ! !
! GlobalVariable methodsFor: 'testing' !
isGlobalVariable

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[InstanceVariable methodsFor: 'testing'] value ! !
! InstanceVariable methodsFor: 'testing' !
isInstanceVariable

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
indirect

	^indirect ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
indirect: anObject

	indirect := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
isArgument

	^isArgument ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
isArgument: anObject

	isArgument := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
scope

	^scope ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
scope: anObject

	scope := anObject.
	scopeNumber := anObject scopeNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
scopeNumber

	^scopeNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'accessing'] value ! !
! LocalVariable methodsFor: 'accessing' !
scopeNumber: anObject

	scopeNumber := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'initialize-release'] value ! !
! LocalVariable methodsFor: 'initialize-release' !
initialize

	self indirect: false.
	self isArgument: false ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable methodsFor: 'testing'] value ! !
! LocalVariable methodsFor: 'testing' !
isLocalVariable

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[LocalVariable class methodsFor: 'instance creation'] value ! !
! LocalVariable class methodsFor: 'instance creation' !
argumentNamed: aSymbol

	^(self named: aSymbol)
		isArgument: true;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariable methodsFor: 'accessing'] value ! !
! NamespaceVariable methodsFor: 'accessing' !
namespaceComponents

	^namespaceComponents ! !
! Doit class methodsFor: 'doit' !
doit ^[NamespaceVariable methodsFor: 'accessing'] value ! !
! NamespaceVariable methodsFor: 'accessing' !
namespaceComponents: anObject

	namespaceComponents := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SelfVariable methodsFor: 'accessing'] value ! !
! SelfVariable methodsFor: 'accessing' !
variableName

	^'self' ! !
! Doit class methodsFor: 'doit' !
doit ^[SelfVariable methodsFor: 'testing'] value ! !
! SelfVariable methodsFor: 'testing' !
isSelf

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[WordToken methodsFor: 'accessing'] value ! !
! WordToken methodsFor: 'accessing' !
words

	^Array with: self value ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'accessing'] value ! !
! ZeroOrMoreParserRule methodsFor: 'accessing' !
nodes

	^nodes ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'accessing'] value ! !
! ZeroOrMoreParserRule methodsFor: 'accessing' !
nodes: anObject

	nodes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'accessing'] value ! !
! ZeroOrMoreParserRule methodsFor: 'accessing' !
passed

	^passed ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'accessing'] value ! !
! ZeroOrMoreParserRule methodsFor: 'accessing' !
passed: anObject

	passed := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'initialize-release'] value ! !
! ZeroOrMoreParserRule methodsFor: 'initialize-release' !
initialize

	self nodes: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'pass and fail'] value ! !
! ZeroOrMoreParserRule methodsFor: 'pass and fail' !
fail: aRule

	self passed: false.
	super fail: aRule ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'pass and fail'] value ! !
! ZeroOrMoreParserRule methodsFor: 'pass and fail' !
pass: aRule

	aRule result ifNotNil: [self nodes add: aRule result].
	self passed: true.
	self tokenStream: aRule tokenStream ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'processing'] value ! !
! ZeroOrMoreParserRule methodsFor: 'processing' !
finished

	self errorString notNil ifTrue: [^self fail].
	self result: (SequenceNode sequence: self nodes).
	self pass ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule methodsFor: 'rules'] value ! !
! ZeroOrMoreParserRule methodsFor: 'rules' !
process: aBlock

	[aBlock value. self passed] whileTrue: [].
	self finished ! !
! Doit class methodsFor: 'doit' !
doit ^[ZeroOrMoreParserRule class methodsFor: 'instance creation'] value ! !
! ZeroOrMoreParserRule class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassCreator methodsFor: 'creating'] value ! !
! ClassCreator methodsFor: 'creating' !
recompileClass

	oldClass selectors do: [:selector |
		SmalltalkParser
			quietRecompileMethod: (oldClass compiledMethodAt: selector) inClass: newClass].

	oldClass class selectors do: [:selector |
		SmalltalkParser
			quietRecompileMethod: (oldClass class compiledMethodAt: selector) inClass: newClass class]

 ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (ClassCreator compiledMethodAt: #recompileClass)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ClassDescription methodsFor: 'fileIn/Out'] value ! !
! ClassDescription methodsFor: 'fileIn/Out' !
methodsFor: aString

	^ClassFileinReader new
		targetClass: self;
		organization: aString;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (ClassDescription compiledMethodAt: #methodsFor:)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
decompile

	^Decompiler new
		literals: self literals;
		targetClass: self mclass;
		numberOfTemporaries: self numberOfTemporaries;
		numberOfArguments: self numberOfArguments;
		numberOfCopiedVariables: 0;
		decompile: self bytecodes ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #decompile)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
decompileNoBytes

	^Decompiler new
		literals: self literals;
		targetClass: self mclass;
		numberOfTemporaries: self numberOfTemporaries;
		numberOfArguments: self numberOfArguments;
		numberOfCopiedVariables: 0;
		decompileNoBytes: self bytecodes ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #decompileNoBytes)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
decompileSingleBytecodeStartingAt: offset

	^Decompiler new
		literals: self literals;
		targetClass: self mclass;
		numberOfTemporaries: self numberOfTemporaries;
		numberOfArguments: self numberOfArguments;
		numberOfCopiedVariables: 0;
		decompileSingleBytecodeFrom: self bytecodes startingAt: offset  ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #decompileSingleBytecodeStartingAt:)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
polymorphicInlineCache

	^polymorphicInlineCache ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #polymorphicInlineCache)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
polymorphicInlineCache: anObject

	polymorphicInlineCache := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #polymorphicInlineCache:)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CompiledCode methodsFor: 'accessing'] value ! !
! CompiledCode methodsFor: 'accessing' !
sourceOffsetsDictionaryForNonCurrentFrame

	| dictionary |
	dictionary := Dictionary new.
	4 to: self sourceOffsets size by: 3 do: [:index |
		| pcOffset spec |
		pcOffset := self sourceOffsets at: index.
		spec := (CodeGenerator bytecodesByIndex at: (bytecodes at: pcOffset + 1) + 1).
		dictionary
			at: pcOffset + (spec argumentSpec at: 2)
			put: (Array
					with: (self sourceOffsets at: index + 1)
					with: (self sourceOffsets at: index + 2))].
	^dictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (CompiledCode compiledMethodAt: #sourceOffsetsDictionaryForNonCurrentFrame)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedClasses: #(ArrayLiteralToken AssignToken BarToken BinaryHeaderNode BinaryMessageNode BinaryToken BlockArgumentToken BlockLiteralNode BlockNode BlockParameterListNode ByteArrayLiteralToken BytecodeSpec CascadeNode CharacterToken ClassFileinReader CloseBraceToken CloseParenthesisToken CloseSquareBracketToken CodeContext CodeGenerator CodeSimulator ColonToken CommaToken CommandHandler CompileError CompileWarning CompoundWordToken DecompileStream Decompiler DevelopmentCommandHandler ErrorToken FileinReader FloatToken GlobalVariable GlobalVariableAssignmentNode GlobalVariableReferenceNode IndirectVariableList InstanceVariable InstanceVariableAssignmentNode InstanceVariableReferenceNode IntegerToken JSONLexicalAnalyzer JSONParser KeywordHeaderNode KeywordMessageNode KeywordToken LeftAngleToken LexicalAnalyzer LiteralNode LocalVariable LocalVariableAssignmentNode LocalVariableReferenceNode MethodLocalVariableAnalysisVisitor MethodNode NamespaceVariable NamespaceVariableAssignmentNode NamespaceVariableReferenceNode ObjectNode OneOfParserRule OneOrMoreParserRule OpenBraceToken OpenParenthesisToken OpenSquareBracketToken OptionalParserRule ParenthesisNode ParseMethodRule ParseTreeNode ParseTreeVisitor Parser ParserRule PeriodToken PragmaNode ReturnNode ReturnToken RightAngleToken RootRule Scope ScopeAnalysisResult SelfVariable SemicolonToken SequenceNode SequenceParserRule SmalltalkLexicalAnalyzer SmalltalkParser SpecialNode SpecialWordToken StatementListNode StringToken SymbolToken TempVarListNode TestParser Token TokenNode TokenRule UnaryHeaderNode UnaryMessageNode ValueNode Variable WordToken ZeroOrMoreParserRule) andMethods: #(#(ClassCreator #recompileClass) #(ClassDescription #'methodsFor:') #(CompiledCode #decompile) #(CompiledCode #decompileNoBytes) #(CompiledCode #'decompileSingleBytecodeStartingAt:') #(CompiledCode #polymorphicInlineCache) #(CompiledCode #'polymorphicInlineCache:') #(CompiledCode #sourceOffsetsDictionaryForNonCurrentFrame))] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompileError methods: #(#endSourceOffset #'endSourceOffset:' #startSourceOffset #'startSourceOffset:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompileError class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Variable methods: #(#'=' #hash #initialize #isGlobalVariable #isIndirectList #isIndirectVariableList #isInstanceVariable #isLocalVariable #isReturnContext #isSelf #'printOn:' #variableName #'variableName:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Variable class methods: #(#'named:' #new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NamespaceVariable methods: #(#namespaceComponents #'namespaceComponents:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NamespaceVariable class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InstanceVariable methods: #(#isInstanceVariable)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InstanceVariable class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LocalVariable methods: #(#indirect #'indirect:' #initialize #isArgument #'isArgument:' #isLocalVariable #scope #'scope:' #scopeNumber #'scopeNumber:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LocalVariable class methods: #(#'argumentNamed:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SelfVariable methods: #(#isSelf #variableName)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SelfVariable class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: GlobalVariable methods: #(#isGlobalVariable)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: GlobalVariable class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParseTreeNode methods: #(#'acceptVisitor:' #endSourceOffset #'endSourceOffset:' #isBinaryHeaderNode #isBinaryMessageNode #isBlockLiteralNode #isBlockNode #isBlockParameterListNode #isCascadeNode #isKeywordHeaderNode #isKeywordMessageNode #isLiteralNode #isMethodNode #isParenthesisNode #isSequence #startSourceOffset #'startSourceOffset:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParseTreeNode class methods: #(#'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeywordHeaderNode methods: #(#'acceptVisitor:' #arguments #'arguments:' #isKeywordHeaderNode #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeywordHeaderNode class methods: #(#'selector:arguments:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NamespaceVariableReferenceNode methods: #(#'acceptVisitor:' #nameComponents #'nameComponents:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NamespaceVariableReferenceNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UnaryMessageNode methods: #(#'acceptVisitor:' #arguments #receiver #'receiver:' #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UnaryMessageNode class methods: #(#'receiver:selector:' #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockNode methods: #(#'acceptVisitor:' #'addVariableAssignment:' #'addVariableReference:' #arguments #'arguments:' #hasReturn #'hasReturn:' #isBlockNode #parent #'parent:' #scope #'scope:' #statements #'statements:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PragmaNode methods: #(#'acceptVisitor:' #arguments #'arguments:' #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PragmaNode class methods: #(#'selector:arguments:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CascadeNode methods: #(#'acceptVisitor:' #isCascadeNode #messages #'messages:' #receiver #'receiver:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CascadeNode class methods: #(#'receiver:messages:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LocalVariableReferenceNode methods: #(#'acceptVisitor:' #scopeNumber #'scopeNumber:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LocalVariableReferenceNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NamespaceVariableAssignmentNode methods: #(#'acceptVisitor:' #nameComponents #'nameComponents:' #value #'value:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NamespaceVariableAssignmentNode class methods: #(#'nameComponents:value:' #'variable:value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TokenNode methods: #(#'printOn:' #token #'token:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TokenNode class methods: #(#'token:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BinaryMessageNode methods: #(#'acceptVisitor:' #argument #'argument:' #arguments #isBinaryMessageNode #receiver #'receiver:' #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BinaryMessageNode class methods: #(#'receiver:selector:argument:' #'receiver:selector:argument:startSourceOffset:endSourceOffset:' #'selector:argument:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LocalVariableAssignmentNode methods: #(#'acceptVisitor:' #value #'value:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LocalVariableAssignmentNode class methods: #(#'variable:value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeywordMessageNode methods: #(#'acceptVisitor:' #arguments #'arguments:' #'isInlinedSelector:' #isKeywordMessageNode #receiver #'receiver:' #selector #'selector:' #'visitIfFalse:' #'visitIfFalseIfTrue:' #'visitIfTrue:' #'visitIfTrueIfFalse:' #'visitInlinedObject:' #'visitWhileFalse:' #'visitWhileTrue:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeywordMessageNode class methods: #(#'receiver:selector:arguments:' #'selector:arguments:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BinaryHeaderNode methods: #(#'acceptVisitor:' #argument #'argument:' #isBinaryHeaderNode #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BinaryHeaderNode class methods: #(#'selector:argument:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: GlobalVariableReferenceNode methods: #(#'acceptVisitor:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: GlobalVariableReferenceNode class methods: #(#'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InstanceVariableAssignmentNode methods: #(#'acceptVisitor:' #value #'value:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InstanceVariableAssignmentNode class methods: #(#'variable:value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: GlobalVariableAssignmentNode methods: #(#'acceptVisitor:' #value #'value:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: GlobalVariableAssignmentNode class methods: #(#'variable:value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReturnNode methods: #(#'acceptVisitor:' #returnLevel #'returnLevel:' #value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReturnNode class methods: #(#'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockParameterListNode methods: #(#'acceptVisitor:' #isBlockParameterListNode #variables #'variables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockParameterListNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodNode methods: #(#'acceptVisitor:' #body #'body:' #header #'header:' #isMethodNode #pragmas #'pragmas:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodNode class methods: #(#'header:body:' #'header:pragmas:body:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TempVarListNode methods: #(#variableNames #variables #'variables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TempVarListNode class methods: #(#'variables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SequenceNode methods: #(#isSequence #sequence #'sequence:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SequenceNode class methods: #(#'sequence:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParenthesisNode methods: #(#'acceptVisitor:' #expression #'expression:' #isParenthesisNode)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParenthesisNode class methods: #(#'expression:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StatementListNode methods: #(#'acceptVisitor:' #statements #'statements:' #variables #'variables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StatementListNode class methods: #(#'statements:' #'variables:statements:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InstanceVariableReferenceNode methods: #(#'acceptVisitor:' #variable #'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: InstanceVariableReferenceNode class methods: #(#'variable:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ValueNode methods: #(#value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ValueNode class methods: #(#'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ObjectNode methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ObjectNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LiteralNode methods: #(#'acceptVisitor:' #isLiteralNode #'printOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LiteralNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockLiteralNode methods: #(#'acceptVisitor:' #isBlockLiteralNode)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockLiteralNode class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SpecialNode methods: #(#'acceptVisitor:' #special #'special:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SpecialNode class methods: #(#'special:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IndirectVariableList methods: #(#initialize #isIndirectList #isIndirectVariableList #isReturnContext #isSelf #'printOn:' #variables #'variables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IndirectVariableList class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Scope methods: #(#'addScope:' #'addVariable:' #'addVariables:' #childScopes #'childScopes:' #initialize #parentScope #'parentScope:' #scopeNumber #'scopeNumber:' #'variableNamed:' #'variableNumber:' #variables #'variables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Scope class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LexicalAnalyzer methods: #(#advance #'captureOffsetsIn:creating:' #endSourceOffset #'endSourceOffset:' #finishedCharacter #'isDigit:radix:' #next #next2 #'next2:' #'next:' #nextCharacter #nextToken #position #'position:' #'reportError:start:end:' #skipComment #skipSeparator #skipSeparators #start #startSourceOffset #'startSourceOffset:' #stream #'stream:' #tokens)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LexicalAnalyzer class methods: #(#'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParserRule methods: #(#'choice:' #'commitAndFailWithMessage:if:' #'commitWithMessage:if:' #errorString #'errorString:' #fail #'fail:' #finished #parentRule #'parentRule:' #'parse:' #parser #'parser:' #pass #'pass:' #'process:' #'produce:' #produceBlock #'produceBlock:' #result #'result:' #tokenStream #'tokenStream:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParserRule class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OneOrMoreParserRule methods: #(#'fail:' #finished #initialize #nodes #'nodes:' #'pass:' #passed #'passed:' #'process:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OneOrMoreParserRule class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ZeroOrMoreParserRule methods: #(#'fail:' #finished #initialize #nodes #'nodes:' #'pass:' #passed #'passed:' #'process:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ZeroOrMoreParserRule class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OneOfParserRule methods: #(#'choice:' #finished #'pass:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OneOfParserRule class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OptionalParserRule methods: #(#'choice:' #finished #'pass:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OptionalParserRule class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SequenceParserRule methods: #(#allPassedSoFar #'choice:' #'errorString:' #'fail:' #finished #initialize #lastZeroOrMoreProducedResult #'parse:' #'pass:' #rulesRun #'rulesRun:' #sequence #'sequence:' #tokensToExpect)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SequenceParserRule class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TokenRule methods: #(#'token:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TokenRule class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParseMethodRule methods: #(#pass)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParseMethodRule class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RootRule methods: #(#pass #'pass:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RootRule class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Token methods: #(#endSourceOffset #'endSourceOffset:' #'printOn:' #startSourceOffset #'startSourceOffset:' #value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Token class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LeftAngleToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LeftAngleToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ArrayLiteralToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ArrayLiteralToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BarToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BarToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CloseSquareBracketToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CloseSquareBracketToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ErrorToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ErrorToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CharacterToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CharacterToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SemicolonToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SemicolonToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteArrayLiteralToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ByteArrayLiteralToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: AssignToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: AssignToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeywordToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeywordToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SymbolToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SymbolToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SpecialWordToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SpecialWordToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReturnToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ReturnToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StringToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StringToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RightAngleToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RightAngleToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CloseParenthesisToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CloseParenthesisToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WordToken methods: #(#words)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WordToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OpenParenthesisToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OpenParenthesisToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OpenSquareBracketToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OpenSquareBracketToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BinaryToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BinaryToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompoundWordToken methods: #(#words)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompoundWordToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: FloatToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: FloatToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PeriodToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PeriodToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockArgumentToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BlockArgumentToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IntegerToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: IntegerToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ScopeAnalysisResult methods: #(#'addArgument:' #'addCopiedVariable:' #'addTemporaryVariable:' #allLocals #arguments #'arguments:' #children #'children:' #copiedVariables #'copiedVariables:' #'definesVariable:' #hasReturn #'hasReturn:' #indirectVariables #'indirectVariables:' #initialize #localVariableNames #localVariables #localsNeeded #'makeIndirect:inScope:' #markReturns #node #'node:' #numberOfArguments #parent #'parent:' #temporaryVariables #'temporaryVariables:' #'variableNumberOf:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ScopeAnalysisResult class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BytecodeSpec methods: #(#argumentSpec #'argumentSpec:' #decompileString #'decompileString:' #name #'name:' #number #'number:' #numberOfBytes #'numberOfBytes:' #'printOn:' #type #'type:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BytecodeSpec class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Decompiler methods: #(#decompile #'decompile:' #decompileNextBytecode #decompileNoBytes #'decompileNoBytes:' #decompileSingleBytecode #'decompileSingleBytecodeFrom:startingAt:' #finishLine #finishLineNoBytes #initialize #literals #'literals:' #numberOfArguments #'numberOfArguments:' #numberOfCopiedVariables #'numberOfCopiedVariables:' #numberOfTemporaries #'numberOfTemporaries:' #'readEscapeSequenceFrom:' #resetLineStreams #result #targetClass #'targetClass:' #writeHeader #writeNextBytecode #writeOffset)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Decompiler class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParseTreeVisitor methods: #(#initialize #'visit:' #'visitArgument:' #'visitBinaryHeader:' #'visitBlockLiteralNode:' #'visitBlockNode:' #'visitBlockNodeStart:' #'visitBlockParameterListNode:' #'visitCascadeEnd:' #'visitCascadeInterMessage:' #'visitCascadeStart:' #'visitEmptyMethodNode:' #visitEmptyStatements #'visitGlobalVariableAssignmentNode:' #'visitGlobalVariableReferenceNode:' #'visitIfFalseBlock:' #'visitIfFalseBlock:ifTrueBlock:' #'visitIfTrueBlock:' #'visitIfTrueBlock:ifFalseBlock:' #'visitInstanceVariableAssignmentNode:' #'visitInstanceVariableReferenceNode:' #'visitKeywordHeader:' #'visitLiteralNode:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMessageNode:' #'visitMessageNodeEnd:' #'visitMessageNodeStart:' #'visitMethodNode:' #'visitMethodNodeStart:' #'visitNamespaceVariableAssignmentNode:' #'visitNamespaceVariableReferenceNode:' #'visitPragma:' #'visitReceiver:' #'visitReturnNode:' #'visitSpecialNode:' #'visitStatementList:' #visitStatementListEnd #'visitStatementListEnd:' #'visitStatementListStart:' #visitStatementSeparator #'visitUnaryHeader:' #'visitWhileFalseBlock:doBlock:' #'visitWhileTrueBlock:doBlock:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ParseTreeVisitor class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodLocalVariableAnalysisVisitor methods: #(#'argumentsFor:' #'copiedVariablesFor:' #declareSelf #'endBlockNode:' #'findVariableDefinition:' #initialize #'localsNeededFor:' #'localsToCopyFor:' #numArgs #numTempsOnly #rootNode #'rootNode:' #'scopeFor:' #scopeStack #'scopeStack:' #scopes #'scopes:' #'startBlockNode:' #'temporariesFor:' #'variableNumberOf:' #'variableNumberOf:inNode:' #'visitBinaryHeader:' #'visitBlockLiteralNode:' #'visitBlockNode:' #'visitBlockParameterListNode:' #'visitInstanceVariableAssignmentNode:' #'visitInstanceVariableReferenceNode:' #'visitKeywordHeader:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMethodNodeStart:' #'visitReturnNode:' #'visitSpecialNode:' #'visitStatementListStart:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodLocalVariableAnalysisVisitor class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeGenerator methods: #(#'addBytecode:' #addDup #'addGlobalDictionary:' #'addLiteral:' #addPop #bytecodeBlockReturn #bytecodeCallOneByte #bytecodeCallOneByteSuper #bytecodeCallShort #bytecodeCallShortSuper #bytecodeCallSuperTwoBytes #bytecodeCallTwoBytes #bytecodeCallWellKnown #bytecodeDropCascadeReceiver #bytecodeDup #'bytecodeFor:' #bytecodeJumpIfFalseOneByte #bytecodeJumpIfFalseTwoBytes #bytecodeJumpIfTrueOneByte #bytecodeJumpIfTrueTwoBytes #bytecodeJumpOneByte #bytecodeJumpTwoBytes #bytecodeNonLocalReturn #bytecodePop #bytecodePrimitive #bytecodePrimitiveReturn #bytecodePushCopyingBlock #bytecodePushFalse #bytecodePushFourByteInteger #bytecodePushFullBlock #bytecodePushLocalIndirect #bytecodePushNil #bytecodePushOneByteGlobal #bytecodePushOneByteInstanceVariable #bytecodePushOneByteInteger #bytecodePushOneByteLiteral #bytecodePushOneByteLocalVariable #bytecodePushSelf #bytecodePushSelfInstvarIndirect #bytecodePushShortGlobal #bytecodePushShortInstanceVariable #bytecodePushShortLocalVariable #bytecodePushSmallLiteral #bytecodePushSmallNegativeInteger #bytecodePushSmallPositiveInteger #bytecodePushThisContext #bytecodePushTrue #bytecodePushTwoByteGlobal #bytecodePushTwoByteInstanceVariable #bytecodePushTwoByteInteger #bytecodePushTwoByteLiteral #bytecodeReturn #bytecodeStoreLocalIndirect #bytecodeStoreNewArray #bytecodeStoreOneByteGlobal #bytecodeStoreOneByteInstanceVariable #bytecodeStoreOneByteLocalVariable #bytecodeStoreSelfInstvarIndirect #bytecodeStoreShortGlobalVariable #bytecodeStoreShortInstanceVariable #bytecodeStoreShortLocalVariable #bytecodeStoreTwoByteGlobalVariable #bytecodeStoreTwoByteInstanceVariable #bytecodeStoreTwoByteLocalVariable #bytecodeStream #'bytecodeStream:' #bytecodes #'callLiteral:args:' #'callOffsetsDo:' #'callOneByteLiteral:args:' #'callShortLiteral:args:' #'callSpecialSelector:' #'callSuperLiteral:args:' #'callSuperOneByteLiteral:args:' #'callSuperShortLiteral:args:' #'callSuperTwoByteLiteral:args:' #'callTwoByteLiteral:args:' #'compileError:' #'compileError:node:' #'compileWarning:' #'compileWarning:node:' #'createBlockFor:variablesToCopy:' #decompile #decompileNoBytes #'globalAssociationFor:' #globalDictionaries #'globalDictionaries:' #hasReturned #'hasReturned:' #initialize #'isGlobalVariable:' #isInlined #isInlinedBlock #'isInlinedBlock:' #'isInstanceVariable:' #'isLocalVariable:' #'isNamespaceGlobal:' #'isSpecialSelector:' #literals #'literals:' #method #methodLocalVariableAnalysis #'methodLocalVariableAnalysis:' #'namespaceGlobalAssociationFor:' #nodeStack #'nodeStack:' #numberOfSends #outerMethod #'outerMethod:' #popNode #pragmas #'pragmas:' #pushCopiedSelf #'pushCopyBlock:variablesToCopy:' #pushFalse #'pushFourByteInteger:' #'pushFullBlock:variablesToCopy:' #'pushGlobalReference:' #'pushGlobalReference:node:' #'pushIndirectLocalVariableReference:' #'pushIndirectVariableArrayFor:' #'pushInstVarReference:' #'pushInteger:' #'pushLiteral:' #'pushLocalVariableNumber:' #'pushLocalVariableReference:' #'pushNamespaceGlobalReference:' #pushNil #'pushNode:' #'pushOneByteGlobal:' #'pushOneByteInstVar:' #'pushOneByteInteger:' #'pushOneByteLiteral:' #'pushOneByteLocalVar:' #pushReturn #pushSelf #'pushSelfInstanceVariableReference:' #'pushShortGlobal:' #'pushShortInstVar:' #'pushShortLiteral:' #'pushShortLocalVar:' #'pushSmallNegativeInteger:' #'pushSmallPositiveInteger:' #pushThisContext #pushTrue #'pushTwoByteGlobal:' #'pushTwoByteInstVar:' #'pushTwoByteInteger:' #'pushTwoByteLiteral:' #'recordSourceOffsetsFor:' #returnLevel #'returnLevel:' #selector #'selector:' #selfVariable #sourceOffsets #'sourceOffsets:' #'storeGlobalVariableAssignment:node:' #'storeIndirectLocalVariableAssignment:' #'storeInstanceVariableAssignment:' #'storeLocalVariableAssignment:' #'storeNamespaceGlobalAssignment:' #'storeOneByteGlobal:' #'storeOneByteInstanceVariable:' #'storeOneByteLocalVar:' #'storeSelfInstvarAssignment:' #'storeShortGlobal:' #'storeShortInstanceVariable:' #'storeShortLocalVar:' #'storeTwoByteGlobal:' #'storeTwoByteInstanceVariable:' #'storeTwoByteLocalVar:' #targetClass #'targetClass:' #'visitArgument:' #'visitBinaryHeader:' #'visitBlockLiteralNode:' #'visitBlockNode:' #'visitBlockNodeStart:' #'visitBlockParameterListNode:' #'visitCascadeEnd:' #'visitCascadeInterMessage:' #'visitCascadeStart:' #'visitEmptyMethodNode:' #visitEmptyStatements #'visitGlobalVariableAssignmentNode:' #'visitGlobalVariableReferenceNode:' #'visitIfFalseBlock:' #'visitIfFalseBlock:ifTrueBlock:' #'visitIfFalseBlock:ifTrueBlock:useLongJumps:' #'visitIfFalseBlock:useLongJumps:' #'visitIfTrueBlock:' #'visitIfTrueBlock:ifFalseBlock:' #'visitIfTrueBlock:ifFalseBlock:useLongJumps:' #'visitIfTrueBlock:useLongJumps:' #'visitInstanceVariableAssignmentNode:' #'visitInstanceVariableReferenceNode:' #'visitKeywordHeader:' #'visitLiteralNode:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMessageNodeEnd:' #'visitMessageNodeStart:' #'visitMethodNode:' #'visitMethodNodeStart:' #'visitNamespaceVariableAssignmentNode:' #'visitNamespaceVariableReferenceNode:' #'visitPragma:' #'visitReceiver:' #'visitReturnNode:' #'visitSpecialNode:' #'visitStatementListEnd:' #'visitStatementListStart:' #visitStatementSeparator #'visitUnaryHeader:' #'visitWhileFalseBlock:doBlock:' #'visitWhileFalseBlock:doBlock:useLongJumps:' #'visitWhileTrueBlock:doBlock:' #'visitWhileTrueBlock:doBlock:useLongJumps:' #'whileEmbeddedBlockDo:' #'writeLiteralsInto:' #'writePICInto:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeGenerator class methods: #(#bytecodeTable #bytecodesByIndex #bytecodesByName #initialize #new #specialSelectors)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Parser methods: #(#atEnd #'commitAndFailWithMessage:if:' #'commitWithMessage:if:' #currentRule #'currentRule:' #errorMessage #fail #'initialRule:' #isFinished #isRootRule #'oneOf:' #'oneOrMore:' #'optional:' #'parse:' #pass #'process:' #'produce:' #result #'rule:' #'sequence:' #'token:' #'token:produce:' #'tokens:' #'zeroOrMore:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Parser class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TestParser methods: #(#parseOneOfRule #parseOneOrMoreRule #parseOptionalRule #parseSequenceRule #parseZeroOrMoreRule)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TestParser class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmalltalkParser methods: #(#'addScope:' #'addScopeVariable:' #'buildAssignStatementList:' #'buildBinaryExpression:' #'buildBinaryMessageHeader:' #'buildBlock:' #'buildBlockParameters:' #'buildCascadeNode:' #'buildKeywordExpression:' #'buildKeywordMessageFrom:' #'buildKeywordMethodHeaderFrom:' #'buildLeftToRightBinaryExpression:' #'buildPragma:' #'buildPragmaMessage:' #'buildStatementBody:' #'buildTempVar:' #'buildUnaryMessageFor:' #'buildVariableAssignNode:' #'createVariableReferenceFor:' #currentMethodName #'currentMethodName:' #'expectToken:' #'findLocalVariableNamed:' #globalDictionaries #'globalDictionaries:' #initialize #'isGlobalVariable:' #'isInstanceVariable:' #'isLocalVariable:' #'isNamespaceVariable:' #newScope #parseAssignStatement #parseAssignStatementList #parseBinaryExpression #parseBinaryMethodHeader #parseBlock #parseBlockParams #parseCascadeExpression #parseCascadeMessage #parseExpression #parseKeywordExpression #parseKeywordMethodHeader #parseLeftToRightBinaryExpression #parseLiteral #parseMethod #parseMethodHeader #parseObject #parseParenthesisExpression #parsePragma #parseReturnStatement #parseStatementBody #parseStatementList #parseTempVars #parseUnaryExpression #parseUnaryMethodHeader #popScope #pragmaLiteral #pragmaMessage #'scopeAndLocalVariableFor:' #scopeStack #'scopeStack:' #scopes #'scopes:' #'stopExpectingToken:' #targetClass #'targetClass:' #tokensToExpect #'tokensToExpect:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmalltalkParser class methods: #(#'compile:inClass:organization:' #'debugIt:' #'evaluate:' #'evaluate:for:' #'fileoutMethod:forClass:on:' #'fileoutMethod:forClass:organization:on:' #'generateForClass:globals:methodString:organization:writeChangesInto:' #'generateForClass:globals:organization:methodString:' #'generateForClass:methodString:organization:' #new #'parseBlockBody:' #'parseBlockBodyString:' #'parseForClass:globals:method:' #'parseForClass:globals:methodString:' #'parseForClass:method:' #'parseForClass:methodString:' #'parseForClass:selector:' #'parseMethod:' #'parseMethodString:' #'quietGenerateForClass:globals:methodString:organization:' #'quietGenerateForClass:methodString:organization:' #'quietRecompileMethod:inClass:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UnaryHeaderNode methods: #(#'acceptVisitor:' #selector #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UnaryHeaderNode class methods: #(#'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmalltalkLexicalAnalyzer methods: #(#binaryCharacters #nextToken #parseArrayLiteral #parseAssignment #parseBar #parseBinary #parseBinarySymbolLiteral #parseBlockArgument #parseByteArrayLiteral #parseCharacterLiteral #parseCloseParenthesis #parseCloseSquareBracket #parseLeftAngle #parseNumber #parseOpenParenthesis #parseOpenSquareBracket #parsePeriod #parseQuotedSymbolLiteral #parseReturn #parseRightAngle #parseSemicolon #parseStringLiteral #parseSymbolLiteral #parseWord #readAlphaNumericWord #readArrayLiteralElement #readArrayLiteralElements #readBinary #readByteArrayLiteralElement #readByteArrayLiteralElements #'readCompoundWordOn:' #'readDecimalPart:' #readExponent #'readFloatStartingWith:' #'readFloatStartingWith:sign:' #readInteger #'readKeywordOn:' #readNumber #'readNumberRadix:' #readStringLiteral #readSubArrayLiteral #readSymbolWord #readWord #skipComment #skipSeparator #'wordTokenFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmalltalkLexicalAnalyzer class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JSONLexicalAnalyzer methods: #(#nextToken #parseCloseBrace #parseCloseSquareBracket #parseColon #parseComma #parseNumber #parseOpenBrace #parseOpenSquareBracket #parseStringLiteral #parseWord #readAlphaNumericWord #'readDecimalPart:' #readExponent #'readFloatStartingWith:' #readInteger #readNumber #readStringLiteral #'readStringQuotedCharacterInto:' #readWord #skipSeparator #'wordTokenFor:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JSONLexicalAnalyzer class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: FileinReader methods: #(#'captureCharacter:' #fileIn #fileInChunk #readChunk #'runDoit:' #stream #'stream:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: FileinReader class methods: #(#'fileIn:' #'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OpenBraceToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: OpenBraceToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CloseBraceToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CloseBraceToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ColonToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ColonToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CommaToken methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CommaToken class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JSONParser methods: #(#parseArray #parseDictionary #parseKeyValuePair #parseKeyValueSequence #parseObject #parseObjectSequence #parseOptionalKeyValueSequence #parsePrimitiveObject)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JSONParser class methods: #(#'evaluate:' #'evaluate:inSession:' #'evaluateJsonString:' #'parseString:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ClassFileinReader methods: #(#'fileInFrom:' #'fixLineEndConventionsIn:' #organization #'organization:' #targetClass #'targetClass:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ClassFileinReader class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DecompileStream methods: #(#atEnd #byteStream #'byteStream:' #compiledCode #'compiledCode:' #next)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DecompileStream class methods: #(#'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompileWarning methods: #(#endSourceOffset #'endSourceOffset:' #startSourceOffset #'startSourceOffset:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompileWarning class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeContext methods: #(#allFrames #allLocalNames #'basicLocalAt:' #'basicLocalAt:put:' #contextId #'contextId:' #'doBytecode:' #dropCascadeReceiver #dup #'findCompiledMethod:startingAt:' #frame #'frame:' #getSelf #grow #initialize #isBlockContext #'jump:' #'jumpIfFalse:' #'jumpIfTrue:' #'localAt:' #method #'method:' #methodClass #methodContext #'methodContext:' #nextBytecode #nextFourBytecodes #nextFourSignedBytes #nextSignedByte #nextTwoBytecodes #nextTwoSignedBytes #pcOffset #'pcOffset:' #peek #'peek:' #peekBytecode #pop #'printOn:' #'push:' #'pushCopyingBlock:copiedVariables:' #'pushFullBlock:copiedVariables:' #'pushGlobal:' #'pushInstVar:' #'pushLiteral:' #'pushLocal:' #'pushLocal:indirect:' #pushSelf #'pushSelfInstVar:' #receiver #restart #rootContext #rootMethod #rootMethodClass #'rootSelfFor:' #sender #'stackAt:' #stackNames #stackOffset #'stackOffset:' #'storeGlobal:' #'storeInstVar:' #'storeLocal:' #'storeLocal:indirect:' #'storeNewArray:local:' #'storeSelfInstVar:' #walkback)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeContext class methods: #(#'bytecodeBlockAt:' #'bytecodeBlockAt:put:' #bytecodeBlocks #callReturnBytecodes #clearBytecodeBlocks #jumpBytecodes #new #pushGlobalBytecodes #pushInstVarBytecodes #pushIntegerBytecodes #pushLiteralBytecodes #pushLocalBytecodes #setupBytecodeBlocks #setupMiscBytecodes #storeGlobalBytecodes #storeInstVarBytecodes #storeLocalBytecodes)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeSimulator methods: #(#blockReturn #'buildFrameFor:' #'call:arguments:' #'callSelector:arguments:' #'callWellKnown:' #currentContext #'currentContext:' #frames #'frames:' #getMethodStartFrame #into #'invoke:on:selector:arguments:' #'invokeBlock:method:arguments:' #'isImportantBytecode:' #'isReturnBytecode:' #nonLocalReturn #over #primitiveReturn #reinvokeMethod #restart #return #returnToCurrentFrame #'returnToFrame:' #'runBytecode:' #runBytecodes #'runToContext:' #runToImportantBytecode #shouldContinueRunning #stepBytecode #stopFrame #'stopFrame:' #stopMethod #'stopMethod:' #'superCall:arguments:' #through)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeSimulator class methods: #(#headerSize)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CommandHandler methods: #(#'processMessage:onWebSocket:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CommandHandler class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DevelopmentCommandHandler methods: #(#'processMessage:onWebSocket:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DevelopmentCommandHandler class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default finishFileinKit] value ! !
! Doit class methodsFor: 'doit' !
doit ^[('kits' asFilename construct: 'CoreUI.kit') fileIn] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKitNamed: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit ensureLoaded: #('Core')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Color
	instVarNames: 'red green blue alpha'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Emphasis
	instVarNames: 'startEmphasisTag endEmphasisTag'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #EmphasisSpan
	instVarNames: 'emphasis startOffset endOffset'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #EmphasisStream
	instVarNames: 'sortedEmphasisSpans nextOffset nestedSpans sortedSpanIndex'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Event
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Event subclassNamed: #DoubleClickEvent
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase subclassNamed: #EventModel
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #HTMLBuilder
	instVarNames: 'nodeStack currentNode htmlNode'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #HTMLStyleDefinition
	instVarNames: 'name keys attributes'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #HTMLTag
	instVarNames: 'tagName styles attributes children'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #HTMLText
	instVarNames: 'text'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #JSONEvaluator
	instVarNames: 'webSession'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Event subclassNamed: #KeyEvent
	instVarNames: 'key modifiers'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Event subclassNamed: #ListSelectionEvent
	instVarNames: 'selectionIndex'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Event subclassNamed: #MessageReceivedEvent
	instVarNames: 'message'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #PopupMenuItem
	instVarNames: 'name id widgetId enabled action requestedValues enabledBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Rectangle
	instVarNames: 'origin corner'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #SessionVariable
	instVarNames: 'value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[EventBase subclassNamed: #UIComponent
	instVarNames: 'menu id ui displayBlock height'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #CompositeComponent
	instVarNames: 'children'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #ListComponent
	instVarNames: 'list selectionIndex listNumberOfRows optionStyles'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #ListDivComponent
	instVarNames: 'list selectionIndex listNumberOfRows optionStyles'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #PushButtonComponent
	instVarNames: 'label actionBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #RichTextEditorComponent
	instVarNames: 'text selectionStart selectionEnd emphasisCollection subject'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #TextComponent
	instVarNames: 'text'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent subclassNamed: #TextEditorComponent
	instVarNames: 'text selectionStart selectionEnd emphasisCollection subject'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #UIOperation
	instVarNames: 'name arguments'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #UIScreen
	instVarNames: 'components addedComponents deletedComponents modifiedComponents commandHandler webSocket componentNumber'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[EventModel subclassNamed: #ValueHolder
	instVarNames: 'value'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #WebSession
	instVarNames: 'sessionVariables random applications currentOpenLocation'
	classInstVarNames: 'current'
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #WebUI
	instVarNames: 'appName parentName bindings updateStream flags bounds title origin extent dragPoint opened htmlTree'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #ListChoiceBox
	instVarNames: 'message choices values answerBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #MessageBox
	instVarNames: 'message severity'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #MultipleChoiceBox
	instVarNames: 'message choices values'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #PopupMenuUI
	instVarNames: 'widgetId popupMenu menuItems'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #RequestBox
	instVarNames: 'message initialAnswer answerBlock'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'CoreUI'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
alpha

	^alpha  ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
alpha: aNumber

	alpha := aNumber asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
blue

	^blue  ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
blue: aNumber

	blue := aNumber asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
green

	^green  ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
green: aNumber

	green := aNumber asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
hue

	^self asHSV at: 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
hue: aNumber

	^self copy fromHSV: (self asHSV at: 1 put: (aNumber mod: 360.0); yourself) ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
red

	^red  ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
red: aNumber

	red := aNumber asInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
saturation

	^self asHSV at: 2 ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
saturation: aNumber

	^self copy fromHSV: (self asHSV at: 2 put: ((aNumber max: 100.0) min: 0.0); yourself) ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
value

	^self asHSV at: 3 ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'accessing'] value ! !
! Color methodsFor: 'accessing' !
value: aNumber

	^self copy fromHSV: (self asHSV at: 3 put: ((aNumber max: 100.0) min: 0.0); yourself) ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'converting'] value ! !
! Color methodsFor: 'converting' !
asHSV

	| redNormalized greenNormalized blueNormalized cMin cMax delta hue saturation value |

	redNormalized := self red / 255.0.
	greenNormalized := self green / 255.0.
	blueNormalized := self blue / 255.0.

	cMax := (redNormalized max: greenNormalized) max: blueNormalized.
	cMin := (redNormalized min: greenNormalized) min: blueNormalized.
	delta := cMax - cMin.
	
	hue := delta = 0.0
		ifTrue: [0.0]
		ifFalse: [
			cMax = redNormalized
				ifTrue: [(greenNormalized - blueNormalized) / delta]
				ifFalse: [
					cMax = greenNormalized
						ifTrue: [(blueNormalized - redNormalized) / delta + 2.0]
						ifFalse: [(redNormalized - greenNormalized) / delta + 4.0]]].

	hue := (hue mod: 6.0) * 60.0.
	saturation := (cMax = 0.0 ifTrue: [0.0] ifFalse: [delta / cMax]) *  100.0.
	value := cMax * 100.0.

	^Array with: hue with: saturation with: value
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'converting'] value ! !
! Color methodsFor: 'converting' !
fromHSV: anArray

	| h s v c x m rgb |

	h := (anArray at: 1) mod: 360.0.
	s := (((anArray at: 2) min: 100.0) max: 0.0) / 100.0.
	v := (((anArray at: 3) min: 100.0) max: 0.0) / 100.0.

	c := v * s.
	x := c * (1.0 - (((h / 60.0) mod: 2.0) - 1) abs).
	m := v - c.

	rgb := self hueFrom: h c: c x: x.

	self red: ((rgb at: 1) + m) * 255.
	self green: ((rgb at: 2) + m) * 255.
	self blue: ((rgb at: 3) + m) * 255.

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'converting'] value ! !
! Color methodsFor: 'converting' !
hueFrom: h c: c x: x

	h < 60.0 ifTrue: [^Array with: c with: x with: 0.0].
	h < 120.0 ifTrue: [^Array with: x with: c with: 0.0].
	h < 180.0 ifTrue: [^Array with: 0.0 with: c with: x].
	h < 240.0 ifTrue: [^Array with: 0.0 with: x with: c].
	h < 300 ifTrue: [^Array with: x with: 0.0 with: c].
	^Array with: c with: 0.0 with: x


 ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'printing'] value ! !
! Color methodsFor: 'printing' !
asString

	| stream |
	stream := WriteStream on: (String new: 10).
	stream nextPut: $#.
	self red printOn: stream paddedWith: $0 to: 2 base: 16.
	self green printOn: stream paddedWith: $0 to: 2 base: 16.
	self blue printOn: stream paddedWith: $0 to: 2 base: 16.
	self alpha printOn: stream paddedWith: $0 to: 2 base: 16.
 
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[Color methodsFor: 'printing'] value ! !
! Color methodsFor: 'printing' !
printOn: aStream

	aStream nextPutAll: self asString ! !
! Doit class methodsFor: 'doit' !
doit ^[Color class methodsFor: 'instance creation'] value ! !
! Color class methodsFor: 'instance creation' !
red: red green: green blue: blue

	^self red: red green: green blue: blue alpha: 255  ! !
! Doit class methodsFor: 'doit' !
doit ^[Color class methodsFor: 'instance creation'] value ! !
! Color class methodsFor: 'instance creation' !
red: red green: green blue: blue alpha: alpha

	^self new
		red: red;
		green: green;
		blue: blue;
		alpha: alpha;
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Color class methodsFor: 'instance creation'] value ! !
! Color class methodsFor: 'instance creation' !
white

	^self red: 255 green: 255 blue: 255 ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis methodsFor: 'accessing'] value ! !
! Emphasis methodsFor: 'accessing' !
endEmphasisTag

	^endEmphasisTag ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis methodsFor: 'accessing'] value ! !
! Emphasis methodsFor: 'accessing' !
endEmphasisTag: aString

	endEmphasisTag := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis methodsFor: 'accessing'] value ! !
! Emphasis methodsFor: 'accessing' !
startEmphasisTag

	^startEmphasisTag ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis methodsFor: 'accessing'] value ! !
! Emphasis methodsFor: 'accessing' !
startEmphasisTag: aString

	startEmphasisTag := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis methodsFor: 'emphasizing'] value ! !
! Emphasis methodsFor: 'emphasizing' !
endEmphasisOn: stream

	stream nextPutAll: self endEmphasisTag ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis methodsFor: 'emphasizing'] value ! !
! Emphasis methodsFor: 'emphasizing' !
startEmphasisOn: stream

	stream nextPutAll: self startEmphasisTag ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
blue

	^self new
		startEmphasisTag: '<span style=\"color:blue;\">';
		endEmphasisTag: '</span>';
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
bold

	^self new
		startEmphasisTag:  '<strong>';
		endEmphasisTag: '</strong>';
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
brown

	^self new
		startEmphasisTag: '<span style=\"color:brown;\">';
		endEmphasisTag: '</span>';
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
compileErrorHighlight

	^self new
		startEmphasisTag: '<span style=\"background-color:#C00;color:white;\">';
		endEmphasisTag: '</span>';
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
green

	^self new
		startEmphasisTag: '<span style=\"color:green;\">';
		endEmphasisTag: '</span>';
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
red

	^self new
		startEmphasisTag: '<span style=\"color:red;\">';
		endEmphasisTag: '</span>';
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Emphasis class methodsFor: 'instance creation'] value ! !
! Emphasis class methodsFor: 'instance creation' !
walkbackCallHighlight

	^self new
		startEmphasisTag: '<span style=\"background-color:#0C0;color:white;\">';
		endEmphasisTag: '</span>';
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'accessing'] value ! !
! EmphasisSpan methodsFor: 'accessing' !
emphasis

	^emphasis ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'accessing'] value ! !
! EmphasisSpan methodsFor: 'accessing' !
emphasis: anEmphasis

	emphasis := anEmphasis ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'accessing'] value ! !
! EmphasisSpan methodsFor: 'accessing' !
endOffset

	^endOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'accessing'] value ! !
! EmphasisSpan methodsFor: 'accessing' !
endOffset: anInteger

	endOffset := anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'accessing'] value ! !
! EmphasisSpan methodsFor: 'accessing' !
startOffset

	^startOffset ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'accessing'] value ! !
! EmphasisSpan methodsFor: 'accessing' !
startOffset: anInteger

	startOffset := anInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'emphasizing'] value ! !
! EmphasisSpan methodsFor: 'emphasizing' !
emphasizeForPosition: anInteger to: stream

	startOffset = anInteger ifTrue: [emphasis startEmphasisOn: stream].
	endOffset + 1 = anInteger ifTrue: [emphasis endEmphasisOn: stream].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'emphasizing'] value ! !
! EmphasisSpan methodsFor: 'emphasizing' !
endEmphasizeForPosition: anInteger to: stream

	endOffset + 1 = anInteger ifTrue: [emphasis endEmphasisOn: stream].
 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'emphasizing'] value ! !
! EmphasisSpan methodsFor: 'emphasizing' !
startEmphasizeForPosition: anInteger to: stream

	startOffset = anInteger ifTrue: [emphasis startEmphasisOn: stream].

 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan methodsFor: 'printing'] value ! !
! EmphasisSpan methodsFor: 'printing' !
printOn: aStream

	aStream nextPutAll: 'Emphasis from ', self startOffset printString, ' to ', self endOffset printString ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisSpan class methodsFor: 'instance creation'] value ! !
! EmphasisSpan class methodsFor: 'instance creation' !
from: start to: end with: emphasis

	^self new
		startOffset: start;
		endOffset: end;
		emphasis: emphasis;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisStream methodsFor: 'emphasizing'] value ! !
! EmphasisStream methodsFor: 'emphasizing' !
writeEmphasisOn: aStream forIndex: index

	nextOffset = index ifFalse: [^self].

	self
		writeEndEmphasisOn: aStream forIndex: index;
		writeStartEmphasisOn: aStream forIndex: index.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisStream methodsFor: 'emphasizing'] value ! !
! EmphasisStream methodsFor: 'emphasizing' !
writeEndEmphasisOn: aStream forIndex: anInteger

	nestedSpans copy reverseDo: [:span |
		span endOffset + 1 = anInteger ifTrue: [
			span endEmphasizeForPosition: anInteger to: aStream.
			nestedSpans remove: span] ]


 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisStream methodsFor: 'emphasizing'] value ! !
! EmphasisStream methodsFor: 'emphasizing' !
writeStartEmphasisOn: aStream forIndex: anInteger

	| nextSpan |

	[
	sortedSpanIndex > sortedEmphasisSpans size ifTrue: [
		nextSpan := nil.
		nextOffset := 0.
		^self].
	nextSpan := (sortedEmphasisSpans at: sortedSpanIndex).
	anInteger = nextSpan startOffset] whileTrue: [
		nestedSpans add: nextSpan.
		sortedSpanIndex := sortedSpanIndex + 1.
		nextSpan startEmphasizeForPosition: anInteger to: aStream].

	nextSpan := (sortedEmphasisSpans at: sortedSpanIndex).
	nextOffset := nestedSpans inject: nextSpan startOffset into: [:index :span | index min: span endOffset + 1].

 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisStream methodsFor: 'initializing'] value ! !
! EmphasisStream methodsFor: 'initializing' !
on: aCollection

	sortedEmphasisSpans := aCollection copy sortedBy: [:a :b | a startOffset < b startOffset or: [a startOffset = b startOffset and: [a endOffset > b endOffset]]].
	sortedSpanIndex := 1.
	aCollection isEmpty ifFalse: [nextOffset := aCollection first startOffset].
	nestedSpans := OrderedCollection new
	
 ! !
! Doit class methodsFor: 'doit' !
doit ^[EmphasisStream class methodsFor: 'instance creation'] value ! !
! EmphasisStream class methodsFor: 'instance creation' !
on: aCollection

	^super new on: aCollection; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Event methodsFor: 'converting'] value ! !
! Event methodsFor: 'converting' !
eventKey

	^self class ! !
! Doit class methodsFor: 'doit' !
doit ^[EventModel methodsFor: 'accessing'] value ! !
! EventModel methodsFor: 'accessing' !
changed

	self signalEvent: #changed ! !
! Doit class methodsFor: 'doit' !
doit ^[EventModel methodsFor: 'events'] value ! !
! EventModel methodsFor: 'events' !
on: eventName send: selector to: receiver

	(eventRegistry at: eventName ifAbsentPut: [OrderedCollection new])
		add: [receiver perform: selector with: self] ! !
! Doit class methodsFor: 'doit' !
doit ^[EventModel methodsFor: 'events'] value ! !
! EventModel methodsFor: 'events' !
on: eventName send: selector to: receiver with: argument

	(eventRegistry at: eventName ifAbsentPut: [OrderedCollection new])
		add: [receiver perform: selector with: argument with: self] ! !
! Doit class methodsFor: 'doit' !
doit ^[EventModel methodsFor: 'events'] value ! !
! EventModel methodsFor: 'events' !
signalEvent: aSymbol

	(eventRegistry at: aSymbol ifAbsent: [
		^self]) do: [:each | each value] ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'accessing'] value ! !
! HTMLBuilder methodsFor: 'accessing' !
currentNode

	^currentNode ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'accessing'] value ! !
! HTMLBuilder methodsFor: 'accessing' !
currentNode: anObject

	currentNode := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'accessing'] value ! !
! HTMLBuilder methodsFor: 'accessing' !
htmlNode

	^htmlNode ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'accessing'] value ! !
! HTMLBuilder methodsFor: 'accessing' !
htmlNode: anObject

	htmlNode := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'accessing'] value ! !
! HTMLBuilder methodsFor: 'accessing' !
nodeStack

	^nodeStack ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'accessing'] value ! !
! HTMLBuilder methodsFor: 'accessing' !
nodeStack: anOrderedCollection

	nodeStack := anOrderedCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
attributeAt: keyString put: valueString

	self currentNode attributeAt: keyString put: valueString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
class: aString

	self key: 'class' value: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
div

	self startTag: 'div' ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
div: aBlock

	self inTag: 'div' do: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
endDiv

	self endTag: 'div' ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
endTag: aString

	self nodeStack removeLast.
	self currentNode: (self nodeStack isEmpty
		ifTrue: [nil]
		ifFalse: [self nodeStack last]) ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
endTagStyle

	self nodeStack removeLast.
	self currentNode: (self nodeStack isEmpty
		ifTrue: [nil]
		ifFalse: [self nodeStack last]) ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
htmlString

	| stream |

	stream := WriteStream on: (ByteString new: 10).
	self htmlNode htmlPrintOn: stream.
	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
id: aString

	self key: 'id' value: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
inHorizontalLayout: aString do: aBlock

	self inTag: 'div' do: [:builder |
		builder
			id: aString;
			attributeAt: 'style' put: 'grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); display: grid;'.
		aBlock value: builder]
  ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
inStyle: aString do: aBlock

	| style |

	style := HTMLStyleDefinition name: aString.

	self currentNode ifNotNil: [:node | node addStyle: style].

	self nodeStack add: style.
	self currentNode: style.

	aBlock cull: self.

	self nodeStack removeLast.
	self currentNode: (self nodeStack isEmpty
		ifTrue: [nil]
		ifFalse: [self nodeStack last]) ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
inTag: aString do: aBlock

	self startTag: aString.
	aBlock cull: self.
	self endTag: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
install: anObject

	anObject renderOn: self
  ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
key: keyString value: valueString

	self attributeAt: keyString put: valueString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
perform: aSelector on: anObject

	anObject perform: aSelector with: self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
startTag: aString

	| tag |

	tag := HTMLTag name: aString.

	htmlNode isNil ifTrue: [htmlNode := tag].

	self currentNode ifNotNil: [:node | node addTag: tag].

	self nodeStack add: tag.
	self currentNode: tag. ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
tagStyle

	| style |

	style := HTMLStyleDefinition name: ''.

	self currentNode ifNotNil: [:node | node addStyle: style].

	self nodeStack add: style.
	self currentNode: style. ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'building'] value ! !
! HTMLBuilder methodsFor: 'building' !
text: aString

	self currentNode addTag: (HTMLText text: aString) ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'initialize-release'] value ! !
! HTMLBuilder methodsFor: 'initialize-release' !
initialize

	self
		nodeStack: OrderedCollection new;
		htmlNode: nil ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'string quoting'] value ! !
! HTMLBuilder methodsFor: 'string quoting' !
htmlUnquote: aString

	| in out inTag|

	in := aString readStream.
	out := WriteStream on: (String new: aString size).
	inTag := false.

	[in atEnd] whileFalse: [
		| character |
		character := in next.
		self htmlUnquoteCharacter: character from: in to: out].

	^out contents
 ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'string quoting'] value ! !
! HTMLBuilder methodsFor: 'string quoting' !
htmlUnquoteCharacter: character from: in to: out

	character = $< ifTrue: [^self htmlUnquoteTagIn: in out: out].
	character = $& ifTrue: [^self htmlUnquoteSpecialCharacterIn: in out: out].
	out nextPut: character ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'string quoting'] value ! !
! HTMLBuilder methodsFor: 'string quoting' !
htmlUnquoteSpecialCharacterIn: in out: out

	| stream finished characterName |

	stream := WriteStream on: (String new: 10).
	finished := false.

	[in atEnd not & finished not] whileTrue: [
		| character |
		character := in next.
		character = $;
			ifTrue: [finished := true]
			ifFalse: [stream nextPut: character]].

	characterName := stream contents.
	characterName = 'gt' ifTrue: [out nextPut: $>. ^self].
	characterName = 'lt' ifTrue: [out nextPut: $<. ^self].
	characterName = 'amp' ifTrue: [out nextPut: $&. ^self].
	characterName = 'quot' ifTrue: [out nextPut: $". ^self].
	characterName = 'apos' ifTrue: [out nextPut: $'. ^self].


 ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder methodsFor: 'string quoting'] value ! !
! HTMLBuilder methodsFor: 'string quoting' !
htmlUnquoteTagIn: in out: out

	[in atEnd] whileFalse: [in next = $> ifTrue: [^self]]. ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLBuilder class methodsFor: 'instance creation'] value ! !
! HTMLBuilder class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
attributes

	^attributes ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
attributes: anObject

	attributes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
for: aString

	self name: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
keys

	^keys ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
keys: anObject

	keys := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'accessing'] value ! !
! HTMLStyleDefinition methodsFor: 'accessing' !
name: anObject

	name := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'building'] value ! !
! HTMLStyleDefinition methodsFor: 'building' !
addKey: aString

	self keys add: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'building'] value ! !
! HTMLStyleDefinition methodsFor: 'building' !
attributeAt: key put: value

	self attributes at: key put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'html'] value ! !
! HTMLStyleDefinition methodsFor: 'html' !
htmlPrintAttributesOn: aStream

	self attributes keysAndValuesDo: [:key :value |
		aStream
			nextPutAll: key;
			nextPutAll: ': ';
			nextPutAll: value;
			nextPutAll: ';';
			cr]. ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'html'] value ! !
! HTMLStyleDefinition methodsFor: 'html' !
htmlPrintOn: aStream

	self keys do: [:each | aStream nextPutAll: each] separatedBy: [aStream space].
	aStream
		nextPutAll: self name;
		nextPutAll: ' {'; cr.
	self htmlPrintAttributesOn: aStream.
	aStream nextPutAll: '}'; cr ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'initialize-release'] value ! !
! HTMLStyleDefinition methodsFor: 'initialize-release' !
initialize

	self keys: OrderedCollection new.
	self attributes: Dictionary new ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'printing'] value ! !
! HTMLStyleDefinition methodsFor: 'printing' !
printOn: aStream

	self htmlPrintOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition methodsFor: 'uncategorized'] value ! !
! HTMLStyleDefinition methodsFor: 'uncategorized' !
with: aBlock

	aBlock value: self ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition class methodsFor: 'instance creation'] value ! !
! HTMLStyleDefinition class methodsFor: 'instance creation' !
name: aString

	^self new
		name: aString;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLStyleDefinition class methodsFor: 'instance creation'] value ! !
! HTMLStyleDefinition class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
addStyle: aStyleDefinition

	self styles add: aStyleDefinition ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
addTag: aTag

	self children add: aTag ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
attributes

	^attributes ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
attributes: anObject

	attributes := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
children

	^children ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
children: anObject

	children := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
styles

	^styles ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
styles: anObject

	styles := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
tagName

	^tagName ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'accessing'] value ! !
! HTMLTag methodsFor: 'accessing' !
tagName: anObject

	tagName := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'attributes'] value ! !
! HTMLTag methodsFor: 'attributes' !
htmlClass: aString

	self attributeAt: 'class' put: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'attributes'] value ! !
! HTMLTag methodsFor: 'attributes' !
id: aString

	self attributeAt: 'id' put: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'attributes'] value ! !
! HTMLTag methodsFor: 'attributes' !
on: aSymbol send: selector to: receiver

	self attributeAt: 'on', aSymbol put: 'simTalkCallback0(''', receiver, ''', ''', selector, ''')' ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'attributes'] value ! !
! HTMLTag methodsFor: 'attributes' !
on: aSymbol send: selector to: receiver with: aString

	self attributeAt: 'on', aSymbol put: 'simTalkCallback1(''$', receiver appName, ''', ''', selector, ''', ''', aString, ''')' ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'attributes'] value ! !
! HTMLTag methodsFor: 'attributes' !
with: aBlock

	| newBuilder |

	newBuilder := HTMLBuilder new.
	aBlock value: newBuilder.
	self children: newBuilder htmlNode allNodes ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'html'] value ! !
! HTMLTag methodsFor: 'html' !
htmlPrintOn: aStream

	aStream nextPutAll: '<';
		nextPutAll: self tagName;
		space.
	self attributes keysAndValuesDo: [:key :value |
		aStream nextPutAll: key;
			nextPutAll: '="';
			nextPutAll: value;
			nextPutAll: '" '].
	aStream nextPutAll: '>'; cr.
	self styles isEmpty ifFalse: [
		aStream nextPutAll: '<style>'; cr.
		self styles do: [:eachStyle | eachStyle htmlPrintOn: aStream].
		aStream nextPutAll: '</style>'; cr].
	self children do: [:child | child htmlPrintOn: aStream].
	aStream
		nextPutAll: '</';
		nextPutAll: self tagName;
		nextPutAll: '>';
		cr ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'initialize-release'] value ! !
! HTMLTag methodsFor: 'initialize-release' !
attributeAt: key

	^attributes at: key ifAbsent: [nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'initialize-release'] value ! !
! HTMLTag methodsFor: 'initialize-release' !
attributeAt: key put: value

	attributes at: key put: value ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'initialize-release'] value ! !
! HTMLTag methodsFor: 'initialize-release' !
initialize

	attributes := Dictionary new.
	children := OrderedCollection new.
	styles := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag methodsFor: 'printing'] value ! !
! HTMLTag methodsFor: 'printing' !
printOn: aStream

	self htmlPrintOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag class methodsFor: 'instance creation'] value ! !
! HTMLTag class methodsFor: 'instance creation' !
name: aString

	^self new
		tagName: aString;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLTag class methodsFor: 'instance creation'] value ! !
! HTMLTag class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLText methodsFor: 'accessing'] value ! !
! HTMLText methodsFor: 'accessing' !
text

	^text ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLText methodsFor: 'accessing'] value ! !
! HTMLText methodsFor: 'accessing' !
text: anObject

	text := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLText methodsFor: 'html'] value ! !
! HTMLText methodsFor: 'html' !
htmlPrintOn: aStream

	aStream nextPutAll: self text ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLText methodsFor: 'printing'] value ! !
! HTMLText methodsFor: 'printing' !
printOn: aStream

	aStream nextPutAll: self text ! !
! Doit class methodsFor: 'doit' !
doit ^[HTMLText class methodsFor: 'instance creation'] value ! !
! HTMLText class methodsFor: 'instance creation' !
text: aString

	^self new text: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONEvaluator methodsFor: 'accessing'] value ! !
! JSONEvaluator methodsFor: 'accessing' !
webSession

	^webSession ifNil: [WebSession current] ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONEvaluator methodsFor: 'accessing'] value ! !
! JSONEvaluator methodsFor: 'accessing' !
webSession: anObject

	webSession := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONEvaluator methodsFor: 'evaluating'] value ! !
! JSONEvaluator methodsFor: 'evaluating' !
evaluate: aCollection

	| result |

	aCollection do: [:each |
		result := self evaluateCommand: each].
	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONEvaluator methodsFor: 'evaluating'] value ! !
! JSONEvaluator methodsFor: 'evaluating' !
evaluateCommand: anArray

	| receiver |

	anArray size = 1 ifTrue: [^self evaluateObject: anArray first].
	receiver := self evaluateObject: anArray first.
	(receiver isUI and: [receiver isDisabled]) ifTrue: [^nil].
	^receiver perform: (anArray at: 2) asSymbol withArguments: (anArray copyFrom: 3 to: anArray size) ! !
! Doit class methodsFor: 'doit' !
doit ^[JSONEvaluator methodsFor: 'evaluating'] value ! !
! JSONEvaluator methodsFor: 'evaluating' !
evaluateObject: anObject

	anObject isNumber ifTrue: [^anObject].
	anObject = true  ifTrue: [^anObject].
	anObject = false  ifTrue: [^anObject].
	anObject = nil ifTrue: [^anObject].
	anObject isString ifTrue: [
		anObject first = $$ ifTrue: [^self webSession sessionVariableAt: (anObject copyFrom: 2 to: anObject size)].
		^anObject].
	anObject isCollection ifTrue: [^self evaluateCommand: anObject].
	self error: 'Unknown object' ! !
! Doit class methodsFor: 'doit' !
doit ^[KeyEvent methodsFor: 'converting'] value ! !
! KeyEvent methodsFor: 'converting' !
key
	^key ! !
! Doit class methodsFor: 'doit' !
doit ^[KeyEvent methodsFor: 'converting'] value ! !
! KeyEvent methodsFor: 'converting' !
key: aCharacter
	key := aCharacter ! !
! Doit class methodsFor: 'doit' !
doit ^[KeyEvent methodsFor: 'converting'] value ! !
! KeyEvent methodsFor: 'converting' !
modifiers: aSet
	modifiers := aSet ! !
! Doit class methodsFor: 'doit' !
doit ^[ListSelectionEvent methodsFor: 'accessing'] value ! !
! ListSelectionEvent methodsFor: 'accessing' !
selectionIndex

	^selectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListSelectionEvent methodsFor: 'accessing'] value ! !
! ListSelectionEvent methodsFor: 'accessing' !
selectionIndex: aNumber

	selectionIndex := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageReceivedEvent methodsFor: 'accessing'] value ! !
! MessageReceivedEvent methodsFor: 'accessing' !
message

	^message ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageReceivedEvent methodsFor: 'accessing'] value ! !
! MessageReceivedEvent methodsFor: 'accessing' !
message: aString

	message := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
action

	^action ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
action: aString

	action := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
enabledBlock

	^enabledBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
enabledBlock: aBlock

	enabledBlock := aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
id

	^id ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
id: aSymbol

	id := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
name: aString

	name := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
requestedValues

	^requestedValues ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
requestedValues: aCollection

	requestedValues := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
widgetId

	^widgetId ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'accessing'] value ! !
! PopupMenuItem methodsFor: 'accessing' !
widgetId: aString

	widgetId := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'adding and removing'] value ! !
! PopupMenuItem methodsFor: 'adding and removing' !
addRequestedValue: aSymbol

	self requestedValues add: aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'initializing'] value ! !
! PopupMenuItem methodsFor: 'initializing' !
initialize

	super initialize.
	enabledBlock := [true].
	requestedValues := Set new ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'rendering'] value ! !
! PopupMenuItem methodsFor: 'rendering' !
menuCallbackString

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallbackNoCapture(''$$appName$'', ''';
		nextPutAll: self id;
		nextPutAll: ''', ''';
		nextPutAll: self widgetId;
		nextPutAll: ''', ''doMenuWith:'', ['.

	self requestedValues do: [:each | stream nextPut: $'; nextPutAll: each; nextPut: $'] separatedBy: [stream nextPutAll: ' , '].

	stream
		nextPutAll: '], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem methodsFor: 'rendering'] value ! !
! PopupMenuItem methodsFor: 'rendering' !
renderHTMLOn: anHTMLBuilder

	anHTMLBuilder div: [
		anHTMLBuilder
			attributeAt: 'class' put: 'menuItem'.

		self enabledBlock value
			ifTrue: [anHTMLBuilder attributeAt: 'onclick' put: self menuCallbackString]
			ifFalse: [anHTMLBuilder attributeAt: 'style' put: 'color: #A0A0A0;'].

		anHTMLBuilder attributeAt: 'onmouseover' put: 'captureRichTextSelection(''', self widgetId,''');'.
		anHTMLBuilder text: self name] ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuItem class methodsFor: 'instance creation'] value ! !
! PopupMenuItem class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
bottom

	^corner y ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
bounds

	^origin corner: corner ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
center

	^Point x: (origin x + corner x) / 2.0 y: (origin y + corner y) / 2.0 ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
corner

	^corner ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
corner: aPoint 

	corner := aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
extent

	^Point x: self width y: self height ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
left

	^origin x ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
origin

	^origin ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
origin: aPoint 

	origin := aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
right

	^corner x ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'accessing'] value ! !
! Rectangle methodsFor: 'accessing' !
top

	^origin y ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'computed values'] value ! !
! Rectangle methodsFor: 'computed values' !
+ aPoint

	^self translatedBy: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'computed values'] value ! !
! Rectangle methodsFor: 'computed values' !
- aPoint

	^self translatedBy: aPoint negated ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'computed values'] value ! !
! Rectangle methodsFor: 'computed values' !
height
	^corner y - origin y ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'computed values'] value ! !
! Rectangle methodsFor: 'computed values' !
translatedBy: aPoint

	^self origin + aPoint corner: self corner + aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'computed values'] value ! !
! Rectangle methodsFor: 'computed values' !
width
	^corner x - origin x ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'printing'] value ! !
! Rectangle methodsFor: 'printing' !
printOn: aStream 

	self origin printOn: aStream.
	aStream nextPutAll: ' corner: '.
	self corner printOn: aStream ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'rendering'] value ! !
! Rectangle methodsFor: 'rendering' !
triangleVertices

	^(Array new: 12)
		at: 1 put: origin x;
		at: 2 put: corner y;
		at: 3 put: origin x;
		at: 4 put: origin y;
		at: 5 put: corner x;
		at: 6 put: origin y;
		at: 7 put: origin x;
		at: 8 put: corner y;
		at: 9 put: corner x;
		at: 10 put: origin y;
		at: 11 put: corner x;
		at: 12 put: corner y;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle methodsFor: 'testing'] value ! !
! Rectangle methodsFor: 'testing' !
containsPoint: aPoint 

	(aPoint x between: origin x and: corner x)
		ifTrue: [^aPoint y between: origin y and: corner y].
	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle class methodsFor: 'instance creation'] value ! !
! Rectangle class methodsFor: 'instance creation' !
origin: origin corner: corner 

	^self new
		origin: origin;
		corner: corner;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Rectangle class methodsFor: 'instance creation'] value ! !
! Rectangle class methodsFor: 'instance creation' !
origin: origin extent: extent 

	^self new
		origin: origin;
		corner: origin + extent;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SessionVariable methodsFor: 'accessing'] value ! !
! SessionVariable methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[SessionVariable methodsFor: 'accessing'] value ! !
! SessionVariable methodsFor: 'accessing' !
value: anObject

	value := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[SessionVariable methodsFor: 'integer operations'] value ! !
! SessionVariable methodsFor: 'integer operations' !
decrement

	^value := value - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[SessionVariable methodsFor: 'integer operations'] value ! !
! SessionVariable methodsFor: 'integer operations' !
decrementBy: aNumber

	^value := value - aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[SessionVariable methodsFor: 'integer operations'] value ! !
! SessionVariable methodsFor: 'integer operations' !
increment

	^value := value + 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[SessionVariable methodsFor: 'integer operations'] value ! !
! SessionVariable methodsFor: 'integer operations' !
incrementBy: aNumber

	^value := value + aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
displayBlock

	^displayBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
displayBlock: aBlock

	displayBlock := aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
height

	^height ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
height: aString

	height := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
id

	^id ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
id: aString

	id := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
menu

	^menu ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
menu: aMenu

	menu := aMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
ui

	^ui ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'accessing'] value ! !
! UIComponent methodsFor: 'accessing' !
ui: aString

	ui := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'binding'] value ! !
! UIComponent methodsFor: 'binding' !
bind

	WebSession current sessionVariableAt: self id put: self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'binding'] value ! !
! UIComponent methodsFor: 'binding' !
bindTo: aUI

	aUI bindComponent: self
  ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'binding'] value ! !
! UIComponent methodsFor: 'binding' !
bindTo: aUI as: aSymbol

	self id: (aUI idFor: aSymbol).
	self bindTo: aUI
  ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'binding'] value ! !
! UIComponent methodsFor: 'binding' !
bindTo: aUI id: aString

	self id: aString.
	self bindTo: aUI
  ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'binding'] value ! !
! UIComponent methodsFor: 'binding' !
unbind

	WebSession current removeSessionVariableAt: self id
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'callbacks'] value ! !
! UIComponent methodsFor: 'callbacks' !
openMenuX: x y: y

	self menu openIn: (self idFor: self id, 'Div') x: x y: y
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'rendering'] value ! !
! UIComponent methodsFor: 'rendering' !
htmlString

	| builder |
	builder := HTMLBuilder new.
	self renderOn: builder.
	^builder htmlString
    ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'updating'] value ! !
! UIComponent methodsFor: 'updating' !
update ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'utility'] value ! !
! UIComponent methodsFor: 'utility' !
idFor: aString

	^self ui idFor: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[UIComponent methodsFor: 'utility'] value ! !
! UIComponent methodsFor: 'utility' !
renderOn: anHTMLBuilder


 ! !
! Doit class methodsFor: 'doit' !
doit ^[CompositeComponent methodsFor: 'accessing'] value ! !
! CompositeComponent methodsFor: 'accessing' !
children

	^children ! !
! Doit class methodsFor: 'doit' !
doit ^[CompositeComponent methodsFor: 'accessing'] value ! !
! CompositeComponent methodsFor: 'accessing' !
children: anObject

	children := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[CompositeComponent methodsFor: 'initializing'] value ! !
! CompositeComponent methodsFor: 'initializing' !
initialize

	super initialize.
	self children: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
list

	^list ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
list: anObject

	list = anObject ifTrue: [^self].

	list := anObject.
	selectionIndex := -1.
	self
		updateList;
		updateSelectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
listNumberOfRows

	^listNumberOfRows ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
listNumberOfRows: anObject 

	listNumberOfRows:= anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
optionStyles

	^optionStyles ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
optionStyles: anObject 

	optionStyles := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
selectionIndex

	^selectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
selectionIndex: anObject 
	selectionIndex = anObject ifTrue: [^self].
	selectionIndex := anObject.
	self updateSelectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
ui

	^ui ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'accessing'] value ! !
! ListComponent methodsFor: 'accessing' !
ui: aWebUI

	ui := aWebUI ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'callbacks'] value ! !
! ListComponent methodsFor: 'callbacks' !
changedSelectedItem: aString

	self selectionIndex: (Integer readFrom: aString readStream).
	self raiseEvent: (ListSelectionEvent new
		selectionIndex: self selectionIndex;
		yourself)  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'callbacks'] value ! !
! ListComponent methodsFor: 'callbacks' !
doubleClick

	self raiseEvent: DoubleClickEvent new ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'rendering'] value ! !
! ListComponent methodsFor: 'rendering' !
renderOn: anHTMLBuilder

	| heightString |

	anHTMLBuilder
		div;
			id: (self id, 'Div');
			attributeAt: 'width' put: '100%'.

	self menu isNil ifFalse: [
		anHTMLBuilder
			attributeAt: 'oncontextmenu'
			put: 'simTalkCallback2(''$', self id , ''', ''openMenuX:y:'', event.pageX, event.pageY); return false;'].

	heightString := self height isNil
		ifTrue: ['100%']
		ifFalse: [self height].

	anHTMLBuilder
			startTag: 'select';
				id: (self id);
				attributeAt: 'name' put: self id;
				attributeAt: 'size' put: self listNumberOfRows printString;
				attributeAt: 'style' put: 'width: 100%; height: ', heightString, '; background-color: rgba(255, 255, 255, 0.0);';
				attributeAt: 'onchange' put: 'simTalkCallback1(''$', self id , ''', ''changedSelectedItem:'' , event.target.value);';
				attributeAt: 'ondblclick' put: 'simTalkCallback0(''$', self id , ''', ''doubleClick'');';
			endTag: 'select';
		endDiv
  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'updating'] value ! !
! ListComponent methodsFor: 'updating' !
optionStyleFor: index

	self optionStyles isNil ifTrue: [^''].
	self optionStyles size >= index ifFalse: [^''].
	^' style=\"', (self optionStyles at: index), '\"'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'updating'] value ! !
! ListComponent methodsFor: 'updating' !
selection

	self selectionIndex = 0 ifTrue: [^nil].
	^self list at: self selectionIndex  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'updating'] value ! !
! ListComponent methodsFor: 'updating' !
updateList

	| stream |

	stream := WriteStream on: (ByteString new: 1000).

	self list keysAndValuesDo: [:key :eachElement |
		stream
			nextPutAll: '<option value=', key printString, (self optionStyleFor: key), '>';
			nextPutAll: (self displayBlock isNil ifTrue: [eachElement] ifFalse: [self displayBlock value: eachElement]);
			nextPutAll: '</option>'].

	self ui setInnerHTMLOf: self id to: stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[ListComponent methodsFor: 'updating'] value ! !
! ListComponent methodsFor: 'updating' !
updateSelectionIndex

	self ui runJavaScript: 'document.getElementById("', self id, '").selectedIndex = "', (self selectionIndex - 1) printString, '";'  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
list

	^list ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
list: anObject

	list = anObject ifTrue: [^self].

	list := anObject.
	selectionIndex := -1.
	self
		updateList;
		updateSelectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
listNumberOfRows

	^listNumberOfRows ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
listNumberOfRows: anObject 

	listNumberOfRows:= anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
optionStyles

	^optionStyles ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
optionStyles: anObject 

	optionStyles := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
selection

	selectionIndex = 0 ifTrue: [^nil].
	^self list at: self selectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
selectionIndex

	^selectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
selectionIndex: anObject 
	selectionIndex = anObject ifTrue: [^self].
	selectionIndex := anObject.
	self updateSelectionIndex ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
ui

	^ui ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'accessing'] value ! !
! ListDivComponent methodsFor: 'accessing' !
ui: aWebUI

	ui := aWebUI ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'actions'] value ! !
! ListDivComponent methodsFor: 'actions' !
changedSelectedItem: anObject

	self selectionIndex: (Integer readFrom: anObject readStream).
	self raiseEvent: (ListSelectionEvent new
		selectionIndex: self selectionIndex;
		yourself).
	self updateList
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'callbacks'] value ! !
! ListDivComponent methodsFor: 'callbacks' !
doubleClick

	self raiseEvent: DoubleClickEvent new ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'rendering'] value ! !
! ListDivComponent methodsFor: 'rendering' !
renderOn: anHTMLBuilder

	| heightString |

	anHTMLBuilder
		div;
			id: (self id, 'Div');
			attributeAt: 'width' put: '100%';
			attributeAt: 'style' put: 'border: 1px black solid; overflow-y: auto;';
			attributeAt: 'padding' put: '5px'.

	self menu isNil ifFalse: [
		anHTMLBuilder
			attributeAt: 'oncontextmenu'
			put: 'simTalkCallback2(''$', self id , ''', ''openMenuX:y:'', event.pageX, event.pageY); return false;'].

	heightString := self height isNil
		ifTrue: ['100%']
		ifFalse: [self height].

	anHTMLBuilder
			startTag: 'div';
				attributeAt: 'style' put: 'list-style-type: none';
				id: (self id);
			endTag: 'dov';
		endDiv
  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'updating'] value ! !
! ListDivComponent methodsFor: 'updating' !
optionStyleFor: index

	self optionStyles isNil ifTrue: [^''].
	self optionStyles size >= index ifFalse: [^''].
	^' style=\"', (self optionStyles at: index), '\"'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'updating'] value ! !
! ListDivComponent methodsFor: 'updating' !
updateList

	| htmlBuilder |

	htmlBuilder := HTMLBuilder new.

	htmlBuilder div: [:builder1 |
		builder1 attributeAt: 'style' put: 'padding: 5px;'.
		self list keysAndValuesDo: [:key :eachElement |
			builder1 div: [:builder2 |
				builder2 id: self id, '-', key printString.
				key = self selectionIndex ifTrue: [
					builder2 attributeAt: 'style' put: 'background-color: #C0C0FF;'].
				builder2 attributeAt: 'onclick' put: 'simTalkCallback1(''$', self id , ''', ''changedSelectedItem:'' , ''', key printString, ''');'.
				builder2 text: (self displayBlock isNil ifTrue: [eachElement] ifFalse: [self displayBlock value: eachElement])
				]]].

	self ui setInnerHTMLOf: self id to: (self ui javascriptQuote: htmlBuilder htmlString) ! !
! Doit class methodsFor: 'doit' !
doit ^[ListDivComponent methodsFor: 'updating'] value ! !
! ListDivComponent methodsFor: 'updating' !
updateSelectionIndex

 ! !
! Doit class methodsFor: 'doit' !
doit ^[PushButtonComponent methodsFor: 'accessing'] value ! !
! PushButtonComponent methodsFor: 'accessing' !
actionBlock

	^actionBlock  ! !
! Doit class methodsFor: 'doit' !
doit ^[PushButtonComponent methodsFor: 'accessing'] value ! !
! PushButtonComponent methodsFor: 'accessing' !
actionBlock: aBlock

	actionBlock := aBlock  ! !
! Doit class methodsFor: 'doit' !
doit ^[PushButtonComponent methodsFor: 'accessing'] value ! !
! PushButtonComponent methodsFor: 'accessing' !
label

	^label  ! !
! Doit class methodsFor: 'doit' !
doit ^[PushButtonComponent methodsFor: 'accessing'] value ! !
! PushButtonComponent methodsFor: 'accessing' !
label: aString

	label := aString  ! !
! Doit class methodsFor: 'doit' !
doit ^[PushButtonComponent methodsFor: 'actions'] value ! !
! PushButtonComponent methodsFor: 'actions' !
pressAction

	self actionBlock value
  ! !
! Doit class methodsFor: 'doit' !
doit ^[PushButtonComponent methodsFor: 'rendering'] value ! !
! PushButtonComponent methodsFor: 'rendering' !
renderOn: anHTMLBuilder

	anHTMLBuilder
		div;
			id: (self id);
			attributeAt: 'class' put: 'button';
			attributeAt: 'tabIndex' put: '2';
			attributeAt: 'onclick' put: 'simTalkCallback0(''$', self id , ''', ''pressAction'');';
			attributeAt: 'style' put: 'align-self: center;';
			text: (self label ifNil: ['']);
		endDiv
      ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
emphasisCollection

	^emphasisCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
emphasisCollection: aCollection

	emphasisCollection := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
selectionEnd

	^selectionEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
selectionEnd: aNumber

	selectionEnd := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
selectionStart

	^selectionStart ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
selectionStart: aNumber

	selectionStart := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
subject

	^subject ifNil: [Doit] ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
subject: anObject

	subject := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
text

	^text ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'accessing'] value ! !
! RichTextEditorComponent methodsFor: 'accessing' !
text: aString

	text := aString.
	self
		clearEmphasis;
		updateText  ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'emphasis'] value ! !
! RichTextEditorComponent methodsFor: 'emphasis' !
addEmphasis: anEmphasisSpan

	self emphasisCollection add: anEmphasisSpan ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'emphasis'] value ! !
! RichTextEditorComponent methodsFor: 'emphasis' !
clearEmphasis

	emphasisCollection := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'initializing'] value ! !
! RichTextEditorComponent methodsFor: 'initializing' !
initialize

	super initialize.
	self
		text: '';
		selectionStart: 0;
		selectionEnd: 0;
		emphasisCollection: OrderedCollection new
 ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
codeMenu

	^PopupMenuUI new
		widgetId: self id;
		addMenuItem: self doItMenuItem;
		addMenuItem: self printItMenuItem;
		addMenuItem: self inspectItMenuItem;
		addMenuItem: self loadMenuItem;
		addMenuItem: self saveMenuItem;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
doItMenuItem

	^PopupMenuItem new
		id: #doIt;
		name: 'Do It';
		action: [:args | self doItWith: args];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
doItWith: aDictionary

	self ui disableWhile: [SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self subject] ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
inspectItMenuItem

	^PopupMenuItem new
			id: #inspectIt;
			name: 'Inspect It';
			action: [:args | self inspectItWith: args];
			requestedValues: #('selectedString');
			yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
inspectItWith: aDictionary

	| object |

	self ui disableWhile: [object := SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self subject].

	object inspect ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
installCodeMenu

	self menu: self codeMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
load: aString

	| workspaceContents fileStream |

	aString isNil ifTrue: [^self].
	aString asFilename exists ifFalse: [^self message: 'File doesn''t exist'].

	fileStream := aString asFilename readStream.
	workspaceContents := fileStream upToEnd.
	fileStream close.

	self
		clearEmphasis;
		text: workspaceContents;
		updateText ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
loadMenuItem

	^PopupMenuItem new
		id: #load;
		name: 'Load...';
		action: [:args | self loadWith: args];
		requestedValues: #();
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
loadWith: aDictionary

	self request: 'Filename to load?' initialAnswer: 'workspace.ws' answerBlock: [:string | self load: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
printItMenuItem

	^PopupMenuItem new
		id: #printIt;
		name: 'Print It';
		action: [:args | self printItWith: args];
		requestedValues: #('selectedString' 'selectionStart' 'selectionEnd');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
printItWith: aDictionary

	| result |

	self ui disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'selectedString')) printString].

	self write: result inTextArea: self id position: (aDictionary at: 'selectionEnd') ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
save: aString to: filenameString

	| file |

	file := filenameString asFilename writeStream.
	file nextPutAll: aString.
	file close
 ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
saveMenuItem

	^PopupMenuItem new
		id: #save;
		name: 'Save...';
		action: [:args | self saveWith: args];
		requestedValues: #('innerHTML');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'menus'] value ! !
! RichTextEditorComponent methodsFor: 'menus' !
saveWith: aDictionary

	self request: 'Filename to save?' initialAnswer: 'workspace.ws' answerBlock: [:string | self save: (aDictionary at: 'value') to: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'rendering'] value ! !
! RichTextEditorComponent methodsFor: 'rendering' !
renderOn: anHTMLBuilder

	| heightString |

	anHTMLBuilder
		div;
			id: (self id, 'Div');
			attributeAt: 'width' put: '100%'.

	self menu isNil ifFalse: [
		anHTMLBuilder
			attributeAt: 'oncontextmenu'
			put: 'simTalkCallback2(''$', self id , ''', ''openMenuX:y:'', event.pageX, event.pageY); return false;'].

	heightString := self height isNil
		ifTrue: ['100%']
		ifFalse: [self height].

	anHTMLBuilder
			startTag: 'div';
				id: (self id);
				attributeAt: 'contenteditable' put: 'true';
				attributeAt: 'name' put: self id;
				attributeAt: 'width' put: '100%';
				attributeAt: 'spellcheck' put: 'false';
				attributeAt: 'style' put: 'border: 1px solid black; padding: 3px;overflow-y: scroll;width: 100%; height: ', heightString,
					';background-color: transparent; resize: none; white-space:pre; font-family:arial; font-size:14px;line-height:1.4;';
				attributeAt: 'tabIndex' put: '2'.

			self height isNil
				ifTrue: [anHTMLBuilder attributeAt: 'height' put: '100%']
				ifFalse: [anHTMLBuilder attributeAt: 'height' put: self height].

		anHTMLBuilder
			endTag: 'div';
		endDiv
    ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'updating'] value ! !
! RichTextEditorComponent methodsFor: 'updating' !
quotedText

	| in out mappings emphasisStream |
	in := self text readStream.
	out := WriteStream on: (String new: self text size).
	mappings := Dictionary new.
	mappings
		at: $\ put: '\\';
		at: Character cr put: '\r\n';
		at: Character tab put: '\t';
		at: $< put: '&lt;';
		at: $> put: '&gt;';
		at: $& put: '&amp;';
		at: $" put: '\"';
		at: $' put: '&apos;'.

	emphasisStream := EmphasisStream on: emphasisCollection.

	[in atEnd] whileFalse: [
		| character replacement |
		character := in next.

		emphasisStream writeEmphasisOn: out forIndex: in position.

		replacement := mappings at: character ifAbsent: [nil].
		replacement isNil
			ifTrue: [out nextPut: character]
			ifFalse: [out nextPutAll: replacement]].

	emphasisStream writeEmphasisOn: out forIndex: in position.

	^out contents ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'updating'] value ! !
! RichTextEditorComponent methodsFor: 'updating' !
setSelectionFrom: startOffset to: endOffset

	self ui runJavaScript: 'setSelectionByAbsoluteOffsets(''', self id , ''',' , startOffset printString, ',' , endOffset printString, ');'. ! !
! Doit class methodsFor: 'doit' !
doit ^[RichTextEditorComponent methodsFor: 'updating'] value ! !
! RichTextEditorComponent methodsFor: 'updating' !
updateText

	self ui isNil ifTrue: [^self].

	self ui setInnerHTMLOf: self id to: self quotedText ! !
! Doit class methodsFor: 'doit' !
doit ^[TextComponent methodsFor: 'accessing'] value ! !
! TextComponent methodsFor: 'accessing' !
text

	^text ! !
! Doit class methodsFor: 'doit' !
doit ^[TextComponent methodsFor: 'accessing'] value ! !
! TextComponent methodsFor: 'accessing' !
text: anObject

	text := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[TextComponent methodsFor: 'rendering'] value ! !
! TextComponent methodsFor: 'rendering' !
renderOn: anHTMLBuilder

	anHTMLBuilder text: self text ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
emphasisCollection

	^emphasisCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
emphasisCollection: aCollection

	emphasisCollection := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
selectionEnd

	^selectionEnd ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
selectionEnd: aNumber

	selectionEnd := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
selectionStart

	^selectionStart ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
selectionStart: aNumber

	selectionStart := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
subject

	^subject ifNil: [Doit] ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
subject: anObject

	subject := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
text

	^text ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'accessing'] value ! !
! TextEditorComponent methodsFor: 'accessing' !
text: aString

	text := aString.
	self updateText  ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'emphasis'] value ! !
! TextEditorComponent methodsFor: 'emphasis' !
addEmphasis: anEmphasisSpan

	self emphasisCollection add: anEmphasisSpan ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'emphasis'] value ! !
! TextEditorComponent methodsFor: 'emphasis' !
clearEmphasis

	emphasisCollection := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'initializing'] value ! !
! TextEditorComponent methodsFor: 'initializing' !
initialize

	super initialize.
	self
		text: '';
		selectionStart: 0;
		selectionEnd: 0;
		emphasisCollection: OrderedCollection new
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
codeMenu

	^PopupMenuUI new
		widgetId: self id;
		addMenuItem: self doItMenuItem;
		addMenuItem: self printItMenuItem;
		addMenuItem: self inspectItMenuItem;
		addMenuItem: self loadMenuItem;
		addMenuItem: self saveMenuItem;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
doItMenuItem

	^PopupMenuItem new
		id: #doIt;
		name: 'Do It';
		action: [:args | self doItWith: args];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
doItWith: aDictionary

	self ui disableWhile: [SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self subject] ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
inspectItMenuItem

	^PopupMenuItem new
			id: #inspectIt;
			name: 'Inspect It';
			action: [:args | self inspectItWith: args];
			requestedValues: #('selectedString');
			yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
inspectItWith: aDictionary

	| object |

	self ui disableWhile: [object := SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self subject].

	object inspect ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
installCodeMenu

	self menu: self codeMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
load: aString

	| workspaceContents fileStream |

	aString isNil ifTrue: [^self].
	aString asFilename exists ifFalse: [^self message: 'File doesn''t exist'].

	fileStream := aString asFilename readStream.
	workspaceContents := fileStream upToEnd.
	fileStream close.

	self
		clearEmphasis;
		text: workspaceContents;
		updateText ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
loadMenuItem

	^PopupMenuItem new
		id: #load;
		name: 'Load...';
		action: [:args | self loadWith: args];
		requestedValues: #();
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
loadWith: aDictionary

	self request: 'Filename to load?' initialAnswer: 'workspace.ws' answerBlock: [:string | self load: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
printItMenuItem

	^PopupMenuItem new
		id: #printIt;
		name: 'Print It';
		action: [:args | self printItWith: args];
		requestedValues: #('selectedString' 'selectionStart' 'selectionEnd');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
printItWith: aDictionary

	| result |

	self ui disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'selectedString')) printString].

	self write: result inTextArea: self id position: (aDictionary at: 'selectionEnd') ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
save: aString to: filenameString

	| file |

	file := filenameString asFilename writeStream.
	file nextPutAll: aString.
	file close
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
saveMenuItem

	^PopupMenuItem new
		id: #save;
		name: 'Save...';
		action: [:args | self saveWith: args];
		requestedValues: #('value');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'menus'] value ! !
! TextEditorComponent methodsFor: 'menus' !
saveWith: aDictionary

	self request: 'Filename to save?' initialAnswer: 'workspace.ws' answerBlock: [:string | self save: (aDictionary at: 'value') to: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'rendering'] value ! !
! TextEditorComponent methodsFor: 'rendering' !
renderOn: anHTMLBuilder

	| heightString |

	anHTMLBuilder
		div;
			id: (self id, 'Div');
			attributeAt: 'width' put: '100%'.

	self menu isNil ifFalse: [
		anHTMLBuilder
			attributeAt: 'oncontextmenu'
			put: 'simTalkCallback2(''$', self id , ''', ''openMenuX:y:'', event.pageX, event.pageY); return false;'].

	heightString := self height isNil
		ifTrue: ['100%']
		ifFalse: [self height].

	anHTMLBuilder
			startTag: 'textarea';
				id: (self id);
				attributeAt: 'spellcheck' put: 'false';
				attributeAt: 'name' put: self id;
				attributeAt: 'width' put: '100%';
				attributeAt: 'style' put: 'width: 100%; height: ', heightString, ';background-color: transparent; resize: none;';
				attributeAt: 'tabIndex' put: '2'.

			self height isNil
				ifTrue: [anHTMLBuilder attributeAt: 'height' put: '100%']
				ifFalse: [anHTMLBuilder attributeAt: 'height' put: self height].

		anHTMLBuilder
			endTag: 'textarea';
		endDiv
    ! !
! Doit class methodsFor: 'doit' !
doit ^[TextEditorComponent methodsFor: 'updating'] value ! !
! TextEditorComponent methodsFor: 'updating' !
updateText

	self ui isNil ifTrue: [^self].
	self ui setAttribute: 'value' of: self id to: (self ui javascriptQuote: self text withEmphasis: self emphasisCollection)  ! !
! Doit class methodsFor: 'doit' !
doit ^[UIOperation methodsFor: 'accessing'] value ! !
! UIOperation methodsFor: 'accessing' !
arguments

	^arguments ! !
! Doit class methodsFor: 'doit' !
doit ^[UIOperation methodsFor: 'accessing'] value ! !
! UIOperation methodsFor: 'accessing' !
arguments: anObject

	arguments := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UIOperation methodsFor: 'accessing'] value ! !
! UIOperation methodsFor: 'accessing' !
name

	^name ! !
! Doit class methodsFor: 'doit' !
doit ^[UIOperation methodsFor: 'accessing'] value ! !
! UIOperation methodsFor: 'accessing' !
name: anObject

	name := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
addComponent: aComponent

	aComponent
		name: self nextComponentName;
		screen: self.
	self components add: aComponent.
	self addedComponents add: aComponent.
	self modifiedComponents add: aComponent.
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
addedCommands
	^self addedComponents collect: [:each |
		each addedCommand]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
addedComponents

	^addedComponents ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
addedComponents: anObject

	addedComponents := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
componentNumber
	^componentNumber
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
componentNumber: aNumber
	componentNumber := aNumber
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
components

	^components ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
components: anObject

	components := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
deletedCommands
	^self deletedComponents collect: [:each |
		each deletedCommand]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
deletedComponents

	^deletedComponents ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
deletedComponents: anObject

	deletedComponents := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
modifiedCommands
	^self modifiedComponents collect: [:each |
		each updateCommand]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
modifiedComponents

	^modifiedComponents ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
modifiedComponents: anObject

	modifiedComponents := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
nextComponentName

	self componentNumber: self componentNumber + 1.
	^'c-', self componentNumber printString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
webSocket
	^webSocket
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'accessing'] value ! !
! UIScreen methodsFor: 'accessing' !
webSocket: aWebSocket
	webSocket := aWebSocket
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'adding and removing'] value ! !
! UIScreen methodsFor: 'adding and removing' !
removeComponent: aComponent

	self components remove: aComponent ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'initialize-release'] value ! !
! UIScreen methodsFor: 'initialize-release' !
initialize

	self
		components: OrderedCollection new;
		componentNumber: 0;
		reset
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'initialize-release'] value ! !
! UIScreen methodsFor: 'initialize-release' !
reset
	self
		addedComponents: OrderedCollection new;
		deletedComponents: OrderedCollection new;
		modifiedComponents: OrderedCollection new
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'rendering'] value ! !
! UIScreen methodsFor: 'rendering' !
refreshCommands
	^self addedCommands copy
		addAll: self modifiedCommands;
		addAll: self deletedCommands;
		add: #('render' #());
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'rendering'] value ! !
! UIScreen methodsFor: 'rendering' !
renderChanges

	| stream |
	stream := WriteStream on: (String new: 100).

	stream nextPut: $~.
	self renderChangesOn: stream.
	webSocket send: stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen methodsFor: 'rendering'] value ! !
! UIScreen methodsFor: 'rendering' !
renderChangesOn: aStream

	self refreshCommands jsonOn: aStream.
	self reset ! !
! Doit class methodsFor: 'doit' !
doit ^[UIScreen class methodsFor: 'instance creation'] value ! !
! UIScreen class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueHolder methodsFor: 'accessing'] value ! !
! ValueHolder methodsFor: 'accessing' !
value

	^value ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueHolder methodsFor: 'accessing'] value ! !
! ValueHolder methodsFor: 'accessing' !
value: anObject 
	value := anObject.
	self changed ! !
! Doit class methodsFor: 'doit' !
doit ^[ValueHolder class methodsFor: 'instance creation'] value ! !
! ValueHolder class methodsFor: 'instance creation' !
value: anObject

	^self new
		value: anObject;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'accessing'] value ! !
! WebSession methodsFor: 'accessing' !
applications

	^applications ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'accessing'] value ! !
! WebSession methodsFor: 'accessing' !
applications: anObject

	applications := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'accessing'] value ! !
! WebSession methodsFor: 'accessing' !
currentOpenLocation

	^currentOpenLocation ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'accessing'] value ! !
! WebSession methodsFor: 'accessing' !
currentOpenLocation: aPoint

	currentOpenLocation := aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'accessing'] value ! !
! WebSession methodsFor: 'accessing' !
sessionVariables

	^sessionVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'accessing'] value ! !
! WebSession methodsFor: 'accessing' !
sessionVariables: anObject

	sessionVariables := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'applications'] value ! !
! WebSession methodsFor: 'applications' !
closeAllApplications

	self applications do: [:each | each close] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'applications'] value ! !
! WebSession methodsFor: 'applications' !
openWindowIDs

	^(BeagleSystem runJavaScriptWithReturn: 'Array.from(document.getElementById(''simTalkRootSection'').children).map(child => child.id)')
		splitBy: $, ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'initialize-release'] value ! !
! WebSession methodsFor: 'initialize-release' !
initialize

	sessionVariables := Dictionary new.
	applications := OrderedCollection new.
	random := Random new.
	currentOpenLocation := 100 @ 100. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'opening and closing'] value ! !
! WebSession methodsFor: 'opening and closing' !
closeAllWindows

	self applications do: [:each |
		[each close]
			on: Error
			do: [:ex | ex return]].
	self applications copy do: [:each | self applications remove: each].
	self clearSessionVariables
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'opening and closing'] value ! !
! WebSession methodsFor: 'opening and closing' !
closeApplication: anApplication
	self applications remove: anApplication.
	self sessionVariables removeKey: anApplication appName ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'opening and closing'] value ! !
! WebSession methodsFor: 'opening and closing' !
openApplication: anApplication

	self applications add: anApplication.
	self sessionVariableAt: anApplication appName put: anApplication.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'opening locations'] value ! !
! WebSession methodsFor: 'opening locations' !
nextOpenLocation

	self currentOpenLocation y > 200 ifTrue: [
		self currentOpenLocation x > 200 ifTrue: [
			self currentOpenLocation: 100 @ 100.
			^self currentOpenLocation].

		self currentOpenLocation: (self currentOpenLocation x + self openingLocationIncrement) @ 100.
		^self currentOpenLocation].

	self currentOpenLocation: (self currentOpenLocation x + self openingLocationIncrement) @ (self currentOpenLocation y + self openingLocationIncrement).
	^self currentOpenLocation ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'opening locations'] value ! !
! WebSession methodsFor: 'opening locations' !
openingLocationIncrement

	^25 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'session variables'] value ! !
! WebSession methodsFor: 'session variables' !
clearSessionVariables

	self sessionVariables: Dictionary new ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'session variables'] value ! !
! WebSession methodsFor: 'session variables' !
newVariableName

	| stream variableName |

	[
		stream := WriteStream on: (String new: 10).
		8 timesRepeat: [
			| value |
			value := (random next * 52) truncated + 1.
			stream nextPut: ('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' at: value)
			].
		variableName := stream contents.
		sessionVariables includesKey: variableName] whileTrue.

	^variableName ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'session variables'] value ! !
! WebSession methodsFor: 'session variables' !
removeSessionVariableAt: aString

	^sessionVariables removeKey: aString ifAbsent: [] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'session variables'] value ! !
! WebSession methodsFor: 'session variables' !
sessionVariableAt: aString

	^sessionVariables at: aString ifAbsentPut: [SessionVariable new] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession methodsFor: 'session variables'] value ! !
! WebSession methodsFor: 'session variables' !
sessionVariableAt: aString put: anObject

	^(self sessionVariableAt: aString) value: anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession class methodsFor: 'applications'] value ! !
! WebSession class methodsFor: 'applications' !
closeAllApplications

	self current closeAllApplications; clearSessionVariables ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession class methodsFor: 'instance creation'] value ! !
! WebSession class methodsFor: 'instance creation' !
current

	^current ifNil: [current := self new] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebSession class methodsFor: 'instance creation'] value ! !
! WebSession class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
addHTMLAfterBeginOf: widgetName to: aString

	| html |

	html := 'document.getElementById("', widgetName, '").insertAdjacentHTML("afterbegin",`', (self replaceAppNameIn: aString), '`);'.

	self runJavaScript: html ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
addHTMLAfterEndOf: widgetName to: aString

	| html |

	html := 'document.getElementById("', widgetName, '").insertAdjacentHTML("afterend",`', (self replaceAppNameIn: aString), '`);'.

	self runJavaScript: html ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
addHTMLBeforeBeginOf: widgetName to: aString

	| html |

	html := 'document.getElementById("', widgetName, '").insertAdjacentHTML("beforebegin",`', (self replaceAppNameIn: aString), '`);'.

	self runJavaScript: html ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
addHTMLBeforeEndOf: widgetName to: aString

	| html |

	html := 'document.getElementById("', widgetName, '").insertAdjacentHTML("beforeend",`', (self replaceAppNameIn: aString), '`);'.

	self runJavaScript: html ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
addToInnerHTML: aString

	self runJavaScript: 'document.getElementById("', self rootName, '").insertAdjacentHTML("beforeend",`', aString, '`);' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
bringToTop

	| html |

	html := 'document.getElementById("simTalkRootSection").appendChild(document.getElementById("', self appName, '"));'.

	self runJavaScript: html ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
changeClassOf: aString from: oldClassString to: newClassString


	self runJavaScript: 'const element = document.getElementById("', aString, '");
element.classList.remove("', oldClassString, '");
element.classList.add("', newClassString, '");' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
removeElement: aString

	self runJavaScript: 'document.getElementById("', aString, '").remove();'  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
replaceHTMLFor: widgetName with: aString

	| html |

	html := 'document.getElementById("', widgetName, '").innerHTML = ', (self replaceAppNameIn: aString), '`);'.

	self runJavaScript: html ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
rootName

	^'simTalkRootSection' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
setAttribute: attributeName of: aString to: value

	| command valueString |
	value isString
		ifTrue: [valueString := '"', value, '"']
		ifFalse: [valueString := value printString].

	command := 'document.getElementById("', aString, '").', attributeName , ' = ' , valueString, ';'.
	self runJavaScript: command ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
setInnerHTML: aString

	^'document.getElementById("', parentName, '").innerHTML = `', aString, '`;' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'DOM access'] value ! !
! WebUI methodsFor: 'DOM access' !
setInnerHTMLOf: aString to: htmlString

	self runJavaScript: 'document.getElementById("', aString, '").innerHTML="', htmlString, '";'. ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
appName

	^appName ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
appName: anObject

	appName := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
bindings

	^bindings ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
bindings: anObject

	bindings := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
bounds: aRectangle

	bounds := aRectangle.
	origin := aRectangle origin.
	aRectangle corner isNil
		ifTrue: [extent := nil]
		ifFalse: [extent := aRectangle extent] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
extent

	^extent ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
extent: aPoint

	extent := aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
flags

	^flags ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
flags: aSet

	flags := aSet ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
htmlTree

	^htmlTree ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
htmlTree: anObject

	htmlTree := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
opened

	^opened ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
opened: aBoolean

	opened := aBoolean ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
origin

	^origin ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
origin: aPoint

	origin := aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
parentName
	^parentName ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'accessing'] value ! !
! WebUI methodsFor: 'accessing' !
parentName: aString
	parentName := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'bindings'] value ! !
! WebUI methodsFor: 'bindings' !
bindingAt: bindingName

	^self bindingAt: bindingName ifAbsentPut: [ValueHolder new] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'bindings'] value ! !
! WebUI methodsFor: 'bindings' !
bindingAt: bindingName ifAbsentPut: aBlock

	^self bindings at: bindingName ifAbsentPut: aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'bindings'] value ! !
! WebUI methodsFor: 'bindings' !
runJavaScript: aString

	updateStream
		ifNil: [BeagleSystem runJavaScript: aString]
		ifNotNil: [updateStream nextPutAll: aString] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'bindings'] value ! !
! WebUI methodsFor: 'bindings' !
updateIndexedTableTo: value

	| stream columnSpecs |

	stream := WriteStream on: (ByteString new: 1000).
	columnSpecs := self widgetSpec at: 6.

	value do: [:eachRow |
		stream nextPutAll: '<tr>'.
		columnSpecs do: [:eachSpec |
			stream
				nextPutAll: '<td>';
				nextPutAll: (self convertValueToString: (eachRow at: (eachSpec at: 2)) type: (eachSpec at: 3));
				nextPutAll: '</td>'].
		stream nextPutAll: '</tr>'.
		].

	self setInnerHTMLOf: self name to: stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'bindings'] value ! !
! WebUI methodsFor: 'bindings' !
updateRadioButtonField: aspectSpec to: value

	self
		setAttribute: #checked
		of: (aspectSpec at: 3)
		to: (value = (aspectSpec at: 5) ifTrue: [true] ifFalse: [false]) ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'bindings'] value ! !
! WebUI methodsFor: 'bindings' !
withinWebUpdateDo: aBlock
	| javaScriptString |

	updateStream := WriteStream on: (String new: 1000).
	[
		aBlock value.
		javaScriptString := updateStream contents.
		updateStream := nil.
		self runJavaScript: javaScriptString]
	ensure: [updateStream := nil]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'building'] value ! !
! WebUI methodsFor: 'building' !
addComponent: aComponent beforeEndOf: parentName

	self addHTMLBeforeEndOf: parentName to: aComponent htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'building'] value ! !
! WebUI methodsFor: 'building' !
postBuild ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'building'] value ! !
! WebUI methodsFor: 'building' !
postOpen
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'changing'] value ! !
! WebUI methodsFor: 'changing' !
htmlQuote: aString withEmphasis: aCollectionOfEmphasisSpan

	| in out mappings |
	in := aString readStream.
	out := WriteStream on: (String new: aString size).
	mappings := Dictionary new.
	mappings
		at: $\ put: '\\';
		at: Character cr put: '\r\n';
		at: Character tab put: '\t';
		at: $" put: '\"'.

	[in atEnd] whileFalse: [
		| character replacement |
		character := in next.

		aCollectionOfEmphasisSpan do: [:each | each emphasizeForPosition: in position to: out].

		replacement := mappings at: character ifAbsent: [nil].
		replacement isNil
			ifTrue: [out nextPut: character]
			ifFalse: [out nextPutAll: replacement]].

	aCollectionOfEmphasisSpan do: [:each | each emphasizeForPosition: in position + 1 to: out].

	^out contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'changing'] value ! !
! WebUI methodsFor: 'changing' !
javascriptQuote: aString

	| in out mappings |
	in := aString readStream.
	out := WriteStream on: (String new: aString size).
	mappings := Dictionary new.
	mappings
		at: $\ put: '\\';
		at: Character cr put: '\n';
		at: Character lf put: '\n';
		at: $" put: '\"'.

	[in atEnd] whileFalse: [
		| character replacement |
		character := in next.
		replacement := mappings at: character ifAbsent: [nil].
		replacement isNil
			ifTrue: [out nextPut: character]
			ifFalse: [out nextPutAll: replacement]].

	^out contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'changing'] value ! !
! WebUI methodsFor: 'changing' !
javascriptQuote: aString withEmphasis: aCollectionOfEmphasisSpan

	| in out mappings |
	in := aString readStream.
	out := WriteStream on: (String new: aString size).
	mappings := Dictionary new.
	mappings
		at: $\ put: '\\';
		at: Character cr put: '\n';
		at: Character lf put: '\n';
		at: $" put: '\"'.

	[in atEnd] whileFalse: [
		| character replacement |
		character := in next.

		aCollectionOfEmphasisSpan do: [:each | each emphasizeForPosition: in position to: out].

		replacement := mappings at: character ifAbsent: [nil].
		replacement isNil
			ifTrue: [out nextPut: character]
			ifFalse: [out nextPutAll: replacement]].

	aCollectionOfEmphasisSpan do: [:each | each emphasizeForPosition: in position + 1 to: out].

	^out contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'closing'] value ! !
! WebUI methodsFor: 'closing' !
close
	WebSession current closeApplication: self.
	self bindings keys do: [:key | (bindings at: key) unbind].

	self runJavaScript: 'document.getElementById("', self appName, '").remove();' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'components'] value ! !
! WebUI methodsFor: 'components' !
bindComponent: aComponent

	aComponent id isNil ifTrue: [aComponent id: (self idFor: WebSession current newVariableName)].
	aComponent ui: self.
	WebSession current sessionVariableAt: aComponent id put: aComponent  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'components'] value ! !
! WebUI methodsFor: 'components' !
listComponentNamed: aSymbol menu: aMenu

	^self bindingAt: aSymbol ifAbsentPut: [
		ListComponent new
			bindTo: self as: aSymbol;
			listNumberOfRows: 10;
			menu: aMenu;
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'components'] value ! !
! WebUI methodsFor: 'components' !
textEditorComponentNamed: aSymbol menu: aMenu

	^self bindingAt: aSymbol ifAbsentPut: [
		TextEditorComponent new
			bindTo: self as: aSymbol;
			menu: aMenu;
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'initialize-release'] value ! !
! WebUI methodsFor: 'initialize-release' !
initialize

	parentName := 'simTalkRootSection'.
	self
		appName: WebSession current newVariableName;
		bindings: Dictionary new;
		flags: Set new;
		origin: self defaultWindowOrigin;
		extent: self defaultWindowExtent;
		opened: false ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
appDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder attributeAt: 'id' put: self appName.
		self
			enableDisableDivOn: builder;
			resizeDivOn: builder] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
bottomRightResizeDiv

	^HTMLBuilder new
		div: [:builder |
			builder
				attributeAt: 'id' put: (self idFor: 'windowDrag');
				attributeAt: 'style' put: 'position: absolute; top: 0; bottom: 0; width: 3000px; height: 2000px; background-color: transparent;';
				attributeAt: 'onmousemove' put: self bottomRightResizeMouseMoveCallbackString;
				attributeAt: 'onmouseup' put: self bottomRightResizeMouseUpCallbackString];
		htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
bottomRightResizeMouseMoveCallbackString

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallback(''$', self appName, ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''resizeBottomRightWindow:'', [''pageX'', ''pageY''], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
bottomRightResizeMouseUpCallbackString

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallback(''$', self appName, ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''stopDrag:'', [''pageX'', ''pageY''], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
bringToTop: aDictionary

	self bringToTop.
	dragPoint := (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') - self origin.
	self addHTMLBeforeEndOf: self rootName to: self dragDiv ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
closeButtonDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder
			attributeAt: 'id' put: (self idFor: 'closeButton');
			"attributeAt: 'class' put: 'toolbarButton';"
			attributeAt: 'style' put: 'margin-left: auto;';
			attributeAt: 'onclick' put: 'simTalkCallback0(''$', self appName,''', ''close''); event.stopPropagation();';
			inTag: 'img' do: [:builder2 |
				builder2
					attributeAt: 'src' put: 'closeButton.png';
					attributeAt: 'width' put: '30';
					attributeAt: 'height' put: '30'
				]]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
defaultWindowExtent

	^nil ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
defaultWindowOrigin

	^WebSession current nextOpenLocation ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
dragBarDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder
			attributeAt: 'id' put: (self idFor: 'dragbar');
			attributeAt: 'style' put: 'background-color: #0000C0; color: white; width: 100%; font-family: sans-serif; font-weight: bold; padding: 8px;';
			attributeAt: 'onmousedown' put: self titleClickCallbackString;
			text: self title] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
dragDiv

	^HTMLBuilder new
		div: [:builder |
			builder
				attributeAt: 'id' put: (self idFor: 'windowDrag');
				attributeAt: 'style' put: 'position: absolute; top: 0; bottom: 0; width: 3000px; height: 2000px; background-color: transparent;';
				attributeAt: 'onmousemove' put: self mouseMoveCallbackString;
				attributeAt: 'onmouseup' put: self mouseUpCallbackString];
		htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
dragWindow: aDictionary

	| offset |

	dragPoint isNil ifTrue: [^self].

	offset := (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') - (self origin + dragPoint).
	self origin: origin + offset.
	self setAbsoluteWindowBounds ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
enableDisableDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder
			attributeAt: 'id' put: (self idFor: 'enableDisable');
			attributeAt: 'style' put: 'background-color: white;'.

		self titleBarDivOn: builder]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
fixedOffset

	^5 @ -40 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
html

	| builder |

	builder := HTMLBuilder new.
	self appDivOn: builder.
	^builder htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
htmlForSpec: specName

	self log: 'htmlForSpec: ', specName.
	^(self class perform: specName asSymbol)
		copyReplaceAll: '$appName$' with: self appName ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
mouseMoveCallbackString

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallback(''$', self appName, ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''dragWindow:'', [''pageX'', ''pageY''], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
mouseUpCallbackString

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallback(''$', self appName, ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''stopDrag:'', [''pageX'', ''pageY''], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
open

	WebSession current openApplication: self.

	self postBuild.
	self addToInnerHTML: self html.

	self postOpen.

	self opened: true ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
open: specName

	WebSession current openApplication: self.
	self postBuild.
	self addToInnerHTML: (self htmlForSpec: specName).

	self postOpen ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
replaceAppNameIn: aString

	^aString copyReplaceAll: '$appName$' with: self appName ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
resizeBottomRight: aDictionary

	dragPoint := (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') - self origin.
	self addHTMLBeforeEndOf: self rootName to: self bottomRightResizeDiv ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
resizeBottomRightCallback

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallback(''$', self appName, ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''resizeBottomRight:'', [''pageX'', ''pageY''], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
resizeBottomRightWindow: aDictionary

	| offset oldDragPoint |

	dragPoint isNil ifTrue: [^self].

	offset := (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') - self origin.

	self extent: offset + self fixedOffset.
	self setAbsoluteWindowBounds.
	self windowResized ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
resizeDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder
			attributeAt: 'id' put: (self idFor: 'resize');
			attributeAt: 'style' put: 'display: grid; grid-template-columns: 1fr 8px; background-color: transparent; width: 100%; height: 8px;';
			div: [:builder2 | builder2 attributeAt: 'style' put: 'background-color: transparent;'];
			div: [:builder2 | builder2
				attributeAt: 'style' put: 'background-color: black;';
				attributeAt: 'onmousedown' put: self resizeBottomRightCallback]] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
setAbsoluteWindowBounds

	self extent isNil
		ifTrue: [
			self
			setAttribute: 'style'
			of: self appName
			to: 'position: absolute; top: ', self origin  y printString, 'px; left: ', self origin x printString, 'px;']
		ifFalse: [
			self
			setAttribute: 'style'
			of: self appName
			to: 'position: absolute; top: ', self origin y printString, 'px; left: ', origin x printString, 'px; width: ', self extent x printString, 'px; height: ', self extent y printString,'px;'] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
stopDrag: aDictionary

	dragPoint := nil.
	self removeElement: (self idFor: 'windowDrag') ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
title

	^'Sample title' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
titleBarDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder
			attributeAt: 'id' put: (self idFor: 'titlebar');
			attributeAt: 'style' put: 'display: grid; grid-template-columns: 1fr auto; background-color: #0000C0; border: 1px solid black;'.

		self
			dragBarDivOn: builder;
			closeButtonDivOn: builder]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
titleClickCallbackString

	| stream |

	stream := WriteStream on: (String new: 40).
	stream
		nextPutAll: 'requestedFieldsCallback(''$', self appName, ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''';
		nextPutAll: self appName;
		nextPutAll: ''', ''bringToTop:'', [''pageX'', ''pageY''], event);'.

	^stream contents ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
titleDivOn: anHTMLBuilder

	anHTMLBuilder div: [:builder |
		builder
			attributeAt: 'id' put: (self idFor: 'Title');
			"attributeAt: 'class' put: 'title';"
			text: self title] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'opening'] value ! !
! WebUI methodsFor: 'opening' !
windowResized ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'testing'] value ! !
! WebUI methodsFor: 'testing' !
disable

	self flags add: #disabled.
	self
		setAttribute: 'style'
		of: (self idFor: 'enableDisable')
		to: 'background-color: #c0c0c0; color: #808080; pointer-events: none;' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'testing'] value ! !
! WebUI methodsFor: 'testing' !
disableWhile: aBlock

	self disable.
	aBlock ensure: [self enable]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'testing'] value ! !
! WebUI methodsFor: 'testing' !
enable

	self flags remove: #disabled ifAbsent: [].
	self setAttribute: 'style' of: (self idFor: 'enableDisable') to: 'background-color: white;' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'testing'] value ! !
! WebUI methodsFor: 'testing' !
isDisabled

	^self flags includes: #disabled ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'testing'] value ! !
! WebUI methodsFor: 'testing' !
isEnabled

	^self isDisabled not ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'testing'] value ! !
! WebUI methodsFor: 'testing' !
isUI

	^true ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'uncategorized'] value ! !
! WebUI methodsFor: 'uncategorized' !
widgetContentType

	self widgetSpec size >= 4 ifFalse: [^nil].

	^self widgetSpec at: 4 ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'uncategorized'] value ! !
! WebUI methodsFor: 'uncategorized' !
write: aString inRichTextArea: idString position: aNumber

	self runJavaScript: 'insertRichText("' , idString, '", "', (self javascriptQuote: aString), '",',  aNumber printString, ');' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'uncategorized'] value ! !
! WebUI methodsFor: 'uncategorized' !
write: aString inTextArea: idString position: aNumber

	self runJavaScript: 'insertText("' , idString, '", "', (self javascriptQuote: aString), '",',  aNumber printString, ');' ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
errorMessage: aString

	MessageBox errorMessage: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
idFor: aString

	^self appName, '-', aString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
infoMessage: aString

	MessageBox infoMessage: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
message: aString

	MessageBox message: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
message: aString choices: choicesList blocks: blocksList

	self disable.
	MultipleChoiceBox
		message: aString choices: choicesList blocks: (blocksList collect: [:each | [each value. self enable]]) ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
message: aString okBlock: okBlock cancelBlock: cancelBlock

	self disable.
	MultipleChoiceBox
		message: aString okBlock: [okBlock value. self enable] cancelBlock: [cancelBlock value. self enable] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
message: aString yesBlock: yesBlock noBlock: noBlock

	self disable.
	MultipleChoiceBox
		message: aString yesBlock: [yesBlock value. self enable] noBlock: [noBlock value. self enable] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
request: aString initialAnswer: initialAnswer answerBlock: answerBlock

	self disable.
	RequestBox
		request: aString initialAnswer: initialAnswer answerBlock: [:answer | answerBlock value: answer. self enable] ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
request: aString initialAnswer: initialAnswer answerBlock: answerBlock at: aPoint

	self disable.
	RequestBox
		request: aString initialAnswer: initialAnswer answerBlock: [:answer | answerBlock value: answer. self enable] at: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI methodsFor: 'utility'] value ! !
! WebUI methodsFor: 'utility' !
warningMessage: aString

	MessageBox warningMessage: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI class methodsFor: 'instance creation'] value ! !
! WebUI class methodsFor: 'instance creation' !
allAspects

	^#() ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI class methodsFor: 'instance creation'] value ! !
! WebUI class methodsFor: 'instance creation' !
new

	^super new initialize ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI class methodsFor: 'opening'] value ! !
! WebUI class methodsFor: 'opening' !
open

	^self new open ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
answerBlock

	^answerBlock  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
answerBlock: aCollection

	answerBlock := aCollection  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
choices

	^choices  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
choices: aCollection

	choices := aCollection  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
message

	^message  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
message: aString

	message := aString  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
values

	^values  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'accessing'] value ! !
! ListChoiceBox methodsFor: 'accessing' !
values: aCollection

	values := aCollection  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'updating'] value ! !
! ListChoiceBox methodsFor: 'updating' !
doCancel

	self close
  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'updating'] value ! !
! ListChoiceBox methodsFor: 'updating' !
doOk: anIntegerString

	| index |

	index := Integer readFrom: anIntegerString readStream.

	self close.

	(index >= 0 and: [self answerBlock notNil])
		ifTrue: [self answerBlock value: (self values at: index + 1)].

  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'updating'] value ! !
! ListChoiceBox methodsFor: 'updating' !
listChoiceBoxHTML

	| htmlStream |

	htmlStream := WriteStream on: (String new: 100).
	htmlStream
		nextPutAll: '<div>', self message, '</div>';
		nextPutAll: '<div id="$appName$-listdiv">';
		nextPutAll: '<select id=''$appName$-list'' size=12;>'.

	choices keysAndValuesDo: [:key :choice |
		htmlStream nextPutAll: '<option>', choice, '</option>'].

	htmlStream
		nextPutAll: '</select>';
		nextPutAll: '<div style="display: flex;">';
		nextPutAll: '<div style="border: 1px solid black; padding: 5px; margin: 2px;" onclick="simTalkCallback1(''$$appName$'', ''doOk:'', document.getElementById(''$appName$-list'').selectedIndex);">Ok</div>';
		nextPutAll: '<div style="border: 1px solid black; padding: 5px; margin: 2px;" onclick="simTalkCallback0(''$$appName$'', ''doCancel'');">Cancel</div>';
		nextPutAll: '</div>'.

	^htmlStream contents  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'updating'] value ! !
! ListChoiceBox methodsFor: 'updating' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self withinWebUpdateDo: [self update]  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox methodsFor: 'updating'] value ! !
! ListChoiceBox methodsFor: 'updating' !
update

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self listChoiceBoxHTML  ! !
! Doit class methodsFor: 'doit' !
doit ^[ListChoiceBox class methodsFor: 'ui specs'] value ! !
! ListChoiceBox class methodsFor: 'ui specs' !
uiSpec

	^'<div id="$appName$">
	<div id="$appName$-ListChoiceToolbar" style="display: flex">
		<div id="$appName$-Title" class="title">Choice</div>
	</div>
</div>
'  ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'accessing'] value ! !
! MessageBox methodsFor: 'accessing' !
message

	^message ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'accessing'] value ! !
! MessageBox methodsFor: 'accessing' !
message: aString

	message := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'accessing'] value ! !
! MessageBox methodsFor: 'accessing' !
severity

	^severity ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'accessing'] value ! !
! MessageBox methodsFor: 'accessing' !
severity: aString

	severity := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'accessing'] value ! !
! MessageBox methodsFor: 'accessing' !
title

	^(self severity ifNil: ['Message']) capitalized ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'opening'] value ! !
! MessageBox methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self withinWebUpdateDo: [self update]  ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'updating'] value ! !
! MessageBox methodsFor: 'updating' !
messageString
	^'<div style="', self styleForSeverity, '">', self message, '</div>' ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'updating'] value ! !
! MessageBox methodsFor: 'updating' !
styleForSeverity
	self severity = #error ifTrue: [^'background-color: red; color: white;'].
	self severity = #warning ifTrue: [^'background-color: yellow;'].
	self severity = #info ifTrue: [^'background-color: lightblue;'].
	^'background-color: white;' ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox methodsFor: 'updating'] value ! !
! MessageBox methodsFor: 'updating' !
update

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self messageString ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
errorMessage: aString

	self errorMessage: aString at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
errorMessage: aString at: aPoint

	self
		message: aString
		severity: #error
		at: aPoint
 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
infoMessage: aString

	self 
		infoMessage: aString
		at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
infoMessage: aString at: aPoint

	self
		message: aString
		severity: #info
		at: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
message: aString

	self
		message: aString
		at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
message: aString at: aPoint

	self
		message: aString
		severity: #message
		at: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
message: aString severity: aSymbol at: aPoint

	self new
		origin: aPoint;
		extent: nil;
		severity: aSymbol;
		message: aString;
		open
 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
uiSpec

	^'<div id="$appName$">
	<div id="$appName$-MessageToolbar" style="display: flex">
		<div id="$appName$-Title" class="title">Message</div>
		<div id="$appName$-closeButton" class="toolbarButton" onclick="simTalkCallback0(''$$appName$'', ''close'');">Close</div>
	</div>
</div>
' ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
warningMessage: aString

	self warningMessage: aString at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MessageBox class methodsFor: 'opening'] value ! !
! MessageBox class methodsFor: 'opening' !
warningMessage: aString at: aPoint

	self
		message: aString
		severity: #warning
		at: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'accessing'] value ! !
! MultipleChoiceBox methodsFor: 'accessing' !
choices

	^choices ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'accessing'] value ! !
! MultipleChoiceBox methodsFor: 'accessing' !
choices: aCollection

	choices := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'accessing'] value ! !
! MultipleChoiceBox methodsFor: 'accessing' !
message

	^message ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'accessing'] value ! !
! MultipleChoiceBox methodsFor: 'accessing' !
message: aString

	message := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'accessing'] value ! !
! MultipleChoiceBox methodsFor: 'accessing' !
values

	^values ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'accessing'] value ! !
! MultipleChoiceBox methodsFor: 'accessing' !
values: aCollection

	values := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'opening'] value ! !
! MultipleChoiceBox methodsFor: 'opening' !
choiceBoxHTML

	| stream |

	stream := WriteStream on: (String new: 100).
	stream
		nextPutAll: '<div style="background-color: white; border: 1px solid black; padding: 5px;">';
		nextPutAll: '<div>', self message, '</div>';
		nextPutAll: '<div id="$appName$-', self appName, '" style="display: flex;">'.

	choices keysAndValuesDo: [:key :choice |
			stream nextPutAll: '<div style="border: 1px solid black; padding: 5px; margin: 2px;" onclick="simTalkCallback1(''$$appName$'', ''doChoice:'', ', key printString, ');">', choice, '</div>'].

	stream nextPutAll: '</div>'.
	stream nextPutAll: '</div>'.
	^stream contents
 ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'opening'] value ! !
! MultipleChoiceBox methodsFor: 'opening' !
doChoice: aString

	| number |

	number := Integer readFrom: aString readStream.
	self close.
	(self values at: number) value ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'opening'] value ! !
! MultipleChoiceBox methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'opening'] value ! !
! MultipleChoiceBox methodsFor: 'opening' !
title

	^'Choice' ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox methodsFor: 'opening'] value ! !
! MultipleChoiceBox methodsFor: 'opening' !
update

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self choiceBoxHTML ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox class methodsFor: 'opening'] value ! !
! MultipleChoiceBox class methodsFor: 'opening' !
message: aString choices: choicesCollection blocks: blockCollection

	self message: aString choices: choicesCollection blocks: blockCollection at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox class methodsFor: 'opening'] value ! !
! MultipleChoiceBox class methodsFor: 'opening' !
message: aString choices: choicesCollection blocks: blockCollection at: aPoint

	self new
		origin: aPoint;
		message: aString;
		choices: choicesCollection;
		values: blockCollection;
		open ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox class methodsFor: 'opening'] value ! !
! MultipleChoiceBox class methodsFor: 'opening' !
message: aString okBlock: okBlock cancelBlock: cancelBlock

	self message: aString okBlock: okBlock cancelBlock: cancelBlock at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox class methodsFor: 'opening'] value ! !
! MultipleChoiceBox class methodsFor: 'opening' !
message: aString okBlock: okBlock cancelBlock: cancelBlock at: aPoint

	self
		message: aString
		choices: #('Ok' 'Cancel')
		blocks: (Array with: okBlock with: cancelBlock)
		at: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox class methodsFor: 'opening'] value ! !
! MultipleChoiceBox class methodsFor: 'opening' !
message: aString yesBlock: yesBlock noBlock: noBlock

	self message: aString yesBlock: yesBlock noBlock: noBlock at: 100 @ 100 ! !
! Doit class methodsFor: 'doit' !
doit ^[MultipleChoiceBox class methodsFor: 'opening'] value ! !
! MultipleChoiceBox class methodsFor: 'opening' !
message: aString yesBlock: yesBlock noBlock: noBlock at: aPoint

	self
		message: aString
		choices: #('Yes' 'No')
		blocks: (Array with: yesBlock with: noBlock)
		at: aPoint ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'accessing'] value ! !
! PopupMenuUI methodsFor: 'accessing' !
menuItems

	^menuItems
 ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'accessing'] value ! !
! PopupMenuUI methodsFor: 'accessing' !
menuItems: aCollection

	menuItems := aCollection
 ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'accessing'] value ! !
! PopupMenuUI methodsFor: 'accessing' !
widgetId

	^widgetId ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'accessing'] value ! !
! PopupMenuUI methodsFor: 'accessing' !
widgetId: aString

	widgetId := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'actions'] value ! !
! PopupMenuUI methodsFor: 'actions' !
doMenuWith: aDictionary

	| menuId menuItem |

	self close.
	menuId := (aDictionary at: 'menuId') asSymbol.
	menuItem := self menuItems detect: [:each | each id = menuId] ifNone: [nil].
	menuItem isNil ifTrue: [^self].
	menuItem action value: aDictionary ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'actions'] value ! !
! PopupMenuUI methodsFor: 'actions' !
hideMenu

	self close ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'adding and removing'] value ! !
! PopupMenuUI methodsFor: 'adding and removing' !
addMenuItem: aMenuItem

	self menuItems add: aMenuItem.
	aMenuItem widgetId: self widgetId ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'closing'] value ! !
! PopupMenuUI methodsFor: 'closing' !
close

	WebSession current sessionVariables removeKey: self appName.
	self runJavaScript: 'document.getElementById("', self appName, '").remove();' ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'initializing'] value ! !
! PopupMenuUI methodsFor: 'initializing' !
initialize

	super initialize.
	self menuItems: OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'opening'] value ! !
! PopupMenuUI methodsFor: 'opening' !
openIn: componentId x: x y: y

	WebSession current sessionVariableAt: self appName put: self.

	self 
		origin: (Integer readFrom: x readStream) @ (Integer readFrom: y readStream);
		extent: nil;
		addHTMLBeforeEndOf: 'simTalkRootSection' to: self htmlString;
		postOpen ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'opening'] value ! !
! PopupMenuUI methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds. ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'rendering'] value ! !
! PopupMenuUI methodsFor: 'rendering' !
htmlString

	| htmlBuilder |

	htmlBuilder := HTMLBuilder new.
	self renderHTMLOn: htmlBuilder.

	^htmlBuilder htmlString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[PopupMenuUI methodsFor: 'rendering'] value ! !
! PopupMenuUI methodsFor: 'rendering' !
renderHTMLOn: htmlBuilder

	htmlBuilder div: [
		htmlBuilder
			attributeAt: 'class' put: 'menuBox';
			attributeAt: 'id' put: '$appName$';
			attributeAt: 'onmouseleave' put: 'simTalkCallback0(''$$appName$'', ''hideMenu'');'.
		self menuItems do: [:eachMenuItem | eachMenuItem renderHTMLOn: htmlBuilder]]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'accessing'] value ! !
! RequestBox methodsFor: 'accessing' !
answerBlock

	^answerBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'accessing'] value ! !
! RequestBox methodsFor: 'accessing' !
answerBlock: aBlock

	answerBlock := aBlock ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'accessing'] value ! !
! RequestBox methodsFor: 'accessing' !
initialAnswer

	^initialAnswer ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'accessing'] value ! !
! RequestBox methodsFor: 'accessing' !
initialAnswer: aString

	initialAnswer := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'accessing'] value ! !
! RequestBox methodsFor: 'accessing' !
message

	^message ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'accessing'] value ! !
! RequestBox methodsFor: 'accessing' !
message: aString

	message := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
defaultWindowExtent

	^200 @ 200 ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
doChoice: aString with: answerString

	| number |
	number := Integer readFrom: aString readStream.
	self close.
	number = 1 ifTrue: [self answerBlock value: answerString].
	number = 2 ifTrue: [self answerBlock value: nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
openAt: aPoint

	self
		origin: aPoint;
		open ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self withinWebUpdateDo: [self update].

	self runJavaScript: 'captureKeyInArea("$', self appName ,
		'","Enter',
		'", "', (self idFor: 'enableDisable'),
		'", "', (self idFor: 'input'),
		'", "pressedEnter:',
		'", ["value"]' ,
		');' ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
requestBoxHTML

	| htmlStream |

	htmlStream := WriteStream on: (String new: 100).
	htmlStream
		nextPutAll: '<div style="background-color: white; border: 1px black solid;">';
		nextPutAll: '<div>', self message, '</div>';
		nextPutAll: '<input type="text" id="$appName$-input" value="', self initialAnswer, '"></input>';
		nextPutAll: '<div id="$appName$-buttons" style="display: flex; margin: 5px;">'.


	#('Ok' 'Cancel') keysAndValuesDo: [:key :choice |
		htmlStream nextPutAll: '<div style="border: 1px solid black; padding: 5px; margin: 2px;" onclick="simTalkCallback2(''$$appName$'', ''doChoice:with:'', ', key printString, ',document.getElementById(''$appName$-input'').value);">', choice, '</div>'].

	htmlStream nextPutAll: '</div>'.
	htmlStream nextPutAll: '</div>'.

	^htmlStream contents
 ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
title

	^'Choose' ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'opening'] value ! !
! RequestBox methodsFor: 'opening' !
update

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self requestBoxHTML ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox methodsFor: 'responding'] value ! !
! RequestBox methodsFor: 'responding' !
pressedEnter: aDictionary

	self close.
	self answerBlock value: (aDictionary at: 'value')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox class methodsFor: 'opening'] value ! !
! RequestBox class methodsFor: 'opening' !
request: aString initialAnswer: initialAnswer answerBlock: answerBlock

	self request: aString initialAnswer: initialAnswer answerBlock: answerBlock at: 0 @ 0 ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox class methodsFor: 'opening'] value ! !
! RequestBox class methodsFor: 'opening' !
request: aString initialAnswer: initialAnswer answerBlock: answerBlock at: aPoint

	| window |

	window := self new
		message: aString;
		initialAnswer: initialAnswer;
		answerBlock: answerBlock;
		openAt: aPoint.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[RequestBox class methodsFor: 'opening'] value ! !
! RequestBox class methodsFor: 'opening' !
uiSpec

	^'<div id="$appName$">
			<style>
	<div id="$appName$-RequestToolbar" style="display: flex;">
		<div id="$appName$-Title" class="title">Request</div>
	</div>
</div>
' ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedClasses: #(Color CompositeComponent DoubleClickEvent Emphasis EmphasisSpan EmphasisStream Event EventModel HTMLBuilder HTMLStyleDefinition HTMLTag HTMLText JSONEvaluator KeyEvent ListChoiceBox ListComponent ListDivComponent ListSelectionEvent MessageBox MessageReceivedEvent MultipleChoiceBox PopupMenuItem PopupMenuUI PushButtonComponent Rectangle RequestBox RichTextEditorComponent SessionVariable TextComponent TextEditorComponent UIComponent UIOperation UIScreen ValueHolder WebSession WebUI) andMethods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Rectangle methods: #(#'+' #'-' #bottom #bounds #center #'containsPoint:' #corner #'corner:' #extent #height #left #origin #'origin:' #'printOn:' #right #top #'translatedBy:' #triangleVertices #width)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Rectangle class methods: #(#'origin:corner:' #'origin:extent:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UIOperation methods: #(#arguments #'arguments:' #name #'name:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UIOperation class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UIScreen methods: #(#'addComponent:' #addedCommands #addedComponents #'addedComponents:' #componentNumber #'componentNumber:' #components #'components:' #deletedCommands #deletedComponents #'deletedComponents:' #initialize #modifiedCommands #modifiedComponents #'modifiedComponents:' #nextComponentName #refreshCommands #'removeComponent:' #renderChanges #'renderChangesOn:' #reset #webSocket #'webSocket:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UIScreen class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Event methods: #(#eventKey)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Event class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeyEvent methods: #(#key #'key:' #'modifiers:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KeyEvent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EventModel methods: #(#changed #'on:send:to:' #'on:send:to:with:' #'signalEvent:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EventModel class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ValueHolder methods: #(#value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ValueHolder class methods: #(#'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MessageReceivedEvent methods: #(#message #'message:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MessageReceivedEvent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WebSession methods: #(#applications #'applications:' #clearSessionVariables #closeAllApplications #closeAllWindows #'closeApplication:' #currentOpenLocation #'currentOpenLocation:' #initialize #newVariableName #nextOpenLocation #'openApplication:' #openWindowIDs #openingLocationIncrement #'removeSessionVariableAt:' #'sessionVariableAt:' #'sessionVariableAt:put:' #sessionVariables #'sessionVariables:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WebSession class methods: #(#closeAllApplications #current #new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SessionVariable methods: #(#decrement #'decrementBy:' #increment #'incrementBy:' #value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SessionVariable class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLTag methods: #(#'addStyle:' #'addTag:' #'attributeAt:' #'attributeAt:put:' #attributes #'attributes:' #children #'children:' #'htmlClass:' #'htmlPrintOn:' #'id:' #initialize #'on:send:to:' #'on:send:to:with:' #'printOn:' #styles #'styles:' #tagName #'tagName:' #'with:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLTag class methods: #(#'name:' #new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLText methods: #(#'htmlPrintOn:' #'printOn:' #text #'text:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLText class methods: #(#'text:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JSONEvaluator methods: #(#'evaluate:' #'evaluateCommand:' #'evaluateObject:' #webSession #'webSession:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: JSONEvaluator class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLStyleDefinition methods: #(#'addKey:' #'attributeAt:put:' #attributes #'attributes:' #'for:' #'htmlPrintAttributesOn:' #'htmlPrintOn:' #initialize #keys #'keys:' #name #'name:' #'printOn:' #'with:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLStyleDefinition class methods: #(#'name:' #new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WebUI methods: #(#'addComponent:beforeEndOf:' #'addHTMLAfterBeginOf:to:' #'addHTMLAfterEndOf:to:' #'addHTMLBeforeBeginOf:to:' #'addHTMLBeforeEndOf:to:' #'addToInnerHTML:' #'appDivOn:' #appName #'appName:' #'bindComponent:' #'bindingAt:' #'bindingAt:ifAbsentPut:' #bindings #'bindings:' #bottomRightResizeDiv #bottomRightResizeMouseMoveCallbackString #bottomRightResizeMouseUpCallbackString #'bounds:' #bringToTop #'bringToTop:' #'changeClassOf:from:to:' #close #'closeButtonDivOn:' #defaultWindowExtent #defaultWindowOrigin #disable #'disableWhile:' #'dragBarDivOn:' #dragDiv #'dragWindow:' #enable #'enableDisableDivOn:' #'errorMessage:' #extent #'extent:' #fixedOffset #flags #'flags:' #html #'htmlForSpec:' #'htmlQuote:withEmphasis:' #htmlTree #'htmlTree:' #'idFor:' #'infoMessage:' #initialize #isDisabled #isEnabled #isUI #'javascriptQuote:' #'javascriptQuote:withEmphasis:' #'listComponentNamed:menu:' #'message:' #'message:choices:blocks:' #'message:okBlock:cancelBlock:' #'message:yesBlock:noBlock:' #mouseMoveCallbackString #mouseUpCallbackString #open #'open:' #opened #'opened:' #origin #'origin:' #parentName #'parentName:' #postBuild #postOpen #'removeElement:' #'replaceAppNameIn:' #'replaceHTMLFor:with:' #'request:initialAnswer:answerBlock:' #'request:initialAnswer:answerBlock:at:' #'resizeBottomRight:' #resizeBottomRightCallback #'resizeBottomRightWindow:' #'resizeDivOn:' #rootName #'runJavaScript:' #setAbsoluteWindowBounds #'setAttribute:of:to:' #'setInnerHTML:' #'setInnerHTMLOf:to:' #'stopDrag:' #'textEditorComponentNamed:menu:' #title #'titleBarDivOn:' #titleClickCallbackString #'titleDivOn:' #'updateIndexedTableTo:' #'updateRadioButtonField:to:' #'warningMessage:' #widgetContentType #windowResized #'withinWebUpdateDo:' #'write:inRichTextArea:position:' #'write:inTextArea:position:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: WebUI class methods: #(#allAspects #new #open)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PopupMenuUI methods: #(#'addMenuItem:' #close #'doMenuWith:' #hideMenu #htmlString #initialize #menuItems #'menuItems:' #'openIn:x:y:' #postOpen #'renderHTMLOn:' #widgetId #'widgetId:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PopupMenuUI class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PopupMenuItem methods: #(#action #'action:' #'addRequestedValue:' #enabledBlock #'enabledBlock:' #id #'id:' #initialize #menuCallbackString #name #'name:' #'renderHTMLOn:' #requestedValues #'requestedValues:' #widgetId #'widgetId:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PopupMenuItem class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListChoiceBox methods: #(#answerBlock #'answerBlock:' #choices #'choices:' #doCancel #'doOk:' #listChoiceBoxHTML #message #'message:' #postOpen #update #values #'values:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListChoiceBox class methods: #(#uiSpec)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MultipleChoiceBox methods: #(#choiceBoxHTML #choices #'choices:' #'doChoice:' #message #'message:' #postOpen #title #update #values #'values:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MultipleChoiceBox class methods: #(#'message:choices:blocks:' #'message:choices:blocks:at:' #'message:okBlock:cancelBlock:' #'message:okBlock:cancelBlock:at:' #'message:yesBlock:noBlock:' #'message:yesBlock:noBlock:at:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MessageBox methods: #(#message #'message:' #messageString #postOpen #severity #'severity:' #styleForSeverity #title #update)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MessageBox class methods: #(#'errorMessage:' #'errorMessage:at:' #'infoMessage:' #'infoMessage:at:' #'message:' #'message:at:' #'message:severity:at:' #uiSpec #'warningMessage:' #'warningMessage:at:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLBuilder methods: #(#'attributeAt:put:' #'class:' #currentNode #'currentNode:' #div #'div:' #endDiv #'endTag:' #endTagStyle #htmlNode #'htmlNode:' #htmlString #'htmlUnquote:' #'htmlUnquoteCharacter:from:to:' #'htmlUnquoteSpecialCharacterIn:out:' #'htmlUnquoteTagIn:out:' #'id:' #'inHorizontalLayout:do:' #'inStyle:do:' #'inTag:do:' #initialize #'install:' #'key:value:' #nodeStack #'nodeStack:' #'perform:on:' #'startTag:' #tagStyle #'text:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: HTMLBuilder class methods: #(#new)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListComponent methods: #(#'changedSelectedItem:' #doubleClick #list #'list:' #listNumberOfRows #'listNumberOfRows:' #'optionStyleFor:' #optionStyles #'optionStyles:' #'renderOn:' #selection #selectionIndex #'selectionIndex:' #ui #'ui:' #updateList #updateSelectionIndex)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TextEditorComponent methods: #(#'addEmphasis:' #clearEmphasis #codeMenu #doItMenuItem #'doItWith:' #emphasisCollection #'emphasisCollection:' #initialize #inspectItMenuItem #'inspectItWith:' #installCodeMenu #'load:' #loadMenuItem #'loadWith:' #printItMenuItem #'printItWith:' #'renderOn:' #'save:to:' #saveMenuItem #'saveWith:' #selectionEnd #'selectionEnd:' #selectionStart #'selectionStart:' #subject #'subject:' #text #'text:' #updateText)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TextEditorComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListSelectionEvent methods: #(#selectionIndex #'selectionIndex:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListSelectionEvent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DoubleClickEvent methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DoubleClickEvent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Emphasis methods: #(#'endEmphasisOn:' #endEmphasisTag #'endEmphasisTag:' #'startEmphasisOn:' #startEmphasisTag #'startEmphasisTag:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Emphasis class methods: #(#blue #bold #brown #compileErrorHighlight #green #red #walkbackCallHighlight)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EmphasisSpan methods: #(#emphasis #'emphasis:' #'emphasizeForPosition:to:' #'endEmphasizeForPosition:to:' #endOffset #'endOffset:' #'printOn:' #'startEmphasizeForPosition:to:' #startOffset #'startOffset:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EmphasisSpan class methods: #(#'from:to:with:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RichTextEditorComponent methods: #(#'addEmphasis:' #clearEmphasis #codeMenu #doItMenuItem #'doItWith:' #emphasisCollection #'emphasisCollection:' #initialize #inspectItMenuItem #'inspectItWith:' #installCodeMenu #'load:' #loadMenuItem #'loadWith:' #printItMenuItem #'printItWith:' #quotedText #'renderOn:' #'save:to:' #saveMenuItem #'saveWith:' #selectionEnd #'selectionEnd:' #selectionStart #'selectionStart:' #'setSelectionFrom:to:' #subject #'subject:' #text #'text:' #updateText)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RichTextEditorComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PushButtonComponent methods: #(#actionBlock #'actionBlock:' #label #'label:' #pressAction #'renderOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: PushButtonComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Color methods: #(#alpha #'alpha:' #asHSV #asString #blue #'blue:' #'fromHSV:' #green #'green:' #hue #'hue:' #'hueFrom:c:x:' #'printOn:' #red #'red:' #saturation #'saturation:' #value #'value:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Color class methods: #(#'red:green:blue:' #'red:green:blue:alpha:' #white)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListDivComponent methods: #(#'changedSelectedItem:' #doubleClick #list #'list:' #listNumberOfRows #'listNumberOfRows:' #'optionStyleFor:' #optionStyles #'optionStyles:' #'renderOn:' #selection #selectionIndex #'selectionIndex:' #ui #'ui:' #updateList #updateSelectionIndex)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ListDivComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompositeComponent methods: #(#children #'children:' #initialize)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CompositeComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TextComponent methods: #(#'renderOn:' #text #'text:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TextComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RequestBox methods: #(#answerBlock #'answerBlock:' #defaultWindowExtent #'doChoice:with:' #initialAnswer #'initialAnswer:' #message #'message:' #'openAt:' #postOpen #'pressedEnter:' #requestBoxHTML #title #update)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: RequestBox class methods: #(#'request:initialAnswer:answerBlock:' #'request:initialAnswer:answerBlock:at:' #uiSpec)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EmphasisStream methods: #(#'on:' #'writeEmphasisOn:forIndex:' #'writeEndEmphasisOn:forIndex:' #'writeStartEmphasisOn:forIndex:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: EmphasisStream class methods: #(#'on:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UIComponent methods: #(#bind #'bindTo:' #'bindTo:as:' #'bindTo:id:' #displayBlock #'displayBlock:' #height #'height:' #htmlString #id #'id:' #'idFor:' #menu #'menu:' #'openMenuX:y:' #'renderOn:' #ui #'ui:' #unbind #update)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: UIComponent class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default finishFileinKit] value ! !
! Doit class methodsFor: 'doit' !
doit ^[('kits' asFilename construct: 'Development Tools.kit') fileIn] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKitNamed: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit ensureLoaded: #('CoreUI')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #BrowserPlugin
	instVarNames: 'browser'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[ParseTreeVisitor subclassNamed: #CodeHighlighter
	instVarNames: 'typeOfCode compiledMethod sourceCode richTextWidget'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #Debugger
	instVarNames: 'context frames currentFrame message selectedField selectedLocal selectedStack simulator fieldList'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #Inspector
	instVarNames: 'object fieldList keysList selectedField text objectStack fieldListWidget inspectorTextWidget workspaceWidget'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector subclassNamed: #BasicInspector
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BrowserPlugin subclassNamed: #KitBrowserPlugin
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BrowserPlugin subclassNamed: #MethodBrowserPlugin
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #SystemBrowser
	instVarNames: 'selectedKit selectedClass selectedProtocol selectedMethod kits classes protocols methods code instanceOrClass browserPlugin'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #Workspace
	instVarNames: 'text'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Development Tools'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
compiledMethod

	^compiledMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
compiledMethod: aCompiledMethod

	compiledMethod := aCompiledMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
richTextWidget

	^richTextWidget ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
richTextWidget: aRichTextEditorComponent

	richTextWidget := aRichTextEditorComponent ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
sourceCode

	^sourceCode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
sourceCode: aString

	sourceCode := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
typeOfCode

	^typeOfCode ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'accessing'] value ! !
! CodeHighlighter methodsFor: 'accessing' !
typeOfCode: aSymbol

	typeOfCode := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'highlighting'] value ! !
! CodeHighlighter methodsFor: 'highlighting' !
highlightMethod

	self richTextWidget
		clearEmphasis;
		addEmphasis: (EmphasisSpan from: 1 to: (self richTextWidget text indexOf: Character cr) with: Emphasis bold).

	(SmalltalkParser parseForClass: self compiledMethod rootMethod mclass methodString: self compiledMethod rootMethod getSource) currentRule result
		acceptVisitor: self
		  ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'highlighting'] value ! !
! CodeHighlighter methodsFor: 'highlighting' !
highlightMethod: aCompiledMethod source: aString forWidget: aWidget

	self
		compiledMethod: aCompiledMethod;
		sourceCode: aString;
		richTextWidget: aWidget.

	self highlightMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitBlockLiteralNode: aNode

	aNode acceptVisitor: self
 ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitGlobalVariableReferenceNode: aNode

	self richTextWidget
		addEmphasis: (EmphasisSpan from: aNode startSourceOffset + 1 to: aNode endSourceOffset + 1 with: Emphasis bold) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitLiteralNode: aNode

	self richTextWidget
		addEmphasis: (EmphasisSpan from: aNode startSourceOffset + 1 to: aNode endSourceOffset + 1 with: Emphasis brown) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitLocalVariableAssignmentNode: aNode

	aNode value acceptVisitor: self.

	self richTextWidget
		addEmphasis: (EmphasisSpan from: aNode startSourceOffset + 1 to: aNode endSourceOffset + 1 with: Emphasis red) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitLocalVariableReferenceNode: aNode

	self richTextWidget
		addEmphasis: (EmphasisSpan from: aNode startSourceOffset + 1 to: aNode endSourceOffset + 1 with: Emphasis red) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitMessageNodeEnd: aNode

	self richTextWidget
		addEmphasis: (EmphasisSpan from: aNode startSourceOffset + 1 to: aNode endSourceOffset + 1 with: Emphasis blue) ! !
! Doit class methodsFor: 'doit' !
doit ^[CodeHighlighter methodsFor: 'visiting'] value ! !
! CodeHighlighter methodsFor: 'visiting' !
visitSpecialNode: aNode

	self richTextWidget
		addEmphasis: (EmphasisSpan from: aNode startSourceOffset + 1 to: aNode endSourceOffset + 1 with: Emphasis green) ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
context

	^context ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
context: anObject

	context := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
currentFrame

	^currentFrame ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
currentFrame: aCodeContext

	currentFrame := aCodeContext ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
getSelf

	^self currentFrame getSelf ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
message

	^message  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
message: aString

	message := aString  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
selectedField

	^selectedField ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
selectedField: aNumber

	selectedField := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
selectedLocal

	^selectedLocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
selectedLocal: aNumber

	selectedLocal := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
selectedStack

	^selectedStack ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
selectedStack: aNumber

	selectedStack := aNumber ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
simulator

	^simulator ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'accessing'] value ! !
! Debugger methodsFor: 'accessing' !
simulator: aCodeSimulator

	simulator := aCodeSimulator ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
inspectSimulator

	self simulator inspect
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
into

	self simulator into.
	self peekBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
over

	self simulator over.
	self peekBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
peekBytecode

	self message: (self simulator currentContext method decompileSingleBytecodeStartingAt: self simulator currentContext pcOffset).
	self currentFrame: self simulator currentContext.
	self update

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
restart

	self simulator
		returnToFrame: self currentFrame;
		restart.
	self
		update;
		peekBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
restartMethod

	self simulator returnToFrame: self currentFrame rootContext frame. ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
restartMethod: aCompiledMethod

	self simulator returnToFrame: self currentFrame rootContext frame.
	self simulator buildFrameFor: aCompiledMethod.
	self currentFrame: self simulator currentContext ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
return

	
	self request: 'Expression?' initialAnswer: 'self' answerBlock: [:string |
		self simulator currentContext push: (SmalltalkParser evaluate: string for: self getSelf).
		self simulator return.
		self peekBytecode]  at: self origin + (50 @ 50) ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
stepBytecode

	self simulator stepBytecode.
	self peekBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'actions'] value ! !
! Debugger methodsFor: 'actions' !
through

	self simulator through.
	self peekBytecode ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'changing'] value ! !
! Debugger methodsFor: 'changing' !
changedInspectorSelection: aNumber

	self selectedField: aNumber.
	self updateSelfTextEditor ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'changing'] value ! !
! Debugger methodsFor: 'changing' !
changedLocalsSelection: aNumber

	self selectedLocal: aNumber.
	self updateLocalsEditor ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'changing'] value ! !
! Debugger methodsFor: 'changing' !
changedStackSelection: aNumber

	self selectedStack: aNumber.
	self updateStackEditor ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'changing'] value ! !
! Debugger methodsFor: 'changing' !
changedWalkbackSelection: aNumber

	self
		currentFrame: (self simulator frames at: aNumber);
		selectedField: nil;
		selectedLocal: nil;

		updateCodeEditor;
		updateSelfInspector;
		updateSelfTextEditor;
		updateLocalsList;
		updateLocalsEditor  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
codeMenu

	^PopupMenuUI new
		widgetId: self codeEditorId;
		addMenuItem: self saveMenuItem;
		addMenuItem: self doItMenuItem;
		addMenuItem: self printItMenuItem;
		addMenuItem: self inspectItMenuItem;
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
doItMenuItem

	^PopupMenuItem new
		id: #doIt;
		name: 'Do It';
		action: [:args | self doItWith: args];
		requestedValues: #('selectedString');
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
doItWith: aDictionary

	self ui disableWhile: [SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self subject]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
inspectItMenuItem

	^PopupMenuItem new
			id: #inspectIt;
			name: 'Inspect It';
			action: [:args | self inspectItWith: args];
			requestedValues: #('selectedString');
			yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
inspectItWith: aDictionary

	| object |

	self ui disableWhile: [object := SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self subject].

	object inspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
printItMenuItem

	^PopupMenuItem new
		id: #printIt;
		name: 'Print It';
		action: [:args | self printItWith: args];
		requestedValues: #('selectedString' 'selectionStart' 'selectionEnd');
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
printItWith: aDictionary

	| result |

	self ui disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'selectedString')) printString].

	self write: result inTextArea: self id position: (aDictionary at: 'selectionEnd')  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
saveMenuItem

	^PopupMenuItem new
		id: #save;
		name: 'Save';
		action: [:args | self saveWith: args];
		addRequestedValue: 'innerHTML';
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'code menu'] value ! !
! Debugger methodsFor: 'code menu' !
saveWith: aDictionary

	| codeString fileinStream method class protocol kit |

	codeString := HTMLBuilder new htmlUnquote: (aDictionary at: 'innerHTML').
	class := self currentFrame rootMethodClass.
	protocol := class organizationFor: (self currentFrame rootMethod selector).
	kit := currentFrame rootMethod kit.

	fileinStream := WriteStream on: (String new: 100).
	fileinStream
		nextPutAll: '! ';
		nextPutAll: class name;
		nextPutAll: ' methodsFor: ''';
		nextPutAll: protocol;
		nextPutAll: ''' !';
		cr;
		nextPut: Character lf;
		nextPutAll: (codeString crToCRLF);
		nextPutAll: '! !'.

	method := [fileinStream contents readStream fileIn]
		on: CompileError , CompileWarning
		do: [:ex |
			self message: '#### ', ex message asString.
			ex return: nil].

	method isNil ifTrue: [
		"self selectedMethod: nil."
		^false].

	kit isNil ifFalse: [
		fileinStream := WriteStream on: (String new: 100).
		fileinStream
			nextPutAll: '(KitManager current kitNamed: ''', kit name, ''') addMethod: (';
			nextPutAll: class name;
			nextPutAll: ' compiledMethodAt: #';
			nextPutAll: method selector;
			nextPutAll: ') !';
			cr; cr.

		fileinStream contents readStream fileIn
		].

	self
		restartMethod: method;
		update;
		peekBytecode
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
doLocalsBasicInspect

	self selectedLocalObject basicInspect    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
doLocalsInspect

	self selectedLocalObject inspect    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
doSelfBasicInspect

	self selectedObject basicInspect    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
doSelfInspect

	self selectedObject inspect    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
doStackBasicInspect

	(self currentFrame stackAt: self selectedStack) basicInspect    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
doStackInspect

	(self currentFrame stackAt: self selectedStack) inspect    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
localsBasicInspectMenuItem

	^PopupMenuItem new
		id: #localsBasicInspect;
		name: 'Basic Inspect';
		action: [:args | self localsBasicInspectWith: args];
		requestedValues: #('selectedString');
		enabledBlock: [self selectedLocal notNil];
		yourself   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
localsBasicInspectWith: aDictionary

	self doLocalsBasicInspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
localsInspectMenu

	^PopupMenuUI new
		widgetId: self localsInspectorListId;
		addMenuItem: self localsInspectMenuItem;
		addMenuItem: self localsBasicInspectMenuItem;
		yourself    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
localsInspectMenuItem

	^PopupMenuItem new
		id: #localsInspect;
		name: 'Inspect';
		action: [:args | self localsInspectWith: args];
		requestedValues: #('selectedString');
		enabledBlock: [self selectedLocal notNil];
		yourself    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
localsInspectWith: aDictionary

	self doLocalsInspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
selfBasicInspectMenuItem

	^PopupMenuItem new
		id: #selfBasicInspect;
		name: 'Basic Inspect';
		action: [:args | self selfBasicInspectWith: args];
		requestedValues: #('selectedString');
		enabledBlock: [self selectedField notNil];
		yourself   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
selfBasicInspectWith: aDictionary

	self doSelfBasicInspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
selfInspectMenu

	^PopupMenuUI new
		widgetId: self selfInspectorListId;
		addMenuItem: self selfInspectMenuItem;
		addMenuItem: self selfBasicInspectMenuItem;
		yourself    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
selfInspectMenuItem

	^PopupMenuItem new
		id: #selfInspect;
		name: 'Inspect';
		action: [:args | self selfInspectWith: args];
		requestedValues: #('selectedString');
		enabledBlock: [self selectedField notNil];
		yourself    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
selfInspectWith: aDictionary

	self doSelfInspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
stackBasicInspectMenuItem

	^PopupMenuItem new
		id: #stackBasicInspect;
		name: 'Basic Inspect';
		action: [:args | self stackBasicInspectWith: args];
		requestedValues: #('selectedString');
		enabledBlock: [self selectedStack notNil];
		yourself   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
stackBasicInspectWith: aDictionary

	self doStackBasicInspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
stackInspectMenu

	^PopupMenuUI new
		widgetId: self stackInspectorListId;
		addMenuItem: self stackInspectMenuItem;
		addMenuItem: self stackBasicInspectMenuItem;
		yourself    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
stackInspectMenuItem

	^PopupMenuItem new
		id: #stackInspect;
		name: 'Inspect';
		action: [:args | self stackInspectWith: args];
		requestedValues: #('selectedString');
		enabledBlock: [self selectedStack notNil];
		yourself    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'menus'] value ! !
! Debugger methodsFor: 'menus' !
stackInspectWith: aDictionary

	self doStackInspect  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'opening'] value ! !
! Debugger methodsFor: 'opening' !
debuggerHTML

	^HTMLBuilder new
		div: [:builder |
			builder
				div: [:builder2 |
					builder2
						id: (self idFor: 'toolBar');
						class: 'buttonBar';
						install: self peekBytecodeWidget;
						install: self stepBytecodeWidget;
						install: self intoWidget;
						install: self throughWidget;
						install: self overWidget;
						install: self restartWidget;
						install: self returnWidget;
						install: self inspectSimulatorWidget];
				install: self messageWidget;
				inHorizontalLayout: (self idFor: 'walkbackComponents') do: [:builder2 |
					builder2
						install: self walkbackListWidget;
						install: self stackInspectorListWidget;
						install: self stackTextEditorWidget];
				install: self codeWidget;
				inHorizontalLayout: (self idFor: 'inspectorComponents') do: [:builder2 |
					builder2
						install: self selfInspectorListWidget;
						install: self selfTextEditorWidget;
						install: self localsInspectorListWidget;
						install: self localsTextEditorWidget]];
		htmlString     ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'opening'] value ! !
! Debugger methodsFor: 'opening' !
defaultWindowExtent

	^900 @ 400 ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'opening'] value ! !
! Debugger methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self simulator: (CodeSimulator new frames: (self tossFramesToSignal: self context allFrames); yourself).
	self simulator frames first push: nil. "to simulate the return value from the unfinished method call"
	self withinWebUpdateDo: [self drawWindow; updateWalkbackList].
	self runJavaScript: 'enableTabsInRichTextArea("', self codeEditorId, '");' ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'opening'] value ! !
! Debugger methodsFor: 'opening' !
title

	^'Debugger' ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'opening'] value ! !
! Debugger methodsFor: 'opening' !
tossFramesToSignal: aCollection

	[(aCollection first method isMemberOf: CompiledMethod)
		and: [aCollection first method selector == #raiseSignal]] whileFalse: [aCollection removeFirst].

	aCollection removeFirst.

	((aCollection first method isMemberOf: CompiledMethod)
		and: [aCollection first method selector == #raiseSignal2]) ifTrue: [aCollection removeFirst].

	((aCollection first method isMemberOf: CompiledMethod)
		and: [aCollection first method selector == #signal:]) ifTrue: [aCollection removeFirst].

	^aCollection
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'simulating'] value ! !
! Debugger methodsFor: 'simulating' !
codeSimulator

	^simulator ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
currentEmphasis

	| offsets sourceOffsets |

	self currentFrame isNil ifTrue: [^nil].

	sourceOffsets := self currentFrame == self simulator frames first
		ifTrue: [self currentFrame method sourceOffsetsDictionary]
		ifFalse: [self currentFrame method sourceOffsetsDictionaryForNonCurrentFrame].

	offsets := sourceOffsets at: self currentFrame pcOffset ifAbsent: [^nil].
	^EmphasisSpan from: offsets first + 1 to: offsets last + 1 with: Emphasis walkbackCallHighlight ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
drawWindow

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self debuggerHTML ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
selectedLocalObject

	self selectedLocal isNil ifTrue: [^nil].
	^self currentFrame localAt: self selectedLocal ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
selectedObject 

	| field |

	self selectedField isNil ifTrue: [^nil].
	self selectedField = 1 ifTrue: [^self getSelf].

	field := self getSelf inspectorFields at: self selectedField - 1.
	field isComputedField ifTrue: [
		^field valueFor: self getSelf].
	^self getSelf inspectorFieldAt: field
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
setEmphasis

	| emphasis |

	emphasis := self currentEmphasis.
	emphasis isNil ifTrue: [^self].

	self codeWidget addEmphasis: emphasis ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
update

	self
		updateWalkbackList;
		updateCodeEditor;
		updateSelfInspector;
		updateLocalsList;
		updateStackList.
	self walkbackListWidget selectionIndex: 1. ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateCodeEditor

	| text |

	text := self currentFrame isNil
		ifTrue: ['']
		ifFalse: [self currentFrame rootMethod getSource].

	self codeWidget text: text.
	text isEmpty ifFalse: [
		CodeHighlighter new
			highlightMethod: self currentFrame method
			source: text
			forWidget: self codeWidget].

	self setEmphasis.
	self codeWidget updateText ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateLocalsEditor

	| text |

	text := self selectedLocal isNil
		ifTrue: ['']
		ifFalse: [(self currentFrame localAt: self selectedLocal) printString].

	^self localsTextEditorWidget text: text  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateLocalsList

	| list |

	list := self currentFrame isNil
		ifTrue: [list := OrderedCollection new]
		ifFalse: [self currentFrame allLocalNames].

	self localsInspectorListWidget list: list ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateSelfInspector

	self currentFrame isNil ifTrue: [
		self selfInspectorListWidget list: OrderedCollection new.
		^self].

	fieldList := self getSelf inspectorFields addFirst: 'self'; yourself.
	self selfInspectorListWidget list: fieldList   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateSelfTextEditor

	| text |

	text := self selectedField isNil
		ifTrue: ['']
		ifFalse: [self selectedObject printString].

	self selfTextEditorWidget text: text; updateText ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateStackEditor

	| text |

	text := self selectedStack isNil
		ifTrue: ['']
		ifFalse: [(self currentFrame stackAt: self selectedStack) printString].

	^self stackTextEditorWidget text: text  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateStackList

	| list |

	list := self currentFrame isNil
		ifTrue: [list := OrderedCollection new]
		ifFalse: [self currentFrame stackNames].

	self stackInspectorListWidget list: list; selectionIndex: 0
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'updating'] value ! !
! Debugger methodsFor: 'updating' !
updateWalkbackList

	self walkbackListWidget list: self simulator frames copy.
	self messageWidget text: (self message ifNil: [''])  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
codeEditorId

	^self idFor: 'codeEditor' ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
codeWidget

	^self bindingAt: #codeEditor ifAbsentPut: [
		RichTextEditorComponent new
			bindTo: self id: self codeEditorId;
			menu: self codeMenu;
			subject: self;
			yourself]   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
inspectSimulatorWidget

	^self bindingAt: #inspectSimulator ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'inspectSimulator ';
			label: 'Inspect';
			actionBlock: [self inspectSimulator];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
intoWidget

	^self bindingAt: #into ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'into';
			label: 'Into';
			actionBlock: [self into];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
localsInspectorListId

	^self idFor: 'localsInspectorList'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
localsInspectorListWidget

	^self bindingAt: #localsInspectorList ifAbsentPut: [
		ListComponent new
			bindTo: self id: self localsInspectorListId;
			listNumberOfRows: 10;
			onEvent: ListSelectionEvent do: [:event | self changedLocalsSelection: event selectionIndex];
			menu: self localsInspectMenu;
			yourself]
    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
localsTextEditorId

	^self idFor: 'localsTextEditor'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
localsTextEditorWidget

	^self bindingAt: #localsTextEditor ifAbsentPut: [
		TextEditorComponent new
			bindTo: self id: self localsTextEditorId;
			yourself]   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
messageEditorId

	^self idFor: 'messageEditor'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
messageWidget

	^self bindingAt: #messageEditor ifAbsentPut: [
		TextEditorComponent new
			bindTo: self id: self messageEditorId;
			height: '100px';
			yourself]   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
overWidget

	^self bindingAt: #over ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'over';
			label: 'Over';
			actionBlock: [self over];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
peekBytecodeWidget

	^self bindingAt: #peekBytecode ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'peekBytecode';
			label: 'Peek Bytecode';
			actionBlock: [self peekBytecode];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
restartWidget

	^self bindingAt: #restart ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'restart';
			label: 'Restart';
			actionBlock: [self restart];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
returnWidget

	^self bindingAt: #return ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'return';
			label: 'Return';
			actionBlock: [self return];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
selfInspectorListId

	^self idFor: 'selfInspectorList'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
selfInspectorListWidget

	^self bindingAt: #selfInspectorList ifAbsentPut: [
		ListComponent new
			bindTo: self id: self selfInspectorListId;
			listNumberOfRows: 10;
			onEvent: ListSelectionEvent do: [:event | self changedInspectorSelection: event selectionIndex];
			menu: self selfInspectMenu;
			yourself]
       ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
selfTextEditorId

	^self idFor: 'selfTextEditor'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
selfTextEditorWidget

	^self bindingAt: #selfTextEditor ifAbsentPut: [
		TextEditorComponent new
			bindTo: self id: self selfTextEditorId;
			yourself]   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
stackInspectorListId

	^self idFor: 'stackInspectorList'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
stackInspectorListWidget

	^self bindingAt: #stackInspectorList ifAbsentPut: [
		ListComponent new
			bindTo: self id: self stackInspectorListId;
			listNumberOfRows: 10;
			height: '100px';
			onEvent: ListSelectionEvent do: [:event | self changedStackSelection: event selectionIndex];
			menu: self stackInspectMenu;
			yourself]
    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
stackTextEditorId

	^self idFor: 'stackTextEditor'  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
stackTextEditorWidget

	^self bindingAt: #stackTextEditor ifAbsentPut: [
		TextEditorComponent new
			bindTo: self id: self stackTextEditorId;
			height: '100px';
			yourself]   ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
stepBytecodeWidget

	^self bindingAt: #stepBytecode ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'stepBytecode';
			label: 'Step Bytecode';
			actionBlock: [self stepBytecode];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
throughWidget

	^self bindingAt: #through ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'through';
			label: 'Through';
			actionBlock: [self through];
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
walkbackListId

	^self idFor: 'walkbackList' ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger methodsFor: 'widgets'] value ! !
! Debugger methodsFor: 'widgets' !
walkbackListWidget

	^self bindingAt: #walkbackList ifAbsentPut: [
		ListComponent new
			bindTo: self id: self walkbackListId;
			listNumberOfRows: 10;
			height: '100px';
			displayBlock: [:each | each printString];
			onEvent: ListSelectionEvent do: [:event | self changedWalkbackSelection: event selectionIndex];

			"menu: self walkbackMenu;
			on: DoubleClickEvent do: [:event | self diveIn];"

			yourself]
    ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger class methodsFor: 'opening'] value ! !
! Debugger class methodsFor: 'opening' !
openOn: aContext

	^self new
		context: aContext;
		open;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Debugger class methodsFor: 'opening'] value ! !
! Debugger class methodsFor: 'opening' !
openOn: aContext message: aString

	^self new
		context: aContext;
		message: aString;
		open;
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
fieldList

	^fieldList  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
fieldList: aCollection

	fieldList := aCollection  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
keysList

	^keysList ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
keysList: anObject

	keysList := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
object

	^object ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
object: anObject

	object := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
objectStack

	^objectStack ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
objectStack: aCollection

	objectStack := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
selectedField

	^selectedField  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'accessing'] value ! !
! Inspector methodsFor: 'accessing' !
selectedField: aNumber

	selectedField := aNumber  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'actions'] value ! !
! Inspector methodsFor: 'actions' !
diveIn

	self selectedObject isNil ifTrue: [^self].

	objectStack add: self object.
	self object: self selectedObject.
	self selectedField: nil.

	self updateFieldList.
	self updateList; updateText; updateTitle ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'actions'] value ! !
! Inspector methodsFor: 'actions' !
doBasicInspect

	self selectedObject basicInspect ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'actions'] value ! !
! Inspector methodsFor: 'actions' !
doInspect

	self selectedObject inspect ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'actions'] value ! !
! Inspector methodsFor: 'actions' !
popOut

	objectStack isEmpty ifTrue: [^self].
	self object: objectStack removeLast.
	self selectedField: nil.

	self updateFieldList.
	self updateList; updateText; updateTitle ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'changing'] value ! !
! Inspector methodsFor: 'changing' !
changedSelectedField: aNumber

	self selectedField: aNumber.
	self updateText
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
codeMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'workspaceTextBox');
		addMenuItem: self doItMenuItem;
		addMenuItem: self printItMenuItem;
		addMenuItem: self inspectItMenuItem;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
doItMenuItem

	^PopupMenuItem new
		id: #doIt;
		name: 'Do It';
		action: [:args | self doItWith: args];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
doItWith: aDictionary

	self disableWhile: [SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self object] ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
inspectItMenuItem

	^PopupMenuItem new
			id: #inspectIt;
			name: 'Inspect It';
			action: [:args | self inspectItWith: args];
			requestedValues: #('selectedString');
			yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
inspectItWith: aDictionary

	| result |

	self disableWhile: [result := SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self object].

	result inspect ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
openCodeMenuX: x y: y

	self codeMenu openIn: (self idFor: 'workspaceTextBox') x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
printItMenuItem

	^PopupMenuItem new
		id: #printIt;
		name: 'Print It';
		action: [:args | self printItWith: args];
		requestedValues: #('selectedString' 'selectionStart' 'selectionEnd');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'code menu'] value ! !
! Inspector methodsFor: 'code menu' !
printItWith: aDictionary

	| result |

	self disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'selectedString') for: self object) printString].

	self write: result inTextArea: (self idFor: 'workspaceTextBox') position: (aDictionary at: 'selectionEnd') ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
basicInspectMenuItem

	^PopupMenuItem new
		id: #basicInspect;
		name: 'Basic Inspect';
		action: [:args | self basicInspectWith: args];
		enabledBlock: [self selectedField notNil];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
basicInspectWith: args

	self doBasicInspect
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
diveInWith: args

	self diveIn ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
diveMenuItem

	^PopupMenuItem new
		id: #dive;
		name: 'Dive';
		action: [:args | self diveInWith: args];
		enabledBlock: [self selectedField notNil];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
fieldMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'fieldList');
		addMenuItem: self diveMenuItem;
		addMenuItem: self popMenuItem;
		addMenuItem: self inspectMenuItem;
		addMenuItem: self basicInspectMenuItem;
		yourself   ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
inspectMenuItem

	^PopupMenuItem new
		id: #inspect;
		name: 'Inspect';
		action: [:args | self inspectWith: args];
		enabledBlock: [self selectedField notNil];
		requestedValues: #('selectedString');
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
inspectWith: args

	self doInspect
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
openFieldMenuX: x y: y

	self fieldMenu openIn: (self idFor: 'fieldList') x: x y: y  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
popMenuItem

	^PopupMenuItem new
		id: #pop;
		name: 'Pop';
		action: [:args | self popOutWith: args];
		enabledBlock: [self objectStack notEmpty];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'field menu'] value ! !
! Inspector methodsFor: 'field menu' !
popOutWith: args

	self popOut
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'html'] value ! !
! Inspector methodsFor: 'html' !
inspectorHTML

	^HTMLBuilder new
		div: [:builder1 |
			builder1
				inHorizontalLayout: (self idFor: 'inspectorComponents') do: [:builder2 |
					builder2
						install: self fieldListWidget;
					install: self inspectorTextWidget];
				install: self workspaceWidget];
		htmlString
   ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'initializing'] value ! !
! Inspector methodsFor: 'initializing' !
initialize

	super initialize.
	objectStack := OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'opening'] value ! !
! Inspector methodsFor: 'opening' !
postOpen

	super postOpen.
	self
		setAbsoluteWindowBounds;
		install;
		withinWebUpdateDo: [self update; updateFieldList].
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
defaultWindowExtent

	^600 @ 200 ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
innerAppName

	^self idFor: 'enableDisable' ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
install

	"self addHTMLBeforeEndOf: self innerAppName to: self browser2ListWidget" ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
selectedObject 

	| field |

	self selectedField isNil ifTrue: [^nil].
	self selectedField = 1 ifTrue: [^self object].

	field := self fieldList at: self selectedField.
	field isComputedField ifTrue: [
		^field valueFor: self object].
	^self object inspectorFieldAt: field ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
title

	^self object class name ifNil: ['Inspector'] ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
update

	self addHTMLBeforeEndOf: self innerAppName to: self inspectorHTML.
	self updateList ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
updateFieldList

	self fieldList: ((self object computedFields , self object inspectorFields) addFirst: 'self'; yourself).
	self fieldListWidget list: (self fieldList collect: [:each | each asString]) ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
updateList

	"| stream |

	self object isNil ifTrue: [^self].

	stream := WriteStream on: (ByteString new: 1000).

	self fieldList keysAndValuesDo: [:key :eachElement |
		stream
			nextPutAll: '<option value=', key printString, '>';
			nextPutAll: eachElement;
			nextPutAll: '</option>'].

	self setInnerHTMLOf: (self idFor: 'fieldList') to: stream contents" ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
updateText

	| text |

	text := self selectedField isNil
		ifTrue: ['']
		ifFalse: [self selectedObject printString].

	self inspectorTextWidget text: text; updateText  ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'updating'] value ! !
! Inspector methodsFor: 'updating' !
updateTitle

	self setInnerHTMLOf: (self idFor: 'dragbar') to: self title ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'widgets'] value ! !
! Inspector methodsFor: 'widgets' !
fieldListWidget

	^self bindingAt: #fieldList ifAbsentPut: [
		ListComponent new
			bindTo: self as: 'fieldList';
			listNumberOfRows: 10;
			menu: self fieldMenu;
			onEvent: ListSelectionEvent do: [:event | self changedSelectedField: event selectionIndex];
			onEvent: DoubleClickEvent do: [:event | self diveIn];
			yourself]
   ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'widgets'] value ! !
! Inspector methodsFor: 'widgets' !
inspectorTextWidget

	^self bindingAt: #inspectorText ifAbsentPut: [
		TextEditorComponent new
			bindTo: self as: 'inspectorTextBox';
			yourself]
    ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector methodsFor: 'widgets'] value ! !
! Inspector methodsFor: 'widgets' !
workspaceWidget

	^self bindingAt: #workspace ifAbsentPut: [
		TextEditorComponent new
			bindTo: self as: 'workspaceTextBox';
			menu: self codeMenu;
			subject: self object;
			yourself]
    ! !
! Doit class methodsFor: 'doit' !
doit ^[Inspector class methodsFor: 'opening'] value ! !
! Inspector class methodsFor: 'opening' !
openOn: anObject

	| inspector |

	^(inspector := self new)
		object: anObject;
		open;
		runJavaScript: 'enableTabsInTextArea("', (inspector idFor: 'workspaceTextBox'), '");'
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[BasicInspector methodsFor: 'opening'] value ! !
! BasicInspector methodsFor: 'opening' !
title

	^'Basic Inspector' ! !
! Doit class methodsFor: 'doit' !
doit ^[BasicInspector methodsFor: 'updating'] value ! !
! BasicInspector methodsFor: 'updating' !
selectedObject 

	self selectedField isNil ifTrue: [^nil].
	self selectedField = 1 ifTrue: [^self object].
	^self object basicInspectorFieldAt: self selectedField - 1 ! !
! Doit class methodsFor: 'doit' !
doit ^[BasicInspector methodsFor: 'updating'] value ! !
! BasicInspector methodsFor: 'updating' !
updateFieldList

	self fieldListWidget list: (self object basicInspectorFields addFirst: 'self'; yourself) ! !
! Doit class methodsFor: 'doit' !
doit ^[KitBrowserPlugin methodsFor: 'computing'] value ! !
! KitBrowserPlugin methodsFor: 'computing' !
computeMethodsListOn: aBrowser

	aBrowser computeKitBrowserMethodsList ! !
! Doit class methodsFor: 'doit' !
doit ^[KitBrowserPlugin methodsFor: 'installing'] value ! !
! KitBrowserPlugin methodsFor: 'installing' !
installBrowserPanesOn: aWebUI

	aWebUI
		installBrowserList;
		installKitBoxWidget;
		installClassBoxWidget;
		installProtocolBoxWidget;
		installMethodBoxWidget;
		installCodeBoxWidget ! !
! Doit class methodsFor: 'doit' !
doit ^[KitBrowserPlugin methodsFor: 'opening'] value ! !
! KitBrowserPlugin methodsFor: 'opening' !
doPostBuildOn: aWebUI

	aWebUI
		kitsList;
		classesList;
		protocolsList;
		methodsList;
		codeTextEditor;
		clearClasses;
		instanceOrClass: #instance ! !
! Doit class methodsFor: 'doit' !
doit ^[KitBrowserPlugin methodsFor: 'opening'] value ! !
! KitBrowserPlugin methodsFor: 'opening' !
doPostOpenOn: aWebUI

	aWebUI computeKitList ! !
! Doit class methodsFor: 'doit' !
doit ^[KitBrowserPlugin methodsFor: 'updating'] value ! !
! KitBrowserPlugin methodsFor: 'updating' !
update: aBrowser

	aBrowser
		updateKitList;
		updateClassList;
		updateInstanceClassSelection;
		updateProtocolList;
		updateMethodList;
		updateCodePane ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodBrowserPlugin methodsFor: 'computing'] value ! !
! MethodBrowserPlugin methodsFor: 'computing' !
computeMethodsListOn: aBrowser

	aBrowser computeMethodBrowserMethodsList ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodBrowserPlugin methodsFor: 'installing'] value ! !
! MethodBrowserPlugin methodsFor: 'installing' !
installBrowserPanesOn: aWebUI

	aWebUI
		installBrowserList;
		installMethodBoxWidget;
		installCodeBoxWidget ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodBrowserPlugin methodsFor: 'opening'] value ! !
! MethodBrowserPlugin methodsFor: 'opening' !
doPostBuildOn: aWebUI

	aWebUI
		methodsList;
		codeTextEditor;
		instanceOrClass: #instance ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodBrowserPlugin methodsFor: 'opening'] value ! !
! MethodBrowserPlugin methodsFor: 'opening' !
doPostOpenOn: aWebUI

	aWebUI clearCode ! !
! Doit class methodsFor: 'doit' !
doit ^[MethodBrowserPlugin methodsFor: 'updating'] value ! !
! MethodBrowserPlugin methodsFor: 'updating' !
update: aBrowser

	aBrowser
		updateMethodListWithClass;
		updateCodePane ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
browserPlugin

	^browserPlugin ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
browserPlugin: aPlugin

	browserPlugin := aPlugin ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
classes
	^classes ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
classes: aCollection
	classes := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
code
	^code ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
code: aString
	code := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
instanceOrClass
	^instanceOrClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
instanceOrClass: aSymbol
	instanceOrClass := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
kits
	^kits ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
kits: aCollection
	kits := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
methods
	^methods ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
methods: aCollection
	methods := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
protocols
	^protocols ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
protocols: aCollection
	protocols := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedClass
	^selectedClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedClass: aClass
	selectedClass := aClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedKit
	^selectedKit ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedKit: aKit
	selectedKit := aKit ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedMethod
	^selectedMethod ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedMethod: aSymbol
	selectedMethod := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedProtocol
	^selectedProtocol ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
selectedProtocol: aString
	selectedProtocol := aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'accessing'] value ! !
! SystemBrowser methodsFor: 'accessing' !
title

	^'System Browser'  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'aspects'] value ! !
! SystemBrowser methodsFor: 'aspects' !
classesList

	^self listComponentNamed: #classesList menu: self classMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'aspects'] value ! !
! SystemBrowser methodsFor: 'aspects' !
codeTextEditor

	^self codeBoxWidget ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'aspects'] value ! !
! SystemBrowser methodsFor: 'aspects' !
kitsList

	^self listComponentNamed: #kitsList menu: self kitMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'aspects'] value ! !
! SystemBrowser methodsFor: 'aspects' !
methodsList

	^self listComponentNamed: #methodsList menu: self methodMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'aspects'] value ! !
! SystemBrowser methodsFor: 'aspects' !
protocolsList

	^self listComponentNamed: #protocolsList menu: self protocolMenu ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'building'] value ! !
! SystemBrowser methodsFor: 'building' !
postBuild
	super postBuild.
	self browserPlugin doPostBuildOn: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedClass: aString
	| class index |
	index := Integer readFrom: aString readStream.
	class := self classes at: index.
	class == selectedClass ifTrue: [^self].
	self
		selectedClass: class;
		computeProtocolsList;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedClassEvent: anEvent

	| class index |
	index := Integer readFrom: anEvent selectionIndex.
	class := self classes at: index.
	class == selectedClass ifTrue: [^self].
	self
		selectedClass: class;
		computeProtocolsList;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedKitEvent: anEvent

	| kit index |
	kit := self kits at: anEvent selectionIndex.
	kit == selectedKit ifTrue: [^self].
	self
		selectedKit: kit;
		computeClassList;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedMethod: aString
	| method index |
	index := Integer readFrom: aString readStream.
	method := self methods at: index.
	method = selectedMethod ifTrue: [^self].
	self
		selectedMethod: method;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedMethodEvent: anEvent

	| method |

	method := self methods at: anEvent selectionIndex.
	method = selectedMethod ifTrue: [^self].
	(method first methodDictionary includesKey: (method at: 3)) ifFalse: [
		method := nil].
	self
		selectedMethod: method;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedProtocol: aString
	| protocol index |
	index := Integer readFrom: aString readStream.
	protocol := self protocols at: index.
	protocol == selectedProtocol ifTrue: [^self].
	self
		selectedProtocol: protocol;
		computeMethodsList;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
changedSelectedProtocolEvent: anEvent

	| protocol |
	protocol := self protocols at: anEvent selectionIndex.
	protocol == selectedProtocol ifTrue: [^self].
	self
		selectedProtocol: protocol;
		computeMethodsList;
		computeCode.

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
clearClasses
	self classes: OrderedCollection new.
	self selectedClass: nil.
	self clearProtocols ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
clearCode
	self code: '' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
clearMethods
	self methods: OrderedCollection new.
	self selectedMethod: nil.
	self clearCode ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
clearProtocols
	self protocols: OrderedCollection new.
	self selectedProtocol: nil.
	self clearMethods ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeClassList
	self clearClasses.
	self selectedKit isNil ifTrue: [^self].
	self classes: ((self selectedKit definedClasses , self selectedKit extendedClasses) asArray sortedBy: [:a :b | a name < b name]).
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeCode

	self clearCode.
	self selectedMethod notNil ifTrue: [
		self code: (self selectedMethod first compiledMethodAt: (self selectedMethod at: 3)) getSource.
		^self].

	self selectedProtocol notNil ifTrue: [
		self code: '<type method here>'.
		^self].

	self selectedClass notNil ifTrue: [
		| stream |
		stream := WriteStream on: (String new: 200).
		self selectedClass fileoutDefinitionOn: stream.
		self code: stream contents.
		^self].

	self selectedKit notNil ifTrue: [
		| stream |
		stream := WriteStream on: (String new: 200).
		stream
			nextPutAll: '(KitManager current kitNamed: ''' , self selectedKit name, ''')';
			cr; tab;
			nextPutAll: 'requiredKitNames: ';
			nextPutAll: self selectedKit requiredKitNames asArray printString;
			nextPutAll: ' !'.
		self code: stream contents.
		^self].

	self code: ''
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeKitBrowserMethodsList

	| methodsToShow |

	self clearMethods.
	self selectedProtocol isNil ifTrue: [^self].
	methodsToShow := self selectedProtocol first organization at: self selectedProtocol last.

	(self isSelectedClassExtended: self selectedClass) ifTrue: [
		methodsToShow := methodsToShow select: [:each | (selectedProtocol first compiledMethodAt: each) kit = self selectedKit]].

	self methods: ((methodsToShow asArray sortedBy: [:a :b | a < b])
		collect: [:eachSelector | Array with: self selectedProtocol first with: self selectedProtocol last with: eachSelector with: (self selectedProtocol first compiledMethodAt: eachSelector) kit]).

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeKitList
	self kits: (KitManager default kits asArray sortedBy: [:a :b | a name < b name]).
	self selectedKit: nil ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeMethodBrowserMethodsList

	self removeDeletedMethodsFromMethodList
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeMethodsList
	
	self browserPlugin computeMethodsListOn: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
computeProtocolsList
	| classOrMetaclass organizations |
	self clearProtocols.
	self selectedClass isNil ifTrue: [^self].
	classOrMetaclass := self instanceOrClass = #instance
		ifTrue: [self selectedClass]
		ifFalse: [self selectedClass class].

	organizations := classOrMetaclass organization keys.
	(self isSelectedClassExtended: self selectedClass) ifTrue: [
		organizations := organizations select: [:eachOrganizationName |
			(classOrMetaclass methodsInOrganization: eachOrganizationName) anySatisfy: [:eachMethod |
				eachMethod kit = self selectedKit]]
		].

	self protocols: ((organizations asArray sortedBy: [:a :b | a < b]) collect: [:eachSymbol |
			Array with: classOrMetaclass with: eachSymbol]).
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
removeDeletedMethodsFromMethodList

	self methods copy do: [:eachMethodDescriptor |
		(eachMethodDescriptor first methodDictionary includesKey: (eachMethodDescriptor at: 3)) ifFalse: [
			self methods: (self methods copyWithout: eachMethodDescriptor)]].

	(self methods includes: self selectedMethod) ifFalse: [
		self selectedMethod: nil] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
showClassMethods
	self instanceOrClass: #class.
	self computeProtocolsList; computeCode.
	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'changing'] value ! !
! SystemBrowser methodsFor: 'changing' !
showInstanceMethods
	self instanceOrClass: #instance.
	self computeProtocolsList; computeCode.
	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class list'] value ! !
! SystemBrowser methodsFor: 'class list' !
classListWidget

	^HTMLBuilder new
		div;
			attributeAt: 'width' put: '100%';
			attributeAt: 'style' put: 'grid-template-columns: 1fr; display: grid;';
			div;
				id: (self idFor: 'classListDiv');
				attributeAt: 'oncontextmenu' put: 'simTalkCallback2(''$$appName$'', ''openClassMenuX:y:'', event.pageX, event.pageY); return false;';
				startTag: 'select';
					id: (self idFor: 'classesList');
					attributeAt: 'name' put: 'classes';
					attributeAt: 'size' put: self listNumberOfRows printString;
					attributeAt: 'style' put: 'width: 100%; background-color: rgba(255, 255, 255, 0.0);';
					attributeAt: 'onchange' put: 'simTalkCallback1(''$$appName$'', ''changedSelectedClass:'' , event.target.value);';
				endTag: 'select';
			endDiv;
			div;
				startTag: 'input';
					id: (self idFor: 'instanceMethodsRadioButton');
					attributeAt: 'type' put: 'radio';
					attributeAt: 'value' put: 'Instance';
					attributeAt: 'name' put: (self idFor: 'instanceClass');
					attributeAt: 'onchange' put: 'simTalkCallback0(''$$appName$'', ''showInstanceMethods'');';
					text: 'Instance';
				endTag: 'input';
				startTag: 'input';
					id: (self idFor: 'classMethodsRadioButton');
					attributeAt: 'type' put: 'radio';
					attributeAt: 'value' put: 'Class';
					attributeAt: 'name' put: (self idFor: 'instanceClass');
					attributeAt: 'onchange' put: 'simTalkCallback0(''$$appName$'', ''showClassMethods'');';
					text: 'Class';
				endTag: 'input';
			endDiv;
		endDiv;
		htmlString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class list'] value ! !
! SystemBrowser methodsFor: 'class list' !
installClassBoxWidget

	self addHTMLBeforeEndOf: self browserListsName to: self classListWidget ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
browseClassReferences

	self selectedClass isNil ifTrue: [^self].
	self class
		openMethodsBrowserOn: (BeagleSystem referencesToClass: self selectedClass). ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
browseInstVarReferences

	self selectedClass isNil ifTrue: [^self].
	ListChoiceBox new
		message: 'Choose one';
		choices: self selectedClass instVarNames;
		values: self selectedClass instVarNames;
		answerBlock: [:x | self class openMethodsBrowserOn: (BeagleSystem referencesToInstanceVariable: x inClass: self selectedClass)];
		open ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
browseInstVarReferencesWith: aDictionary

	self browseInstVarReferences ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
browseUndeclaredReferences

	ListChoiceBox new
		message: 'Choose one';
		choices: Undeclared keys asArray;
		values: Undeclared keys asArray;
		answerBlock: [:undeclaredSymbol | self class openMethodsBrowserOn: (BeagleSystem referencesToUndeclared: undeclaredSymbol)];
		open
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
classHierarchyString

	| classHierarchyStream indentLevel |

	classHierarchyStream := WriteStream on: (String new: 100).

	indentLevel := 0.

	self writeClassHierarchyStringFor: self selectedClassOrMetaclass on: classHierarchyStream indentLevel: indentLevel.

	^classHierarchyStream contents
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
classMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'classListDiv');
		addMenuItem: self classReferencesMenuItem;
		addMenuItem: self undeclaredReferencesMenuItem;
		addMenuItem: self instanceVariableReferencesMenuItem;
		addMenuItem: self removeClassMenuItem;
		addMenuItem: self moveClassToKitMenuItem;
		addMenuItem: self showClassHierarchyMenuItem;
		addMenuItem: self createAccessorsMenuItem;
		yourself
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
classMenuName
	^self idFor: 'classMenu' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
classReferencesMenuItem

	^PopupMenuItem new
		id: #classReferences;
		name: 'Class References';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedClass notNil];
		action: [:args | self classReferencesWith: args];
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
classReferencesWith: aDictionary

	| class |

	class := self selectedClass.
	class isNil ifTrue: [
		^self message: 'No class selected.'].

	self class
		openMethodsBrowserOn: (BeagleSystem referencesToClass: class) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
createAccessorsForInstVar: aString

	| getterName setterName |

	getterName := aString asSymbol.
	setterName := (aString, ':') asSymbol.

	(self selectedClassOrMetaclass methodDictionary includesKey: getterName) ifTrue: [
		^self message: 'Method ', getterName, ' already exists'].

	(self selectedClassOrMetaclass methodDictionary includesKey: setterName) ifTrue: [
		^self message: 'Method ', setterName, ' already exists'].

	self createGetterMethodFor: getterName.
	self createSetterMethodFor: setterName.

	self
		computeProtocolsList;
		updateBrowser


  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
createAccessorsMenuItem

	^PopupMenuItem new
		id: #createAccessors;
		name: 'Create Accessors';
		enabledBlock: [self selectedClass notNil];
		action: [:args | self createAccessorsWith: args];
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
createAccessorsWith: aDictionary

	self selectedClass isNil ifTrue: [^self].
	ListChoiceBox new
		message: 'Choose one';
		choices: self selectedClass instVarNames;
		values: self selectedClass instVarNames;
		answerBlock: [:x | self createAccessorsForInstVar: x];
		open  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
createGetterMethodFor: getterName

	| stream |

	stream := WriteStream on: (String new: 100).
	stream
		nextPutAll: '! ';
		nextPutAll: self selectedClassOrMetaclass printString;
		nextPutAll: ' methodsFor: ''accessing'' !';
		cr;
		nextPutAll: getterName;
		cr;cr; tab;
		nextPutAll: '^';
		nextPutAll: getterName;
		nextPutAll: '! !'.

	stream contents readStream fileIn.

  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
createSetterMethodFor: setterName

	| stream |

	stream := WriteStream on: (String new: 100).
	stream
		nextPutAll: '! ';
		nextPutAll: self selectedClassOrMetaclass printString;
		nextPutAll: ' methodsFor: ''accessing'' !';
		cr;
		nextPutAll: setterName;
		nextPutAll: ' anObject';
		cr; cr; tab;
		nextPutAll: (setterName copyWithout: $:);
		nextPutAll: ' := anObject! !'.

	stream contents readStream fileIn

  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
instanceVariableReferencesMenuItem

	^PopupMenuItem new
		id: #instVarReferences;
		name: 'Instance Variable References';
		enabledBlock: [self selectedClass notNil];
		action: [:args | self browseInstVarReferencesWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
moveClassToKitMenuItem

	^PopupMenuItem new
		id: #moveClassToKit;
		name: 'Move Class to Kit';
		enabledBlock: [self selectedClass notNil];
		action: [:args | self moveClassToKitWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
moveClassToKitWith: aDictionary

	self request: 'Kit Name?' initialAnswer: 'Other' answerBlock: [:newKitName | self moveSelectedClassToKit: newKitName] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
moveSelectedClassToKit: aString

	| classToMove newKit |

	classToMove := self selectedClass.
	
	aString isNil ifTrue: [^self].
	classToMove  isNil ifTrue: [^self].

	(KitManager current kitForClass: classToMove ifNone: [^self]) removeClass: classToMove.
	(newKit := KitManager current kitNamedIfAbsentAdd: aString) addClass: classToMove.
	self computeKitList.
	self selectedKit: newKit;
		computeClassList;
		selectedClass: classToMove.

	self updateBrowser
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
openClassMenuX: x y: y

	self classMenu openIn: (self idFor: 'classListDiv') x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
removeClass

	self selectedClass isNil ifTrue: [^self].

	ClassCreator new removeClass: self selectedClass.
	self computeClassList; updateBrowser

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
removeClassMenuItem

	^PopupMenuItem new
		id: #removeClass;
		name: 'Remove Class';
		enabledBlock: [self selectedClass notNil];
		action: [:args | self removeClassWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
removeClassWith: args

	^self removeClass ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
showClassHierarchy

	self
		clearProtocols;
		computeProtocolsList;
		code: self classHierarchyString;
		updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
showClassHierarchyMenuItem

	^PopupMenuItem new
		id: #showClassHierarchy;
		name: 'Show Class Hierarchy';
		enabledBlock: [self selectedClass notNil];
		action: [:args | self showClassHierarchyWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
showClassHierarchyWith: args

	^self showClassHierarchy ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
undeclaredReferencesMenuItem

	^PopupMenuItem new
		id: #undeclaredReferences;
		name: 'Undeclared References';
		enabledBlock: [Undeclared notEmpty];
		action: [:args | self undeclaredReferencesWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
undeclaredReferencesWith: aDictionary

	self browseUndeclaredReferences ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
writeClassHierarchyStringFor: aClass on: aStream indentLevel: anInteger

	| indentLevel |

	indentLevel := anInteger.

	aClass withAllSuperclasses reverseDo: [:eachSuperclass |
		self writeClassSummaryStringFor: eachSuperclass on: aStream indentLevel: indentLevel.
		indentLevel := indentLevel + 1].

	self writeSubclassSummaryStringsFor: aClass on: aStream indentLevel: indentLevel
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
writeClassSummaryStringFor: aClass on: aStream indentLevel: anInteger

	anInteger timesRepeat: [aStream tab].
	aStream
		nextPutAll: aClass printString;
		nextPutAll: ' ('.

	aClass instVarNames do: [:eachInstVarName | aStream print: eachInstVarName; space].
	aStream nextPut: $).
	aStream cr

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'class menus'] value ! !
! SystemBrowser methodsFor: 'class menus' !
writeSubclassSummaryStringsFor: aClass on: aStream indentLevel: anInteger

	| indentLevel |

	indentLevel := anInteger + 1.
	aClass subclasses do: [:subclass |
		self writeClassSummaryStringFor: subclass on: aStream indentLevel: indentLevel.
		self writeSubclassSummaryStringsFor: subclass on: aStream indentLevel: anInteger + 1]
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code list'] value ! !
! SystemBrowser methodsFor: 'code list' !
codeBoxWidget

	^self bindingAt: #workspace ifAbsentPut: [
		RichTextEditorComponent new
			bindTo: self as: 'codeTextBox';
			menu: self codeMenu;
			subject: self;
			yourself]
    ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code list'] value ! !
! SystemBrowser methodsFor: 'code list' !
installCodeBoxWidget

	self addHTMLBeforeEndOf: self innerAppName to: self codeBoxWidget htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeDoitMenuItem

	^PopupMenuItem new
		id: #doit;
		name: 'Do It';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		addRequestedValue: 'richTextSelectedString';
		action: [:args | self doItWith: args];
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeImplementersMenuItem

	^PopupMenuItem new
		id: #codeImplementers;
		name: 'Implementers';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		addRequestedValue: 'richTextSelectionStart';
		addRequestedValue: 'richTextSelectionEnd';
		addRequestedValue: 'richTextSelectedString';
		action: [:args | self codeImplementersWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeImplementersWith: aDictionary

	| method selector |

	(aDictionary at: 'richTextSelectedString') isEmpty ifTrue: [^self].

	method := self selectedMethod first compiledMethodAt: (self selectedMethod at: 3).
	selector := method findSendWithOffset: (aDictionary at: 'richTextSelectionStart').
	selector isNil ifTrue: [^self].

	self class
		openMethodsBrowserOn: (BeagleSystem implementersOf: selector) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')   ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeInspectItMenuItem

	^PopupMenuItem new
		id: #inspectit;
		name: 'Inspect It';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		addRequestedValue: 'richTextSelectedString';
		action: [:args | self inspectItWith: args];
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'codeTextBox');
		addMenuItem: self saveCodeMenuItem;
		addMenuItem: self codeSendersMenuItem;
		addMenuItem: self codeImplementersMenuItem;
		addMenuItem: self codeDoitMenuItem;
		addMenuItem: self codePrintItMenuItem;
		addMenuItem: self codeInspectItMenuItem;
		addMenuItem: self selectedCodeClassReferencesMenuItem;
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeMenuName

	^self idFor: 'codeMenu' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codePrintItMenuItem

	^PopupMenuItem new
		id: #printit;
		name: 'Print It';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		addRequestedValue: 'richTextSelectionStart';
		addRequestedValue: 'richTextSelectionEnd';
		addRequestedValue: 'richTextSelectedString';
		action: [:args | self printItWith: args];
		yourself  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeSendersMenuItem

	^PopupMenuItem new
		id: #codeSenders;
		name: 'Senders';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		addRequestedValue: 'richTextSelectionStart';
		addRequestedValue: 'richTextSelectionEnd';
		addRequestedValue: 'richTextSelectedString';
		action: [:args | self codeSendersWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
codeSendersWith: aDictionary

	| method selector |

	(aDictionary at: 'richTextSelectedString') isEmpty ifTrue: [^self].

	method := self selectedMethod first compiledMethodAt: (self selectedMethod at: 3).
	selector := method findSendWithOffset: (aDictionary at: 'richTextSelectionStart').
	selector isNil ifTrue: [^self].

	self class
		openMethodsBrowserOn: (BeagleSystem sendersOf: selector) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')   ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
inspectItWith: aDictionary

	| result |

	self disableWhile: [result := SmalltalkParser evaluate: (aDictionary at: 'richTextSelectedString')].

	result inspect.
	self updateCodePane ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
openCodeMenuX: x y: y

	self codeMenu openIn: (self idFor: 'codeBoxDiv') x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
printItWith: aDictionary

	| result |

	self disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'richTextSelectedString')) printString].

	self code: (self code copyFrom: 1 to: (aDictionary at: 'richTextSelectionEnd')) ,
		result, ' ',
		(self code copyFrom: (aDictionary at: 'richTextSelectionEnd') + 1 to: self code size).

	self codeBoxWidget clearEmphasis.
	self updateCodePaneNoHighlight.
	self codeBoxWidget setSelectionFrom: (aDictionary at: 'richTextSelectionEnd') to: ((aDictionary at: 'richTextSelectionEnd' ) + 1 + result size)
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
saveClassDefinition: aString

	aString readStream fileIn ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
saveCodeMenuItem

	^PopupMenuItem new
		id: #saveCode;
		name: 'Save';
		addRequestedValue: 'innerHTML';
		action: [:args | self saveCodeWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
saveCodeWith: aDictionary

	| oldSelectedMethod strippedText |

	strippedText := self stripText: (aDictionary at: 'innerHTML').

	(self selectedMethod isNil and: [self selectedProtocol isNil]) ifTrue: [
		self disableWhile: [self saveClassDefinition: strippedText].
		self
			clearClasses;
			computeClassList;
			updateBrowser.
		^self].

	(self saveMethodDefinition: strippedText) ifFalse: [^self].

	oldSelectedMethod := self selectedMethod.
	self
		clearCode;
		computeMethodsList.

	self
		selectedMethod: oldSelectedMethod;
		computeCode.

	self updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
saveMethodDefinition: aString

	| fileinStream method classString protocol kit |

	classString := self selectedMethod notNil
		ifTrue: [self selectedMethod first printString]
		ifFalse: [self selectedClass isNil
			ifTrue: [nil]
			ifFalse: [self selectedClassOrMetaclass printString]].

	classString isNil ifTrue: [^self].

	protocol := self selectedMethod notNil
		ifTrue: [
			kit := self selectedMethod at: 4.
			(self selectedMethod at: 2) ifNil: ['uncategorized'].
			]
		ifFalse: [
			kit := nil.
			self selectedProtocol notNil
				ifTrue: [self selectedProtocol last]
				ifFalse: ['uncategorized']].

	fileinStream := WriteStream on: (String new: 100).
	fileinStream
		nextPutAll: '! ';
		nextPutAll: classString;
		nextPutAll: ' methodsFor: ''';
		nextPutAll: protocol;
		nextPutAll: ''' !';
		cr;
		nextPut: Character lf;
		nextPutAll: (aString crToCRLF);
		nextPutAll: '! !'.

	method := [fileinStream contents readStream fileIn]
		on: CompileError , CompileWarning
		do: [:ex |
			| convertedString endOffset |
			convertedString := aString lfToCR.
			endOffset := ex endSourceOffset + 1 min: convertedString size.

			self code:
				(convertedString copyFrom: 1 to: endOffset),
				' ' , ex message asString, ' ',
				(convertedString copyFrom: endOffset + 1 to: convertedString size).

			self codeBoxWidget
				text: self code;
				updateText;
				setSelectionFrom: (ex endSourceOffset +1 min: convertedString size) to: (ex endSourceOffset +1 min: convertedString size) + 2 + ex message asString size.

			ex return: nil].

	method isNil ifTrue: [
		"self selectedMethod: nil."
		^false].

	kit isNil ifFalse: [
		fileinStream := WriteStream on: (String new: 100).
		fileinStream
			nextPutAll: '(KitManager current kitNamed: ''', kit name, ''') addMethod: (';
			nextPutAll: classString;
			nextPutAll: ' compiledMethodAt: #';
			nextPutAll: method selector;
			nextPutAll: ') !';
			cr; cr.

		fileinStream contents readStream fileIn
		].

	self selectedMethod: (
		Array
			with: method mclass
			with: (method mclass organizationFor: method selector)
			with: method selector
			with: method kit).

	^true
    ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
selectedCodeClassReferencesMenuItem

	^PopupMenuItem new
		id: #classReferences;
		name: 'Class References';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		addRequestedValue: 'richTextSelectionStart';
		addRequestedValue: 'richTextSelectionEnd';
		addRequestedValue: 'richTextSelectedString';
		action: [:args | self selectedCodeClassReferencesWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'code menus'] value ! !
! SystemBrowser methodsFor: 'code menus' !
selectedCodeClassReferencesWith: aDictionary

	| class className |

	className := (aDictionary at: 'richTextSelectedString') trimSeparators.
	className isEmpty ifTrue: [^self].

	class := Smalltalk at: className asSymbol ifAbsent: [nil].
	class isNil ifTrue: [
		^self message: 'No such class: ', className].

	self class
		openMethodsBrowserOn: (BeagleSystem referencesToClass: class) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
browserList

	^HTMLBuilder new
		inHorizontalLayout: self browserListsName do: [:builder | ];
		htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
browserListsName

	^self idFor: 'browserLists' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
fixedOffset

	^5 @ (self listNumberOfRows * -1 - 220) ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
highlightDoitFor: aComponent
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
highlightFor: aComponent

	self selectedMethod isNil
		ifTrue: [self highlightDoitFor: aComponent]
		ifFalse: [self highlightMethodFor: aComponent]

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
highlightMethodFor: aComponent

	CodeHighlighter new
		highlightMethod: (self selectedMethod first compiledMethodAt: (self selectedMethod at: 3))
		source: aComponent text
		forWidget: aComponent		
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
innerAppName

	^self idFor: 'enableDisable' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
installBrowserList

	self addHTMLBeforeEndOf: self innerAppName to: self browserList ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
installBrowserPanes

	self browserPlugin installBrowserPanesOn: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
listNumberOfRows

	^"self extent y // 30" 10 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'html'] value ! !
! SystemBrowser methodsFor: 'html' !
stripText: aString

	^HTMLBuilder new htmlUnquote: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit list'] value ! !
! SystemBrowser methodsFor: 'kit list' !
installKitBoxWidget

	self kitsList
		onEvent: ListSelectionEvent do: [:event | self changedSelectedKitEvent: event].

	self addComponent: self kitsList beforeEndOf: self browserListsName ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
fileoutKitMenuItem

	^PopupMenuItem new
		id: #fileoutKit;
		name: 'Fileout Kit';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedKit notNil];
		action: [:args | self fileoutKitWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
fileoutKitWith: aDictionary

	self selectedKit isNil ifTrue: [^self].
	self selectedKit fileout ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
findClass

	self request: 'Class Name?' initialAnswer: 'Object' answerBlock: [:answer | answer isNil ifFalse: [self findClass: answer]] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
findClass: aString

	| class kit classNames className |

	classNames := (Smalltalk keys select: [:each | aString matches: each]) asArray sorted.
	classNames isEmpty ifTrue: [self warningMessage: 'Class ', aString asSymbol, ' not found'. ^self].

	classNames size = 1 ifTrue: [^self findClassName: classNames first].

	className := ListChoiceBox new
		message: 'Which class?';
		choices: classNames;
		values: classNames;
		answerBlock: [:className | self findClassName: className];
		open

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
findClassMenuItem

	^PopupMenuItem new
		id: #findClass;
		name: 'Find Class';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		action: [:args | self findClassWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
findClassName: aString

	| class kit |

	class := Smalltalk at: aString asSymbol ifAbsent: [nil].
	class isNil
		ifTrue: [self warningMessage: 'Class ', aString asSymbol, ' not found'. ^self].

	kit := KitManager current kitForClass: class.
	kit isNil ifTrue: [self warningMessage: 'No kit for ', aString asSymbol printString. ^self].

	self
		selectedKit: kit;
		computeClassList;
		selectedClass: class;
		instanceOrClass: #instance;
		computeProtocolsList;
		updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
findClassWith: aDictionary

	self
		request: 'Class Name?'
		initialAnswer: 'Object'
		answerBlock: [:answer | answer isNil ifFalse: [self findClass: answer]]
		at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
kitMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'kitListDiv');
		addMenuItem: self findClassMenuItem;
		addMenuItem: self newKitMenuItem;
		addMenuItem: self removeKitMenuItem;
		addMenuItem: self fileoutKitMenuItem;
		addMenuItem: self unloadKitMenuItem;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
kitMenuName
	^self idFor: 'kitMenu' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
newKit

	self request: 'Kit Name?' initialAnswer: 'New Kit' answerBlock: [:answer | self newKit: answer] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
newKit: aString

	| kit |

	aString isNil ifTrue: [^self].
	aString isEmpty ifTrue: [^self].
	(KitManager current kitNamed: aString) notNil ifTrue: [
		self warningMessage: 'Kit ', aString printString, ' already exists'.
		^self].
	kit := KitManager current addKitNamed: aString.
	self
		computeKitList;
		selectedKit: kit;
		computeClassList;
		updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
newKitMenuItem

	^PopupMenuItem new
		id: #newKit;
		name: 'New Kit';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		action: [:args | self newKitWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
newKitWith: aDictionary

	self
		request: 'Kit Name?'
		initialAnswer: 'New Kit'
		answerBlock: [:answer | self newKit: answer]
		at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
openKitMenuX: x y: y

	self kitMenu openIn: (self idFor: 'kitListDiv') x: x y: y
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
removeKit

	self selectedKit isNil ifTrue: [^self].
	self selectedKit definedClasses isEmpty ifFalse: [
		self warningMessage: 'Kit isn''t empty - can''t remove'.
		^self].
	KitManager current removeKit: self selectedKit.
	self computeKitList.
	self updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
removeKitMenuItem

	^PopupMenuItem new
		id: #removeKit;
		name: 'Remove Kit';
		enabledBlock: [self selectedKit notNil];
		action: [:args | self removeKitWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
removeKitWith: aDictionary

	self removeKit ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
unloadKitMenuItem

	^PopupMenuItem new
		id: #unloadKit;
		name: 'Unload Kit';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedKit notNil];
		action: [:args | self unloadKitWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'kit menus'] value ! !
! SystemBrowser methodsFor: 'kit menus' !
unloadKitWith: aDictionary

	| reason |

	self selectedKit isNil ifTrue: [^self].

	reason := self selectedKit cantUnloadReason.
	reason notNil ifTrue: [^self message: reason].

	self selectedKit unload.
	self
		clearClasses;
		computeKitList;
		updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method list'] value ! !
! SystemBrowser methodsFor: 'method list' !
installMethodBoxWidget

	self methodsList
			onEvent: ListSelectionEvent do: [:event | self changedSelectedMethodEvent: event].

	self addComponent: self methodsList beforeEndOf: self browserListsName ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method list'] value ! !
! SystemBrowser methodsFor: 'method list' !
methodListWidget

	^HTMLBuilder new
		div;
			id: (self idFor: 'methodListDiv');
			attributeAt: 'width' put: '100%';
			attributeAt: 'oncontextmenu' put: 'simTalkCallback2(''$$appName$'', ''openMethodMenuX:y:'', event.pageX, event.pageY); return false;';
			startTag: 'select';
				id: (self idFor: 'methodsList');
				attributeAt: 'name' put: 'methods';
				attributeAt: 'size' put: self listNumberOfRows printString;
				attributeAt: 'style' put: 'width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.0);';
				attributeAt: 'onchange' put: 'simTalkCallback1(''$$appName$'', ''changedSelectedMethod:'' , event.target.value);';
			endTag: 'select';
		endDiv;
		htmlString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
deleteMethodMenuItem

	^PopupMenuItem new
		id: #deleteMethod;
		name: 'Delete';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedMethod notNil];
		action: [:args | self deleteMethodWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
deleteMethodWith: aDictionary

	| class |
	self selectedMethod isNil ifTrue: [^self].
	self selectedMethod first removeSelector: (self selectedMethod at: 3).
	self clearCode;
		computeMethodsList.
	self withinWebUpdateDo: [self update]
	 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodImplementersMenuItem

	^PopupMenuItem new
		id: #methodImplementers;
		name: 'Implementers';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedMethod notNil];
		action: [:args | self methodImplementersWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodImplementersWith: aDictionary

	self selectedMethod isNil ifTrue: [^self].
	self class
		openMethodsBrowserOn: (BeagleSystem implementersOf: (self selectedMethod at: 3)) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'methodListDiv');
		addMenuItem: self methodSendersMenuItem;
		addMenuItem: self methodImplementersMenuItem;
		addMenuItem: self methodMessagesMenuItem;
		addMenuItem: self moveMethodToProtocolMenuItem;
		addMenuItem: self deleteMethodMenuItem;
		addMenuItem: self moveMethodToKitMenuItem;
		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodMenuName

	^self idFor: 'methodMenu' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodMessagesMenuItem

	^PopupMenuItem new
		id: #methodMessages;
		name: 'Messages';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedMethod notNil];
		action: [:args | self methodMessagesWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodMessagesWith: aDictionary

	| selectors |
	self selectedMethod isNil ifTrue: [^self].

	selectors := (self selectedMethod first compiledMethodAt: (self selectedMethod at: 3)) allMessages.
	ListChoiceBox new
		message: 'Selector?';
		choices: selectors;
		values: selectors;
		answerBlock: [:selector |
			self class
				openMethodsBrowserOn: (BeagleSystem implementersOf: selector) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')];
		open

	  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodSendersMenuItem

	^PopupMenuItem new
		id: #methodSenders;
		name: 'Senders';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedMethod notNil];
		action: [:args | self methodSendersWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
methodSendersWith: aDictionary

	self selectedMethod isNil ifTrue: [^self].
	self class
		openMethodsBrowserOn: (BeagleSystem sendersOf: (self selectedMethod at: 3)) at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
moveMethodToKitMenuItem

	^PopupMenuItem new
		id: #moveMethodToKit;
		name: 'Move to Kit';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedMethod notNil];
		action: [:args | self moveToKitWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
moveMethodToProtocolMenuItem

	^PopupMenuItem new
		id: #moveMethodToProtocol;
		name: 'Move to Protocol';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedMethod notNil];
		action: [:args | self moveToProtocolWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
moveToKit: aString

	| kit |

	aString isNil ifTrue: [^self].

	kit := KitManager current kitNamed: aString.
	kit isNil ifTrue: [
		^self message: 'Kit not found: ', aString].

	kit addMethod: (self selectedMethod first compiledMethodAt: (self selectedMethod at: 3)).

	self
		computeMethodsList;
		updateBrowser  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
moveToKitWith: aDictionary

	self selectedMethod isNil ifTrue: [^self].

	self
		request: 'New kit?'
		initialAnswer: 'uncategorized'
		answerBlock: [:value | self moveToKit: value]
		at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
moveToProtocol: aString

	| oldSelectedProtocol |

	aString isNil ifTrue: [^self].
	self selectedClassOrMetaclass organizationAt: aString add: (self selectedMethod at: 3).

	oldSelectedProtocol := self selectedProtocol.

	self
		clearProtocols;
		computeProtocolsList;
		selectedProtocol: oldSelectedProtocol;
		computeMethodsList;
		updateBrowser  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
moveToProtocolWith: aDictionary

	| oldSelectedProtocol |

	self selectedMethod isNil ifTrue: [^self].

	self
		request: 'New protocol?'
		initialAnswer: 'uncategorized'
		answerBlock: [:value | self moveToProtocol: value]
		at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'method menus'] value ! !
! SystemBrowser methodsFor: 'method menus' !
openMethodMenuX: x y: y

	self methodMenu openIn: (self idFor: 'methodListDiv') x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'opening'] value ! !
! SystemBrowser methodsFor: 'opening' !
defaultWindowExtent

	^1000 @ 300 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'opening'] value ! !
! SystemBrowser methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.

	self browserPlugin doPostOpenOn: self.

	self
		installBrowserPanes;
		withinWebUpdateDo: [
			self update].

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","s',
		'", "', (self idFor: 'codeTextBox'),
		'", "', (self idFor: 'codeTextBox'),
		'", "saveCodeWith:',
		'", ["innerHTML"]' ,
		');'.

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","d',
		'", "', (self idFor: 'codeTextBox'),
		'", "', (self idFor: 'codeTextBox'),
		'", "doItWith:',
		'", ["richTextSelectedString", "richTextSelectionStart", "richTextSelectionEnd"]' ,
		');'.

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","p',
		'", "', (self idFor: 'codeTextBox'),
		'", "', (self idFor: 'codeTextBox'),
		'", "printItWith:',
		'", ["richTextSelectedString", "richTextSelectionStart", "richTextSelectionEnd"]' ,
		');'.

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","q',
		'", "', (self idFor: 'codeTextBox'),
		'", "', (self idFor: 'codeTextBox'),
		'", "inspectItWith:',
		'", ["richTextSelectedString", "richTextSelectionStart", "richTextSelectionEnd"]' ,
		');' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol list'] value ! !
! SystemBrowser methodsFor: 'protocol list' !
installProtocolBoxWidget

	self protocolsList
		onEvent: ListSelectionEvent do: [:event | self changedSelectedProtocolEvent: event].

	self addComponent: self protocolsList beforeEndOf: self browserListsName ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol list'] value ! !
! SystemBrowser methodsFor: 'protocol list' !
protocolListWidget

	^HTMLBuilder new
		div;
			id: (self idFor: 'protocolListDiv');
			attributeAt: 'width' put: '100%';
			attributeAt: 'onContextMenu' put: 'simTalkCallback2(''$$appName$'', ''openProtocolMenuX:y:'', event.pageX, event.pageY); return false;';
			startTag: 'select';
				id: (self idFor: 'protocolsList');
				attributeAt: 'name' put: 'protocols';
				attributeAt: 'size' put: self listNumberOfRows printString;
				attributeAt: 'style' put: 'width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.0);';
				attributeAt: 'onchange' put: 'simTalkCallback1(''$$appName$'', ''changedSelectedProtocol:'' , event.target.value);';
			endTag: 'select';
		endDiv;
		htmlString
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
findMethodAnswer: aString

	| methodNames |

	methodNames := (self selectedClassOrMetaclass methodDictionary keys select: [:each | aString matches: each]) asArray sorted.
	methodNames isEmpty ifTrue: [self warningMessage: 'Method ', aString asSymbol, ' not found'. ^self].

	methodNames size = 1 ifTrue: [^self findMethodName: methodNames first].

	ListChoiceBox new
		message: 'Which method?';
		choices: methodNames ;
		values: methodNames ;
		answerBlock: [:methodName | self findMethodName: methodName];
		open

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
findMethodMenuItem

	^PopupMenuItem new
		id: #findMethod;
		name: 'Find Method';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		action: [:args | self findMethodWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
findMethodName: aString

	| organization methodName |

	methodName := aString asSymbol.
	(self selectedClass methodDictionary includesKey: methodName) ifFalse: [^self].

	organization := self selectedClass organizationFor: methodName.
	self
		computeProtocolsList;
		selectedProtocol: (Array with: self selectedClass with: organization);
		computeMethodsList;
		selectedMethod: (Array with: selectedClass with: organization with: methodName);
		computeCode;
		updateBrowser

 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
findMethodWith: aDictionary

	self selectedClass isNil ifTrue: [^self].
	self
		request: 'Method name'
		initialAnswer: ''
		answerBlock: [:answer | self findMethodAnswer: answer]
		at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
locateClassFor: aSymbol

	self selectedClass withAllSuperclassess do: [:eachClass |
		(eachClass methodDictionary includesKey: aSymbol) ifTrue: [^eachClass]
		].

	^nil
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
newProtocolAnswer: aString

	aString isNil ifTrue: [^self].
	(self selectedClassOrMetaclass organization includesKey: aString)
		ifTrue: [self warningMessage: 'Protocol ', aString, ' already exists'. ^self].

	self selectedClassOrMetaclass newOrganization: aString.
	self
		clearProtocols;
		computeProtocolsList;
		selectedProtocol: (self protocols detect: [:each | each first = self selectedClassOrMetaclass and: [each last = aString]]);
		updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
newProtocolMenuItem

	^PopupMenuItem new
		id: #newProtocol;
		name: 'New Protocol';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		action: [:args | self newProtocolWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
newProtocolWith: aDictionary

	self
		request: 'Protocol name'
		initialAnswer: 'uncategorized'
		answerBlock: [:answer | self newProtocolAnswer: answer]
		at: (aDictionary at: 'pageX') @ (aDictionary at: 'pageY') ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
openProtocolMenuX: x y: y

	self protocolMenu openIn: (self idFor: 'protocolListDiv') x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
protocolMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'protocolListDiv');
		addMenuItem: self newProtocolMenuItem;
		addMenuItem: self findMethodMenuItem;
		addMenuItem: self removeProtocolMenuItem;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
protocolMenuHTML

	^'	<div id="$appName$-protocolMenu"  class="menuBox" onmouseleave="simTalkCallback0(''$$appName$'', ''hideProtocolMenu'');">
		<div  class="menuItem" onclick="simTalkCallback0(''$$appName$'', ''doNewProtocol'');">New protocol</div>
		<div  class="menuItem" onclick="simTalkCallback0(''$$appName$'', ''doRemoveProtocol'');">Remove protocol</div>
	</div>
' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
protocolMenuName

	^self idFor: 'protocolMenu' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
removeProtocolMenuItem

	^PopupMenuItem new
		id: #removeProtocol;
		name: 'Remove Protocol';
		addRequestedValue: 'pageX';
		addRequestedValue: 'pageY';
		enabledBlock: [self selectedProtocol notNil];
		action: [:args | self removeProtocolWith: args];
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'protocol menus'] value ! !
! SystemBrowser methodsFor: 'protocol menus' !
removeProtocolWith: aDictionary

	| classOrMetaclass |

	self selectedProtocol isNil ifTrue: [
		self infoMessage: 'No protocol is selected'.
		^self].
	classOrMetaclass := self selectedClassOrMetaclass.
	classOrMetaclass isNil ifTrue: [^self].

	(classOrMetaclass organization at: self selectedProtocol last) isEmpty ifFalse: [
		self infoMessage: 'The protocol isn''t empty - can''t delete'.
		^self].
	classOrMetaclass organization removeKey: self selectedProtocol last.

	self
		computeProtocolsList;
		updateBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'testing'] value ! !
! SystemBrowser methodsFor: 'testing' !
isClassMethods

	^self instanceOrClass = #class ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'testing'] value ! !
! SystemBrowser methodsFor: 'testing' !
isInstanceMethods

	^self instanceOrClass = #instance ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
classMethodsRadioButtonName
	^self idFor: 'classMethodsRadioButton' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
codeTextBoxName
	^self idFor: 'codeTextBox' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
instanceMethodsRadioButtonName
	^self idFor: 'instanceMethodsRadioButton' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
isSelectedClassExtended: aClass

	^(self selectedKit definedClasses includes: aClass) not
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
update
	self browserPlugin update: self ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateBrowser

	self withinWebUpdateDo: [self update] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateClassList
	| index |
	self classesList list: (self classes collect: [:each | (self isSelectedClassExtended: each) ifTrue: ['~' , each name] ifFalse: [each name]]).

	index := self selectedClass
		ifNil: [0]
		ifNotNil: [self classesList list indexOf: ((self isSelectedClassExtended: self selectedClass) ifTrue: ['~' , self selectedClass name] ifFalse: [self selectedClass name])].

	self classesList selectionIndex: index.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateCodePane

	self codeBoxWidget text: self code.

	self highlightFor: self codeBoxWidget.

	self codeBoxWidget updateText ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateCodePaneNoHighlight

	self codeBoxWidget text: self code.
	self codeBoxWidget updateText ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateInstanceClassSelection

	self isInstanceMethods
		ifTrue: [self setAttribute: 'checked' of: self instanceMethodsRadioButtonName to: 'checked']
		ifFalse: [self setAttribute: 'checked' of: self classMethodsRadioButtonName to: 'checked']
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateKitList
	| newList index |
	newList := self kits collect: [:each | each name].

	self kitsList list: newList.

	index := self selectedKit
		ifNil: [0]
		ifNotNil: [newList indexOf: self selectedKit name].
	
	self kitsList selectionIndex: index.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateMethodList
	| index |
	self methodsList list: (self methods collect: [:each |
		| method |
		method := each first compiledMethodAt: (each at: 3).
		method kit isNil
			ifTrue: [each at: 3]
			ifFalse: [(each at: 3) asString, ' [', method kit name, ']']]).

	index := self selectedMethod
		ifNil: [0]
		ifNotNil: [self methods findFirst: [:each | (each at: 3) == (self selectedMethod at: 3)]].

	self methodsList selectionIndex: index.
  ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateMethodListWithClass

	| index methodsAndStrings |

	methodsAndStrings := (self methods collect: [:each |
		| method |
		method := each first compiledMethodAt: (each at: 3).
		method kit isNil
			ifTrue: [Array with: each with: each first printString, ' ', (each at: 3), ' {', (each at: 2), '}']
			ifFalse: [Array with: each with: each first printString, ' ', (each at: 3), ' {', (each at: 2), '} [' , method kit name, ']']]).

	self methodsList list: (methodsAndStrings collect: [:each | each last]).

	index := self selectedMethod
		ifNil: [0]
		ifNotNil: [self methods indexOf: self selectedMethod].

	self methodsList selectionIndex: index.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'updating'] value ! !
! SystemBrowser methodsFor: 'updating' !
updateProtocolList
	| index |
	self protocolsList list: (self protocols collect: [:each | each last]).

	index := self selectedProtocol
		ifNil: [0]
		ifNotNil: [self protocols indexOf: self selectedProtocol].

	self protocolsList selectionIndex: index.
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser methodsFor: 'utility'] value ! !
! SystemBrowser methodsFor: 'utility' !
selectedClassOrMetaclass

	^self isClassMethods
		ifTrue: [self selectedClass class]
		ifFalse: [self selectedClass] ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser class methodsFor: 'opening'] value ! !
! SystemBrowser class methodsFor: 'opening' !
open
	self openKitBrowser ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser class methodsFor: 'opening'] value ! !
! SystemBrowser class methodsFor: 'opening' !
openKitBrowser
	| browser |
	browser := self new
		browserPlugin: KitBrowserPlugin new;
		open;
		yourself.

	browser runJavaScript: 'enableTabsInRichTextArea("', browser codeTextBoxName, '");' ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser class methodsFor: 'opening'] value ! !
! SystemBrowser class methodsFor: 'opening' !
openKitBrowserAt: aPoint

	| browser |
	browser := self new
		origin: aPoint;
		browserPlugin: KitBrowserPlugin new;
		open;
		yourself.

	browser runJavaScript: 'enableTabsInRichTextArea("', browser codeTextBoxName, '");'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser class methodsFor: 'opening'] value ! !
! SystemBrowser class methodsFor: 'opening' !
openMethodsBrowserOn: aCollection

	| browser |

	browser := self new
		browserPlugin: MethodBrowserPlugin new;
		methods: aCollection;
		open;
		yourself.

	browser runJavaScript: 'enableTabsInRichTextArea("', browser codeTextBoxName, '");'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[SystemBrowser class methodsFor: 'opening'] value ! !
! SystemBrowser class methodsFor: 'opening' !
openMethodsBrowserOn: aCollection at: aPoint

	| browser |

	browser := self new
		origin: aPoint;
		browserPlugin: MethodBrowserPlugin new;
		methods: (aCollection sortedBy: [:a :b | a first name, (a at: 3) < (b first name , (b at: 3))]);
		open;
		yourself.

	browser runJavaScript: 'enableTabsInRichTextArea("', browser codeTextBoxName, '");'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
codeMenu

	^PopupMenuUI new
		widgetId: (self idFor: 'workspaceTextBox');
		addMenuItem: self doItMenuItem;
		addMenuItem: self printItMenuItem;
		addMenuItem: self inspectItMenuItem;
		addMenuItem: self debugItMenuItem;
		addMenuItem: self loadMenuItem;
		addMenuItem: self saveMenuItem;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
debugItMenuItem

	^PopupMenuItem new
			id: #debugIt;
			name: 'Debug It';
			action: [:args | self debugItWith: args];
			requestedValues: #('selectedString');
			yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
debugItWith: aDictionary

	| object |

	self disableWhile: [object := SmalltalkParser evaluate: 'nil halt. [', (aDictionary at: 'selectedString'), '] value'].

	^object ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
doItMenuItem

	^PopupMenuItem new
		id: #doIt;
		name: 'Do It';
		action: [:args | self doItWith: args];
		requestedValues: #('selectedString');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
doItWith: aDictionary

	self disableWhile: [SmalltalkParser evaluate: (aDictionary at: 'selectedString')] ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
inspectItMenuItem

	^PopupMenuItem new
			id: #inspectIt;
			name: 'Inspect It';
			action: [:args | self inspectItWith: args];
			requestedValues: #('selectedString');
			yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
inspectItWith: aDictionary

	| object |

	self disableWhile: [object := SmalltalkParser evaluate: (aDictionary at: 'selectedString')].

	object inspect ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
load: aString

	| workspaceContents fileStream |

	aString isNil ifTrue: [^self].
	aString asFilename exists ifFalse: [^self message: 'File doesn''t exist'].

	fileStream := aString asFilename readStream.
	workspaceContents := fileStream upToEnd.
	fileStream close.

	self setAttribute: #value of: (self idFor: #workspaceTextBox) to: (self javascriptQuote: workspaceContents) ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
loadMenuItem

	^PopupMenuItem new
		id: #load;
		name: 'Load...';
		action: [:args | self loadWith: args];
		requestedValues: #();
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
loadWith: aDictionary

	self request: 'Filename to load?' initialAnswer: 'workspace.ws' answerBlock: [:string | self load: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
openCodeMenuX: x y: y

	self codeMenu openIn: (self idFor: 'workspaceTextBox') x: x y: y ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
printItMenuItem

	^PopupMenuItem new
		id: #printIt;
		name: 'Print It';
		action: [:args | self printItWith: args];
		requestedValues: #('selectedString' 'selectionStart' 'selectionEnd');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
printItWith: aDictionary

	| result |

	self disableWhile: [result := ' ==> ', (SmalltalkParser evaluate: (aDictionary at: 'selectedString')) printString].

	self write: result inTextArea: (self idFor: 'workspaceTextBox') position: (aDictionary at: 'selectionEnd') ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
save: aString to: filenameString

	| file |

	file := filenameString asFilename writeStream.
	file nextPutAll: aString.
	file close
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
saveMenuItem

	^PopupMenuItem new
		id: #save;
		name: 'Save...';
		action: [:args | self saveWith: args];
		requestedValues: #('value');
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'code menu'] value ! !
! Workspace methodsFor: 'code menu' !
saveWith: aDictionary

	self request: 'Filename to save?' initialAnswer: 'workspace.ws' answerBlock: [:string | self save: (aDictionary at: 'value') to: string] ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'opening'] value ! !
! Workspace methodsFor: 'opening' !
defaultWindowExtent

	^800 @ 200 ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'opening'] value ! !
! Workspace methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self withinWebUpdateDo: [self update].

	self runJavaScript: 'enableTabsInTextArea("', self workspaceTextBoxName, '");'.

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","d',
		'", "', (self idFor: 'workspaceTextBox'),
		'", "', (self idFor: 'workspaceTextBox'),
		'", "doItWith:',
		'", ["selectedString", "selectionEnd"]' ,
		');'.

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","p',
		'", "', (self idFor: 'workspaceTextBox'),
		'", "', (self idFor: 'workspaceTextBox'),
		'", "printItWith:',
		'", ["selectedString", "selectionEnd"]' ,
		');'.

	self runJavaScript: 'captureControlKeyInArea("$', self appName ,
		'","q',
		'", "', (self idFor: 'workspaceTextBox'),
		'", "', (self idFor: 'workspaceTextBox'),
		'", "inspectItWith:',
		'", ["selectedString", "selectionEnd"]' ,
		');' ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'opening'] value ! !
! Workspace methodsFor: 'opening' !
title

	^'Workspace' ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'opening'] value ! !
! Workspace methodsFor: 'opening' !
workspaceTextBoxHTML

	^HTMLBuilder new
		install: self workspaceWidget;
		htmlString ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'opening'] value ! !
! Workspace methodsFor: 'opening' !
workspaceTextBoxName

	^self idFor: 'workspaceTextBox' ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'updating'] value ! !
! Workspace methodsFor: 'updating' !
update

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self workspaceTextBoxHTML ! !
! Doit class methodsFor: 'doit' !
doit ^[Workspace methodsFor: 'widgets'] value ! !
! Workspace methodsFor: 'widgets' !
workspaceWidget

	^self bindingAt: #workspace ifAbsentPut: [
		TextEditorComponent new
			bindTo: self id: self workspaceTextBoxName;
			menu: self codeMenu;
			yourself]  ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
browseClassReferences
	| selector |

	RequestBox request: 'Class name?' initialAnswer: '' answerBlock: [:className |
		| class |
		class := Smalltalk at: className asSymbol ifAbsent: [nil].
		class isNil ifFalse: [
			SystemBrowser openMethodsBrowserOn: (BeagleSystem referencesToClass: class) at: 100 @ 100] ] ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (BeagleSystem class compiledMethodAt: #browseClassReferences)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
browseImplementers
	| selector |

	RequestBox request: 'Method name?' initialAnswer: '' answerBlock: [:methodName |

	SystemBrowser openMethodsBrowserOn: (BeagleSystem implementersOf: methodName asSymbol) at: 100 @ 100]    ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (BeagleSystem class compiledMethodAt: #browseImplementers)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem class methodsFor: 'navigating'] value ! !
! BeagleSystem class methodsFor: 'navigating' !
browseSenders
	| selector |

	RequestBox request: 'Method name?' initialAnswer: '' answerBlock: [:methodName |

	SystemBrowser openMethodsBrowserOn: (BeagleSystem sendersOf: methodName asSymbol) at: 100 @ 100]    ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (BeagleSystem class compiledMethodAt: #browseSenders)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'inspecting'] value ! !
! Dictionary methodsFor: 'inspecting' !
inspectorFieldAt: aString

	^self at: aString ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Dictionary compiledMethodAt: #inspectorFieldAt:)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Dictionary methodsFor: 'inspecting'] value ! !
! Dictionary methodsFor: 'inspecting' !
inspectorFields

	| indexedFields |

	indexedFields := OrderedCollection new.
	self keys asArray do: [:each | indexedFields add: each].
	^indexedFields sorted ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Dictionary compiledMethodAt: #inspectorFields)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
basicInspect

	BasicInspector openOn: self  ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #basicInspect)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
basicInspectorFieldAt: aStringOrInteger

	| allInstVarNames index |
	allInstVarNames := self class allInstVarNames.
	index := allInstVarNames indexOf: aStringOrInteger.
	index > 0 ifTrue: [^self instVarAt: index].

	index := aStringOrInteger.
	index > self basicSize ifTrue: [^'Bad Index'].
	^self basicAt: index ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #basicInspectorFieldAt:)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
basicInspectorFields

	| indexedFields |

	indexedFields := OrderedCollection new.
	1 to: (self basicSize min: 500) do: [:each | indexedFields add: each].
	^self class allInstVarNames sorted , indexedFields  ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #basicInspectorFields)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
computedFields

	^OrderedCollection new ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #computedFields)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
inspect

	Inspector openOn: self  ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #inspect)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
inspectorFieldAt: aStringOrInteger

	^self basicInspectorFieldAt: aStringOrInteger ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #inspectorFieldAt:)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
inspectorFields

	^self basicInspectorFields ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #inspectorFields)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object methodsFor: 'inspecting'] value ! !
! Object methodsFor: 'inspecting' !
isComputedField

	^false ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Object compiledMethodAt: #isComputedField)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Point methodsFor: 'inspecting'] value ! !
! Point methodsFor: 'inspecting' !
computedFields

	^super computedFields
		add: (ComputedField name: 'r' action: [:point | point r]);
		add: (ComputedField name: 'theta' action: [:point | point theta radiansToDegrees]);
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit addMethod: (Point compiledMethodAt: #computedFields)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedClasses: #(BasicInspector BrowserPlugin CodeHighlighter Debugger Inspector KitBrowserPlugin MethodBrowserPlugin SystemBrowser Workspace) andMethods: #(#(BeagleSystem class #browseClassReferences) #(BeagleSystem class #browseImplementers) #(BeagleSystem class #browseSenders) #(Dictionary #'inspectorFieldAt:') #(Dictionary #inspectorFields) #(Object #basicInspect) #(Object #'basicInspectorFieldAt:') #(Object #basicInspectorFields) #(Object #computedFields) #(Object #inspect) #(Object #'inspectorFieldAt:') #(Object #inspectorFields) #(Object #isComputedField) #(Point #computedFields))] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KitBrowserPlugin methods: #(#'computeMethodsListOn:' #'doPostBuildOn:' #'doPostOpenOn:' #'installBrowserPanesOn:' #'update:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: KitBrowserPlugin class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodBrowserPlugin methods: #(#'computeMethodsListOn:' #'doPostBuildOn:' #'doPostOpenOn:' #'installBrowserPanesOn:' #'update:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: MethodBrowserPlugin class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Workspace methods: #(#codeMenu #debugItMenuItem #'debugItWith:' #defaultWindowExtent #doItMenuItem #'doItWith:' #inspectItMenuItem #'inspectItWith:' #'load:' #loadMenuItem #'loadWith:' #'openCodeMenuX:y:' #postOpen #printItMenuItem #'printItWith:' #'save:to:' #saveMenuItem #'saveWith:' #title #update #workspaceTextBoxHTML #workspaceTextBoxName #workspaceWidget)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Workspace class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BasicInspector methods: #(#selectedObject #title #updateFieldList)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BasicInspector class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeHighlighter methods: #(#compiledMethod #'compiledMethod:' #highlightMethod #'highlightMethod:source:forWidget:' #richTextWidget #'richTextWidget:' #sourceCode #'sourceCode:' #typeOfCode #'typeOfCode:' #'visitBlockLiteralNode:' #'visitGlobalVariableReferenceNode:' #'visitLiteralNode:' #'visitLocalVariableAssignmentNode:' #'visitLocalVariableReferenceNode:' #'visitMessageNodeEnd:' #'visitSpecialNode:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: CodeHighlighter class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SystemBrowser methods: #(#browseClassReferences #browseInstVarReferences #'browseInstVarReferencesWith:' #browseUndeclaredReferences #browserList #browserListsName #browserPlugin #'browserPlugin:' #'changedSelectedClass:' #'changedSelectedClassEvent:' #'changedSelectedKitEvent:' #'changedSelectedMethod:' #'changedSelectedMethodEvent:' #'changedSelectedProtocol:' #'changedSelectedProtocolEvent:' #classHierarchyString #classListWidget #classMenu #classMenuName #classMethodsRadioButtonName #classReferencesMenuItem #'classReferencesWith:' #classes #'classes:' #classesList #clearClasses #clearCode #clearMethods #clearProtocols #code #'code:' #codeBoxWidget #codeDoitMenuItem #codeImplementersMenuItem #'codeImplementersWith:' #codeInspectItMenuItem #codeMenu #codeMenuName #codePrintItMenuItem #codeSendersMenuItem #'codeSendersWith:' #codeTextBoxName #codeTextEditor #computeClassList #computeCode #computeKitBrowserMethodsList #computeKitList #computeMethodBrowserMethodsList #computeMethodsList #computeProtocolsList #'createAccessorsForInstVar:' #createAccessorsMenuItem #'createAccessorsWith:' #'createGetterMethodFor:' #'createSetterMethodFor:' #defaultWindowExtent #deleteMethodMenuItem #'deleteMethodWith:' #fileoutKitMenuItem #'fileoutKitWith:' #findClass #'findClass:' #findClassMenuItem #'findClassName:' #'findClassWith:' #'findMethodAnswer:' #findMethodMenuItem #'findMethodName:' #'findMethodWith:' #fixedOffset #'highlightDoitFor:' #'highlightFor:' #'highlightMethodFor:' #innerAppName #'inspectItWith:' #installBrowserList #installBrowserPanes #installClassBoxWidget #installCodeBoxWidget #installKitBoxWidget #installMethodBoxWidget #installProtocolBoxWidget #instanceMethodsRadioButtonName #instanceOrClass #'instanceOrClass:' #instanceVariableReferencesMenuItem #isClassMethods #isInstanceMethods #'isSelectedClassExtended:' #kitMenu #kitMenuName #kits #'kits:' #kitsList #listNumberOfRows #'locateClassFor:' #methodImplementersMenuItem #'methodImplementersWith:' #methodListWidget #methodMenu #methodMenuName #methodMessagesMenuItem #'methodMessagesWith:' #methodSendersMenuItem #'methodSendersWith:' #methods #'methods:' #methodsList #moveClassToKitMenuItem #'moveClassToKitWith:' #moveMethodToKitMenuItem #moveMethodToProtocolMenuItem #'moveSelectedClassToKit:' #'moveToKit:' #'moveToKitWith:' #'moveToProtocol:' #'moveToProtocolWith:' #newKit #'newKit:' #newKitMenuItem #'newKitWith:' #'newProtocolAnswer:' #newProtocolMenuItem #'newProtocolWith:' #'openClassMenuX:y:' #'openCodeMenuX:y:' #'openKitMenuX:y:' #'openMethodMenuX:y:' #'openProtocolMenuX:y:' #postBuild #postOpen #'printItWith:' #protocolListWidget #protocolMenu #protocolMenuHTML #protocolMenuName #protocols #'protocols:' #protocolsList #removeClass #removeClassMenuItem #'removeClassWith:' #removeDeletedMethodsFromMethodList #removeKit #removeKitMenuItem #'removeKitWith:' #removeProtocolMenuItem #'removeProtocolWith:' #'saveClassDefinition:' #saveCodeMenuItem #'saveCodeWith:' #'saveMethodDefinition:' #selectedClass #'selectedClass:' #selectedClassOrMetaclass #selectedCodeClassReferencesMenuItem #'selectedCodeClassReferencesWith:' #selectedKit #'selectedKit:' #selectedMethod #'selectedMethod:' #selectedProtocol #'selectedProtocol:' #showClassHierarchy #showClassHierarchyMenuItem #'showClassHierarchyWith:' #showClassMethods #showInstanceMethods #'stripText:' #title #undeclaredReferencesMenuItem #'undeclaredReferencesWith:' #unloadKitMenuItem #'unloadKitWith:' #update #updateBrowser #updateClassList #updateCodePane #updateCodePaneNoHighlight #updateInstanceClassSelection #updateKitList #updateMethodList #updateMethodListWithClass #updateProtocolList #'writeClassHierarchyStringFor:on:indentLevel:' #'writeClassSummaryStringFor:on:indentLevel:' #'writeSubclassSummaryStringsFor:on:indentLevel:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SystemBrowser class methods: #(#open #openKitBrowser #'openKitBrowserAt:' #'openMethodsBrowserOn:' #'openMethodsBrowserOn:at:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BrowserPlugin methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: BrowserPlugin class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Inspector methods: #(#basicInspectMenuItem #'basicInspectWith:' #'changedSelectedField:' #codeMenu #defaultWindowExtent #diveIn #'diveInWith:' #diveMenuItem #doBasicInspect #doInspect #doItMenuItem #'doItWith:' #fieldList #'fieldList:' #fieldListWidget #fieldMenu #initialize #innerAppName #inspectItMenuItem #'inspectItWith:' #inspectMenuItem #'inspectWith:' #inspectorHTML #inspectorTextWidget #install #keysList #'keysList:' #object #'object:' #objectStack #'objectStack:' #'openCodeMenuX:y:' #'openFieldMenuX:y:' #popMenuItem #popOut #'popOutWith:' #postOpen #printItMenuItem #'printItWith:' #selectedField #'selectedField:' #selectedObject #title #update #updateFieldList #updateList #updateText #updateTitle #workspaceWidget)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Inspector class methods: #(#'openOn:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Debugger methods: #(#'changedInspectorSelection:' #'changedLocalsSelection:' #'changedStackSelection:' #'changedWalkbackSelection:' #codeEditorId #codeMenu #codeSimulator #codeWidget #context #'context:' #currentEmphasis #currentFrame #'currentFrame:' #debuggerHTML #defaultWindowExtent #doItMenuItem #'doItWith:' #doLocalsBasicInspect #doLocalsInspect #doSelfBasicInspect #doSelfInspect #doStackBasicInspect #doStackInspect #drawWindow #getSelf #inspectItMenuItem #'inspectItWith:' #inspectSimulator #inspectSimulatorWidget #into #intoWidget #localsBasicInspectMenuItem #'localsBasicInspectWith:' #localsInspectMenu #localsInspectMenuItem #'localsInspectWith:' #localsInspectorListId #localsInspectorListWidget #localsTextEditorId #localsTextEditorWidget #message #'message:' #messageEditorId #messageWidget #over #overWidget #peekBytecode #peekBytecodeWidget #postOpen #printItMenuItem #'printItWith:' #restart #restartMethod #'restartMethod:' #restartWidget #return #returnWidget #saveMenuItem #'saveWith:' #selectedField #'selectedField:' #selectedLocal #'selectedLocal:' #selectedLocalObject #selectedObject #selectedStack #'selectedStack:' #selfBasicInspectMenuItem #'selfBasicInspectWith:' #selfInspectMenu #selfInspectMenuItem #'selfInspectWith:' #selfInspectorListId #selfInspectorListWidget #selfTextEditorId #selfTextEditorWidget #setEmphasis #simulator #'simulator:' #stackBasicInspectMenuItem #'stackBasicInspectWith:' #stackInspectMenu #stackInspectMenuItem #'stackInspectWith:' #stackInspectorListId #stackInspectorListWidget #stackTextEditorId #stackTextEditorWidget #stepBytecode #stepBytecodeWidget #through #throughWidget #title #'tossFramesToSignal:' #update #updateCodeEditor #updateLocalsEditor #updateLocalsList #updateSelfInspector #updateSelfTextEditor #updateStackEditor #updateStackList #updateWalkbackList #walkbackListId #walkbackListWidget)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Debugger class methods: #(#'openOn:' #'openOn:message:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default finishFileinKit] value ! !
! Doit class methodsFor: 'doit' !
doit ^[('kits' asFilename construct: 'Other.kit') fileIn] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKitNamed: 'Other'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit ensureLoaded: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedClasses: #() andMethods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default finishFileinKit] value ! !
! Doit class methodsFor: 'doit' !
doit ^[('kits' asFilename construct: 'Tests.kit') fileIn] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKitNamed: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit ensureLoaded: #('CoreUI')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Testcase
	instVarNames: 'selector status'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase subclassNamed: #DictionaryTests
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase subclassNamed: #LargeIntegerTests
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase subclassNamed: #NumberConversionTests
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase subclassNamed: #ObjectTests
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase subclassNamed: #SmallIntegerTests
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase subclassNamed: #StringMatcherTests
	instVarNames: ''
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[WebUI subclassNamed: #TestcaseWindow
	instVarNames: 'suites tests'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Object subclassNamed: #Testsuite
	instVarNames: 'children'
	classInstVarNames: ''
	environment: Object systemDictionary
	kitName: 'Tests'] value ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
assert: aBoolean

	aBoolean ifFalse: [
		Error signal: 'Assert failed'] ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
assert: aValue equals: anotherValue

	aValue = anotherValue ifFalse: [
		Error signal: 'Assert failed - ', aValue printString, ' should be ', anotherValue printString] ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
performTest

	| result |
	self setUp.
	result := Error try: [self perform: self selector. true]
		catch: [:ex | ex return: false]
		finally: [self tearDown].

	^result ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
performTestNoErrorHandling

	self setUp.
	self perform: self selector
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
selector

	^selector ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
selector: anObject

	selector := anObject ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
setUp ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
status

	^status ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
status: aSymbol

	status := aSymbol ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
tearDown ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'accessing'] value ! !
! Testcase methodsFor: 'accessing' !
testLargeAdd

	self
		assert: (SmallInteger maxVal + 10) hex equals: '+[9 0 0 0 0 0 0 10 ]';
		"assert: (SmallInteger maxVal + 10 + 20) hex equals: '+[1D 0 0 0 0 0 0 10 ]';"
		assert: (SmallInteger maxVal + 10 - 20) hex equals: 'FFFFFFFFFFFFFF5' ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'initializing'] value ! !
! Testcase methodsFor: 'initializing' !
initialize

	self status: #notRun ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase methodsFor: 'printing'] value ! !
! Testcase methodsFor: 'printing' !
printOn: aStream

	aStream
		nextPutAll: 'Test: ';
		print: self class;
		nextPutAll: ' -> ';
		nextPutAll: self selector;
		nextPutAll: '    ==> ';
		nextPutAll: self status ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'instance creation'] value ! !
! Testcase class methodsFor: 'instance creation' !
new

	^super new initialize; yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'instance creation'] value ! !
! Testcase class methodsFor: 'instance creation' !
openWindow

	TestcaseWindow new
		addSuite: self;
		open
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'instance creation'] value ! !
! Testcase class methodsFor: 'instance creation' !
openWindowAllSuites

	| window |
	window := TestcaseWindow new.
	Testcase withAllSubclasses do: [:class |
		window addSuite: class].

	window open
 ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'instance creation'] value ! !
! Testcase class methodsFor: 'instance creation' !
selector: aSymbol

	^self new
		selector: aSymbol;
		yourself ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'running'] value ! !
! Testcase class methodsFor: 'running' !
allTestcaseNames

	^self selectors select: [:each | each size >= 4 and: [(each asString copyFrom: 1 to: 4) = 'test']]

 ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'running'] value ! !
! Testcase class methodsFor: 'running' !
allTestcases

	^self allTestcaseNames collect: [:selector | self new selector: selector; yourself] ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'running'] value ! !
! Testcase class methodsFor: 'running' !
performAllTests

	| result |

	result := OrderedCollection new.

	self performTestsOn: result.

	^result
  ! !
! Doit class methodsFor: 'doit' !
doit ^[Testcase class methodsFor: 'running'] value ! !
! Testcase class methodsFor: 'running' !
performTestsOn: aCollection

	self allTestcaseNames do: [:selector |
		aCollection add: (selector -> (self selector: selector) performTest)].

  ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testAssociationAt

	| dictionary |
	dictionary := Dictionary new.
	1 to: 5 do: [:i | dictionary at: i printString put: i].

	self
		assert: dictionary size = 5;
		assert: dictionary keys size = 5;
		assert: dictionary values size = 5;
		assert: dictionary isEmpty not.

	1 to: 5 do: [:i |
		| association |
		association := dictionary associationAt: i printString.
		self
			assert: (association isMemberOf: Association);
			assert: (association key = i printString);
			assert: (association value = i)].

	

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testAt

	| dictionary |
	dictionary := Dictionary new.
	1 to: 5 do: [:i | dictionary at: i printString put: i].

	self
		assert: dictionary size = 5;
		assert: dictionary keys size = 5;
		assert: dictionary values size = 5;
		assert: dictionary isEmpty not.

	1 to: 5 do: [:i | self assert: (dictionary at: i printString) = i].

	

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testAtIfAbsent

	| dictionary |
	dictionary := Dictionary new.
	1 to: 5 do: [:i | dictionary at: i printString put: i].

	self
		assert: (dictionary at: 'hello' ifAbsent: ['junk']) = 'junk'
	

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testAtIfAbsentPut

	| dictionary |
	dictionary := Dictionary new.
	1 to: 5 do: [:i | dictionary at: i printString put: i].

	self
		assert: (dictionary at: 'hello' ifAbsentPut: ['junk']) = 'junk';
		assert: (dictionary at: 'hello') = 'junk'
	

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testAtPut

	| dictionary |
	dictionary := Dictionary new.
	1 to: 5 do: [:i | dictionary at: i printString put: i].

	self
		assert: dictionary size = 5;
		assert: dictionary keys size = 5;
		assert: dictionary values size = 5;
		assert: dictionary isEmpty not

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testGrow

	| dictionary |
	dictionary := Dictionary new.
	1 to: 200 do: [:i | dictionary at: i printString put: i].

	self
		assert: dictionary size = 200;
		assert: dictionary keys size = 200;
		assert: dictionary values size = 200;
		assert: dictionary isEmpty not.

	1 to: 200 do: [:i | self assert: (dictionary at: i printString) = i].

	

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testNew

	| dictionary |
	dictionary := Dictionary new.
	self
		assert: dictionary size = 0;
		assert: dictionary keys size = 0;
		assert: dictionary values size = 0;
		assert: dictionary isEmpty

 ! !
! Doit class methodsFor: 'doit' !
doit ^[DictionaryTests methodsFor: 'testing'] value ! !
! DictionaryTests methodsFor: 'testing' !
testRemove

	| dictionary size |
	size := 20.

	dictionary := Dictionary new.
	1 to: size do: [:i | dictionary at: i printString put: i].

	self
		assert: dictionary size = size;
		assert: dictionary keys size = size;
		assert: dictionary values size = size;
		assert: dictionary isEmpty not.

	dictionary keys do: [:each |
		dictionary removeKey: each.
		self assert: (dictionary includesKey: each) not.
		dictionary keys do: [:key | dictionary includesKey: key]]

	

 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeIntegerTests methodsFor: 'tests'] value ! !
! LargeIntegerTests methodsFor: 'tests' !
testAdd

	self
		assert: (5 asLargeInteger + 4 asLargeInteger) equals: 9;
		assert: (5 asLargeInteger + -4 asLargeInteger) equals: 1;
		assert: (-5 asLargeInteger + 4 asLargeInteger) equals: -1;
		assert: (-5 asLargeInteger + -4 asLargeInteger) equals: -9;

		assert: (5 asLargeInteger + -9  asLargeInteger) equals: -4;
		assert: (-5 asLargeInteger + 9 asLargeInteger) equals: 4
	


 ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeIntegerTests methodsFor: 'tests'] value ! !
! LargeIntegerTests methodsFor: 'tests' !
testLargeAdd

	self
		assert: (SmallInteger maxVal + 10) hex equals: '+[9 0 0 0 0 0 0 10 ]';
		assert: (SmallInteger maxVal + 10 + 20) hex equals: '+[1D 0 0 0 0 0 0 10 ]';
		assert: (SmallInteger maxVal + 10 - 20) hex equals: 'FFFFFFFFFFFFFF5' ! !
! Doit class methodsFor: 'doit' !
doit ^[LargeIntegerTests methodsFor: 'tests'] value ! !
! LargeIntegerTests methodsFor: 'tests' !
testSubtract

	self
		assert: (5 asLargeInteger - 4 asLargeInteger) equals: 1;
		assert: (5 asLargeInteger - -4 asLargeInteger) equals: 9;
		assert: (-5 asLargeInteger - 4 asLargeInteger) equals: -9;
		assert: (-5 asLargeInteger - -4 asLargeInteger) equals: -1;

		assert: (5 asLargeInteger - -9  asLargeInteger) equals: 14;
		assert: (-5 asLargeInteger - 9 asLargeInteger) equals: -14
	


 ! !
! Doit class methodsFor: 'doit' !
doit ^[NumberConversionTests methodsFor: 'tests'] value ! !
! NumberConversionTests methodsFor: 'tests' !
testFractionToFloat

	| fraction float |

	fraction := 3 / 2.
	float  := 5.3.

	self
		assert: (fraction + float) printString equals: '6.8';
		assert: (float  + fraction) printString equals: '6.8';

		assert: (fraction - float) printString equals: '-3.8';
		assert: (float - fraction) printString equals:  '3.8';

		assert: (fraction * float) printString equals: '7.95';
		assert: (float * fraction) printString equals: '7.95';

		assert: (fraction / float) printString equals: '0.2830188679245';
		assert: (float / fraction) printString equals: '3.5333333333333';

		assert: (fraction > float ) not;
		assert: float > fraction;

		assert: (fraction >= float ) not;
		assert: float >= fraction;

		assert: (float < fraction) not;
		assert: fraction < float ;

		assert: (float <= fraction) not;
		assert: fraction <= float;

		assert: (fraction = float ) not;
		assert: (float  = fraction) not;

		assert: (fraction ~= float );
		assert: (float ~= fraction);

		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[NumberConversionTests methodsFor: 'tests'] value ! !
! NumberConversionTests methodsFor: 'tests' !
testFractionToLargeInteger

	| fraction largeInteger |

	fraction := 3 / 2.
	largeInteger := SmallInteger maxVal + 10.

	self
		assert: (fraction + largeInteger) hex equals: '+[15 0 0 0 0 0 0 20 ] / 2';
		assert: (largeInteger  + fraction) hex equals: '+[15 0 0 0 0 0 0 20 ] / 2';

		assert: (fraction - largeInteger) hex equals: '-[F 0 0 0 0 0 0 20 ] / 2';
		assert: (largeInteger - fraction) hex equals:  '+[F 0 0 0 0 0 0 20 ] / 2';

		assert: (fraction * largeInteger) hex equals: '+[1B 0 0 0 0 0 0 30 ] / 2';
		assert: (largeInteger * fraction) hex equals: '+[1B 0 0 0 0 0 0 30 ] / 2';

		assert: (fraction / largeInteger) hex equals: '1 / +[9 0 0 0 0 0 0 10 ]';
		assert: (largeInteger / fraction) hex equals: '+[12 0 0 0 0 0 0 20 ] / 3';

		assert: (fraction > largeInteger) not;
		assert: largeInteger > fraction;

		assert: (fraction >= largeInteger) not;
		assert: largeInteger >= fraction;

		assert: (largeInteger < fraction) not;
		assert: fraction < largeInteger;

		assert: (largeInteger <= fraction) not;
		assert: fraction <= largeInteger;

		assert: (fraction = largeInteger) not;
		assert: (largeInteger = fraction) not;

		assert: (fraction ~= largeInteger);
		assert: (largeInteger ~= fraction);

		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[NumberConversionTests methodsFor: 'tests'] value ! !
! NumberConversionTests methodsFor: 'tests' !
testLargeIntegerToFloat

	| largeInteger float |

	largeInteger := SmallInteger maxVal + 10.
	float  := 500000.3.

	self
		assert: largeInteger asFloat printString equals: '1.15292150460685e18';
		assert: (largeInteger + float) printString equals: '1.15292150460735e18';
		assert: (float  + largeInteger) printString equals: '1.15292150460735e18';

		assert: (largeInteger - float) printString equals: '1.15292150460635e18';
		assert: (float - largeInteger) printString equals:  '-1.15292150460635e18';

		assert: (largeInteger * float) printString equals: '5.76461098179875e23';
		assert: (float * largeInteger) printString equals: '5.76461098179875e23';

		assert: (largeInteger / float) printString equals: '2.3058416257087e12';
		assert: (float / largeInteger) printString equals: '4.33681129202728e-13';

		assert: largeInteger > float;
		assert: (float > largeInteger) not;

		assert: largeInteger >= float;
		assert: (float >= largeInteger) not;

		assert: float < largeInteger;
		assert: (largeInteger < float) not;

		assert: float <= largeInteger;
		assert: (largeInteger <= float) not;

		assert: (largeInteger = float ) not;
		assert: (float  = largeInteger) not;

		assert: (largeInteger ~= float );
		assert: (float ~= largeInteger);

		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[NumberConversionTests methodsFor: 'tests'] value ! !
! NumberConversionTests methodsFor: 'tests' !
testSmallIntegerToFloat

	| float |

	float  := 5.3.

	self
		assert: (3 + float) printString equals: '8.3';
		assert: (float  + 3) printString equals: '8.3';

		assert: (3 - float) printString equals: '-2.3';
		assert: (float - 3) printString equals:  '2.3';

		assert: (3 * float) printString equals: '15.9';
		assert: (float * 3) printString equals: '15.9';

		assert: (3 / float) printString equals: '0.56603773584906';
		assert: (float / 3) printString equals: '1.76666666666667';

		assert: (3 > float ) not;
		assert: float > 3;

		assert: (3 >= float ) not;
		assert: float >= 3;

		assert: (float < 3) not;
		assert: 3 < float ;

		assert: (float <= 3) not;
		assert: 3 <= float;

		assert: (3 = float ) not;
		assert: (float  = 3) not;

		assert: (3 ~= float );
		assert: (float ~= 3);

		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[NumberConversionTests methodsFor: 'tests'] value ! !
! NumberConversionTests methodsFor: 'tests' !
testSmallIntegerToFraction

	self
		assert: 3 + (5 / 2) equals: 11 / 2;
		assert: (5 / 2) + 3 equals: 11 / 2;

		assert: 3 - (5 / 2) equals: 1 / 2;
		assert: (5 / 2) - 3 equals: -1 / 2;

		assert: 3 * (5 / 2) equals: 15 / 2;
		assert: (5 / 2) * 3 equals: 15 / 2;

		assert: 3 / (5 / 2) equals: 6 / 5;
		assert: (5 / 2) / 3 equals: 5 / 6;

		assert: 3 > (5 / 2);
		assert: ((5 / 2) > 3) not;

		assert: 3 >= (5 / 2);
		assert: ((5 / 2) >= 3) not;

		assert: (5 / 2) < 3;
		assert: (3 < (5 / 2)) not;

		assert: (5 / 2) <= 3;
		assert: (3 <= (5 / 2)) not;

		assert: (3 = (5 / 2)) not;
		assert: ((5 / 2) = 3) not;

		assert: (3 ~= (5 / 2));
		assert: ((5 / 2) ~= 3) ! !
! Doit class methodsFor: 'doit' !
doit ^[NumberConversionTests methodsFor: 'tests'] value ! !
! NumberConversionTests methodsFor: 'tests' !
testSmallIntegerToLargeInteger

	| largeInteger |

	largeInteger := SmallInteger maxVal + 10.

	self
		assert: (3 + largeInteger) hex equals: '+[C 0 0 0 0 0 0 10 ]';
		assert: (largeInteger + 3) hex equals: '+[C 0 0 0 0 0 0 10 ]';

		assert: (3 - largeInteger) hex equals: '-[6 0 0 0 0 0 0 10 ]';
		assert: (largeInteger - 3) hex equals:  '+[6 0 0 0 0 0 0 10 ]';

		assert: (3 * largeInteger) hex equals: '+[1B 0 0 0 0 0 0 30 ]';
		assert: (largeInteger * 3) hex equals: '+[1B 0 0 0 0 0 0 30 ]';

		assert: (3 / largeInteger) hex equals: '3 / +[9 0 0 0 0 0 0 10 ]';
		assert: (largeInteger / 3) hex equals: '+[9 0 0 0 0 0 0 10 ] / 3';

		assert: (3 > largeInteger) not;
		assert: largeInteger > 3;

		assert: (3 >= largeInteger) not;
		assert: largeInteger >= 3;

		assert: (largeInteger < 3) not;
		assert: 3 < largeInteger;

		assert: (largeInteger <= 3) not;
		assert: 3 <= largeInteger;

		assert: (3 = largeInteger) not;
		assert: (largeInteger = 3) not;

		assert: (3 ~= largeInteger);
		assert: (largeInteger ~= 3);

		yourself
 ! !
! Doit class methodsFor: 'doit' !
doit ^[ObjectTests methodsFor: 'testing'] value ! !
! ObjectTests methodsFor: 'testing' !
testIfNil

	self assert: (nil ifNil: [5]) = 5 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallIntegerTests methodsFor: 'tests'] value ! !
! SmallIntegerTests methodsFor: 'tests' !
testMinusSmallInteger

	self
		assert: 5 - 4 equals: 1;
		assert: 5 - -4 equals: 9;
		assert: -5 - 4 equals: -9;
		assert: -5 - -4 equals: -1 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallIntegerTests methodsFor: 'tests'] value ! !
! SmallIntegerTests methodsFor: 'tests' !
testPerformMinusSmallInteger

	self
		assert: (5 perform: #- with: 4) equals: 1;
		assert: (5 perform: #- with:  -4) equals: 9;
		assert: (-5 perform: #- with:  4) equals: -9;
		assert: (-5 perform: #- with:  -4) equals: -1 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallIntegerTests methodsFor: 'tests'] value ! !
! SmallIntegerTests methodsFor: 'tests' !
testPerformPlusSmallInteger

	self
		assert: (5 perform: #+ with: 4) equals: 9;
		assert: (5 perform: #+ with: -4) equals: 1;
		assert: (-5 perform: #+ with: 4) equals: -1;
		assert: (-5 perform: #+ with: -4) equals: -9 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallIntegerTests methodsFor: 'tests'] value ! !
! SmallIntegerTests methodsFor: 'tests' !
testPerformTimesSmallInteger

	self
		assert: (5 perform: #* with: 4) equals: 20;
		assert: (5 perform: #* with: -4) equals: -20;
		assert: (-5 perform: #* with: 4) equals: -20;
		assert: (-5 perform: #* with: -4) equals: 20 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallIntegerTests methodsFor: 'tests'] value ! !
! SmallIntegerTests methodsFor: 'tests' !
testPlusSmallInteger

	self
		assert: 5 + 4 equals: 9;
		assert: 5 + -4 equals: 1;
		assert: -5 + 4 equals: -1;
		assert: -5 + -4 equals: -9 ! !
! Doit class methodsFor: 'doit' !
doit ^[SmallIntegerTests methodsFor: 'tests'] value ! !
! SmallIntegerTests methodsFor: 'tests' !
testTimesSmallInteger

	self
		assert: 5 * 4 equals: 20;
		assert: 5 * -4 equals: -20;
		assert: -5 * 4 equals: -20;
		assert: -5 * -4 equals: 20 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchEndStringStarPattern

	| matcher |

	matcher := StringMatcher pattern: 'he*'.

	self assert: (matcher match: 'hello')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchMidStringStarPattern

	| matcher |

	matcher := StringMatcher pattern: 'h*lo'.

	self assert: (matcher match: 'hello')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchStringAnyCharacterPattern

	| matcher |

	matcher := StringMatcher pattern: '?ello'.

	self assert: (matcher match: 'hello')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchStringPattern

	| matcher |

	matcher := StringMatcher pattern: 'hello'.

	self assert: (matcher match: 'hello')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchStringStarPattern

	| matcher |

	matcher := StringMatcher pattern: '*lo'.

	self assert: (matcher match: 'hello')
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchStringTooLongPattern

	| matcher |

	matcher := StringMatcher pattern: 'hello'.

	self assert: (matcher match: 'hello2') not
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testMatchStringTooShortPattern

	| matcher |

	matcher := StringMatcher pattern: 'hello'.

	self assert: (matcher match: 'hell') not
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testNoMatchStringPattern

	| matcher |

	matcher := StringMatcher pattern: 'hello'.

	self assert: (matcher match: 'there') not
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testNoMatchStringStarPattern

	| matcher |

	matcher := StringMatcher pattern: '*lo'.

	self assert: (matcher match: 'hell') not
 ! !
! Doit class methodsFor: 'doit' !
doit ^[StringMatcherTests methodsFor: 'testing'] value ! !
! StringMatcherTests methodsFor: 'testing' !
testNoMatchStringTooLongStarPattern

	| matcher |

	matcher := StringMatcher pattern: '*lo'.

	self assert: (matcher match: 'hello2') not
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'accessing'] value ! !
! TestcaseWindow methodsFor: 'accessing' !
suites

	^suites ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'accessing'] value ! !
! TestcaseWindow methodsFor: 'accessing' !
suites: aCollection

	suites := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'accessing'] value ! !
! TestcaseWindow methodsFor: 'accessing' !
tests

	^tests ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'accessing'] value ! !
! TestcaseWindow methodsFor: 'accessing' !
tests: aCollection

	tests := aCollection ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'actions'] value ! !
! TestcaseWindow methodsFor: 'actions' !
clear

	self tests do: [:test |
		test status: #notRun].
	self update ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'actions'] value ! !
! TestcaseWindow methodsFor: 'actions' !
debugAll

	self tests do: [:test |
		test status: (test performTestNoErrorHandling ifTrue: [#passed] ifFalse: [#failed])].
	self update ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'actions'] value ! !
! TestcaseWindow methodsFor: 'actions' !
runAll

	self tests do: [:test |
		test status: (test performTest ifTrue: [#passed] ifFalse: [#failed])].
	self update ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'adding and removing'] value ! !
! TestcaseWindow methodsFor: 'adding and removing' !
addSuite: aTestcaseClass

	self suites add: aTestcaseClass.
	self tests addAll: aTestcaseClass allTestcases ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'initializing'] value ! !
! TestcaseWindow methodsFor: 'initializing' !
initialize

	super initialize.
	self suites: OrderedCollection new;
		tests: OrderedCollection new
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
clearWidget

	^self bindingAt: #clear ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'clear';
			label: 'Clear';
			actionBlock: [self clear];
			yourself]
  ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
debugAllWidget

	^self bindingAt: #debugAll ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'debugAll ';
			label: 'Debug All';
			actionBlock: [self debugAll];
			yourself]
  ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
defaultWindowExtent

	^400 @ 400 ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
install

	self addHTMLBeforeEndOf: (self idFor: 'enableDisable') to: self testcaseHTML ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
postOpen

	super postOpen.
	self setAbsoluteWindowBounds.
	self install; update
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
runAllWidget

	^self bindingAt: #runAll ifAbsentPut: [
		PushButtonComponent new
			bindTo: self as: 'runAll ';
			label: 'Run All';
			actionBlock: [self runAll];
			yourself]
  ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
testcaseHTML

	^HTMLBuilder new
		div: [:builder |
			builder
				div: [:builder2 |
					builder2
						id: (self idFor: 'toolBar');
						class: 'buttonBar';
						install: self runAllWidget;
						install: self debugAllWidget;
						install: self clearWidget];
				install: self testcaseListWidget;
				yourself];
		htmlString     ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
testcaseListId

	^self idFor: 'testcaseList'
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
testcaseListWidget

	^self bindingAt: #testcaseList ifAbsentPut: [
		ListComponent new
			bindTo: self id: self testcaseListId;
			listNumberOfRows: 10;
			yourself]
  
  ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'opening'] value ! !
! TestcaseWindow methodsFor: 'opening' !
title

	^'Testcase Window' ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'updating'] value ! !
! TestcaseWindow methodsFor: 'updating' !
allTestcases

	| collection |

	collection := OrderedCollection new.
	self suites do: [:eachSuite | collection addAll: eachSuite allTestcases].
	^collection
 ! !
! Doit class methodsFor: 'doit' !
doit ^[TestcaseWindow methodsFor: 'updating'] value ! !
! TestcaseWindow methodsFor: 'updating' !
update

	self withinWebUpdateDo: [
		(self bindingAt: #testcaseList)
			optionStyles: (self tests collect: [:each |
				each status = #passed
					ifTrue: ['color: green;']
					ifFalse: [each status = #failed
						ifTrue: ['background-color: red; color: white;']
						ifFalse: ['']]]);
			list: (self tests collect: [:each | each printString])
		] ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedClasses: #(DictionaryTests LargeIntegerTests NumberConversionTests ObjectTests SmallIntegerTests StringMatcherTests Testcase TestcaseWindow Testsuite) andMethods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Testcase methods: #(#'assert:' #'assert:equals:' #initialize #performTest #performTestNoErrorHandling #'printOn:' #selector #'selector:' #setUp #status #'status:' #tearDown #testLargeAdd)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Testcase class methods: #(#allTestcaseNames #allTestcases #new #openWindow #openWindowAllSuites #performAllTests #'performTestsOn:' #'selector:')] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ObjectTests methods: #(#testIfNil)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: ObjectTests class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TestcaseWindow methods: #(#'addSuite:' #allTestcases #clear #clearWidget #debugAll #debugAllWidget #defaultWindowExtent #initialize #install #postOpen #runAll #runAllWidget #suites #'suites:' #testcaseHTML #testcaseListId #testcaseListWidget #tests #'tests:' #title #update)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: TestcaseWindow class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DictionaryTests methods: #(#testAssociationAt #testAt #testAtIfAbsent #testAtIfAbsentPut #testAtPut #testGrow #testNew #testRemove)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: DictionaryTests class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Testsuite methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: Testsuite class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StringMatcherTests methods: #(#testMatchEndStringStarPattern #testMatchMidStringStarPattern #testMatchStringAnyCharacterPattern #testMatchStringPattern #testMatchStringStarPattern #testMatchStringTooLongPattern #testMatchStringTooShortPattern #testNoMatchStringPattern #testNoMatchStringStarPattern #testNoMatchStringTooLongStarPattern)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: StringMatcherTests class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargeIntegerTests methods: #(#testAdd #testLargeAdd #testSubtract)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: LargeIntegerTests class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmallIntegerTests methods: #(#testMinusSmallInteger #testPerformMinusSmallInteger #testPerformPlusSmallInteger #testPerformTimesSmallInteger #testPlusSmallInteger #testTimesSmallInteger)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: SmallIntegerTests class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NumberConversionTests methods: #(#testFractionToFloat #testFractionToLargeInteger #testLargeIntegerToFloat #testSmallIntegerToFloat #testSmallIntegerToFraction #testSmallIntegerToLargeInteger)] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default currentKit allDefinedMethodsFor: NumberConversionTests class methods: #()] value ! !
! Doit class methodsFor: 'doit' !
doit ^[KitManager default finishFileinKit] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem globalGarbageCollect] value ! !
! Doit class methodsFor: 'doit' !
doit ^[BeagleSystem saveImage] value ! !
